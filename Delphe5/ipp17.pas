
{
 Copyright 1999 2016 Intel Corporation All Rights Reserved.
 
 The source code, information and material ("Material") contained herein is
 owned by Intel Corporation or its suppliers or licensors, and title
 to such Material remains with Intel Corporation or its suppliers or
 licensors. The Material contains proprietary information of Intel
 or its suppliers and licensors. The Material is protected by worldwide
 copyright laws and treaty provisions. No part of the Material may be used,
 copied, reproduced, modified, published, uploaded, posted, transmitted,
 distributed or disclosed in any way without Intel`s prior express written
 permission. No license under any patent, copyright or other intellectual
 property rights in the Material is granted to or conferred upon you,
 either expressly, by implication, inducement, estoppel or otherwise.
 Any license under such intellectual property rights must be express and
 approved by Intel in writing.
 
 Unless otherwise agreed by Intel in writing,
 you may not remove or alter this notice or any other notice embedded in
 Materials by Intel or Intel`s suppliers or licensors in any way.
}

{
 Translation to Pascal: Adriaan van Os <adriaan@microbizz.nl>
 Version: 20160528

 This file is distributed in the hope that it will be useful but WITHOUT ANY WARRANTY;
 without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 use it AT YOUR OWN RISK.
}

{$mode macpas}
{$macro on}
{$inline on}
{$B-}
{$H-}
{$extendedsyntax off}
{$align 4}
{$packenum 4}

unit ipp;

interface

{
              Intel(R) Integrated Performance Primitives
              Purpose: Describes the IPP version
}

const
  IPP_VERSION_MAJOR  = 9;
  IPP_VERSION_MINOR  = 0;
  IPP_VERSION_UPDATE = 2;

  IPP_VERSION_STR    = '9.0.2';

{
              Intel(R) Integrated Performance Primitives
              Common Types and Macro Definitions
}

{$ifc (defined WIN32) or (defined WIN64)    }
{$definec _ippapi stdcall; external; }
{$elsec                                     }
{$definec _ippapi cdecl; external; }
{$endc                                      }


{
              Intel(R) Integrated Performance Primitives
              Basic Types and Macro Definitions
}

const
  IPP_PI = 3.14159265358979323846;    { ANSI C does not support M_PI }
  IPP_2PI = 6.28318530717958647692;   { 2*pi                         }
  IPP_PI2 = 1.57079632679489661923;   { pi/2                         }
  IPP_PI4 = 0.78539816339744830961;   { pi/4                         }
  IPP_PI180 = 0.01745329251994329577; { pi/180                       }
  IPP_RPI = 0.31830988618379067154;   { 1/pi                         }
  IPP_SQRT2 = 1.41421356237309504880; { sqrt(2)                      }
  IPP_SQRT3 = 1.73205080756887729353; { sqrt(3)                      }
  IPP_LN2 = 0.69314718055994530942;   { ln(2)                        }
  IPP_LN3 = 1.09861228866810969139;   { ln(3)                        }
  IPP_E = 2.71828182845904523536;     { e                            }
  IPP_RE = 0.36787944117144232159;    { 1/e                          }
  IPP_EPS23 = single( 1.19209289e-07);
  IPP_EPS52 = double( 2.2204460492503131e-016);

  IPP_MAX_8U = 255;
  IPP_MAX_16U = 65535;
  IPP_MAX_32U = 4294967295;
  IPP_MIN_8U = 0;
  IPP_MIN_16U = 0;
  IPP_MIN_32U = 0;
  IPP_MIN_8S = -128;
  IPP_MAX_8S = 127;
  IPP_MIN_16S = -32768;
  IPP_MAX_16S = 32767;
  IPP_MIN_32S = -2147483648;
  IPP_MAX_32S = 2147483647;
  IPP_MIN_64U = 0;

{ internal compiler error 200706102

  IPP_MAX_64S = 9223372036854775807;
  IPP_MIN_64S = -9223372036854775808;
  IPP_MAX_64U = 18446744073709551615;
}

  IPP_MINABS_32F  = single( 1.175494351e-38);
  IPP_MAXABS_32F  = single( 3.402823466e+38);
  IPP_EPS_32F     = single( 1.192092890e-07);
  IPP_MINABS_64F  = double( 2.2250738585072014e-308);
  IPP_MAXABS_64F  = double( 1.7976931348623158e+308);
  IPP_EPS_64F     = double( 2.2204460492503131e-016);


type
  charPtr           = ^char;
  SignedByte       = -128..+127;
  Word16           =  UNSIGNEDWORD;
  Word32           =  UNSIGNEDLONG;
  Word64           = QWORD;
  OpaqueRecord     = record end;
  OpaquePtr        = ^OpaqueRecord;
  float            = single; {?}

type
  Int16Ptr          = ^Int16;
  Int32Ptr          = ^Int32;
  Int64Ptr          = ^Int64;
  Word16Ptr         = ^Word16;
  Word32Ptr         = ^Word32;
  Word64Ptr         = ^Word64;
  singlePtr         = ^single;
  doublePtr         = ^double;

type
  double_2_2Ptr     = ^double_2_2;
  double_2_3Ptr     = ^double_2_3;
  double_2_4Ptr     = ^double_2_4;
  double_3_3Ptr     = ^double_3_3;
  double_3_4Ptr     = ^double_3_4;
  double_4_2Ptr     = ^double_4_2;
  double_2_2        = array[ 0..1, 0..1] of double;
  double_2_3        = array[ 0..1, 0..2] of double;
  double_2_4        = array[ 0..1, 0..3] of double;
  double_3_3        = array[ 0..2, 0..2] of double;
  double_3_4        = array[ 0..2, 0..3] of double;
  double_4_2        = array[ 0..3, 0..1] of double;

type
  IppLibraryVersionPtr = ^IppLibraryVersion;
  IppLibraryVersion =
    record
      major       : Int32;                       { e.g. 1                               }
      minor       : Int32;                       { e.g. 2                               }
      majorBuild  : Int32;                       { e.g. 3                               }
      build       : Int32;                       { e.g. 10, always >= majorBuild        }
      targetCpu   : packed array[ 0..3] of char; { corresponding to Intel(R) processor  }
      Name        : charPtr;                     { e.g. "ippsw7"                        }
      Version     : charPtr;                     { e.g. "v1.2 Beta"                     }
      BuildDate   : charPtr                      { e.g. "Jul 20 99"                     }
    end;

type
  Ipp8u           = byte;
  Ipp16u          = Word16;
  Ipp32u          = Word32;
  Ipp64u          = Word64;
  Ipp8s           = SignedByte;
  Ipp16s          = Int16;
  Ipp32s          = Int32;
  Ipp64s          = Int64;
  Ipp32f          = single;
  Ipp64f          = double;
  Ipp16f          = Ipp16s;

type
  Ipp8uPtr        = ^Ipp8u;
  Ipp16uPtr       = ^Ipp16u;
  Ipp32uPtr       = ^Ipp32u;
  Ipp64uPtr       = ^Ipp64u;
  Ipp8sPtr        = ^Ipp8s;
  Ipp16sPtr       = ^Ipp16s;
  Ipp32sPtr       = ^Ipp32s;
  Ipp64sPtr       = ^Ipp64s;
  Ipp32fPtr       = ^Ipp32f;
  Ipp64fPtr       = ^Ipp64f;
  Ipp16fPtr       = ^Ipp16f;

type
  Ipp32sPtrPtr    = ^Ipp32sPtr;

type
  Int32_3Ptr      = ^Int32_3;
  Ipp8u_3Ptr      = ^Ipp8u_3;
  Ipp16u_3Ptr     = ^Ipp16u_3;
  Ipp32u_3Ptr     = ^Ipp32u_3;
  Ipp16s_3Ptr     = ^Ipp16s_3;
  Ipp32s_3Ptr     = ^Ipp32s_3;
  Ipp32f_3Ptr     = ^Ipp32f_3;
  Ipp64f_3Ptr     = ^Ipp64f_3;
  Ipp32f_1        = packed array[ 0..0] of Ipp32f;
  Int32_3         = packed array[ 0..2] of Int32;
  Ipp8u_3         = packed array[ 0..2] of Ipp8u;
  Ipp16u_3        = packed array[ 0..2] of Ipp16u;
  Ipp32u_3        = packed array[ 0..2] of Ipp32u;
  Ipp16s_3        = packed array[ 0..2] of Ipp16s;
  Ipp32s_3        = packed array[ 0..2] of Ipp32s;
  Ipp32f_3        = packed array[ 0..2] of Ipp32f;
  Ipp64f_3        = packed array[ 0..2] of Ipp64f;

type
  Int32_4Ptr      = ^Int32_4;
  Ipp8u_4Ptr      = ^Ipp8u_4;
  Ipp16u_4Ptr     = ^Ipp16u_4;
  Ipp32u_4Ptr     = ^Ipp32u_4;
  Ipp16s_4Ptr     = ^Ipp16s_4;
  Ipp32s_4Ptr     = ^Ipp32s_4;
  Ipp32f_4Ptr     = ^Ipp32f_4;
  Ipp64f_4Ptr     = ^Ipp64f_4;
  Int32_4         = packed array[ 0..3] of Int32;
  Ipp8u_4         = packed array[ 0..3] of Ipp8u;
  Ipp16u_4        = packed array[ 0..3] of Ipp16u;
  Ipp32u_4        = packed array[ 0..3] of Ipp32u;
  Ipp16s_4        = packed array[ 0..3] of Ipp16s;
  Ipp32s_4        = packed array[ 0..3] of Ipp32s;
  Ipp32f_4        = packed array[ 0..3] of Ipp32f;
  Ipp64f_4        = packed array[ 0..3] of Ipp64f;

type
  Ipp32f_3_4Ptr   = ^Ipp32f_3_4;
  Ipp32f_4_4Ptr   = ^Ipp32f_4_4;
  Ipp32f_3_4      = array[ 0..2, 0..3] of Ipp32f;
  Ipp32f_4_4      = array[ 0..3, 0..3] of Ipp32f;

type
  Ipp8u_256Ptr    = ^Ipp8u_256;
  Ipp8u_256       = packed array[ 0..255] of Ipp8u;

type
  Int32_258Ptr    = ^Int32_258;
  Int32_258       = packed array[ 0..257] of Int32;

type
  Ipp8uPtrPtr     = ^Ipp8uPtr;
  Ipp16uPtrPtr    = ^Ipp16uPtr;
  Ipp16sPtrPtr    = ^Ipp16sPtr;
  Ipp32fPtrPtr    = ^Ipp32fPtr;

type
  Ipp8scPtr = ^Ipp8sc;
  Ipp8sc =
    record
      re: Ipp8s;
      im: Ipp8s
    end;

  Ipp16scPtr = ^Ipp16sc;
  Ipp16sc =
    record
      re: Ipp16s;
      im: Ipp16s
    end;
  
  Ipp16ucPtr = ^Ipp16uc;
  Ipp16uc =
    record
      re: Ipp16u;
      im: Ipp16u
    end;

  Ipp32scPtr = ^Ipp32sc;
  Ipp32sc =
    record
      re: Ipp32s;
      im: Ipp32s
    end;

  Ipp32fcPtr = ^Ipp32fc;
  Ipp32fc =
    record
      re: Ipp32f;
      im: Ipp32f
    end;

  Ipp64scPtr = ^Ipp64sc;
  Ipp64sc =
    record
      re: Ipp64s;
      im: Ipp64s
    end;

  Ipp64fcPtr = ^Ipp64fc;
  Ipp64fc =
    record
      re: Ipp64f;
      im: Ipp64f
    end;

const
  ippDataTypeUndef = -1;
  ippDataType1u    =  0;
  ippDataType8u    =  1;
  ippDataType8uc   =  2;
  ippDataType8s    =  3;
  ippDataType8sc   =  4;
  ippDataType16u   =  5;
  ippDataType16uc  =  6;
  ippDataType16s   =  7;
  ippDataType16sc  =  8;
  ippDataType32u   =  9;
  ippDataType32uc  = 10;
  ippDataType32s   = 11;
  ippDataType32sc  = 12;
  ippDataType32f   = 13;
  ippDataType32fc  = 14;
  ippDataType64u   = 15;
  ippDataType64uc  = 16;
  ippDataType64s   = 17;
  ippDataType64sc  = 18;
  ippDataType64f   = 19;
  ippDataType64fc  = 20;

type
  IppDataType = Int32;
  IppBool = ( ippFalse, ippTrue);


{
              Intel(R) Integrated Performance Primitives
              Derivative Types and Macro Definitions
 
              The main purpose of this header file is 
              to support compatibility with the legacy
              domains until their end of life. 
}


{----------------------------------------------------------------------------}
{                   Below are ippCore domain specific definitions            }
{----------------------------------------------------------------------------}

const
  ippCPUID_MMX        = $00000001; { Intel Architecture MMX technology supported  }
  ippCPUID_SSE        = $00000002; { Streaming SIMD Extensions                    }
  ippCPUID_SSE2       = $00000004; { Streaming SIMD Extensions 2                  }
  ippCPUID_SSE3       = $00000008; { Streaming SIMD Extensions 3                  }
  ippCPUID_SSSE3      = $00000010; { Supplemental Streaming SIMD Extensions 3     }
  ippCPUID_MOVBE      = $00000020; { The processor supports MOVBE instruction     }
  ippCPUID_SSE41      = $00000040; { Streaming SIMD Extensions 4.1                }
  ippCPUID_SSE42      = $00000080; { Streaming SIMD Extensions 4.2                }
  ippCPUID_AVX        = $00000100; { Advanced Vector Extensions instruction set   }
  ippAVX_ENABLEDBYOS  = $00000200; { The operating system supports AVX            }
  ippCPUID_AES        = $00000400; { AES instruction                              }
  ippCPUID_CLMUL      = $00000800; { PCLMULQDQ instruction                        }
  ippCPUID_ABR        = $00001000; { Reserved                                     }
  ippCPUID_RDRAND     = $00002000; { Read Random Number instructions              }
  ippCPUID_F16C       = $00004000; { Float16 instructions                         }
  ippCPUID_AVX2       = $00008000; { Advanced Vector Extensions 2 instruction set }
  ippCPUID_ADCOX      = $00010000; { ADCX and ADOX instructions                   }
  ippCPUID_RDSEED     = $00020000; { The RDSEED instruction                       }
  ippCPUID_PREFETCHW  = $00040000; { The PREFETCHW instruction                    }
  ippCPUID_SHA        = $00080000; { Intel (R) SHA Extensions                     }
  ippCPUID_AVX512F    = $00100000; { AVX-512 Foundation instructions              }
  ippCPUID_AVX512CD   = $00200000; { AVX-512 Conflict Detection instructions      }
  ippCPUID_AVX512ER   = $00400000; { AVX-512 Exponential & Reciprocal instructions}
  ippCPUID_AVX512PF   = $00800000; { AVX-512 Prefetch instructions                }
  ippCPUID_AVX512BW   = $01000000; { AVX-512 Byte & Word instructions             }
  ippCPUID_AVX512DQ   = $02000000; { AVX-512 DWord & QWord instructions           }
  ippCPUID_AVX512VL   = $04000000; { AVX-512 Vector Length extensions             }
  ippCPUID_KNC        = $80000000; { Intel(R) Xeon Phi(TM) Coprocessor            }
  ippCPUID_NOCHECK    = $8000000000000000; { Force ippSetCpuFeatures to set CPU features without check }
  ippCPUID_GETINFO_A = $616f666e69746567; { Force ipp_GetCpuFeatures to work as cpuid instruction }

{ define IPP_COUNT_OF( obj )  (sizeof(obj)/sizeof(obj[0])) }

{----------------------------------------------------------------------------}
{                   Below are ippSP domain specific definitions              }
{----------------------------------------------------------------------------}

const
  ippRndZero          =  0;
  ippRndNear          =  1;
  ippRndFinancial     =  2;
  ippRndHintAccurate  = 16;

type
  IppRoundMode        = Int32;

type
  IppHintAlgorithm    = ( ippAlgHintNone, ippAlgHintFast, ippAlgHintAccurate);
  IppCmpOp            = ( ippCmpLess, ippCmpLessEq, ippCmpEq, ippCmpGreaterEq, ippCmpGreater);

const
  ippAlgAuto          = $00000000;
  ippAlgDirect        = $00000001;
  ippAlgFFT           = $00000002;
  ippAlgMask          = $000000FF;

type
  IppAlgType          = Int32;

const
  ippsNormNone        = $00000000; { default }
  ippsNormA           = $00000100; { biased normalization }
  ippsNormB           = $00000200; { unbiased normalization }
  ippsNormMask        = $0000FF00;

type
  IppsNormOp          = Int32;

const
  ippNormInf          = $0000000;
  ippNormL1           = $00000002;
  ippNormL2           = $00000004;

type
  IppNormType         = Int32;

const
  IPP_FFT_DIV_FWD_BY_N  = 1;
  IPP_FFT_DIV_INV_BY_N  = 2;
  IPP_FFT_DIV_BY_SQRTN  = 4;
  IPP_FFT_NODIV_BY_ANY  = 8;

const
  IPP_DIV_FWD_BY_N      = 1;
  IPP_DIV_INV_BY_N      = 2;
  IPP_DIV_BY_SQRTN      = 4;
  IPP_NODIV_BY_ANY      = 8;

type
  IppPointPolarPtr = ^IppPointPolar;
  IppPointPolar =
    record
      rho           : Ipp32f;
      theta         : Ipp32f 
    end;
  
  IppPointPolar_2Ptr  = ^IppPointPolar_2;
  IppPointPolar_2     = array[ 0..1] of IppPointPolar;

  IppWinType          = ( ippWinBartlett, ippWinBlackman, ippWinHamming, ippWinHann, ippWinRect);

  IppsIIRFilterType   = ( ippButterworth, ippChebyshev1);

  IppsZCType          = ( ippZCR, ippZCXor, ippZCC);

  IppsROIPtr          = ^IppsROI;
  IppsROI             =
    record
      left            : Int32;
      right           : Int32
    end;

type
  IppsRandUniState_8uPtr = OpaquePtr;
  IppsRandUniState_16sPtr = OpaquePtr;
  IppsRandUniState_32fPtr = OpaquePtr;
  IppsRandUniState_64fPtr = OpaquePtr;

  IppsRandGaussState_8uPtr = OpaquePtr;
  IppsRandGaussState_16sPtr = OpaquePtr;
  IppsRandGaussState_32fPtr = OpaquePtr;
  IppsRandGaussState_64fPtr = OpaquePtr;

  IppsFFTSpec_C_32fcPtr = OpaquePtr;
  IppsFFTSpec_C_32fPtr = OpaquePtr;
  IppsFFTSpec_R_32fPtr = OpaquePtr;

  IppsFFTSpec_C_32fcPtrPtr = ^IppsFFTSpec_C_32fcPtr;
  IppsFFTSpec_C_32fPtrPtr = ^IppsFFTSpec_C_32fPtr;
  IppsFFTSpec_R_32fPtrPtr = ^IppsFFTSpec_R_32fPtr;

  IppsFFTSpec_C_64fcPtr = OpaquePtr;
  IppsFFTSpec_C_64fPtr = OpaquePtr;
  IppsFFTSpec_R_64fPtr = OpaquePtr;

  IppsFFTSpec_C_64fcPtrPtr = ^IppsFFTSpec_C_64fcPtr;
  IppsFFTSpec_C_64fPtrPtr = ^IppsFFTSpec_C_64fPtr;
  IppsFFTSpec_R_64fPtrPtr = ^IppsFFTSpec_R_64fPtr;

  IppsDFTSpec_C_32fcPtr = OpaquePtr;
  IppsDFTSpec_C_32fPtr = OpaquePtr;
  IppsDFTSpec_R_32fPtr = OpaquePtr;

  IppsDFTSpec_C_64fcPtr = OpaquePtr;
  IppsDFTSpec_C_64fPtr = OpaquePtr;
  IppsDFTSpec_R_64fPtr = OpaquePtr;

  IppsDCTFwdSpec_32fPtr = OpaquePtr;
  IppsDCTInvSpec_32fPtr = OpaquePtr;

  IppsDCTFwdSpec_32fPtrPtr = ^IppsDCTFwdSpec_32fPtr;
  IppsDCTInvSpec_32fPtrPtr = ^IppsDCTInvSpec_32fPtr;

  IppsDCTFwdSpec_64fPtr = OpaquePtr;
  IppsDCTInvSpec_64fPtr = OpaquePtr;

  IppsDCTFwdSpec_64fPtrPtr = ^IppsDCTFwdSpec_64fPtr;
  IppsDCTInvSpec_64fPtrPtr = ^IppsDCTInvSpec_64fPtr;

  IppsWTFwdState_32fPtr = OpaquePtr;
  IppsWTFwdState_8u32fPtr = OpaquePtr;
  IppsWTFwdState_16s32fPtr = OpaquePtr;
  IppsWTFwdState_16u32fPtr = OpaquePtr;
  IppsWTInvState_32fPtr = OpaquePtr;
  IppsWTInvState_32f8uPtr = OpaquePtr;
  IppsWTInvState_32f16sPtr = OpaquePtr;
  IppsWTInvState_32f16uPtr = OpaquePtr;

  IppsIIRState_32fPtr = OpaquePtr;
  IppsIIRState_32fcPtr = OpaquePtr;
  IppsIIRState32f_16sPtr = OpaquePtr;
  IppsIIRState32fc_16scPtr = OpaquePtr;
  IppsIIRState_64fPtr = OpaquePtr;
  IppsIIRState_64fcPtr = OpaquePtr;
  IppsIIRState64f_32fPtr = OpaquePtr;
  IppsIIRState64fc_32fcPtr = OpaquePtr;
  IppsIIRState64f_32sPtr = OpaquePtr;
  IppsIIRState64fc_32scPtr = OpaquePtr;
  IppsIIRState64f_16sPtr = OpaquePtr;
  IppsIIRState64fc_16scPtr = OpaquePtr;

  IppsIIRState_32fPtrPtr = ^IppsIIRState_32fPtr;
  IppsIIRState_32fcPtrPtr = ^IppsIIRState_32fcPtr;
  IppsIIRState32f_16sPtrPtr = ^IppsIIRState32f_16sPtr;
  IppsIIRState32fc_16scPtrPtr = ^IppsIIRState32fc_16scPtr;
  IppsIIRState_64fPtrPtr = ^IppsIIRState_64fPtr;
  IppsIIRState_64fcPtrPtr = ^IppsIIRState_64fcPtr;
  IppsIIRState64f_32fPtrPtr = ^IppsIIRState64f_32fPtr;
  IppsIIRState64fc_32fcPtrPtr = ^IppsIIRState64fc_32fcPtr;
  IppsIIRState64f_32sPtrPtr = ^IppsIIRState64f_32sPtr;
  IppsIIRState64fc_32scPtrPtr = ^IppsIIRState64fc_32scPtr;
  IppsIIRState64f_16sPtrPtr = ^IppsIIRState64f_16sPtr;
  IppsIIRState64fc_16scPtrPtr = ^IppsIIRState64fc_16scPtr;

  IppsFIRSpec_32fPtr = OpaquePtr;
  IppsFIRSpec_64fPtr = OpaquePtr;
  IppsFIRSpec_32fcPtr = OpaquePtr;
  IppsFIRSpec_64fcPtr = OpaquePtr;

  IppsFIRLMSState_32fPtr = OpaquePtr;
  IppsFIRLMSState32f_16sPtr = OpaquePtr;

  IppsFIRLMSState_32fPtrPtr = ^IppsFIRLMSState_32fPtr;
  IppsFIRLMSState32f_16sPtrPtr = ^IppsFIRLMSState32f_16sPtr;

  IppsHilbertSpecPtr = OpaquePtr;

  IppsFIRSparseState_32fPtr = OpaquePtr;
  IppsIIRSparseState_32fPtr = OpaquePtr;

  IppsFIRSparseState_32fPtrPtr = ^IppsFIRSparseState_32fPtr;
  IppsIIRSparseState_32fPtrPtr = ^IppsIIRSparseState_32fPtr;

  IppsResamplingPolyphase_16sPtr = OpaquePtr;
  IppsResamplingPolyphaseFixed_16sPtr = OpaquePtr;
  IppsResamplingPolyphase_32fPtr = OpaquePtr;
  IppsResamplingPolyphaseFixed_32fPtr = OpaquePtr;


{----------------------------------------------------------------------------}
{                   Below are ippIP domain specific definitions              }
{----------------------------------------------------------------------------}

const
  IPP_TEMPORAL_COPY      = 0;
  IPP_NONTEMPORAL_STORE  = 1;
  IPP_NONTEMPORAL_LOAD   = 2;

type
  IppEnum = Int32;

{ define IPP_DEG_TO_RAD( deg ) ( (deg)/180.0 * IPP_PI ) }

const {duplicate identifier ippiNorm, AvO}
  k_ippiNormNone        = $00000000; { default }
  k_ippiNorm            = $00000100; { normalized form }
  k_ippiNormCoefficient = $00000200; { correlation coefficient in the range [-1.0 ... 1.0] }
  k_ippiNormMask        = $0000FF00;

type
  IppiNormOp = Int32;

const
  ippiROIFull   = $00000000;
  ippiROIValid  = $00010000;
  ippiROISame   = $00020000;
  ippiROIMask   = $00FF0000;

type
  IppiROIShape = Int32;

type
  IppChannels   =
    ( ippC0,
      ippC1,
      ippC2,
      ippC3,
      ippC4,
      ippP2,
      ippP3,
      ippP4,
      ippAC1,
      ippAC4,
      ippA0C4,
      ippAP4);

const
  ippBorderConst     =  0;
  ippBorderRepl      =  1;
  ippBorderWrap      =  2;
  ippBorderMirror    =  3; { left border: 012... -> 21012... }
  ippBorderMirrorR   =  4; { left border: 012... -> 210012... }
  ippBorderInMem     =  6;
  ippBorderTransp    =  7;
  ippBorderInMemTop     =  $0010;
  ippBorderInMemBottom  =  $0020;
  ippBorderInMemLeft    =  $0040;
  ippBorderInMemRight   =  $0080;

type
  IppiBorderType = Int32;

  IppiAxis = ( ippAxsHorizontal,  ippAxsVertical,  ippAxsBoth,  ippAxs45,  ippAxs135);

  IppiRectPtr = ^IppiRect;
  IppiRect =
    record
      x       : Int32;
      y       : Int32;
      width   : Int32;
      height  : Int32
    end;

  IppiPointPtr = ^IppiPoint;
  IppiPoint =
    record
      x       : Int32;
      y       : Int32
    end;

  IppiSizePtr = ^IppiSize;
  IppiSize =
    record
      width   : Int32;
      height  : Int32
    end;

  IppiPoint_32fPtr = ^IppiPoint_32f;
  IppiPoint_32f =
    record
      x       : Ipp32f;
      y       : Ipp32f
    end;

const
  ippMskSize1x3 = 13;
  ippMskSize1x5 = 15;
  ippMskSize3x1 = 31;
  ippMskSize3x3 = 33;
  ippMskSize5x1 = 51;
  ippMskSize5x5 = 55;

type
  IppiMaskSize = Int32;

const
  IPPI_INTER_NN                 =  1;
  IPPI_INTER_LINEAR             =  2;
  IPPI_INTER_CUBIC              =  4;
  IPPI_INTER_CUBIC2P_BSPLINE    =  5; { two-parameter cubic filter (B=1, C=0) }
  IPPI_INTER_CUBIC2P_CATMULLROM =  6; { two-parameter cubic filter (B=0, C=1/2) }
  IPPI_INTER_CUBIC2P_B05C03     =  7; { two-parameter cubic filter (B=1/2, C=3/10) }
  IPPI_INTER_SUPER              =  8;
  IPPI_INTER_LANCZOS            = 16;
  IPPI_ANTIALIASING             = 1 shl 29;
  IPPI_SUBPIXEL_EDGE            = 1 shl 30;
  IPPI_SMOOTH_EDGE              = 1 shl 31;

const
  ippNearest    = IPPI_INTER_NN;
  ippLinear     = IPPI_INTER_LINEAR;
  ippCubic      = IPPI_INTER_CUBIC2P_CATMULLROM;
  ippLanczos    = IPPI_INTER_LANCZOS;
  ippHahn       = 0;
  ippSuper      = IPPI_INTER_SUPER;

type
  IppiInterpolationType = Int32;

  IppiFraction =
    ( ippPolyphase_1_2,
      ippPolyphase_3_5,
      ippPolyphase_2_3,
      ippPolyphase_7_10,
      ippPolyphase_3_4);

const
  IPP_FASTN_ORIENTATION = $0001;
  IPP_FASTN_NMS         = $0002;
  IPP_FASTN_CIRCLE      = $0004;
  IPP_FASTN_SCORE_MODE0 = $0020;

type
  IppiAlphaType =
    ( ippAlphaOver,
      ippAlphaIn,
      ippAlphaOut,
      ippAlphaATop,
      ippAlphaXor,
      ippAlphaPlus,
      ippAlphaOverPremul,
      ippAlphaInPremul,
      ippAlphaOutPremul,
      ippAlphaATopPremul,
      ippAlphaXorPremul,
      ippAlphaPlusPremul);

  IppiDeconvFFTState_32f_C1RPtr = OpaquePtr;
  IppiDeconvFFTState_32f_C3RPtr = OpaquePtr;
  IppiDeconvLR_32f_C1RPtr = OpaquePtr;
  IppiDeconvLR_32f_C3RPtr = OpaquePtr;

const
  ippiFilterBilateralGauss = 100;
  ippiFilterBilateralGaussFast = 101;

type
  IppiFilterBilateralType = Int32;

  IppiFilterBilateralSpecPtr = OpaquePtr;

const
  ippDistNormL1 = $00000002;

type
  IppiDistanceMethodType = Int32;

  IppiResizeFilterType = ( ippResizeFilterHann,  ippResizeFilterLanczos);

  IppiResizeFilterStatePtr = OpaquePtr;

  IppiBorderSizePtr = ^IppiBorderSize;
  IppiBorderSize =
    record
      borderLeft    : Ipp32u;
      borderTop     : Ipp32u;
      borderRight   : Ipp32u;
      borderBottom  : Ipp32u
    end;

  IppiWarpDirection = ( ippWarpForward, ippWarpBackward);

  IppiWarpTransformType = ( ippWarpAffine, ippWarpPerspective, ippWarpBilinear);

type
  IppiResizeSpec_32fPtr = OpaquePtr;
  IppiResizeYUV422SpecPtr = OpaquePtr;
  IppiResizeYUV420SpecPtr = OpaquePtr;

  IppiResizeSpec_64fPtr = OpaquePtr;

  IppiWarpSpecPtr = OpaquePtr;

  IppiFilterBorderSpecPtr = OpaquePtr;

  IppiThresholdAdaptiveSpecPtr = OpaquePtr;

  IppiHistogramSpecPtr = OpaquePtr;

type
  IppiHOGConfigPtr = ^IppiHOGConfig;
  IppiHOGConfig =
    record
      cvCompatible    : Int32; { openCV compatible output format }
      cellSize        : Int32; { squre cell size (pixels) }
      blockSize       : Int32; { square block size (pixels) }
      blockStride     : Int32; { block displacement (the same for x- and y- directions) }
      nbins           : Int32; { required number of bins }
      sigma           : Ipp32f; { gaussian factor of HOG block weights }
      l2thresh        : Ipp32f; { normalization factor }
       winSize        : IppiSize { detection window size (pixels) }
    end;

type
  IppiFFTSpec_C_32fcPtr = OpaquePtr;
  IppiFFTSpec_R_32fPtr = OpaquePtr;

  IppiDFTSpec_C_32fcPtr = OpaquePtr;
  IppiDFTSpec_R_32fPtr = OpaquePtr;

  IppiDCTFwdSpec_32fPtr = OpaquePtr;
  IppiDCTInvSpec_32fPtr = OpaquePtr;

  IppiWTFwdSpec_32f_C1RPtr = OpaquePtr;
  IppiWTInvSpec_32f_C1RPtr = OpaquePtr;
  IppiWTFwdSpec_32f_C3RPtr = OpaquePtr;
  IppiWTInvSpec_32f_C3RPtr = OpaquePtr;

  IppiMomentState_64fPtr = OpaquePtr;

type
  IppiHuMoment_64fPtr = ^IppiHuMoment_64f;
  IppiHuMoment_64f = array[ 0..6] of Ipp64f;

type
  IppiLUT_SpecPtr = OpaquePtr;

const
  IPP_HOG_MAX_CELL   = 16; { max size of CELL }
  IPP_HOG_MAX_BLOCK  = 64; { max size of BLOCK }
  IPP_HOG_MAX_BINS   = 16; { max number of BINS }

type
  IppiHOGSpecPtr = OpaquePtr;


{ Below are 3D Image (Volume) Processing specific definitions }

type
  IpprVolumePtr = ^IpprVolume;
  IpprVolume =
    record
      width   : Int32;
      height  : Int32;
      depth   : Int32
    end;

  IpprCuboidPtr = ^IpprCuboid;
  IpprCuboid =
    record
      x       : Int32;
      y       : Int32;
      z       : Int32;
      width   : Int32;
      height  : Int32;
      depth   : Int32
    end;

  IpprPointPtr = ^IpprPoint;
  IpprPoint =
    record
      x       : Int32;
      y       : Int32;
      z       : Int32
    end;

{----------------------------------------------------------------------------}
{                   Below are ippCV domain specific definitions              }
{----------------------------------------------------------------------------}

type
  IppiDifferentialKernel =
    ( ippFilterSobelVert,
      ippFilterSobelHoriz,
      ippFilterSobel,
      ippFilterScharrVert,
      ippFilterScharrHoriz,
      ippFilterScharr,
      ippFilterCentralDiffVert,
      ippFilterCentralDiffHoriz,
      ippFilterCentralDiff);

  IppiKernelType = 
    ( ippKernelSobel,
      ippKernelScharr,
      ippKernelSobelNeg);

  IppiNorm =
    ( ippiNormInf,
      ippiNormL1,
      ippiNormL2,
      ippiNormFM);

type
  IppiMorphStatePtr = OpaquePtr;
  IppiMorphAdvStatePtr = OpaquePtr;
  IppiMorphGrayState_8uPtr = OpaquePtr;
  IppiMorphGrayState_32fPtr = OpaquePtr;

  IppiConvStatePtr = OpaquePtr;

type
  IppiConnectedCompPtr = ^IppiConnectedComp;
  IppiConnectedComp =
    record
      area    : Ipp64f;                 {  area of the segmented component  }
      value   : array[ 0..2] of Ipp64f; {  gray scale value of the segmented component  }
      rect    : IppiRect                {  bounding rectangle of the segmented component  }
    end;

type
  IppiPyramidStatePtr = OpaquePtr;

  IppiPyramidDownState_8u_C1RPtr      = IppiPyramidStatePtr;
  IppiPyramidDownState_16u_C1RPtr     = IppiPyramidStatePtr;
  IppiPyramidDownState_32f_C1RPtr     = IppiPyramidStatePtr;
  IppiPyramidDownState_8u_C3RPtr      = IppiPyramidStatePtr;
  IppiPyramidDownState_16u_C3RPtr     = IppiPyramidStatePtr;
  IppiPyramidDownState_32f_C3RPtr     = IppiPyramidStatePtr;
  IppiPyramidUpState_8u_C1RPtr        = IppiPyramidStatePtr;
  IppiPyramidUpState_16u_C1RPtr       = IppiPyramidStatePtr;
  IppiPyramidUpState_32f_C1RPtr       = IppiPyramidStatePtr;
  IppiPyramidUpState_8u_C3RPtr        = IppiPyramidStatePtr;
  IppiPyramidUpState_16u_C3RPtr       = IppiPyramidStatePtr;
  IppiPyramidUpState_32f_C3RPtr       = IppiPyramidStatePtr;

  IppiPyramidDownState_8u_C1RPtrPtr   = ^IppiPyramidStatePtr;
  IppiPyramidDownState_16u_C1RPtrPtr  = ^IppiPyramidStatePtr;
  IppiPyramidDownState_32f_C1RPtrPtr  = ^IppiPyramidStatePtr;
  IppiPyramidDownState_8u_C3RPtrPtr   = ^IppiPyramidStatePtr;
  IppiPyramidDownState_16u_C3RPtrPtr  = ^IppiPyramidStatePtr;
  IppiPyramidDownState_32f_C3RPtrPtr  = ^IppiPyramidStatePtr;
  IppiPyramidUpState_8u_C1RPtrPtr     = ^IppiPyramidStatePtr;
  IppiPyramidUpState_16u_C1RPtrPtr    = ^IppiPyramidStatePtr;
  IppiPyramidUpState_32f_C1RPtrPtr    = ^IppiPyramidStatePtr;
  IppiPyramidUpState_8u_C3RPtrPtr     = ^IppiPyramidStatePtr;
  IppiPyramidUpState_16u_C3RPtrPtr    = ^IppiPyramidStatePtr;
  IppiPyramidUpState_32f_C3RPtrPtr    = ^IppiPyramidStatePtr;

type
  IppiPyramidPtrPtr = ^IppiPyramidPtr;
  IppiPyramidPtr = ^IppiPyramid;
  IppiPyramid =
    record
      pImage  : Ipp8uPtrPtr;
      pRoi    : IppiSizePtr;
      pRate   : Ipp64fPtr;
      pStep   : Int32Ptr;
      pState  : Ipp8uPtr;
      level   : Int32
    end;

  IppiOptFlowPyrLKPtr = OpaquePtr;

type
  IppiOptFlowPyrLK_8u_C1RPtr  = IppiOptFlowPyrLKPtr;
  IppiOptFlowPyrLK_16u_C1RPtr = IppiOptFlowPyrLKPtr;
  IppiOptFlowPyrLK_32f_C1RPtr = IppiOptFlowPyrLKPtr;

  IppiOptFlowPyrLK_8u_C1RPtrPtr  = ^IppiOptFlowPyrLKPtr;
  IppiOptFlowPyrLK_16u_C1RPtrPtr = ^IppiOptFlowPyrLKPtr;
  IppiOptFlowPyrLK_32f_C1RPtrPtr = ^IppiOptFlowPyrLKPtr;

  IppiHaarClassifier_32fPtr = OpaquePtr;
  IppiHaarClassifier_32sPtr = OpaquePtr;

  IppFGHistogramState_8u_C1RPtr = OpaquePtr;
  IppFGHistogramState_8u_C3RPtr = OpaquePtr;

  IppFGGaussianState_8u_C1RPtr = OpaquePtr;
  IppFGGaussianState_8u_C3RPtr = OpaquePtr;

type
  IppiInpaintFlag =
    ( IPP_INPAINT_TELEA,
      IPP_INPAINT_NS);

type
  IppFilterGaussianSpecPtr = OpaquePtr;

  IppiInpaintState_8u_C1RPtr = OpaquePtr;
  IppiInpaintState_8u_C3RPtr = OpaquePtr;

  IppiInpaintState_8u_C1RPtrPtr = ^IppiInpaintState_8u_C1RPtr;
  IppiInpaintState_8u_C3RPtrPtr = ^IppiInpaintState_8u_C3RPtr;

  IppiHoughProbSpecPtr = OpaquePtr;

  IppiFastNSpecPtr = OpaquePtr;

type
  IppiCornerFastNPtr = ^IppiCornerFastN;
  IppiCornerFastN =
    record
      x             : Int32;
      y             : Int32;
      cornerType    : Int32;
      orientation   : Int32;
      angle         : single;
      score         : single
    end;

type
  IppFGMMState_8u_C3RPtr = OpaquePtr;

type
  IppFGMModelPtr = ^IppFGMModel;
  IppFGMModel =
    record
      numFrames     : Word32;
      maxNGauss     : Word32;
      varInit       : Ipp32f;
      varMin        : Ipp32f;
      varMax        : Ipp32f;
      varWBRatio    : Ipp32f;
      bckgThr       : Ipp32f;
      varNGRatio    : Ipp32f;
      reduction     : Ipp32f;
      shadowValue   : Ipp8u;
      shadowFlag    : char;
      shadowRatio   : Ipp32f
    end;

const
  IPP_SEGMENT_QUEUE     = $01;
  IPP_SEGMENT_DISTANCE  = $02;
  IPP_SEGMENT_BORDER_4  = $40;
  IPP_SEGMENT_BORDER_8  = $80;

{ define IPP_TRUNC(a,b) ((a)&~((b)-1)) }
{ define IPP_APPEND(a,b) (((a)+(b)-1)&~((b)-1)) }


{----------------------------------------------------------------------------}
{                   Below are ippCC domain specific definitions             }
{----------------------------------------------------------------------------}

const
  IPP_UPPER        = 1;
  IPP_LEFT         = 2;
  IPP_CENTER       = 4;
  IPP_RIGHT        = 8;
  IPP_LOWER        = 16;
  IPP_UPPER_LEFT   = 32;
  IPP_UPPER_RIGHT  = 64;
  IPP_LOWER_LEFT   = 128;
  IPP_LOWER_RIGHT  = 256;

type
  IppiDitherType =
    ( ippDitherNone,  ippDitherFS,  ippDitherJJN,  ippDitherStucki,  ippDitherBayer);


{----------------------------------------------------------------------------}
{                   Below are ippCH domain specific definitions             }
{----------------------------------------------------------------------------}

type
  IppRegExpFindPtr = ^IppRegExpFind;
  IppRegExpFind =
    record
      pFind   : Pointer;
      lenFind : Int32 
    end;

type
  IppRegExpStatePtr = OpaquePtr;

type
  IppRegExpFormat =
    ( ippFmtASCII,
      ippFmtUTF8);

type
  IppRegExpReplaceStatePtr = OpaquePtr;


{----------------------------------------------------------------------------}
{                   Below are ippDC domain specific definitions             }
{----------------------------------------------------------------------------}

type
  IppMTFState_8uPtr = OpaquePtr;

type
  IppBWTSortAlgorithmHint =
    ( ippBWTItohTanakaLimSort,
      ippBWTItohTanakaUnlimSort,
      ippBWTSuffixSort,
      ippBWTAutoSort);

type
  IppLZSSState_8uPtr = OpaquePtr;
  IppLZ77State_8uPtr = OpaquePtr;

type
  IppLZ77ComprLevel =
    ( IppLZ77FastCompr,
      IppLZ77AverageCompr,
      IppLZ77BestCompr);

  IppLZ77Chcksm =
    ( IppLZ77NoChcksm,
      IppLZ77Adler32,
      IppLZ77CRC32);
  
  IppLZ77Flush =
    ( IppLZ77NoFlush,
      IppLZ77SyncFlush,
      IppLZ77FullFlush,
      IppLZ77FinishFlush);

  IppLZ77PairPtr = ^IppLZ77Pair;
  IppLZ77Pair =
    record
      length  : Ipp16u;
      offset  : Ipp16u
    end;

  IppLZ77DeflateStatus =
    ( IppLZ77StatusInit,
      IppLZ77StatusLZ77Process,
      IppLZ77StatusHuffProcess,
      IppLZ77StatusFinal);

  IppLZ77HuffMode =
    ( IppLZ77UseFixed,
      IppLZ77UseDynamic,
      IppLZ77UseStored);

  IppLZ77InflateStatus =
    ( IppLZ77InflateStatusInit,
      IppLZ77InflateStatusHuffProcess,
      IppLZ77InflateStatusLZ77Process,
      IppLZ77InflateStatusFinal);

  IppInflateStatePtr = ^IppInflateState;
  IppInflateState =
    record
      pWindow         : Ipp8uPtr; { pointer to the sliding window (the dictionary for the LZ77 algorithm) }
      winSize         : Word32;   { size of the sliding window }
      tableType       : Word32;   { type of Huffman code tables ( example : for ; 0 - tables for Fixed Huffman codes) }
      tableBufferSize : Word32    { (ENOUGH = 2048) * (sizeof(code) = 4) - sizeof(IppInflateState) }
    end;

  IppInflateModePtr = ^IppInflateMode;
  IppInflateMode = { this type is used as a translator of the inflate_mode type from zlib }
    ( ippTYPE,
      ippLEN,
      ippLENEXT);

  IppDeflateFreqTablePtr = ^IppDeflateFreqTable;
  IppDeflateFreqTable =
    record
      freq  : Ipp16u;
      code  : Ipp16u
    end;

  IppDeflateFreqTable30Ptr = ^IppDeflateFreqTable30;
  IppDeflateFreqTable30 = array[ 0..29] of IppDeflateFreqTable;

  IppDeflateFreqTable286Ptr = ^IppDeflateFreqTable286;
  IppDeflateFreqTable286 = array[ 0..285] of IppDeflateFreqTable;

  IppDeflateHuffCodePtr = ^IppDeflateHuffCode;
  IppDeflateHuffCode =
    record
      code  : Ipp16u;
      len   : Ipp16u
    end;
  
  IppDeflateHuffCode30Ptr = ^IppDeflateHuffCode30;
  IppDeflateHuffCode30 = array[ 0..29] of IppDeflateHuffCode;

  IppDeflateHuffCode286Ptr = ^IppDeflateHuffCode286;
  IppDeflateHuffCode286 = array[ 0..285] of IppDeflateHuffCode;

type
  IppRLEState_BZ2Ptr = OpaquePtr;

  IppEncodeHuffState_BZ2Ptr = OpaquePtr;

  IppDecodeHuffState_BZ2Ptr = OpaquePtr;

type
  IppLZOMethod =
    ( IppLZO1XST,  { Single-threaded, generic LZO-compatible}
      IppLZO1XMT); { Multi-threaded }

type
  IppLZOState_8uPtr = OpaquePtr;

{ ----------------------------------------------------------------------------

        The following enumerator defines a status of IPP operations
                     negative value means error
}

const
  ippStsNotSupportedModeErr    = -9999; { The requested mode is currently not supported.  }
  ippStsCpuNotSupportedErr     = -9998; { The target CPU is not supported. }
  ippStsInplaceModeNotSupportedErr = -9997; { The inplace operation is currently not supported. }

  ippStsIIRIIRLengthErr        = -234; { Vector length for IIRIIR function is less than 3*(IIR order) }
  ippStsWarpTransformTypeErr   = -233; { The warp transform type is illegal }
  ippStsExceededSizeErr        = -232; { Requested size exceeded the maximum supported ROI size }
  ippStsWarpDirectionErr       = -231; { The warp transform direction is illegal }

  ippStsFilterTypeErr          = -230; { The filter type is incorrect or not supported }

  ippStsNormErr                = -229; { The norm is incorrect or not supported }

  ippStsAlgTypeErr             = -228; { Algorithm type is not supported.        }
  ippStsMisalignedOffsetErr    = -227; { The offset is not aligned with an element. }

  ippStsQuadraticNonResidueErr = -226; { SQRT operation on quadratic non-residue value. }

  ippStsBorderErr              = -225; { Illegal value for border type.}

  ippStsDitherTypeErr          = -224; { Dithering type is not supported. }
  ippStsH264BufferFullErr      = -223; { Buffer for the output bitstream is full. }
  ippStsWrongAffinitySettingErr= -222; { An affinity setting does not correspond to the affinity setting that was set by f.ippSetAffinity(). }
  ippStsLoadDynErr             = -221; { Error when loading the dynamic library. }

  ippStsPointAtInfinity        = -220; { Point at infinity is detected.  }

  ippStsUnknownStatusCodeErr   = -216; { Unknown status code. }

  ippStsOFBSizeErr             = -215; { Incorrect value for crypto OFB block size. }
  ippStsLzoBrokenStreamErr     = -214; { LZO safe decompression function cannot decode LZO stream. }

  ippStsRoundModeNotSupportedErr  = -213; { Rounding mode is not supported. }
  ippStsDecimateFractionErr    = -212; { Fraction in Decimate is not supported. }
  ippStsWeightErr              = -211; { Incorrect value for weight. }

  ippStsQualityIndexErr        = -210; { Cannot calculate the quality index for an image filled with a constant. }
  ippStsIIRPassbandRippleErr   = -209; { Ripple in passband for Chebyshev1 design is less than zero,  equal to zero,  or greater than 29. }
  ippStsFilterFrequencyErr     = -208; { Cutoff frequency of filter is less than zero,  equal to zero,  or greater than 0.5. }
  ippStsFIRGenOrderErr         = -207; { Order of the FIR filter for design is less than 1.                    }
  ippStsIIRGenOrderErr         = -206; { Order of the IIR filter for design is less than 1,  or greater than 12. }

  ippStsConvergeErr            = -205; { The algorithm does not converge. }
  ippStsSizeMatchMatrixErr     = -204; { The sizes of the source matrices are unsuitable. }
  ippStsCountMatrixErr         = -203; { Count value is less than,  or equal to zero. }
  ippStsRoiShiftMatrixErr      = -202; { RoiShift value is negative or not divisible by the size of the data type. }

  ippStsResizeNoOperationErr   = -201; { One of the output image dimensions is less than 1 pixel. }
  ippStsSrcDataErr             = -200; { The source buffer contains unsupported data. }
  ippStsMaxLenHuffCodeErr      = -199; { Huff: Max length of Huffman code is more than the expected one. }
  ippStsCodeLenTableErr        = -198; { Huff: Invalid codeLenTable. }
  ippStsFreqTableErr           = -197; { Huff: Invalid freqTable. }

  ippStsIncompleteContextErr   = -196; { Crypto: set up of context is not complete. }

  ippStsSingularErr            = -195; { Matrix is singular. }
  ippStsSparseErr              = -194; { Positions of taps are not in ascending order,  or are negative,  or repetitive. }
  ippStsBitOffsetErr           = -193; { Incorrect bit offset value. }
  ippStsQPErr                  = -192; { Incorrect quantization parameter value. }
  ippStsVLCErr                 = -191; { Illegal VLC or FLC is detected during stream decoding. }
  ippStsRegExpOptionsErr       = -190; { RegExp: Options for the pattern are incorrect. }
  ippStsRegExpErr              = -189; { RegExp: The structure pRegExpState contains incorrect data. }
  ippStsRegExpMatchLimitErr    = -188; { RegExp: The match limit is exhausted. }
  ippStsRegExpQuantifierErr    = -187; { RegExp: Incorrect quantifier. }
  ippStsRegExpGroupingErr      = -186; { RegExp: Incorrect grouping. }
  ippStsRegExpBackRefErr       = -185; { RegExp: Incorrect back reference. }
  ippStsRegExpChClassErr       = -184; { RegExp: Incorrect character class. }
  ippStsRegExpMetaChErr        = -183; { RegExp: Incorrect metacharacter. }
  ippStsStrideMatrixErr        = -182; { Stride value is not positive or not divisible by the size of the data type. }
  ippStsCTRSizeErr             = -181; { Incorrect value for crypto CTR block size. }
  ippStsJPEG2KCodeBlockIsNotAttached =-180; { Codeblock parameters are not attached to the state structure. }
  ippStsNotPosDefErr           = -179; { Matrix is not positive definite. }

  ippStsEphemeralKeyErr        = -178; { ECC: Invalid ephemeral key.   }
  ippStsMessageErr             = -177; { ECC: Invalid message digest.  }
  ippStsShareKeyErr            = -176; { ECC: Invalid share key.   }
  ippStsIvalidPublicKey        = -175; { ECC: Invalid public key.  }
  ippStsIvalidPrivateKey       = -174; { ECC: Invalid private key. }
  ippStsOutOfECErr             = -173; { ECC: Point out of EC.     }
  ippStsECCInvalidFlagErr      = -172; { ECC: Invalid Flag.        }

  ippStsMP3FrameHeaderErr      = -171; { Error in fields of the IppMP3FrameHeader structure. }
  ippStsMP3SideInfoErr         = -170; { Error in fields of the IppMP3SideInfo structure. }

  ippStsBlockStepErr           = -169; { Step for Block is less than 8. }
  ippStsMBStepErr              = -168; { Step for MB is less than 16. }

  ippStsAacPrgNumErr           = -167; { AAC: Invalid number of elements for one program.   }
  ippStsAacSectCbErr           = -166; { AAC: Invalid section codebook.                     }
  ippStsAacSfValErr            = -164; { AAC: Invalid scalefactor value.                    }
  ippStsAacCoefValErr          = -163; { AAC: Invalid quantized coefficient value.          }
  ippStsAacMaxSfbErr           = -162; { AAC: Invalid coefficient index.  }
  ippStsAacPredSfbErr          = -161; { AAC: Invalid predicted coefficient index.  }
  ippStsAacPlsDataErr          = -160; { AAC: Invalid pulse data attributes.  }
  ippStsAacGainCtrErr          = -159; { AAC: Gain control is not supported.  }
  ippStsAacSectErr             = -158; { AAC: Invalid number of sections.  }
  ippStsAacTnsNumFiltErr       = -157; { AAC: Invalid number of TNS filters.  }
  ippStsAacTnsLenErr           = -156; { AAC: Invalid length of TNS region.  }
  ippStsAacTnsOrderErr         = -155; { AAC: Invalid order of TNS filter.  }
  ippStsAacTnsCoefResErr       = -154; { AAC: Invalid bit-resolution for TNS filter coefficients.  }
  ippStsAacTnsCoefErr          = -153; { AAC: Invalid coefficients of TNS filter. }
  ippStsAacTnsDirectErr        = -152; { AAC: Invalid direction TNS filter.  }
  ippStsAacTnsProfileErr       = -151; { AAC: Invalid TNS profile.  }
  ippStsAacErr                 = -150; { AAC: Internal error.  }
  ippStsAacBitOffsetErr        = -149; { AAC: Invalid current bit offset in bitstream.  }
  ippStsAacAdtsSyncWordErr     = -148; { AAC: Invalid ADTS syncword.  }
  ippStsAacSmplRateIdxErr      = -147; { AAC: Invalid sample rate index.  }
  ippStsAacWinLenErr           = -146; { AAC: Invalid window length (not short or long).  }
  ippStsAacWinGrpErr           = -145; { AAC: Invalid number of groups for current window length.  }
  ippStsAacWinSeqErr           = -144; { AAC: Invalid window sequence range.  }
  ippStsAacComWinErr           = -143; { AAC: Invalid common window flag.  }
  ippStsAacStereoMaskErr       = -142; { AAC: Invalid stereo mask.  }
  ippStsAacChanErr             = -141; { AAC: Invalid channel number.  }
  ippStsAacMonoStereoErr       = -140; { AAC: Invalid mono-stereo flag.  }
  ippStsAacStereoLayerErr      = -139; { AAC: Invalid this Stereo Layer flag.  }
  ippStsAacMonoLayerErr        = -138; { AAC: Invalid this Mono Layer flag.  }
  ippStsAacScalableErr         = -137; { AAC: Invalid scalable object flag.  }
  ippStsAacObjTypeErr          = -136; { AAC: Invalid audio object type.  }
  ippStsAacWinShapeErr         = -135; { AAC: Invalid window shape.  }
  ippStsAacPcmModeErr          = -134; { AAC: Invalid PCM output interleaving indicator.  }
  ippStsVLCUsrTblHeaderErr          = -133; { VLC: Invalid header inside table. }
  ippStsVLCUsrTblUnsupportedFmtErr  = -132; { VLC: Table format is not supported.  }
  ippStsVLCUsrTblEscAlgTypeErr      = -131; { VLC: Ecs-algorithm is not supported. }
  ippStsVLCUsrTblEscCodeLengthErr   = -130; { VLC: Esc-code length inside table header is incorrect. }
  ippStsVLCUsrTblCodeLengthErr      = -129; { VLC: Code length inside table is incorrect.  }
  ippStsVLCInternalTblErr           = -128; { VLC: Invalid internal table. }
  ippStsVLCInputDataErr             = -127; { VLC: Invalid input data. }
  ippStsVLCAACEscCodeLengthErr      = -126; { VLC: Invalid AAC-Esc code length. }
  ippStsNoiseRangeErr         = -125; { Noise value for Wiener Filter is out of range. }
  ippStsUnderRunErr           = -124; { Error in data under run. }
  ippStsPaddingErr            = -123; { Detected padding error indicates the possible data corruption. }
  ippStsCFBSizeErr            = -122; { Incorrect value for crypto CFB block size. }
  ippStsPaddingSchemeErr      = -121; { Invalid padding scheme.  }
  ippStsInvalidCryptoKeyErr   = -120; { A compromised key causes suspansion of the requested cryptographic operation.  }
  ippStsLengthErr             = -119; { Incorrect value for string length. }
  ippStsBadModulusErr         = -118; { Bad modulus caused a failure in module inversion. }
  ippStsLPCCalcErr            = -117; { Cannot evaluate linear prediction. }
  ippStsRCCalcErr             = -116; { Cannot compute reflection coefficients. }
  ippStsIncorrectLSPErr       = -115; { Incorrect values for Linear Spectral Pair. }
  ippStsNoRootFoundErr        = -114; { No roots are found for equation. }
  ippStsJPEG2KBadPassNumber   = -113; { Pass number exceeds allowed boundaries [0,nOfPasses-1]. }
  ippStsJPEG2KDamagedCodeBlock= -112; { Codeblock for decoding contains damaged data. }
  ippStsH263CBPYCodeErr       = -111; { Illegal Huffman code is detected through CBPY stream processing. }
  ippStsH263MCBPCInterCodeErr = -110; { Illegal Huffman code is detected through MCBPC Inter stream processing. }
  ippStsH263MCBPCIntraCodeErr = -109; { Illegal Huffman code is detected through MCBPC Intra stream processing. }
  ippStsNotEvenStepErr        = -108; { Step value is not pixel multiple. }
  ippStsHistoNofLevelsErr     = -107; { Number of levels for histogram is less than 2. }
  ippStsLUTNofLevelsErr       = -106; { Number of levels for LUT is less than 2. }
  ippStsMP4BitOffsetErr       = -105; { Incorrect bit offset value. }
  ippStsMP4QPErr              = -104; { Incorrect quantization parameter. }
  ippStsMP4BlockIdxErr        = -103; { Incorrect block index. }
  ippStsMP4BlockTypeErr       = -102; { Incorrect block type. }
  ippStsMP4MVCodeErr          = -101; { Illegal Huffman code is detected during MV stream processing. }
  ippStsMP4VLCCodeErr         = -100; { Illegal Huffman code is detected during VLC stream processing. }
  ippStsMP4DCCodeErr          = -99; { Illegal code is detected during DC stream processing. }
  ippStsMP4FcodeErr           = -98; { Incorrect fcode value. }
  ippStsMP4AlignErr           = -97; { Incorrect buffer alignment .           }
  ippStsMP4TempDiffErr        = -96; { Incorrect temporal difference.         }
  ippStsMP4BlockSizeErr       = -95; { Incorrect size of a block or macroblock. }
  ippStsMP4ZeroBABErr         = -94; { All BAB values are equal to zero.             }
  ippStsMP4PredDirErr         = -93; { Incorrect prediction direction.        }
  ippStsMP4BitsPerPixelErr    = -92; { Incorrect number of bits per pixel.    }
  ippStsMP4VideoCompModeErr   = -91; { Incorrect video component mode.       }
  ippStsMP4LinearModeErr      = -90; { Incorrect DC linear mode. }
  ippStsH263PredModeErr       = -83; { Incorrect Prediction Mode value.                                       }
  ippStsH263BlockStepErr      = -82; { The step value is less than 8.                                         }
  ippStsH263MBStepErr         = -81; { The step value is less than 16.                                        }
  ippStsH263FrameWidthErr     = -80; { The frame width is less than 8.                                        }
  ippStsH263FrameHeightErr    = -79; { The frame height is less than,  or equal to zero.                        }
  ippStsH263ExpandPelsErr     = -78; { Expand pixels number is less than 8.                               }
  ippStsH263PlaneStepErr      = -77; { Step value is less than the plane width.                           }
  ippStsH263QuantErr          = -76; { Quantizer value is less than,  or equal to zero,  or greater than 31. }
  ippStsH263MVCodeErr         = -75; { Illegal Huffman code is detected during MV stream processing.                  }
  ippStsH263VLCCodeErr        = -74; { Illegal Huffman code is detected during VLC stream processing.                 }
  ippStsH263DCCodeErr         = -73; { Illegal code is detected during DC stream processing.                          }
  ippStsH263ZigzagLenErr      = -72; { Zigzag compact length is more than 64.                             }
  ippStsFBankFreqErr          = -71; { Incorrect value for the filter bank frequency parameter. }
  ippStsFBankFlagErr          = -70; { Incorrect value for the filter bank parameter.           }
  ippStsFBankErr              = -69; { Filter bank is not correctly initialized.              }
  ippStsNegOccErr             = -67; { Occupation count is negative.                     }
  ippStsCdbkFlagErr           = -66; { Incorrect value for the codebook flag parameter. }
  ippStsSVDCnvgErr            = -65; { SVD algorithm does not converge.               }
  ippStsJPEGHuffTableErr      = -64; { JPEG Huffman table is destroyed.        }
  ippStsJPEGDCTRangeErr       = -63; { JPEG DCT coefficient is out of range. }
  ippStsJPEGOutOfBufErr       = -62; { Attempt to access out of the buffer limits.   }
  ippStsDrawTextErr           = -61; { System error in the draw text operation. }
  ippStsChannelOrderErr       = -60; { Incorrect order of the destination channels. }
  ippStsZeroMaskValuesErr     = -59; { All values of the mask are equal to zero. }
  ippStsQuadErr               = -58; { The quadrangle is nonconvex or degenerates into triangle,  line, or point }
  ippStsRectErr               = -57; { Size of the rectangle region is less than,  or equal to 1. }
  ippStsCoeffErr              = -56; { Incorrect values for transformation coefficients.   }
  ippStsNoiseValErr           = -55; { Incorrect value for noise amplitude for dithering.             }
  ippStsDitherLevelsErr       = -54; { Number of dithering levels is out of range.             }
  ippStsNumChannelsErr        = -53; { Number of channels is incorrect,  or not supported.                  }
  ippStsCOIErr                = -52; { COI is out of range. }
  ippStsDivisorErr            = -51; { Divisor is equal to zero,  function is aborted. }
  ippStsAlphaTypeErr          = -50; { Illegal type of image compositing operation.                           }
  ippStsGammaRangeErr         = -49; { Gamma range bounds is less than,  or equal to zero.                      }
  ippStsGrayCoefSumErr        = -48; { Sum of the conversion coefficients must be less than,  or equal to 1.    }
  ippStsChannelErr            = -47; { Illegal channel number.                                                }
  ippStsToneMagnErr           = -46; { Tone magnitude is less than,  or equal to zero.                          }
  ippStsToneFreqErr           = -45; { Tone frequency is negative,  or greater than,  or equal to 0.5.           }
  ippStsTonePhaseErr          = -44; { Tone phase is negative,  or greater than,  or equal to 2*PI.              }
  ippStsTrnglMagnErr          = -43; { Triangle magnitude is less than,  or equal to zero.                      }
  ippStsTrnglFreqErr          = -42; { Triangle frequency is negative,  or greater than,  or equal to 0.5.       }
  ippStsTrnglPhaseErr         = -41; { Triangle phase is negative,  or greater than,  or equal to 2*PI.          }
  ippStsTrnglAsymErr          = -40; { Triangle asymmetry is less than -PI, or greater than,  or equal to PI.   }
  ippStsHugeWinErr            = -39; { Kaiser window is too big.                                             }
  ippStsJaehneErr             = -38; { Magnitude value is negative.                                           }
  ippStsStrideErr             = -37; { Stride value is less than the length of the row. }
  ippStsEpsValErr             = -36; { Negative epsilon value.             }
  ippStsWtOffsetErr           = -35; { Invalid offset value for wavelet filter.                                       }
  ippStsAnchorErr             = -34; { Anchor point is outside the mask.                                             }
  ippStsMaskSizeErr           = -33; { Invalid mask size.                                                           }
  ippStsShiftErr              = -32; { Shift value is less than zero.                                                }
  ippStsSampleFactorErr       = -31; { Sampling factor is less than,  or equal to zero.                                }
  ippStsSamplePhaseErr        = -30; { Phase value is out of range: 0 <= phase < factor.                             }
  ippStsFIRMRFactorErr        = -29; { MR FIR sampling factor is less than,  or equal to zero.                         }
  ippStsFIRMRPhaseErr         = -28; { MR FIR sampling phase is negative,  or greater than,  or equal to the sampling factor. }
  ippStsRelFreqErr            = -27; { Relative frequency value is out of range.                                     }
  ippStsFIRLenErr             = -26; { Length of a FIR filter is less than,  or equal to zero.                         }
  ippStsIIROrderErr           = -25; { Order of an IIR filter is not valid. }
  ippStsDlyLineIndexErr       = -24; { Invalid value for the delay line sample index. }
  ippStsResizeFactorErr       = -23; { Resize factor(s) is less than,  or equal to zero. }
  ippStsInterpolationErr      = -22; { Invalid interpolation mode. }
  ippStsMirrorFlipErr         = -21; { Invalid flip mode.                                         }
  ippStsMoment00ZeroErr       = -20; { Moment value M(0,0) is too small to continue calculations. }
  ippStsThreshNegLevelErr     = -19; { Negative value of the level in the threshold operation.    }
  ippStsThresholdErr          = -18; { Invalid threshold bounds. }
  ippStsContextMatchErr       = -17; { Context parameter does not match the operation. }
  ippStsFftFlagErr            = -16; { Invalid value for the FFT flag parameter. }
  ippStsFftOrderErr           = -15; { Invalid value for the FFT order parameter. }
  ippStsStepErr               = -14; { Step value is not valid. }
  ippStsScaleRangeErr         = -13; { Scale bounds are out of range. }
  ippStsDataTypeErr           = -12; { Data type is incorrect or not supported. }
  ippStsOutOfRangeErr         = -11; { Argument is out of range,  or point is outside the image. }
  ippStsDivByZeroErr          = -10; { An attempt to divide by zero. }
  ippStsMemAllocErr           = -9; { Memory allocated for the operation is not enough.}
  ippStsNullPtrErr            = -8; { Null pointer error. }
  ippStsRangeErr              = -7; { Incorrect values for bounds: the lower bound is greater than the upper bound. }
  ippStsSizeErr               = -6; { Incorrect value for data size. }
  ippStsBadArgErr             = -5; { Incorrect arg/param of the function.  }
  ippStsNoMemErr              = -4; { Not enough memory for the operation. }
  ippStsSAReservedErr3        = -3; { Unknown/unspecified error,  -3. }
  ippStsErr                   = -2; { Unknown/unspecified error,  -2. }
  ippStsSAReservedErr1        = -1; { Unknown/unspecified error,  -1. }

   { no errors }
  ippStsNoErr                 =   0; { No errors. }

   { warnings  }
  ippStsNoOperation       =   1; { No operation has been executed. }
  ippStsMisalignedBuf     =   2; { Misaligned pointer in operation in which it must be aligned. }
  ippStsSqrtNegArg        =   3; { Negative value(s) for the argument in the Sqrt function. }
  ippStsInvZero           =   4; { INF result. Zero value was met by InvThresh with zero level. }
  ippStsEvenMedianMaskSize=   5; { Even size of the Median Filter mask was replaced with the odd one. }
  ippStsDivByZero         =   6; { Zero value(s) for the divisor in the Div function. }
  ippStsLnZeroArg         =   7; { Zero value(s) for the argument in the Ln function.     }
  ippStsLnNegArg          =   8; { Negative value(s) for the argument in the Ln function. }
  ippStsNanArg            =   9; { Argument value is not a number.                  }
  ippStsJPEGMarker        =   10; { JPEG marker in the bitstream.                 }
  ippStsResFloor          =   11; { All result values are floored.                        }
  ippStsOverflow          =   12; { Overflow in the operation.                   }
  ippStsLSFLow            =   13; { Quantized LP synthesis filter stability check is applied at the low boundary of [0;pi]. }
  ippStsLSFHigh           =   14; { Quantized LP synthesis filter stability check is applied at the high boundary of [0;pi]. }
  ippStsLSFLowAndHigh     =   15; { Quantized LP synthesis filter stability check is applied at both boundaries of [0;pi]. }
  ippStsZeroOcc           =   16; { Zero occupation count. }
  ippStsUnderflow         =   17; { Underflow in the operation. }
  ippStsSingularity       =   18; { Singularity in the operation.                                       }
  ippStsDomain            =   19; { Argument is out of the function domain.                                      }
  ippStsNonIntelCpu       =   20; { The target CPU is not Genuine Intel.                                         }
  ippStsCpuMismatch       =   21; { Cannot set the library for the given CPU.                                     }
  ippStsNoIppFunctionFound =  22; { Application does not contain Intel IPP function calls.                            }
  ippStsDllNotFoundBestUsed = 23; { Dispatcher cannot find the newest version of the Intel IPP dll.                  }
  ippStsNoOperationInDll  =   24; { The function does nothing in the dynamic version of the library.             }
  ippStsInsufficientEntropy=  25; { Generation of the prime/key failed due to insufficient entropy in the random seed and stimulus bit string. }
  ippStsOvermuchStrings   =   26; { Number of destination strings is more than expected.                         }
  ippStsOverlongString    =   27; { Length of one of the destination strings is more than expected.              }
  ippStsAffineQuadChanged =   28; { 4th vertex of destination quad is not equal to customer`s one.               }
  ippStsWrongIntersectROI =   29; { ROI has no intersection with the source or destination ROI. No operation. }
  ippStsWrongIntersectQuad =  30; { Quadrangle has no intersection with the source or destination ROI. No operation. }
  ippStsSmallerCodebook   =   31; { Size of created codebook is less than the cdbkSize argument. }
  ippStsSrcSizeLessExpected = 32; { DC: Size of the source buffer is less than the expected one. }
  ippStsDstSizeLessExpected = 33; { DC: Size of the destination buffer is less than the expected one. }
  ippStsStreamEnd           = 34; { DC: The end of stream processed. }
  ippStsDoubleSize        =   35; { Width or height of image is odd. }
  ippStsNotSupportedCpu   =   36; { The CPU is not supported. }
  ippStsUnknownCacheSize  =   37; { The CPU is supported,  but the size of the cache is unknown. }
  ippStsSymKernelExpected =   38; { The Kernel is not symmetric. }
  ippStsEvenMedianWeight  =   39; { Even weight of the Weighted Median Filter is replaced with the odd one. }
  ippStsWrongIntersectVOI =   40; { VOI has no intersection with the source or destination volume. No operation.                            }
  ippStsI18nMsgCatalogInvalid=41; { Message Catalog is invalid,  English message returned.                                                    }
  ippStsI18nGetMessageFail  = 42; { Failed to fetch a localized message,  English message returned. For more information use errno on Linux* OS and GetLastError on Windows* OS. }
  ippStsWaterfall           = 43; { Cannot load required library,  waterfall is used. }
  ippStsPrevLibraryUsed     = 44; { Cannot load required library,  previous dynamic library is used. }
  ippStsLLADisabled         = 45; { OpenMP* Low Level Affinity is disabled. }
  ippStsNoAntialiasing      = 46; { The mode does not support antialiasing. }
  ippStsRepetitiveSrcData   = 47; { DC: The source data is too repetitive. }
  ippStsSizeWrn             = 48; { The size does not allow to perform full operation. }
  ippStsFeatureNotSupported = 49; { Current CPU doesn`t support at least 1 of the desired features. }
  ippStsUnknownFeature      = 50; { At least one of the desired features is unknown. }
  ippStsFeaturesCombination = 51; { Wrong combination of features. }
  ippStsAccurateModeNotSupported = 52; { Accurate mode is not supported. }

type
  IppStatus = Int32;

{const} var  
  ippRectInfinite : IppiRect external name '_ippRectInfinite';

{
              Intel(R) Integrated Performance Primitives
              Core (ippCore)
}

{ ----------------------------------------------------------------------------

                   Functions declarations

{ ----------------------------------------------------------------------------

  Name:       ippGetLibVersion
  Purpose:    getting of the library version
  Returns:    the structure of information about version
              of ippcore library
  Parameters:

  Notes:      not necessary to release the returned structure
}

 function ippGetLibVersion: IppLibraryVersionPtr; cdecl; external;

{ ----------------------------------------------------------------------------

  Name:       ippGetStatusString
  Purpose:    convert the library status code to a readable string
  Parameters:
    StsCode   IPP status code
  Returns:    pointer to string describing the library status code

  Notes:      don`t free the pointer
}

 function ippGetStatusString( StsCode: IppStatus): charPtr; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippGetCpuClocks
  Purpose:    reading of time stamp counter (TSC) register value
  Returns:    TSC value

  Note:      An hardware exception is possible if TSC reading is not supported by
/              the current chipset
}

 function ippGetCpuClocks: Ipp64u; _ippapi

{ ----------------------------------------------------------------------------

  Names:  ippSetFlushToZero,
          ippSetDenormAreZero.

  Purpose: ippSetFlushToZero enables or disables the flush-to-zero mode, 
           ippSetDenormAreZero enables or disables the denormals-are-zeros
           mode.

  Arguments:
     value       - !0 or 0 - set or clear the corresponding bit of MXCSR
     pUMask      - pointer to user store current underflow exception mask
                   ( may be NULL if don`t want to store )

  Return:
   ippStsNoErr              - Ok
   ippStsCpuNotSupportedErr - the mode is not supported
}

 function ippSetFlushToZero( value : Int32 ; pUMask : Word32Ptr ): IppStatus; _ippapi
 function ippSetDenormAreZeros( value : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippAlignPtr
  Purpose:    pointer aligning
  Returns:    aligned pointer

  Parameter:
    ptr        - pointer
    alignBytes - number of bytes to align
}

 function ippAlignPtr( ptr : Pointer ; alignBytes : Int32 ): Pointer; _ippapi

{ ----------------------------------------------------------------------------

                   Functions to allocate and free memory
{ ----------------------------------------------------------------------------

  Name:       ippMalloc
  Purpose:    64-byte aligned memory allocation
  Parameter:
    len       number of bytes
  Returns:    pointer to allocated memory

  Notes:      the memory allocated by ippMalloc has to be free by ippFree
              function only.
}

 function ippMalloc(length : Int32 ): Pointer; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippFree
  Purpose:    free memory allocated by the ippMalloc function
  Parameter:
    ptr       pointer to the memory allocated by the ippMalloc function

  Notes:      use the function to free memory allocated by ippMalloc
}

procedure ippFree(ptr : Pointer ); _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippInit
  Purpose:    Automatic switching to best for current cpu library code using.
  Returns:
   ippStsNoErr

  Parameter:  nothing

  Notes:      At the moment of this function execution no any other IPP function
              has to be working
}

 function ippInit: IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippGetCpuFreqMhz

  Purpose:    the function estimates cpu frequency and returns
              its value in MHz as a integer

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         null pointer to the freq value
    ippStsSizeErr            wrong num tries : of ; internal var
  Arguments:
    pMhz                     pointer to the integer to write
                             cpu freq value estimated

  Notes:      no exact value guaranteed : is ; the value could
              vary with cpu workloading
}

 function ippGetCpuFreqMhz( pMhz : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippSetNumThreads

  Purpose:

  Return:
    ippStsNoErr              Ok
    ippStsNoOperation        For static library internal threading is not supported
    ippStsSizeErr            Desired number of threads less or equal zero

  Arguments:
    numThr                   Desired number of threads
}

 function ippSetNumThreads( numThr : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippGetNumThreads

  Purpose:

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         Pointer to numThr is Null
    ippStsNoOperation        For static library internal threading is not supported
                             and return value is always == 1

  Arguments:
    pNumThr                  Pointer to memory location where to store current numThr
}

 function ippGetNumThreads( var pNumThr : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippGetMaxCacheSizeB

  Purpose:  Detects maximal from the sizes of L2 or L3 in bytes

  Return:
    ippStsNullPtrErr         The result`s pointer is NULL.
    ippStsNotSupportedCpu    The cpu is not supported.
    ippStsUnknownCacheSize   The cpu supported : is ; but the size of the cache is unknown.
    ippStsNoErr              Ok

  Arguments:
    pSizeByte                Pointer to the result

  Note:
    1). Intel(R) processors are supported only.
    2). Intel(R) Itanium(R) processors and platforms with Intel XScale(R) technology are unsupported
    3). For unsupported processors the result is "0",
        and the return status is "ippStsNotSupportedCpu".
    4). For supported processors the result is "0",
        and the return status is "ippStsUnknownCacheSize".
        if sizes of the cache is unknown.
}

 function ippGetMaxCacheSizeB( pSizeByte : Int32Ptr ): IppStatus; _ippapi

{
  Name:       ippGetCpuFeatures
  Purpose:    Detects CPU features.
  Parameters:
    pFeaturesMask   Pointer to the features mask.
                    Nonzero value of bit means the corresponding feature is supported.
                    Features mask values are defined in the ippdefs.h
                      [ 0] - MMX        ( ippCPUID_MMX   )
                      [ 1] - SSE        ( ippCPUID_SSE   )
                      [ 2] - SSE2       ( ippCPUID_SSE2  )
                      [ 3] - SSE3       ( ippCPUID_SSE3  )
                      [ 4] - SSSE3      ( ippCPUID_SSSE3 )
                      [ 5] - MOVBE      ( ippCPUID_MOVBE )
                      [ 6] - SSE41      ( ippCPUID_SSE41 )
                      [ 7] - SSE42      ( ippCPUID_SSE42 )
                      [ 8] - AVX        ( ippCPUID_AVX   )
                      [ 9] - ENABLEDBYOS( ippAVX_ENABLEDBYOS )
                      [10] - AES        ( ippCPUID_AES   )
                      [11] - PCLMULQDQ  ( ippCPUID_CLMUL )
                      [12] - ABR        ( ippCPUID_ABR )
                      [13] - RDRAND     ( ippCPUID_RDRAND )
                      [14] - F16C       ( ippCPUID_F16C )
                      [15] - AVX2       ( ippCPUID_AVX2 )
                      [16] - ADOX/ADCX  ( ippCPUID_ADCOX )      ADCX and ADOX instructions
                      [17] - RDSEED     ( ippCPUID_RDSEED )     The RDSEED instruction
                      [18] - PREFETCHW  ( ippCPUID_PREFETCHW )  The PREFETCHW instruction
                      [19] - SHA        ( ippCPUID_SHA )        Intel (R) SHA Extensions
                      [20:63] - Reserved

    pCpuidInfoRegs  Pointer to the 4-element vector.
                    Result of CPUID.1 are stored in this vector.
                      [0] - register EAX
                      [1] - register EBX
                      [2] - register ECX
                      [3] - register EDX
                    If pointer pCpuidInfoRegs is set NULL : to ; registers are not stored.

  Returns:
    ippStsNullPtrErr         The pointer to the features mask (pFeaturesMask) is NULL.
    ippStsNotSupportedCpu    CPU is not supported.
    ippStsNoErr              Ok

  Note: Only IA-32 and Intel(R) 64 are supported
}

 function ippGetCpuFeatures( pFeaturesMask : Ipp64uPtr ; pCpuidInfoRegs : Ipp32u_4Ptr ): IppStatus; _ippapi

{
  Name:       ippGetEnabledCpuFeatures
  Purpose:    Detects enabled features for loaded libraries
  Returns:    Features mask
                    Features mask values are defined in the ippdefs.h
                      [ 0] - ippCPUID_MMX
                      [ 1] - ippCPUID_SSE
                      [ 2] - ippCPUID_SSE2
                      [ 3] - ippCPUID_SSE3
                      [ 4] - ippCPUID_SSSE3
                      [ 5] - ippCPUID_MOVBE
                      [ 6] - ippCPUID_SSE41
                      [ 7] - ippCPUID_SSE42
                      [ 8] - ippCPUID_AVX
                      [ 9] - ippAVX_ENABLEDBYOS
                      [10] - ippCPUID_AES
                      [11] - ippCPUID_CLMUL
                      [12] - ippCPUID_ABR
                      [13] - ippCPUID_RDRAND
                      [14] - ippCPUID_F16C
                      [15] - ippCPUID_AVX2
                      [16] - ippCPUID_ADCOX
                      [17] - ippCPUID_RDSEED
                      [18] - ippCPUID_PREFETCHW
                      [19] - ippCPUID_SHA
                      [20:63] - Reserved
}

 function ippGetEnabledCpuFeatures: Ipp64u; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippSetCpuFeatures

  Purpose: Changes the set of enabled/disabled CPU features.
           This function sets the processor-specific code of the Intel IPP
           library according to the processor features specified in cpuFeatures.

  Return:
    ippStsNoErr                 No errors.
    Warnings:
    ippStsFeatureNotSupported   Current CPU doesn`t support at least 1 of the
                                desired features;
    ippStsUnknownFeature        At least one of the desired features is unknown;
    ippStsFeaturesCombination   Wrong combination of features;
    ippStsCpuMismatch           Indicates that the specified processor features
                                are not valid. Previously set code is used.

  Arguments:
    cpuFeatures                 Desired features to support by the library
                                (see ippdefs.h for ippCPUID_XX definition)

  NOTE:       this function can re-initializes dispatcher and after the
              call another library (letter) may work
  CAUTION:    At the moment of this function excecution no any other IPP
              function has to be working

  The next pre-defined sets of features can be used:
  32-bit code:
 #define PX_FM ( ippCPUID_MMX | ippCPUID_SSE )
 #define W7_FM ( PX_FM | ippCPUID_SSE2 )
 #define V8_FM ( W7_FM | ippCPUID_SSE3 | ippCPUID_SSSE3 )
 #define S8_FM ( V8_FM | ippCPUID_MOVBE )
 #define P8_FM ( V8_FM | ippCPUID_SSE41 | ippCPUID_SSE42 | ippCPUID_AES | ippCPUID_CLMUL | ippCPUID_SHA )
 #define G9_FM ( P8_FM | ippCPUID_AVX | ippAVX_ENABLEDBYOS | ippCPUID_RDRAND | ippCPUID_F16C )
 #define H9_FM ( G9_FM | ippCPUID_AVX2 | ippCPUID_MOVBE | ippCPUID_ADCOX | ippCPUID_RDSEED | ippCPUID_PREFETCHW )

 64-bit code:
 #define PX_FM ( ippCPUID_MMX | ippCPUID_SSE | ippCPUID_SSE2 )
 #define M7_FM ( PX_FM | ippCPUID_SSE3 )
 #define N8_FM ( S8_FM )
 #define U8_FM ( V8_FM )
 #define Y8_FM ( P8_FM )
 #define E9_FM ( G9_FM )
 #define L9_FM ( H9_FM )
}

 function ippSetCpuFeatures( cpuFeatures : Ipp64u ): IppStatus; _ippapi


{
              Intel(R) Integrated Performance Primitives
              Color Conversion Library (ippCC)
}


{ ----------------------------------------------------------------------------

                   Functions declarations

{ ----------------------------------------------------------------------------

  Name:       ippccGetLibVersion
  Purpose:    getting of the library version
  Returns:    the structure of information about version
              of ippCC library
  Parameters:

  Notes:      not necessary to release the returned structure
}

 function ippccGetLibVersion: IppLibraryVersionPtr; _ippapi

{ ----------------------------------------------------------------------------

                   Color Space  Conversion Functions

{ ----------------------------------------------------------------------------

  Name:       ippiCbYCr422ToBGR_709HDTV_8u_C2C3R
  Purpose:    Converts a UYVY image to the BGR24 image
  Name:       ippiCbYCr422ToBGR_709HDTV_8u_C2C4R
  Purpose:    Converts a UYVY image to the BGRA image
  Name:       ippiBGRToCbYCr422_709HDTV_8u_C3C2R
  Purpose:    Converts a BGR24 image to the UYVY image
  Name:       ippiBGRToCbYCr422_709HDTV_8u_AC4C2R
  Purpose:    Converts a BGRA  image to the UYVY image
  Name:       ippiYCbCr420ToBGR_709HDTV_8u_P3C4R
  Purpose:    Converts a I420(IYUV) image to the BGRA image
  Name:       ippiBGRToYCbCr420_709HDTV_8u_AC4P3R
  Purpose:    Converts a BGRA image to the I420(IYUV) image
  Parameters:
     pSrc     Pointer to the source image (for pixel-order data).An array of
              pointers to separate source color planes (for plane-order data)
     pDst     Pointer to the destination image (for pixel-order data).An array
              of pointers to separate destination color planes (for plane-order data)
     roiSize  Size of source and destination ROI in pixels
     srcStep  Step in bytes through the source image to jump on the next line
     dstStep  Step in bytes through the destination image to jump on the next line
  Returns:
     ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
     ippStsSizeErr     roiSize has field with zero or negative value
     ippStsNoErr       No errors
  Reference:
      Jack Keith
      Video Demystified: A Handbook for the Engineer : Digital ; 2nd ed.
      1996.pp.(42-43)
    YCbCr <> RGB ITU_R BT.709 (HDTV) where R'G'B' has a range of 16-235
       Y has a range of 16 - 235. Cb,Cr have a range of 16 - 240
       Y  =  0.2126*R' + 0.7152*G' + 0.0722*B'
       Cb = -0.117*R'  - 0.394*G'  + 0.511 * B' + 128
       Cr =  0.511*R'  - 0.464*G'  - 0.047 * B' + 128
       Cb = 0.5389 (B' - Y )
       Cr = 0.6350 (R' - Y )
       Digital representation.
       Quantization level assignment:
         - Video data:        1 through 254
         - Timing reference:  0 and 255
       R' = Y + 1.540*(Cr - 128 )
       G' = Y - 0.459*(Cr - 128 ) - 0.183*( Cb - 128 )
       B' = Y + 1.816*(Cb - 128)
}

 function ippiCbYCr422ToBGR_709HDTV_8u_C2C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCbYCr422ToBGR_709HDTV_8u_C2C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiBGRToCbYCr422_709HDTV_8u_C3C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToCbYCr422_709HDTV_8u_AC4C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420ToBGR_709HDTV_8u_P3C4R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiBGRToYCbCr420_709HDTV_8u_AC4P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Parameters:
     pSrc     Pointer to the source image (for pixel-order data).An array of
              pointers to separate source color planes (for plane-order data)
     pDst     Pointer to the destination image (for pixel-order data).An array
              of pointers to separate destination color planes (for plane-order data)
     roiSize  Size of source and destination ROI in pixels
     srcStep  Step in bytes through the source image to jump on the next line
     dstStep  Step in bytes through the destination image to jump on the next line
  Returns:
     ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
     ippStsSizeErr     roiSize has field with zero or negative value
     ippStsNoErr       No errors
  Reference:
      Jack Keith
      Video Demystified: A Handbook for the Engineer : Digital ; 2nd ed.
      1996.pp.(42-43)
    YCbCr <> RGB ITU_R BT.709 (Computer System Considerations) where R'G'B' has a range of 0-255
    Y  =  0.183*R' + 0.614*G' + 0.062*B' + 16
    Cb = -0.101*R' - 0.338*G' + 0.439*B' + 128
    Cr =  0.439*R' - 0.399*G' - 0.040*B' + 128
    R' = 1.164*(Y - 16) + 1.793*(Cr - 128 )
    G' = 1.164*(Y - 16) - 0.534*(Cr - 128 )- 0.213*( Cb - 128 )
    B' = 1.164*(Y - 16) + 2.115*(Cb - 128 )
}

 function ippiBGRToYCbCr420_709CSC_8u_AC4P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCrCb420_709CSC_8u_AC4P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiBGRToYCbCr420_709CSC_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCrCb420_709CSC_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCbCr420_709CSC_8u_C3P2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCbCr420_709CSC_8u_AC4P2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiYCbCr420ToBGR_709CSC_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCrToBGR_709CSC_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCrToBGR_709CSC_8u_P3C4R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:
  ippiBGRToCbYCr422_8u_AC4C2R,       ippiCbYCr422ToBGR_8u_C2C4R,
  ippiYCbCr411ToBGR_8u_P3C3R
  ippiYCbCr411ToBGR_8u_P3C4R

  ippiRGBToCbYCr422_8u_C3C2R,        ippiCbYCr422ToRGB_8u_C2C3R,
  ippiRGBToCbYCr422Gamma_8u_C3C2R,
  ippiYCbCr422ToRGB_8u_P3C3R

  ippiRGBToYCbCr422_8u_C3C2R,        ippiYCbCr422ToRGB_8u_C2C3R,
                                     ippiYCbCr422ToRGB_8u_C2C4R,
  ippiRGBToYCbCr422_8u_P3C2R,        ippiYCbCr422ToRGB_8u_C2P3R,

  ippiRGBToYCbCr420_8u_C3P3R,        ippiYCbCr420ToRGB_8u_P3C3R,
  ippiYCbCr420ToBGR_8u_P3C3R,

  ippiYCbCr422ToRGB565_8u16u_C2C3R,  ippiYCbCr422ToBGR565_8u16u_C2C3R,
  ippiYCbCr422ToRGB555_8u16u_C2C3R,  ippiYCbCr422ToBGR555_8u16u_C2C3R,
  ippiYCbCr422ToRGB444_8u16u_C2C3R,  ippiYCbCr422ToBGR444_8u16u_C2C3R,

  ippiYCbCrToRGB565_8u16u_P3C3R,     ippiYCbCrToBGR565_8u16u_P3C3R,
  ippiYCbCrToRGB444_8u16u_P3C3R,     ippiYCbCrToBGR444_8u16u_P3C3R,
  ippiYCbCrToRGB555_8u16u_P3C3R,     ippiYCbCrToBGR555_8u16u_P3C3R,

  ippiYCbCr420ToRGB565_8u16u_P3C3R,  ippiYCbCr420ToBGR565_8u16u_P3C3R
  ippiYCbCr420ToRGB555_8u16u_P3C3R,  ippiYCbCr420ToBGR555_8u16u_P3C3R,
  ippiYCbCr420ToRGB444_8u16u_P3C3R,  ippiYCbCr420ToBGR444_8u16u_P3C3R,

  ippiYCbCr422ToRGB565_8u16u_P3C3R,  ippiYCbCr422ToBGR565_8u16u_P3C3R,
  ippiYCbCr422ToRGB555_8u16u_P3C3R,  ippiYCbCr422ToBGR555_8u16u_P3C3R,
  ippiYCbCr422ToRGB444_8u16u_P3C3R,  ippiYCbCr422ToBGR444_8u16u_P3C3R,

  ippiRGBToYCrCb422_8u_C3C2R,        ippiYCrCb422ToRGB_8u_C2C3R,
                                     ippiYCrCb422ToBGR_8u_C2C3R,
                                     ippiYCrCb422ToRGB_8u_C2C4R,
                                     ippiYCrCb422ToBGR_8u_C2C4R,
  ippiRGBToYCrCb422_8u_P3C2R,        ippiYCrCb422ToRGB_8u_C2P3R,


  Purpose:    Converts an RGB/BGR image to the YCbCr/CbYCr/YCrCb image and vice versa.
  Parameters:
     pSrc     Pointer to the source image (for pixel-order data).An array of
              pointers to separate source color planes (for plane-order data)
     pDst     Pointer to the destination image (for pixel-order data).An array
                of pointers to separate destination color planes (for plane-order data)
     roiSize  Size of source and destination ROI in pixels
     srcStep  Step in bytes through the source image to jump on the next line
     dstStep  Step in bytes through the destination image to jump on the next line
     aval     Constant value to create the fourth channel.
  Returns:
     ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
     ippStsSizeErr     roiSize has field with zero or negative value
     ippStsNoErr       No errors
  Reference:
      Jack Keith
      Video Demystified: A Handbook for the Engineer : Digital ; 2nd ed.
      1996.pp.(42-43)

  The YCbCr color space was developed as part of Recommendation ITU-R BT.601
  (formerly CCI 601). Y is defined to have a nominal range of 16 to 235;
  Cb and Cr are defined to have a range of 16 to 240, with 128 equal to zero.
  The function ippiRGBToYCbCr422_8u_P3C2R uses 4:2:2 sampling format. For every
  two  horizontal samples : Y ; there is one Cb and Cr sample.
  Each pixel in the input RGB image is of 24 bit depth. Each pixel in the
  output YCbCr image is of 16 bit depth.
  Sequence of samples in the YCbCr422 image is
             Y0Cb0Y1Cr0,Y2Cb1Y3Cr1,...
  Sequence of samples in the CbYCr422 image is:
             Cb0Y0CrY1,Cb1Y2Cr1Y3,...
  All functions operate on the gamma-corrected RGB (R'G'B') images
  ( ippiRGBToCbYCrGamma_8u_C3C2R : except ; see below) with pixel values
  in the range 0 .. 255, as is commonly found in computer system.
  Conversion is performed according to the following equations:

       Y  =  0.257*R' + 0.504*G' + 0.098*B' + 16
       Cb = -0.148*R' - 0.291*G' + 0.439*B' + 128
       Cr =  0.439*R' - 0.368*G' - 0.071*B' + 128

       R' = 1.164*(Y - 16) + 1.596*(Cr - 128 )
       G' = 1.164*(Y - 16) - 0.813*(Cr - 128 )- 0.392*( Cb - 128 )
       B' = 1.164*(Y - 16) + 2.017*(Cb - 128 )

   Note that for the YCbCr-to-equations : RGB ; the RGB values must be saturated
   at the 0 and 255 levels due to occasional excursions outside the nominal
   YCbCr ranges.
   Note that two-planar YCbCr420 image is also known as NV12 format and YCrCb420 as NV21.

   ippiRGBToCbYCr422Gamma_8u_C3C2R function additionally performs gamma-correction, there is
   sample down filter(1/4,1/2,1/4).
}

 function ippiRGBToYCbCr420_8u_C3P2R( pRGB : Ipp8uPtr ; rgbStep : Int32 ; pY : Ipp8uPtr ; YStep : Int32 ; pCbCr : Ipp8uPtr ; CbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYCbCr420_8u_C4P2R( pRGB : Ipp8uPtr ; rgbStep : Int32 ; pY : Ipp8uPtr ; YStep : Int32 ; pCbCr : Ipp8uPtr ; CbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCbCr420_8u_C3P2R( pRGB : Ipp8uPtr ; rgbStep : Int32 ; pY : Ipp8uPtr ; YStep : Int32 ; pCbCr : Ipp8uPtr ; CbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCbCr420_8u_AC4P2R( pRGB : Ipp8uPtr ; rgbStep : Int32 ; pY : Ipp8uPtr ; YStep : Int32 ; pCbCr : Ipp8uPtr ; CbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiYCbCr420ToRGB_8u_P2C3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420ToRGB_8u_P2C4R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiYCbCr420ToBGR_8u_P2C3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420ToBGR_8u_P2C4R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi

 function ippiBGRToCbYCr422_8u_AC4C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCbYCr422ToBGR_8u_C2C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiYCbCr411ToBGR_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr411ToBGR_8u_P3C4R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiCbYCr422ToRGB_8u_C2C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToCbYCr422Gamma_8u_C3C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToCbYCr422_8u_C3C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr422ToRGB_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToYCbCr422_8u_C3C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr422ToRGB_8u_C2C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr422ToRGB_8u_C2C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiRGBToYCbCr422_8u_P3C2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr422ToRGB_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420ToBGR_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420ToRGB_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYCbCr420_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToYCrCb422_8u_C3C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb422ToRGB_8u_C2C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb422ToBGR_8u_C2C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb422ToRGB_8u_C2C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiYCrCb422ToBGR_8u_C2C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi

 function ippiRGBToYCrCb422_8u_P3C2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb422ToRGB_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr422ToBGR_8u_C2C4R / ippiYCbCr422ToBGR_8u_C2C3R
  Purpose:    Converts a YUY2 image to the BGRA / RGB24 image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr        One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 2 or if roiSize.height < 1

  Arguments:
    pSrc                     pointer to the source image
    srcStep                  step for the source image
    pDst                     pointer to the destination image
    dstStep                  step for the destination image
    roiSize                 region of interest to be processed, in pixels
}

 function ippiYCbCr422ToBGR_8u_C2C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiYCbCr422ToBGR_8u_C2C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCrToBGR_8u_P3C4R / ippiYCbCrToBGR_8u_P3C3R
  Purpose:    Converts a P444 image to the BGRA / RGB24 image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr        One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4 or if roiSize.height < 1
  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pDst                     pointer to the destination image
    dstStep                  step for the destination image
    roiSize                 region of interest to be processed, in pixels
}

 function ippiYCbCrToBGR_8u_P3C4R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiYCbCrToBGR_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiBGRToYCbCr411_8u_C3P3R/ippiBGRToYCbCr411_8u_AC4P3R/ippiBGR565ToYCbCr411_16u8u_C3P3R/ippiBGR555ToYCbCr411_16u8u_C3P3R
  Purpose:    Converts a RGB24/RGBA/RGB565/RGB565 image to the P411 image
  Return:
    ippStsNoErr           Ok
    ippStsNullPtrErr      one or more pointers are NULL
    ippStsSizeErr         if roiSize.width < 4 or if roiSize.height < 1
  Arguments:
    pSrc          Pointer to the source image
    srcStep       Step through the source image
    pDst          An array of pointers  to separate destination color planes.
    dstStep       An array of step in bytes through the destination planes
    roiSize       region of interest to be processed, in pixels
}

 function ippiBGRToYCbCr411_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCbCr411_8u_AC4P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiBGRToYCbCr422_8u_C3P3R/ippiBGRToYCbCr422_8u_AC4P3R/ippiBGR565ToYCbCr422_16u8u_C3P3R/ippiBGR555ToYCbCr422_16u8u_C3P3R
  Purpose:    Converts a RGB24/RGBA/RGB565/RGB565 image to the P422 image
  Return:
    ippStsNoErr           Ok
    ippStsNullPtrErr      one or more pointers are NULL
    ippStsSizeErr         if roiSize.width < 2 or if roiSize.height < 1
  Arguments:
    pSrc          Pointer to the source image
    srcStep       Step through the source image
    pDst          An array of pointers  to separate destination color planes.
    dstStep       An array of step in bytes through the destination planes
    roiSize       region of interest to be processed, in pixels
}

 function ippiBGRToYCbCr422_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCbCr422_8u_AC4P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiBGRToYCbCr420_8u_C3P3R/ippiBGRToYCbCr420_8u_AC4P3R/ippiBGR565ToYCbCr420_16u8u_C3P3R/ippiBGR555ToYCbCr420_16u8u_C3P3R
  Purpose:    Converts a RGB24/RGBA/RGB565/RGB565 image to the IYUV image
  Return:
    ippStsNoErr           Ok
    ippStsNullPtrErr      one or more pointers are NULL
    ippStsSizeErr         if roiSize.width < 2 or if roiSize.height < 0
  Arguments:
    pSrc          Pointer to the source image
    srcStep       Step through the source image
    pDst          An array of pointers  to separate destination color planes.
    dstStep       An array of step in bytes through the destination planes
    roiSize       region of interest to be processed, in pixels
}

 function ippiBGRToYCbCr420_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCbCr420_8u_AC4P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiBGRToYCbCr422_8u_C3C2R/ippiBGRToYCbCr422_8u_AC4C2R/ippiBGR555ToYCbCr422_16u8u_C3C2R/ippiBGR565ToYCbCr422_16u8u_C3C2R
  Purpose:    Converts a RGB24/RGBA/RGB565/RGB565 image to the YUY2 image
  Return:
    ippStsNoErr           Ok
    ippStsNullPtrErr      one or more pointers are NULL
    ippStsSizeErr         if roiSize.width < 2 or if roiSize.height < 1
  Arguments:
    pSrc          Pointer to the source image
    srcStep       Step through the source image
    pDst          An array of pointers  to separate destination color planes.
    dstStep       An array of step in bytes through the destination planes
    roiSize       region of interest to be processed, in pixels
}

 function ippiBGRToYCbCr422_8u_C3C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCbCr422_8u_AC4C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiBGRToYCrCb420_8u_C3P3R/ippiBGRToYCrCb420_8u_AC4P3R/ippiBGR555ToYCrCb420_16u8u_C3P3R/ippiBGR565ToYCrCb420_16u8u_C3P3R
  Purpose:    Converts a RGB24/RGBA/RGB565/RGB565 image to the YV12 image
  Return:
    ippStsNoErr           Ok
    ippStsNullPtrErr      one or more pointers are NULL
    ippStsSizeErr         if roiSize.width < 2 or if roiSize.height < 2
  Arguments:
    pSrc          Pointer to the source image
    srcStep       Step through the source image
    pDst          An array of pointers  to separate destination color planes.
    dstStep       An array of step in bytes through the destination planes
    roiSize       region of interest to be processed, in pixels
}

 function ippiBGRToYCrCb420_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCrCb420_8u_AC4P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiRGBToYCrCb420_8u_AC4P3R
  Purpose:    Converts a RGBA image to the YV12 image
  Return:
    ippStsNoErr            Ok
    ippStsNullPtrErr      one or more pointers are NULL
    ippStsDoubleSize    Indicates a warning if roiSize is not a multiple of 2.
  Arguments:
    pSrc            Pointer to the source image ROI.
    srcStep        Distance in bytes between starts of consecutive lines in the source image.
    pDst            An array of pointers to ROI in the separate planes of the destination image.
    dstStep        Distance in bytes between starts of consecutive lines in the destination image.
    roiSize Size of the source and destination ROI in pixels.
}

 function ippiRGBToYCrCb420_8u_AC4P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiYCrCb420ToRGB_8u_P3C4R  and  ippiYCbCr420ToBGR_8u_P3C4R
  Purpose:    Converts a YV12 image to the a RGBA image and converts a IYUV image to the a BGRA
  Return:
    ippStsNoErr           Ok
    ippStsNullPtrErr      one or more pointers are NULL
    ippStsDoubleSize    Indicates a warning if roiSize is not a multiple of 2.
  Arguments:
    pSrc         An array of pointers to ROI in separate planes of the source image.
    srcStep      An array of distances in bytes between starts of consecutive lines in the source image planes.
    pDst         Pointer to the destination image ROI.
    dstStep      Distance in bytes between starts of consecutive lines in the destination image.
    roiSize      Size of the source and destination ROI in pixels.
    aval         Constant value to create the fourth channel.
}

 function ippiYCbCr420ToBGR_8u_P3C4R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiYCrCb420ToRGB_8u_P3C4R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiYCrCb420ToRGB_8u_P2C4R,  ippiYCrCb420ToBGR_8u_P2C4R, ippiYCrCb420ToRGB_8u_P2C3R, ippiYCrCb420ToBGR_8u_P2C3R
  Purpose:    Converts NV21 two-plane image to RGBA/BGRA/RGB/BGR image
  Return:
    ippStsNoErr         No errors
    ippStsNullPtrErr    One or more pointers are NULL
    ippStsSizeErr       roiSize has field with zero or negative value
    ippStsDoubleSize    Indicates a warning if roiSize is not a multiple of 2.
  Arguments:
    pSrcY        Pointer to the source image Y plane.
    srcYStep     Step through the source image Y plane.
    pSrcCrCb     Pointer to the source image CrCb plane.
    srcCrCbStep  Step through the source image CrCb plane.
    pDst         Pointer to the destination image ROI.
    dstStep      Distance in bytes between starts of consecutive lines in the destination image.
    roiSize      Size of the source and destination ROI in pixels.
    aval         Constant value to create the fourth channel.
}

 function ippiYCrCb420ToRGB_8u_P2C4R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCrCb : Ipp8uPtr ; srcCrCbStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiYCrCb420ToBGR_8u_P2C4R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCrCb : Ipp8uPtr ; srcCrCbStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiYCrCb420ToRGB_8u_P2C3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCrCb : Ipp8uPtr ; srcCrCbStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb420ToBGR_8u_P2C3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCrCb : Ipp8uPtr ; srcCrCbStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiRGBToYCbCr_8u_AC4P3R and ippiRGBToYCbCr_8u_C3P3R
  Purpose:    Converts a RGBA and RGB image to the YUV 4:4:4 image
  Return:
    ippStsNoErr            Ok
    ippStsNullPtrErr      one or more pointers are NULL
  Arguments:
    pSrc          Pointer to the source image ROI for pixel-order image. An array of pointers to ROI in each separate source color planes for planar images.
    srcStep      Distance in bytes between starts of consecutive lines in the source image.
   pDst            Pointer to the destination image ROI. An array of pointers to ROI in the separate destination color planes for planar images.
   dstStep       Distance in bytes between starts of consecutive lines in the destination image.
   roiSize        Size of the source and destination ROI in pixels.
}

 function ippiRGBToYCbCr_8u_AC4P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYCbCr_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiYCbCrToRGB_8u_P3C4R
  Purpose:    Converts a YUV 4:4:4 image to the a RGBA image
  Return:
    ippStsNoErr           Ok
    ippStsNullPtrErr      one or more pointers are NULL
    Arguments:
    pSrc             An array of pointers to ROI in each separate source color planes.
    srcStep         Distance in bytes between starts of consecutive lines in the source image.
    pDst             Pointer to the destination image ROI.
    dstStep         Distance in bytes between starts of consecutive lines in the destination image.
    roiSize          Size of the source and destination ROI in pixels.
    aval               Constant value to create the fourth channel.
}

 function ippiYCbCrToRGB_8u_P3C4R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr422_8u_P3C2R
  Purpose:    Converts 422 planar image to YUY2
  Name:       ippiYCbCr422ToCbYCr422_8u_P3C2R
  Purpose:    Converts the P422 image to UYVY image
  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            Width of first plain 422-image less than 2(4)
                             or height equal zero

  Parameters:
    pSrc[3]                  Array of pointers to the source image planes
    srcStep[3]               Array of steps through the source image planes
    pDst[3]                  Array of pointers to the destination image planes
    dstStep[3]               Array of steps through the destination image planes
    pSrc                     Pointer to the source pixel-order image
    srcStep                  Step through the source pixel-order image
    pDst                     Pointer to the destination pixel-order image
    dstStep                  Step through the destination pixel-order image
    roiSize                  Size of the ROI
}

 function ippiYCbCr422_8u_P3C2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr422ToCbYCr422_8u_P3C2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCrCb420ToBGR_Filter_8u_P3C4R
  Purpose:    Converts a YV12 image to the RGB32 image
  Return:
    ippStsNoErr           Ok
    ippStsNullPtrErr      one or more pointers are NULL
    ippStsSizeErr         if roiSize.width < 2 or if roiSize.height < 2
    ippStsDoubleSize      sizes of image is not multiples of 2
  Arguments:
    pDst          Pointer to the destination image
    dstStep       Step through the destination image
    pSrc          An array of pointers  to separate source color planes.
    srcStep       An array of step in bytes through the source planes
    roiSize       Region of interest to be processed, in pixels
    aval          Constant value to create the fourth channel.
}

 function ippiYCrCb420ToBGR_Filter_8u_P3C4R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiJoin420_8u_P2C2R, ippiJoin420_Filter_8u_P2C2R

  Purpose:    Converts 420 two-plane image to 2-channel pixel-image : order ; 
              ippiJoin420_Filter additionally performs deinterlace filtering NV12 to YUY2

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field with zero or negative value

  Parameters:
    pSrcY                    Pointer to the source image Y plane.
    srcYStep                 Step through the source image Y plane.
    pSrcCbCr                 Pointer to the source image interleaved chrominance plane.
    srcCbCrStep              Step through the source image CbCr plane.
    pDst                     Pointer to the destination image
    dstStep                  Step through the destination image
    roiSize                  Size of ROI : the ; height and width should be multiple of 2.
    layout                   Slice layout (for deinterlace filter).
             Possible values:
                IPP_UPPER  - the first slice.
                IPP_CENTER - the middle slices.
                IPP_LOWER  - the last   slice.
                IPP_LOWER && IPP_UPPER && IPP_CENTER - image is not sliced.
  Notes:
    Source 4:2:0 two-plane image format ( NV12 ):
    all Y (pSrcY) samples are found first in memory as an array of
    unsigned char with an even number of lines memory alignment),
    followed immediately by an array(pSrcCbCr) of unsigned char
    containing interleaved U and V samples (such that if addressed as a little-endian
    type : WORD ; U would be in the LSBs and V would be in the MSBs).

    Sequence of samples in the destination 4:2:2 pixel-order two-channel image (YUY2):
    Y0U0Y1V0,Y2U1Y3V1,...

    The function ippiJoin420_Filter_8u_P2C2R usually operates on the sliced images
     ( the height of slices should be a multiple of 16).
}

 function ippiYCbCr420ToYCbCr422_8u_P2C2R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420ToYCbCr422_Filter_8u_P2C2R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; layout : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:
    ippiYCbCr420ToYCrCb420_Filter_8u_P2P3R
    ippiYCbCr420ToYCrCb420_8u_P2P3R
    formely known ippiSplit420_8u_P2P3R : as ; ippiSplit420_Filter_8u_P2P3R

  Purpose:    Converts NV12 two-plane image to YV12 three-plane image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field with zero or negative value

  Parameters:
    pSrcY                    Pointer to the source image Y plane.
    srcYStepY                Step through the source image Y plane.
    pSrcCbCr                 Pointer to the source image CbCr plane.
    srcCbCrStep              Step through the source image CbCr plane.
    pDst[3]                  Array of pointers to the destination image planes
    dstStep[3]               Array of steps through the destination image planes
    roiSize                  Size of ROI : the ; should be multiple of 2.
    layout                   Slice layout (for deinterlace filter).
             Possible values:
                IPP_UPPER  - the first slice.
                IPP_CENTER - the middle slices.
                IPP_LOWER  - the last   slice.
                IPP_LOWER && IPP_UPPER && IPP_CENTER - image is not sliced.
  Notes:
    Source 4:2:0 two-plane image format (NV12):
    all Y (pSrcY) samples are found first in memory as an array of
    unsigned char with an even number of lines memory alignment),
    followed immediately by an array(pSrcCbCr) of unsigned char
    containing interleaved U and V samples (such that if addressed as a little-endian
    type : WORD ; U would be in the LSBs and V would be in the MSBs).

    Destination 4:2:0 three-plane image format(YV12 ):
    the order of the pointers to destination images - Y V U.

    The function ippiSplit420_Filter_8u_P2P3R usually operates on the sliced images
    ( the height of slices should be a multiple of 16).
}

 function ippiYCbCr420ToYCrCb420_Filter_8u_P2P3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ; layout : Int32 ): IppStatus; _ippapi
 function ippiYCbCr420ToYCrCb420_8u_P2P3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYUToYU422_8u_C2P2R, ippiUYToYU422_8u_C2P2R
  Purpose:    Converts 2-YUY2 : channel ; UYVY images to the 2-plane NV12 image

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field value less than 2

  Parameters:
    pDstY                    Pointer to the destination image Y plane.
    dstYStep                 The step through the destination image Y plane.
    pDstCbCr                 Pointer to the destination image CbCr plane.
    dstCbCrStep              The step through the destination image CbCr plane.
    pSrc                     Pointer to the source image
    srcStep                  Step through the source image
    roiSize                  Size of ROI : the ; should be multiple of 2.
  Notes:
    for ippiYUToYU422_8u_C2P2R sequence of bytes in the source image is( YUY2 ):
                   Y0U0Y1V0,Y2U1Y3V1,...
    for ippiUYToYU422_8u_C2P2R sequence of bytes in the destination image is( UYVY ):
                   U0Y0V0Y1,U1Y2V1Y3,...
    Sequence of bytes in the destination image is:
      NV12
        Y plane    Y0Y1Y2Y3
       UV plane    U0V0U1V1
      NV21
        Y plane    Y0Y1Y2Y3
       UV plane    U0V0U1V1
}

 function ippiYCbCr422ToYCbCr420_8u_C2P2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr422ToYCrCb420_8u_C2P2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCrCb : Ipp8uPtr ; dstUVStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCbYCr422ToYCbCr420_8u_C2P2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr422ToYCrCb420_8u_C2P3R, ippiCbYCr422ToYCrCb420_8u_C2P3R
  Purpose:    Converts 2-YUY2 : channel ; UYVY images to the 3-plane YV12 image

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field value less than 2

  Parameters:
    pSrc          Pointer to the source image
    srcStep       Step through the source image
    roiSize       Size of ROI : the ; should be multiple of 2.
    pDst          An array of pointers  to separate destination color planes.
    dstStep       An array of step in bytes through the destination planes
  Notes:
    for ippiYUToYV422_8u_C2P3R sequence of bytes in the source image is( YUY2 ):
                   Y0U0Y1V0,Y2U1Y3V1,...
    for ippiUYToYV422_8u_C2P3R sequence of bytes in the destination image is( UYVY ):
                   U0Y0V0Y1,U1Y2V1Y3,...
    Sequence of planes in the destination image is( YV12 ):  Y V U
}

 function ippiYCbCr422ToYCrCb420_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCbYCr422ToYCrCb420_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYUToUY422_8u_C2R, ippiUYToYU422_8u_C2R
  Purpose:    Converts a 2-channel YUY2 image to the UYVY image and vice versa

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field value less than 2

  Parameters:
    pSrc                     Pointer to the source image
    srcStep                  Step through the source i mage
    roiSize                  Size of ROI : the ; roiSize.width should be multiple of 2
    pDst                     Pointer to the  destination image
    dstStep                  Step through the destination image
  Notes:
    sequence of bytes in the source image for ippiYUToUY422_8u_C2R and in the destination image for ippiUYToYU422_8u_C2P2R is( YUY2 ):
                   Y0U0Y1V0,Y2U1Y3V1,...
    sequence of bytes in the destination image for ippiUYToYU422_8u_C2R and in the source image for ippiUYToYU422_8u_C2P2R is( UYVY ):
                   U0Y0V0Y1,U1Y2V1Y3,...
}

 function ippiYCbCr422ToCbYCr422_8u_C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCbYCr422ToYCbCr422_8u_C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYVToUY420_8u_P3C2R, ippiYVToYU420_8u_P3C2R
  Purpose:    Converts a 3-plane YV12 image to 2-YUY2 : channel ; UYVY images

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field value less than 2

  Parameters:
    pSrc                     An array of three pointers to source image planes
    srcStep                  An array of steps through the source image planes
    roiSize                  Size of ROI : the ; should be multiple 2.
    pDst                     Pointer to the  destination image
    dstStep                  Step through the destination image
  Notes:
    Sequence of planes in the source image is( YV12 ):  Y V U
    for ippiYVToUY420_8u_P3C2R sequence of bytes in the destination image is( YUY2 ):
                   Y0U0Y1V0,Y2U1Y3V1,...
    for ippiUYToYU422_8u_C2P2R sequence of bytes in the destination image is( UYVY ):
                   U0Y0V0Y1,U1Y2V1Y3,...
}

 function ippiYCrCb420ToCbYCr422_8u_P3C2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb420ToYCbCr422_8u_P3C2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiRGBToYCbCr422_8u_C3P3R/ippiYCbCr422ToBGR_8u_P3C3R
  PVCS ID 9600
  Purpose:    Converts a RGB24/YUY2 image to the YUY2/RGB24 image
  Return:
    ippStsNoErr            Ok
    ippStsNullPtrErr      one or more pointers are NULL
    ippStsDoubleSize    Indicates a warning if roiSize is not a multiple of 2.
  Arguments:
   pSrc        Pointer to the source image ROI for pixel-order image. An array of pointers to ROI in each separate source color planes for planar images.
   srcStep     Distance in bytes between starts of consecutive lines in the source image.
   pDst        Pointer to the destination image ROI. An array of pointers to ROI in the separate destination color and alpha planes for planar images.
   dstStep     Distance in bytes between starts of consecutive lines in the destination image.
   roiSize     Size of the source and destination ROI in pixels.
}

 function ippiRGBToYCbCr422_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr422ToBGR_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCrCb420ToYCbCr420_8u_P3P2R
  Purpose:    Converts a 3-plane YV12 image to the 2-plane NV12 image

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field value less than 2

  Parameters:
    pSrc                     An array of three pointers to source image planes
    srcStep                  An array of steps through the source image planes
    roiSize                  Size of ROI : the ; should be multiple 2.
    pDstY                    Pointer to the destination image Y plane.
    dstYStep                 Step through the destination image Y plane.
    pDstCbCr                 Pointer to the destination image CbCr plane.
    dstCbCrStep              Step through the destination image CbCr plane.
  Notes:
    Sequence of planes in the source image is( YV12 ):  Y V U
    Sequence of bytes in the destination image is( NV12 ):
        Y plane    Y0Y1Y2Y3
       UV plane    U0V0U1V1
}

 function ippiYCrCb420ToYCbCr420_8u_P3P2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYUToUY420_8u_P2C2R
  Purpose:    Converts a 2-plane NV12 image to the 2-channel UYVY image

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field value less than 2

  Parameters:
    pSrcY                    Pointer to the source image Y plane.
    srcYStep                 Step through the source image Y plane.
    pSrcCbCr                 Pointer to the source image CbCr plane.
    srcCbCrStep              Step through the source image CbCr plane.
    pDst                     Pointer to the destination image
    dstStep                  Step through the destination image
    roiSize                  Size of ROI : the ; should be multiple of 2.
  Notes:
    Sequence of bytes in the source image is( NV12 ):
        Y plane    Y0Y1Y2Y3
       UV plane    U0V0U1V1
    for ippiUYToYU422_8u_C2P2R sequence of bytes in the destination image is( UYVY ):
                   U0Y0V0Y1,U1Y2V1Y3,...
}

 function ippiYCbCr420ToCbYCr422_8u_P2C2R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr422ToYCbCr422_8u_C2P3R
  Purpose:    Converts a YUY2 image to the P422 image
  Name:       ippiYCrCb422ToYCbCr422_8u_C2P3R
  Purpose:    Converts a YVYU image to the P422 image
  Name:       ippiCbYCr422ToYCbCr422_8u_C2P3R
  Purpose:    Converts a UYVY image to the P422 image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 2

  Arguments:
    pSrc                     pointer to the source image
    srcStep                  step for the source image
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 2.
}

 function ippiYCbCr422_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb422ToYCbCr422_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCbYCr422ToYCbCr422_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr422ToYCbCr420_8u_C2P3R
  Purpose:    Converts a 2-channel YUY2 image to the I420(IYUV) image
  Name:       ippiCbYCr422ToYCbCr420_8u_C2P3R
  Purpose:    Converts a 2-channel YUY2 image to the I420(IYUV) image
  Name:       ippiYCrCb422ToYCbCr420_8u_C2P3R
  Purpose:    Converts a 2-channel YVYU image to the I420(IYUV) image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 2 || roiSize.height < 2

  Arguments:
    pSrc                     pointer to the source image
    srcStep                  step for the source image
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width and roiSize.height  should be multiple 2.
}

 function ippiYCbCr422ToYCbCr420_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCbYCr422ToYCbCr420_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb422ToYCbCr420_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr422ToYCbCr411_8u_C2P3R
  Purpose:    Converts a YUY2 image to the P411 image
  Name:       ippiCbYCr422ToYCbCr411_8u_C2P3R
  Purpose:    Converts a YUY2 image to the P411 image
  Name:       ippiYCrCb422ToYCbCr411_8u_C2P3R
  Purpose:    Converts a YVYU image to the P411 image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4

  Arguments:
    pSrc                     pointer to the source image
    srcStep                  step for the source image
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
}

 function ippiYCbCr422ToYCbCr411_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCbYCr422ToYCbCr411_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb422ToYCbCr411_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:    ippiYCbCr422ToYCbCr420_8u_P3P2R
  Purpose:    Converts a P422 image to the NV12 image
  Name:    ippiYCbCr420_8u_P3P2R
  Purpose:    Converts a IYUV image to the NV12 image
  Name:    ippiYCbCr420ToYCbCr411_8u_P3P2R
  Purpose:    Converts a IYUV image to the NV11 image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr        One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 2 || roiSize.height < 2

  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pDstY                    pointer to the source Y plane
    dstYStep                 step  for the destination Y plane
    pDstCbCr                 pointer to the destination CbCr plane
    dstCbCrStep              step  for the destination CbCr plane
    roiSize                  region of interest to be processed, in pixels
  Notes:
    roiSize.width and roiSize.height should be multiple 2.
}

 function ippiYCbCr422ToYCbCr420_8u_P3P2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420_8u_P3P2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420ToYCbCr411_8u_P3P2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:    ippiYCbCr422ToYCbCr411_8u_P3P2R
  Purpose:    Converts a P422 image to the NV11 image
  Name:    ippiYCrCb420ToYCbCr411_8u_P3P2R
  Purpose:    Converts a YV12 image to the NV11 image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr        One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4 || roiSize.height < 2

  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pDstY                    pointer to the source Y plane
    dstYStep                 step  for the destination Y plane
    pDstCbCr                 pointer to the destination CbCr plane
    dstCbCrStep              step  for the destination CbCr plane
    roiSize                  region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
    roiSize.height should be multiple 2.
}

 function ippiYCbCr422ToYCbCr411_8u_P3P2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb420ToYCbCr411_8u_P3P2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr422ToYCbCr420_8u_P3R
  Purpose:    Converts a P422 image to the I420(IYUV)image
  Name:       ippiYCbCr420ToYCbCr422_8u_P3R
  Purpose:    Converts a IYUV image to the P422 image
  Name:       ippiYCrCb420ToYCbCr422_8u_P3R
  Purpose:    Converts a YV12 image to the P422 image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr        One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 2 || roiSize.height < 2

  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width and roiSize.height  should be multiple 2.
}

 function ippiYCbCr422ToYCbCr420_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420ToYCbCr422_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb420ToYCbCr422_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr420ToYCbCr422_Filter_8u_P3R
  Purpose:    Converts a IYUV image to the P422 image.
  Name:       ippiYCrCb420ToYCbCr422_Filter_8u_P3R
  Purpose:    Converts a YV12 image to the P422 image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 2 || roiSize.height < 8

  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 2.
    roiSize.height should be multiple 8.
    We use here Catmull-Rom interpolation.
}

 function ippiYCbCr420ToYCbCr422_Filter_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCrCb420ToYCbCr422_Filter_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr420ToYCbCr422_Filter_8u_P2P3R
  Purpose:    Converts a NV12 image to the P422 image.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 2 || roiSize.height < 8

  Arguments:
    pSrcY                    pointer to the source Y plane
    srcYStep                 step  for the source Y plane
    pSrcCbCr                 pointer to the source CbCr plane
    srcCbCrStep              step  for the source CbCr plane
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 2.
    roiSize.height should be multiple 8.
    We use here Catmull-Rom interpolation.
}

 function ippiYCbCr420ToYCbCr422_Filter_8u_P2P3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr420ToYCbCr422_8u_P2P3R
  Purpose:    Converts a NV12 image to the P422 image.
  Name:       ippiYCbCr420_8u_P2P3R
  Purpose:    Converts a NV12 image to the I420(IYUV) image.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 2 || roiSize.height < 2

  Arguments:
    pSrcY                    pointer to the source Y plane
    srcYStep                 step  for the source Y plane
    pSrcCbCr                 pointer to the source CbCr plane
    srcCbCrStep              step  for the source CbCr plane
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 2.
    roiSize.height should be multiple 2.
}

 function ippiYCbCr420ToYCbCr422_8u_P2P3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420_8u_P2P3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr420ToYCbCr411_8u_P2P3R
  Purpose:    Converts a NV12 image to the P411 image.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4 || roiSize.height < 2

  Arguments:
    pSrcY                    pointer to the source Y plane
    srcYStep                 step  for the source Y plane
    pSrcCbCr                 pointer to the source CbCr plane
    srcCbCrStep              step  for the source CbCr plane
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
    roiSize.height should be multiple 2.
}

 function ippiYCbCr420ToYCbCr411_8u_P2P3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr411ToYCbCr422_8u_P3C2R
  Purpose:    Converts a P411 image to the YUY2 image.
  Name:       ippiYCbCr411ToYCrCb422_8u_P3C2R
  Purpose:    Converts a P411 image to the YVYU image.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4

  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pSrc                     pointer to the destination image
    srcStep                  step for the destination image
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
}

 function ippiYCbCr411ToYCbCr422_8u_P3C2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr411ToYCrCb422_8u_P3C2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr411ToYCbCr422_8u_P3R
  Purpose:    Converts a P411 image to the P422 image
  Name:       ippiYCbCr411ToYCrCb422_8u_P3R
  Purpose:    Converts a P411 image to the YVYU image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr        One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4

  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width should be multiple 4.
}

 function ippiYCbCr411ToYCbCr422_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr411ToYCrCb422_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr411ToYCbCr420_8u_P3R
  Purpose:    Converts a P411 image to the I420(IYUV) image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr        One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4 || roiSize.height < 2

  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
    roiSize.height should be multiple 2.
}

 function ippiYCbCr411ToYCbCr420_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:    ippiYCbCr411ToYCbCr420_8u_P3P2R
  Purpose:    Converts a P411 image to the NV12 image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4 || roiSize.height < 2

  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pDstY                    pointer to the source Y plane
    dstYStep                 step  for the destination Y plane
    pDstCbCr                 pointer to the destination CbCr plane
    dstCbCrStep              step  for the destination CbCr plane
    roiSize                  region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
    roiSize.height should be multiple 2.
}

 function ippiYCbCr411ToYCbCr420_8u_P3P2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:    ippiYCbCr411ToYCbCr411_8u_P3P2R
  Purpose:    Converts a P411 image to the NV11 image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4

  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pDstY                    pointer to the source Y plane
    dstYStep                 step  for the destination Y plane
    pDstCbCr                 pointer to the destination CbCr plane
    dstCbCrStep              step  for the destination CbCr plane
    roiSize                  region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
}

 function ippiYCbCr411_8u_P3P2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr411ToYCbCr422_8u_P2C2R
  Purpose:    Converts a NV11 image to the YUY2 image.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4

  Arguments:
    pSrcY                    pointer to the source Y plane
    srcYStep                 step  for the source Y plane
    pSrcCbCr                 pointer to the source CbCr plane
    srcCbCrStep              step  for the source CbCr plane
    pSrc                     pointer to the destination image
    srcStep                  step for the destination image
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
}

 function ippiYCbCr411ToYCbCr422_8u_P2C2R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr411ToYCbCr422_8u_P2P3R
  Purpose:    Converts a NV11 image to the P422 image.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4

  Arguments:
    pSrcY                    pointer to the source Y plane
    srcYStep                 step  for the source Y plane
    pSrcCbCr                 pointer to the source CbCr plane
    srcCbCrStep              step  for the source CbCr plane
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
}

 function ippiYCbCr411ToYCbCr422_8u_P2P3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr411ToYCrCb420_8u_P2P3R
  Purpose:    Converts a NV11 image to the YV12 image.
  Name:       ippiYCbCr411ToYCbCr420_8u_P2P3R
  Purpose:    Converts a NV11 image to the I420(IYUV) image.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4 || roiSize.height < 2

  Arguments:
    pSrcY                    pointer to the source Y plane
    srcYStep                 step  for the source Y plane
    pSrcCbCr                 pointer to the source CbCr plane
    srcCbCrStep              step  for the source CbCr plane
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
    roiSize.height should be multiple 2.
}

 function ippiYCbCr411ToYCrCb420_8u_P2P3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr411ToYCbCr420_8u_P2P3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr411_8u_P2P3R
  Purpose:    Converts a NV11 image to the P411 image.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4

  Arguments:
    pSrcY                    pointer to the source Y plane
    srcYStep                 step  for the source Y plane
    pSrcCbCr                 pointer to the source CbCr plane
    srcCbCrStep              step  for the source CbCr plane
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
}

 function ippiYCbCr411_8u_P2P3R( pSrcY : Ipp8uPtr ; srcYStep : Int32 ; pSrcCbCr : Ipp8uPtr ; srcCbCrStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr422ToYCbCr411_8u_C2P2R
  Purpose:    Converts a YUY2 image to the NV11 image YUY2ToNV11
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 4

  Arguments:
    pSrc                     pointer to the source image
    srcStep                  step for the source image
    pDstY                    pointer to the source Y plane
    dstYStep                 step  for the destination Y plane
    pDstCbCr                 pointer to the destination CbCr plane
    dstCbCrStep              step  for the destination CbCr plane
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width  should be multiple 4.
}

 function ippiYCbCr422ToYCbCr411_8u_C2P2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDstY : Ipp8uPtr ; dstYStep : Int32 ; pDstCbCr : Ipp8uPtr ; dstCbCrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr422ToYCbCr411_8u_P3R
  Purpose:    Converts a P422 image to the P411 image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr        One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 2 || roiSize.height < 2

  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pDst                     array of pointers to the components of the destination image
    dstStep                  array of steps values for every component
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width and roiSize.height  should be multiple 2.
}

 function ippiYCbCr422ToYCbCr411_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr422ToYCrCb422_8u_P3C2R
  Purpose:    Converts a P422 image to the YVYU image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr        One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 2

  Arguments:
    pSrc                     array of pointers to the components of the source image
    srcStep                  array of step values for every component
    pSrc                     pointer to the destination image
    srcStep                  step for the destination image
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width and should be multiple 2.
}

 function ippiYCbCr422ToYCrCb422_8u_P3C2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCbCr422ToYCrCb422_8u_C2R
  Purpose:    Converts a YUY2 image to the YVYU image
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr        One or more pointers are NULL
    ippStsSizeErr            if roiSize.width < 2

  Arguments:
    pSrc                     pointer to the source image
    srcStep                  step for the source image
    pSrc                     pointer to the destination image
    srcStep                  step for the destination image
     roiSize                 region of interest to be processed, in pixels
  Notes:
    roiSize.width should be multiple 2.
}

 function ippiYCbCr422ToYCrCb422_8u_C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:    ippiYCbCr422ToGray_8u_C2C1R
  Purpose:    Converts an YUY2/YUY2 image to the Gray image
  Return:
    ippStsNoErr              No errors
    ippStsNullPtrErr         One or more pointers are NULL
    ippStsSizeErr            roiSize has a field with zero or negative value

  Arguments:
    pSrc                     Pointer to the source image
    srcStep                  Step in bytes through the source image to jump on the next line
    pDst                     Pointer to the destination image
    dstStep                  Step in bytes through the destination image to jump on the next line
    roiSize                  Region of interest (ROI) to be processed, in pixels
}

 function ippiYCbCr422ToGray_8u_C2C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name: ippiRGBToYCbCr_8u_C3R,       ippiYCbCrToRGB_8u_C3R.
        ippiRGBToYCbCr_8u_AC4R,      ippiYCbCrToRGB_8u_AC4R.
        ippiRGBToYCbCr_8u_P3R,       ippiYCbCrToRGB_8u_P3R.
        ippiYCbCrToRGB_8u_P3C3R
        ippiYCbCrToBGR444_8u16u_C3R, ippiYCbCrToRGB444_8u16u_C3R,
        ippiYCbCrToBGR555_8u16u_C3R, ippiYCbCrToRGB555_8u16u_C3R,
        ippiYCbCrToBGR565_8u16u_C3R, ippiYCbCrToRGB565_8u16u_C3R,

  Purpose:    Convert an RGB(BGR) image to and from YCbCr color model
  Parameters:
     pSrc   Pointer to the source image (for pixel-order data).An array of pointers
            to separate source color planes (in case of plane-order data)
     pDst   Pointer to the resultant image (for pixel-order data).An array of pointers
            to separate source color planes (in case of plane-order data)
     roiSize Size of the ROI in pixels.
     srcStep Step in bytes through the source image to jump on the next line
     dstStep Step in bytes through the destination image to jump on the next line
  Returns:
           ippStsNullPtrErr  src == NULL or dst == NULL
           ippStsStepErr,    srcStep or dstStep is less than or equal to zero
           ippStsSizeErr     roiSize has a field with zero or negative value
           ippStsNoErr       No errors
  Reference:
      Jack Keith
      Video Demystified: A Handbook for the Engineer : Digital ; 2nd ed.
      1996.pp.(42-43)

  The YCbCr color space was developed as part of Recommendation ITU-R BT.601
  (formerly CCI 601). Y is defined to have a nominal range of 16 to 235;
  Cb and Cr are defined to have a range of 16 to 240, with 128 equal to zero.
  If the gamma-corrected RGB(R'G'B') image has a range 0 .. 255, as is commonly
  found in computer system (and in our library), the following equations may be
  used:

       Y  =  0.257*R' + 0.504*G' + 0.098*B' + 16
       Cb = -0.148*R' - 0.291*G' + 0.439*B' + 128
       Cr =  0.439*R' - 0.368*G' - 0.071*B' + 128

       R' = 1.164*(Y - 16) + 1.596*(Cr - 128 )
       G' = 1.164*(Y - 16) - 0.813*(Cr - 128 )- 0.392*( Cb - 128 )
       B' = 1.164*(Y - 16) + 2.017*(Cb - 128 )

   Note that for the YCbCr-to-equations : RGB ; the RGB values must be saturated
   at the 0 and 255 levels due to occasional excursions outside the nominal
   YCbCr ranges.
}

 function ippiRGBToYCbCr_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYCbCr_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYCbCr_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCrToRGB_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCrToRGB_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCrToRGB_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCrToRGB_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiRGBToYUV_8u_C3R,  ippiYUVToRGB_8u_C3R.
              ippiRGBToYUV_8u_AC4R, ippiYUVToRGB_8u_AC4R.
              ippiRGBToYUV_8u_P3R,  ippiYUVToRGB_8u_P3R.
              ippiRGBToYUV_8u_C3P3R,ippiYUVToRGB_8u_P3C3R.
  Purpose:    Converts an RGB image to the YUV color model and vice versa.
  Parameters:
     pSrc   Pointer to the source image (for pixel-order data).An array of pointers
            to separate source color planes (for plane-order data)
     pDst   Pointer to the destination image (for pixel-order data).An array of
            pointers to separate destination color planes (for of plane-order data)
     roiSize   Size of ROI in pixels.
     srcStep   Step in bytes through the source image to jump on the next line
     dstStep   Step in bytes through the destination image to jump on the next line
  Returns:
           ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
           ippStsStepErr,    srcStep or dstStep is less than or equal to zero
           ippStsSizeErr     roiSize has a field with zero or negative value
           ippStsNoErr       No errors
  Reference:
      Jack Keith
      Video Demystified: A Handbook for the Engineer : Digital ; 2nd ed.
      1996.pp.(40-41)

     The YUV color space is the basic color space used by PAL : the ; NTSC, and
  SECAM composite color video standards.

  These functions operate with gamma-corrected images.
  The basic equations for conversion between gamma-corrected RGB(R'G'B')and YUV are:

       Y' =  0.299*R' + 0.587*G' + 0.114*B'
       U  = -0.147*R' - 0.289*G' + 0.436*B' = 0.492*(B' - Y' )
       V  =  0.615*R' - 0.515*G' - 0.100*B' = 0.877*(R' - Y' )

       R' = Y' + 1.140 * V
       G' = Y' - 0.394 * U - 0.581 * V
       B' = Y' + 2.032 * U

     For digital RGB values in the range [0 .. 255], Y has a range [0..255],
   U a range [-112 .. +112], and V a range [-157..+157].

   These equations are usually scaled to simplify the implementation in an actual
   NTSC or PAL digital encoder or decoder.
}

 function ippiRGBToYUV_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUVToRGB_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYUV_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUVToRGB_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUVToRGB_8u_C3C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiRGBToYUV_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUVToRGB_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYUV_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUVToRGB_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiBGRToYUV420_8u_AC4P3R
  PVCS ID 7635
  Return:
    ippStsNoErr         Ok
    ippStsNullPtrErr    one or more pointers are NULL
    ippStsDoubleSize    Indicates a warning if roiSize is not a multiple of 2.
  Arguments:
    pSrc          Pointer to the source image ROI.
    srcStep       Distance in bytes between starts of consecutive lines in the source image.
    pDst          An array of pointers to ROI in the separate planes of the destination image.
    dstStep       Distance in bytes between starts of consecutive lines in the destination image.
    roiSize       Size of the source and destination ROI in pixels.
}

 function ippiBGRToYUV420_8u_AC4P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiRGBToYUV_8u_AC4P4R
  PVCS ID 8868
  Return:
    ippStsNoErr            Ok
    ippStsNullPtrErr      one or more pointers are NULL
  Arguments:
   pSrc         Pointer to the source image ROI for pixel-order image.
   srcStep      Distance in bytes between starts of consecutive lines in the source image.
   pDst         Pointer to the destination image ROI. An array of pointers to ROI in the separate destination color and alpha planes for planar images.
   dstStep      Distance in bytes between starts of consecutive lines in the destination image.
   roiSize      Size of the source and destination ROI in pixels.
}

 function ippiRGBToYUV_8u_AC4P4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiRGBToYUV422_8u_C3P3R,  ippiYUV422ToRGB_8u_P3C3R.
              ippiRGBToYUV422_8u_P3R,    ippiYUV422ToRGB_8u_P3R.
              ippiRGBToYUV420_8u_C3P3R,  ippiYUV420ToRGB_8u_P3C3R.
              ippiRGBToYUV422_8u_C3C2R,  ippiYUV422ToRGB_8u_C2C3R.
         ippiYUV420ToBGR565_8u16u_P3C3R,
         ippiYUV420ToBGR555_8u16u_P3C3R,
         ippiYUV420ToBGR444_8u16u_P3C3R,
         ippiYUV420ToRGB565_8u16u_P3C3R,
         ippiYUV420ToRGB555_8u16u_P3C3R,
         ippiYUV420ToRGB444_8u16u_P3C3R.

  Purpose:    Converts an RGB (BGR) image to the YUV color model with 4:2:2 or
              4:2:0 sampling and vice versa.
  Parameters:
     pSrc  Pointer to the source image (for pixel-order data).An array of pointers
           to separate source color planes (for plane-order data)
     pDst  Pointer to the destination image (for pixel-order data).An array of pointers
           to separate destination color planes (for plane-order data)
     roiSize   Size of the ROI in pixels.
     srcStep   Step in bytes through the source image to jump on the next line(for pixel-order data).
               An array of step values for the separate source color planes (for plane-order data).
     dstStep   Step in bytes through destination image to jump on the next line(for pixel-order data).
               An array of step values for the separate destination color planes (for plane-order data).
  Returns:
           ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
           ippStsStepErr     srcStep or dstStep is less than or equal to zero
           ippStsSizeErr     roiSize has a field with zero or negative value
           ippStsNoErr       No errors
  Reference:
      Jack Keith
      Video Demystified: A Handbook for the Engineer : Digital ; 2nd ed.
      1996.pp.(40-41)

     The YUV color space is the basic color space used by the PAL , NTSC , and
  SECAM composite color video standards.

  The functions operate with 4:2:2 and 4:2:0 sampling formats.
    4:2:2 uses the horizontal-only 2:1 reduction of U V : and ; 
    4:2:0 uses 2:1 reduction of U and V in both the vertical and
    horizontal directions.

  These functions operate with gamma-corrected images.
  The basic equations for conversion between gamma-corrected RGB(R'G'B')and YUV are:

       Y' =  0.299*R' + 0.587*G' + 0.114*B'
       U  = -0.147*R' - 0.289*G' + 0.436*B' = 0.492*(B' - Y' )
       V  =  0.615*R' - 0.515*G' - 0.100*B' = 0.877*(R' - Y' )

       R' = Y' + 1.140 * V
       G' = Y' - 0.394 * U - 0.581 * V
       B' = Y' + 2.032 * U

     For digital RGB values with the range [0 .. 255], Y has a range [0..255],
   U a range [-112 .. +112], and V a range [-157..+157].


   These equations are usually scaled to simplify the implementation in an actual
   NTSC or PAL digital encoder or decoder.
}

 function ippiYUV420ToRGB_8u_P3AC4R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUV422ToRGB_8u_P3AC4R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYUV422_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUV422ToRGB_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYUV422_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUV422ToRGB_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYUV420_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUV420ToRGB_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUV420ToBGR_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYUV420_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUV420ToRGB_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToYUV422_8u_C3C2R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYUV422ToRGB_8u_C2C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiRGBToYUV422_8u_P3,   ippiYUV422ToRGB_8u_P3.
              ippiRGBToYUV422_8u_C3P3, ippiYUV422ToRGB_8u_P3C3.
              ippiRGBToYUV420_8u_C3P3, ippiYUV420ToRGB_8u_P3C3.
              ippiRGBToYUV420_8u_P3,   ippiYUV420ToRGB_8u_P3.
  Purpose:    Converts an RGB image to YUV color model with 4:2:2 and
              4:2:0 sampling and vice versa.
  Parameters:
     pSrc   Pointer to the source image (for pixel-order data).An array of pointers
            to the separate source color planes (for plane-order data)
     pDst   Pointer to the destination image (for pixel-order data).An array of pointers
            to the separate destination color planes (for plane-order data)
     imgSize   Size of the source and destination images in pixels
  Returns:
           ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
           ippStsStepErr,    srcStep or dstStep is less than or equal to zero
           ippStsSizeErr     imgSize has a field with zero or negative value
           ippStsNoErr       No errors
  Reference:
      Jack Keith
      Video Demystified: A Handbook for the Engineer : Digital ; 2nd ed.
      1996.pp.(40-41)

     The YUV color space is the basic color space used by the PAL , NTSC , and
  SECAM composite color video standards.

  The functions operate with 4:2:2 and 4:2:0 sampling formats.
    4:2:2 uses the horizontal-only 2:1 reduction of U V : and ; 
    4:2:0 uses 2:1 reduction of U and V in both the vertical and
    horizontal directions.

  These functions operate with gamma-corrected images.
  The basic equations to convert between gamma-corrected RGB(R'G'B')and YUV are:

       Y' =  0.299*R' + 0.587*G' + 0.114*B'
       U  = -0.147*R' - 0.289*G' + 0.436*B' = 0.492*(B' - Y' )
       V  =  0.615*R' - 0.515*G' - 0.100*B' = 0.877*(R' - Y' )

       R' = Y' + 1.140 * V
       G' = Y' - 0.394 * U - 0.581 * V
       B' = Y' + 2.032 * U

   For digital RGB values with the range [0 .. 255], Y has the range [0..255],
   U the range [-112 .. +112],V the range [-157..+157].

   These equations are usually scaled to simplify the implementation in an actual
   NTSC or PAL digital encoder or decoder.
}

 function ippiRGBToYUV422_8u_P3( pSrc : Ipp8u_3Ptr ; pDst : Ipp8u_3Ptr ; imgSize : IppiSize ): IppStatus; _ippapi
 function ippiYUV422ToRGB_8u_P3( pSrc : Ipp8u_3Ptr ; pDst : Ipp8u_3Ptr ; imgSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYUV422_8u_C3P3( pSrc : Ipp8uPtr ; pDst : Ipp8u_3Ptr ; imgSize : IppiSize ): IppStatus; _ippapi
 function ippiYUV422ToRGB_8u_P3C3( pSrc : Ipp8u_3Ptr ; pDst : Ipp8uPtr ; imgSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYUV420_8u_C3P3( pSrc : Ipp8uPtr ; pDst : Ipp8u_3Ptr ; imgSize : IppiSize ): IppStatus; _ippapi
 function ippiYUV420ToRGB_8u_P3C3( pSrc : Ipp8u_3Ptr ; pDst : Ipp8uPtr ; imgSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYUV420_8u_P3( pSrc : Ipp8u_3Ptr ; pDst : Ipp8u_3Ptr ; imgSize : IppiSize ): IppStatus; _ippapi
 function ippiYUV420ToRGB_8u_P3( pSrc : Ipp8u_3Ptr ; pDst : Ipp8u_3Ptr ; imgSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCoCgToBGR_16s8u_P3C3R  ippiYCoCgToBGR_16s8u_P3C4R
  Purpose:    Converts a YCoCg image to the RGB24/RGB32 image.
  Name:       ippiYCoCgToBGR_16s8u_P3C3R  ippiBGRToYCoCg_8u16s_C4P3R
  Purpose:    Converts a RGB24/RGB32 image to the YCoCg image.
  Name:       ippiYCoCgToSBGR_16s_P3C3R  ippiSBGRToYCoCg_16s_C3P3R
  Purpose:    Converts a YCoCg image to the scRGB48/scRGB64 image.
  Name:       ippi_SC_BGRToYCoCg_16s_C3P3R  ippi_SC_BGRToYCoCg_16s_C4P3R
  Purpose:    Converts a scRGB48/scRGB64 image to the YCoCg image.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL

  Arguments:
    pYCC                     array of pointers to the components of the YCoCg image
    yccStep                  step for Y : every ; Co,Cg component
    pBGR                     Pointer to the BGR image (for pixel-order data).
    bgrStep                  step  for the BGR image.
    roiSize                  region of interest to be processed, in pixels
  Notes:
    Y  = (( R + G*2 + B) + 2 ) / 4
   Co  = (( R -       B) + 1 ) / 2
   Cg  = ((-R + G*2 - B) + 2 ) / 4

    R  =  Y + Co - Cg
    G  =  Y +      Cg
    B  =  Y - Co - Cg
    scRGB allows negative values and values above 1.0
}

 function ippiYCoCgToBGR_16s8u_P3C3R( pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; pBGR : Ipp8uPtr ; bgrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCoCg_8u16s_C3P3R( pBGR : Ipp8uPtr ; bgrStep : Int32 ; pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCoCgToBGR_16s8u_P3C4R( pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; pBGR : Ipp8uPtr ; bgrStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiBGRToYCoCg_8u16s_C4P3R( pBGR : Ipp8uPtr ; bgrStep : Int32 ; pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCoCgToSBGR_16s_P3C3R( pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; pBGR : Ipp16sPtr ; bgrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSBGRToYCoCg_16s_C3P3R( pBGR : Ipp16sPtr ; bgrStep : Int32 ; pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCoCgToSBGR_16s_P3C4R( pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; pBGR : Ipp16sPtr ; bgrStep : Int32 ; roiSize : IppiSize ; aval : Ipp16s ): IppStatus; _ippapi
 function ippiSBGRToYCoCg_16s_C4P3R( pBGR : Ipp16sPtr ; bgrStep : Int32 ; pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCoCgToSBGR_32s16s_P3C3R( pYCC : Ipp32s_3Ptr ; yccStep : Int32 ; pBGR : Ipp16sPtr ; bgrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSBGRToYCoCg_16s32s_C3P3R( pBGR : Ipp16sPtr ; bgrStep : Int32 ; pYCC : Ipp32s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCoCgToSBGR_32s16s_P3C4R( pYCC : Ipp32s_3Ptr ; yccStep : Int32 ; pBGR : Ipp16sPtr ; bgrStep : Int32 ; roiSize : IppiSize ; aval : Ipp16s ): IppStatus; _ippapi
 function ippiSBGRToYCoCg_16s32s_C4P3R( pBGR : Ipp16sPtr ; bgrStep : Int32 ; pYCC : Ipp32s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiYCoCgToBGR_Rev_16s8u_P3C3R  ippiYCoCgToBGR_Rev_16s8u_P3C4R
  Purpose:    Converts a YCoCg-R image to the scRGB48/scRGB64 image.
  Name:       ippiBGRToYCoCg_Rev_8u16s_C3P3R  ippiBGRToYCoCg_Rev_8u16s_C4P3R
  Purpose:    Converts a scRGB48/scRGB64 image to the YCoCg-R image.
  Name:       ippiYCoCgToSBGR_Rev_16s_P3C3R  ippiYCoCgToSBGR_Rev_16s_P3C4R
  Purpose:    Converts a YCoCg-R image to the scRGB48/scRGB64 image.
  Name:       ippiSBGRToYCoCg_Rev_16s_C3P3R  ippiSBGRToYCoCg_Rev_16s_C4P3R
  Purpose:    Converts a scRGB48/scRGB64 image to the YCoCg-R image.
              Where: YCoCg-R  - Reversible transform.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One or more pointers are NULL

  Arguments:
    pYCC                     array of pointers to the components of the YCoCg image
    yccStep                  step for Y : every ; Co,Cg component
    pBGR                     Pointer to the BGR image (for pixel-order data).
    bgrStep                  step  for the BGR image.
    roiSize                  region of interest to be processed, in pixels
  Notes:
    Co =  R  -  B
    t  =  B  + (Co >> 1)
    Cg =  G  -  t
    Y  =  t  + (Cg >> 1)

    t  =  Y  - (Cg >> 1)
    G  =  Cg + t
    B  =  t  - (Co >> 1)
    R  =  B  +  Co
    If each of the RGB channels are integer values with
    an N-range : bit ; then the luma channel Y requires bits : N ; 
    and the chroma channels require N+1 bits.
}

 function ippiYCoCgToBGR_Rev_16s8u_P3C3R( pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; pBGR : Ipp8uPtr ; bgrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToYCoCg_Rev_8u16s_C3P3R( pBGR : Ipp8uPtr ; bgrStep : Int32 ; pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCoCgToBGR_Rev_16s8u_P3C4R( pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; pBGR : Ipp8uPtr ; bgrStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiBGRToYCoCg_Rev_8u16s_C4P3R( pBGR : Ipp8uPtr ; bgrStep : Int32 ; pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCoCgToSBGR_Rev_16s_P3C3R ( pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; pBGR : Ipp16sPtr ; bgrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSBGRToYCoCg_Rev_16s_C3P3R ( pBGR : Ipp16sPtr ; bgrStep : Int32 ; pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCoCgToSBGR_Rev_16s_P3C4R ( pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; pBGR : Ipp16sPtr ; bgrStep : Int32 ; roiSize : IppiSize ; aval : Ipp16s ): IppStatus; _ippapi
 function ippiSBGRToYCoCg_Rev_16s_C4P3R ( pBGR : Ipp16sPtr ; bgrStep : Int32 ; pYCC : Ipp16s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSBGRToYCoCg_Rev_16s32s_C3P3R( pBGR : Ipp16sPtr ; bgrStep : Int32 ; pYCC : Ipp32s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCoCgToSBGR_Rev_32s16s_P3C4R( pYCC : Ipp32s_3Ptr ; yccStep : Int32 ; pBGR : Ipp16sPtr ; bgrStep : Int32 ; roiSize : IppiSize ; aval : Ipp16s ): IppStatus; _ippapi
 function ippiYCoCgToSBGR_Rev_32s16s_P3C3R( pYCC : Ipp32s_3Ptr ; yccStep : Int32 ; pBGR : Ipp16sPtr ; bgrStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSBGRToYCoCg_Rev_16s32s_C4P3R( pBGR : Ipp16sPtr ; bgrStep : Int32 ; pYCC : Ipp32s_3Ptr ; yccStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiRGBToGray
  Purpose:    Converts an RGB image to gray scale (fixed coefficients)
  Parameters:
     pSrc     Pointer to the source image , points to point(0,0)
     pDst     Pointer to the destination image , points to point(0,0)
     roiSize  Size of the ROI in pixels. Since the function performs point
          operations (without a border), the ROI may be the whole image.
     srcStep  Step in bytes through the source image to jump on the next line
     dstStep  Step in bytes through the destination image to jump on the next line
  Returns:
           ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
           ippStsSizeErr     roiSize has a field with zero or negative value
           ippStsNoErr       No errors
  Reference:
      Jack Keith
      Video Demystified: A Handbook for the Engineer : Digital ; 2nd ed.
      1996.p.(82)

  The transform coefficients of equation below correspond to the standard for
  red : NTSC ; green and blue CRT phosphors (1953) that are standardized in the
  ITU-R Recommendation BT. 601-2 (formerly CCIR Rec. 601-2).

  The basic equation to compute non-linear video luma (monochrome) from non-linear
  (gamma-corrected) RGB(R'G'B') is:

  Y' = 0.299 * R' + 0.587 * G' + 0.114 * B';

}

 function ippiRGBToGray_8u_C3C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToGray_16u_C3C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToGray_16s_C3C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToGray_32f_C3C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToGray_8u_AC4C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToGray_16u_AC4C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToGray_16s_AC4C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToGray_32f_AC4C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiGrayToRGB
  Purpose:    Converts gray scale image to RGB/BGR image by copiing luminance component to color components
  Parameters:
     pSrc              Pointer to the source image
     pDst              Pointer to the destination image
     roiSize           Size of source and destination ROI in pixels
     srcStep           Step in bytes through the source image to jump on the next line
     dstStep           Step in bytes through the destination image to jump on the next line
     aval              Constant value to create the fourth channel
  Returns:
     ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
     ippStsSizeErr     roiSize has a field with zero or negative value
     ippStsNoErr       No errors
}

 function ippiGrayToRGB_8u_C1C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGrayToRGB_16u_C1C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGrayToRGB_32f_C1C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGrayToRGB_8u_C1C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi
 function ippiGrayToRGB_16u_C1C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp16u ): IppStatus; _ippapi
 function ippiGrayToRGB_32f_C1C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiColorToGray
  Purpose:    Converts an RGB image to gray scale (custom coefficients)
  Parameters:
     pSrc      Pointer to the source image , points to point(0,0)
     pDst      Pointer to the destination image , points to point(0,0)
     roiSize   Size of the ROI in pixels. Since the function performs point
               operations (without a border), the ROI may be the whole image.
     srcStep   Step in bytes through the source image to jump on the next line
     dstStep   Step in bytes through the destination image to jump on the next line
     coeffs[3] User-defined vector of coefficients.
                 The sum of the coefficients should be less than or equal to 1
  Returns:
           ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
           ippStsSizeErr     roiSize has a field with zero or negative value
           ippStsNoErr       No errors

  The following equation is used to convert an RGB image to gray scale:

   Y = coeffs[0] * R + coeffs[1] * G + coeffs[2] * B;

}

 function ippiColorToGray_8u_C3C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const coeffs : Ipp32f_3): IppStatus; _ippapi
 function ippiColorToGray_16u_C3C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const coeffs : Ipp32f_3): IppStatus; _ippapi
 function ippiColorToGray_16s_C3C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const coeffs : Ipp32f_3): IppStatus; _ippapi
 function ippiColorToGray_32f_C3C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const coeffs : Ipp32f_3): IppStatus; _ippapi
 function ippiColorToGray_64f_C3C1R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const coeffs : Ipp64f_3): IppStatus; _ippapi

 function ippiColorToGray_8u_AC4C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const coeffs : Ipp32f_3): IppStatus; _ippapi
 function ippiColorToGray_16u_AC4C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const coeffs : Ipp32f_3): IppStatus; _ippapi
 function ippiColorToGray_16s_AC4C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const coeffs : Ipp32f_3): IppStatus; _ippapi
 function ippiColorToGray_32f_AC4C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const coeffs : Ipp32f_3): IppStatus; _ippapi
 function ippiColorToGray_64f_AC4C1R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const coeffs : Ipp64f_3): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:     ippiRGBToHLS,     ippiHLSToRGB
            ippiBGRToHLS,     ippiHLSToBGR
  Purpose:    Converts an RGB(BGR) image to the HLS color model and vice versa
  Parameters:
     pSrc      Pointer to the source image , points to point(0,0)
     pDst      Pointer to the destination image , points to point(0,0)
     roiSize   Size of the ROI in pixels. Since the function performs point
               operations (without a border), the ROI may be the whole image.
     srcStep   Step in bytes through the source image to jump on the next line
     dstStep   Step in bytes through the destination image to jump on the next line
  Returns:
           ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
           ippStsStepErr     srcStep or dstStep is less than or equal to zero
           ippStsSizeErr     roiSize has a field with zero or negative value
           ippStsNoErr       No errors
  RGB and HLS values for the 32f data type should be in the range [0..1]
  Reference:
      David F.Rogers
      Procedural Elements for Computer Graphics
      1985.pp.(403-406)

       H is the hue red at degrees : 0 ; which has range [0 .. 360 degrees],
       L is lightness : the ; 
       S is saturation : the ; 

       The RGB to HLS conversion algorithm in pseudo code:
   Lightness:
      M1 = max(R,G,B); M2 = max(R,G,B); L = (M1+M2)/2
   Saturation:
      if M1 = M2 then // achromatic case
          S = 0
          H = 0
      else // chromatics case
          if L <= 0.5 then
               S = (M1-M2) / (M1+M2)
          else
               S = (M1-M2) / (2-M1-M2)
   Hue:
      Cr = (M1-R) / (M1-M2)
      Cg = (M1-G) / (M1-M2)
      Cb = (M1-B) / (M1-M2)
      if R = M2 then H = Cb - Cg
      if G = M2 then H = 2 + Cr - Cb
      if B = M2 then H = 4 + Cg - Cr
      H = 60*H
      if H < 0 then H = H + 360

      The HSL to RGB conversion algorithm in pseudo code:
      if L <= 0.5 then
           M2 = L *(1 + S)
      else
           M2 = L + S - L * S
      M1 = 2 * L - M2
      if S = 0 then
         R = G = B = L
      else
          h = H + 120
          if h > 360 then
              h = h - 360

          if h  <  60 then
              R = ( M1 + ( M2 - M1 ) * h / 60)
          else if h < 180 then
              R = M2
          else if h < 240 then
              R = M1 + ( M2 - M1 ) * ( 240 - h ) / 60
          else
              R = M1
          h = H
          if h  <  60 then
              G = ( M1 + ( M2 - M1 ) * h / 60
          else if h < 180 then
              G = M2
          else if h < 240 then
              G = M1 + ( M2 - M1 ) * ( 240 - h ) / 60
          else
              G  = M1
          h = H - 120
          if h < 0 then
              h += 360
          if h  <  60 then
              B = ( M1 + ( M2 - M1 ) * h / 60
          else if h < 180 then
              B = M2
          else if h < 240 then
              B = M1 + ( M2 - M1 ) * ( 240 - h ) / 60
          else
              B = M1

    H,L,S,R,G,B are scaled to the range:
             [0..1]                      for the depth : 32f ; 
             [0..IPP_MAX_8u]             for the depth : 8u ; 
             [0..IPP_MAX_16u]            for the depth : 16u ; 
             [IPP_MIN_16S..IPP_MAX_16s]  for the 16s depth.
}

 function ippiBGRToHLS_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToHLS_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToRGB_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToHLS_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToRGB_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToHLS_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToRGB_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToHLS_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToRGB_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToHLS_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToRGB_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToHLS_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToRGB_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToHLS_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToRGB_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToHLS_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToRGB_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiBGRToHLS_8u_AP4R( pSrc : Ipp8u_4Ptr ; srcStep : Int32 ; pDst : Ipp8u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToHLS_8u_AP4C4R( pSrc : Ipp8u_4Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToHLS_8u_AC4P4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiBGRToHLS_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToHLS_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToHLS_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToBGR_8u_AP4R( pSrc : Ipp8u_4Ptr ; srcStep : Int32 ; pDst : Ipp8u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToBGR_8u_AP4C4R( pSrc : Ipp8u_4Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToBGR_8u_AC4P4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToBGR_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToBGR_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHLSToBGR_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:        ippiRGBToHSV,   ippiHSVToRGB
  Purpose:    Converts an RGB image to the HSV color model and vice versa
  Parameters:
     pSrc      Pointer to the source image , points to point(0,0)
     pDst      Pointer to the destination image , points to point(0,0)
     roiSize   Size of the ROI in pixels.
     srcStep   Step in bytes through the source image to jump on the next line
     dstStep   Step in bytes through the destination image to jump on the next line
  Returns:
           ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
           ippStsStepErr     srcStep or dstStep is less than or equal to zero
           ippStsSizeErr     roiSize has a field with zero or negative value
           ippStsNoErr       No errors
  Reference:
      David F.Rogers
      Procedural Elements for Computer Graphics
      1985.pp.(401-403)

       H is the hue red at degrees : 0 ; which has range [0 .. 360 degrees],
       S is saturation : the ; 
       V is the value
       The RGB to HSV conversion algorithm in pseudo code:
   Value:
      V = max(R,G,B);
   Saturation:
      temp = min(R,G,B);
      if V = 0 then // achromatic case
          S = 0
          H = 0
      else // chromatics case
          S = (V - temp)/V
   Hue:
      Cr = (V - R) / (V - temp)
      Cg = (V - G) / (V - temp)
      Cb = (V - B) / (V - temp)
      if R = V then H = Cb - Cg
      if G = V then H = 2 + Cr - Cb
      if B = V then H = 4 + Cg - Cr
      H = 60*H
      if H < 0 then H = H + 360

      The HSV to RGB conversion algorithm in pseudo code:
      if S = 0 then
         R = G = B = V
      else
          if H = 360 then
              H = 0
          else
              H = H/60
           I = floor(H)
           F = H - I;
           M = V * ( 1 - S);
           N = V * ( 1 - S * F);
           K = V * ( 1 - S * (1 - F));
           if(I == 0)then( R = V;G = K;B = M;)
           if(I == 1)then( R = N;G = V;B = M;)
           if(I == 2)then( R = M;G = V;B = K;)
           if(I == 3)then( R = M;G = N;B = V;)
           if(I == 4)then( R = K;G = M;B = V;)
           if(I == 5)then( R = V;G = M;B = N;)

           in the range [0..IPP_MAX_8u ] for the depth : 8u ; 
           in the range [0..IPP_MAX_16u] for the depth : 16u ; 
}

 function ippiRGBToHSV_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHSVToRGB_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToHSV_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHSVToRGB_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToHSV_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHSVToRGB_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToHSV_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiHSVToRGB_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:     ippiRGBToYCC,   ippiYCCToRGB
  Purpose:    Converts an RGB image to the YCC color model and vice versa.
  Parameters:
    pSrc          Pointer to the source image ROI
    srcStep       Step through the source image (bytes)
    pDst          Pointer to the destination image ROI
    dstStep       Step through the destination image (bytes)
    dstRoiSize    size of the ROI
  Returns:
           ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
           ippStsStepErr     srcStep or dstStep is less than or equal to zero
           ippStsSizeErr     roiSize has a field with zero or negative value
           ippStsNoErr       No errors
  Reference:
      Jack Keith
      Video Demystified: a Handbook for the Engineer : Digital ; 2nd ed.
      1996.pp.(46-47)

  The basic equations to convert gamma-corrected R'G'B' image to YCC are:

   RGB data is transformed into PhotoYCC data:
    Y  =  0.299*R' + 0.587*G' + 0.114*B'
    C1 = -0.299*R' - 0.587*G' + 0.886*B' = B'- Y
    C2 =  0.701*R' - 0.587*G' - 0.114*B' = R'- Y
   Y,C1,C2 are quantized and limited to the range [0..1]
    Y  = 1. / 1.402 * Y
    C1 = 111.4 / 255. * C1 + 156. / 255.
    C2 = 135.64 /255. * C2 + 137. / 255.

  Conversion of PhotoYCC data to RGB data for CRT computer display:

   normal luminance and chrominance data are recovered
    Y  = 1.3584 * Y
    C1 = 2.2179 * (C1 - 156./255.)
    C2 = 1.8215 * (C2 - 137./255.)
   PhotoYCC data is transformed into RGB data
    R' = L + C2
    G' = L - 0.194*C1 - 0.509*C2
    B' = L + C1
    Where:  Y -  luminance; C1 : and ; C2  - two chrominance values.

  Equations are given above in assumption that Y : the ; C1, C2, R, G, and B
   values are in the range [0..1].
   Y, C1, C2, R, G, B - are scaled to the range:
             [0..1]                      for the depth : 32f ; 
             [0..IPP_MAX_8u]             for the depth : 8u ; 
             [0..IPP_MAX_16u]            for the depth : 16u ; 
             [IPP_MIN_16s..IPP_MAX_16s]  for the 16s depth.
}

 function ippiRGBToYCC_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCCToRGB_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYCC_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCCToRGB_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToYCC_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCCToRGB_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYCC_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCCToRGB_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToYCC_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCCToRGB_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYCC_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCCToRGB_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToYCC_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCCToRGB_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYCC_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCCToRGB_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiRGBToXYZ,     ippiXYZToRGB
  Purpose:    Converts an RGB image to the XYZ color model and vice versa.
  Parameters:
    pSrc          Pointer to the source image ROI
    srcStep       Step through the source image (bytes)
    pDst          Pointer to the destination image ROI
    dstStep       Step through the destination image (bytes)
    dstRoiSize    size of the ROI
  Returns:
           ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
           ippStsStepErr     srcStep or dstStep is less than or equal to zero
           ippStsSizeErr     roiSize has a field with zero or negative value
           ippStsNoErr       No errors
  Reference:
      David F. Rogers
      Procedural Elements for Computer Graphics.
      1985.

  The basic equations to convert between Rec. 709 RGB (with its D65 white point) and CIE XYZ are:

       X =  0.412453 * R + 0.35758 * G + 0.180423 * B
       Y =  0.212671 * R + 0.71516 * G + 0.072169 * B
       Z =  0.019334 * R + 0.119193* G + 0.950227 * B

       R = 3.240479 * X - 1.53715  * Y  - 0.498535 * Z
       G =-0.969256 * X + 1.875991 * Y  + 0.041556 * Z
       B = 0.055648 * X - 0.204043 * Y  + 1.057311 * Z
  Equations are given above in assumption that the X,Y,Z,R,G, and B
   values are in the range [0..1].
   Y, C1, C2, R, G, B - are scaled to the range:
           [0..1]                      for the 32f depth, 
           [0..IPP_MAX_8u]             for the 8u depth, 
           [0..IPP_MAX_16u]            for the 16u depth, 
           [IPP_MIN_16s..IPP_MAX_16s]  for the 16s depth.
}

 function ippiRGBToXYZ_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXYZToRGB_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToXYZ_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXYZToRGB_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToXYZ_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXYZToRGB_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToXYZ_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXYZToRGB_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToXYZ_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiXYZToRGB_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToXYZ_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXYZToRGB_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToXYZ_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXYZToRGB_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToXYZ_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXYZToRGB_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiRGBToLUV,     ippiLUVToRGB
  Purpose:    Converts an RGB image to the LUV color model and vice versa.
  Parameters:
    pSrc          Pointer to the source image ROI
    srcStep       Step through the source image (bytes)
    pDst          Pointer to the destination image ROI
    dstStep       Step through the destination image (bytes)
    dstRoiSize    size of the ROI
  Returns:
           ippStsNullPtrErr  pSrc == NULL, or pDst == NULL
           ippStsStepErr     srcStep or dstStep is less than or equal to zero
           ippStsSizeErr     roiSize has a field with zero or negative value
           ippStsNoErr       No errors
  Reference:
     Computer Graphics: Principles and Practices. James D. Foley... [et al]. 2nd edition.
     Addison-Wesley, 1990.p.(584)

    At first an RGB image is converted to the XYZ format image (see the functions
    ippiRGBToXYZ), then to the CIELUV with the white point D65 and CIE chromaticity
    coordinates of white point (xn,yn) = (0.312713, 0.329016), and Yn = 1.0 - the luminance of white point.

       L = 116. * (Y/Yn)**1/3. - 16.
       U = 13. * L * ( u - un )
       V = 13. * L * ( v - vn )
      These are quantized and limited to the 8-bit range of 0 to 255.
       L =   L * 255. / 100.
       U = ( U + 134. ) * 255. / 354.
       V = ( V + 140. ) * 255. / 256.
       where:
       u' = 4.*X / (X + 15.*Y + 3.*Z)
       v' = 9.*Y / (X + 15.*Y + 3.*Z)
       un = 4.*xn / ( -2.*xn + 12.*yn + 3. )
       vn = 9.*yn / ( -2.*xn + 12.*yn + 3. ).
       xn, yn is the CIE chromaticity coordinates of white point.
       Yn = 255. is the luminance of white point.

       The L component values are in the range [0..100], the U component values are
       in the range [-134..220], and the V component values are in the range [-140..122].

      The CIELUV to RGB conversion is performed as following. At first
      a LUV image is converted to the XYZ image
       L  =   L * 100./ 255.
       U  = ( U * 354./ 255.) - 134.
       V  = ( V * 256./ 255.) - 140.
       u = U / ( 13.* L ) + un
       v = V / ( 13.* L ) + vn
       Y = (( L + 16. ) / 116. )**3.
       Y *= Yn
       X =  -9.* Y * u / (( u - 4.)* v - u * v )
       Z = ( 9.*Y - 15*v*Y - v*X ) / 3. * v
       where:
       un = 4.*xn / ( -2.*xn + 12.*yn + 3. )
       vn = 9.*yn / ( -2.*xn + 12.*yn + 3. ).
       xn, yn is the CIE chromaticity coordinates of white point.
       Yn = 255. is the luminance of white point.

     Then the XYZ image is converted to the RGB image (see the functions
     ippiXYZToRGB).
}

 function ippiRGBToLUV_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToLUV_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiLUVToRGB_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLUVToBGR_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToLUV_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLUVToRGB_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToLUV_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLUVToRGB_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToLUV_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLUVToRGB_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToLUV_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLUVToRGB_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToLUV_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLUVToRGB_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToLUV_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiBGRToLUV_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiLUVToRGB_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLUVToBGR_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRGBToLUV_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLUVToRGB_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiBGRToLab_8u_C3R    and ippiLabToBGR_8u_C3R
              ippiBGRToLab_8u16u_C3R and ippiLabToBGR_16u8u_C3R
  Purpose:    Converts an RGB image to CIE Lab color model and vice-versa
  Parameters:
    pSrc          Pointer to the source image ROI
    srcStep       Step through the source  image (bytes)
    pDst          Pointer to the destination image ROI
    dstStep       Step through the destination image (bytes)
    roiSize       Size of the ROI
  Returns:
     ippStsNullPtrErr  if src == NULL or dst == NULL
     ippStsSizeErr     if imgSize.width <= 0 || imgSize.height <= 0
     ippStsNoErr       otherwise
  Reference:
     Computer graphics: principles and practices. James D. Foley... [et al.]. 2nd ed.
     Addison-Wesley, c1990.p.(584)

    At first an RGB image is converted to the XYZ color model (see the function
    ippRGBToXYZ_8u_C3R), then to the CIELab with the white point D65 and CIE chromaticity
    coordinates of white point (xn,yn) = (0.312713, 0.329016)
    L = 116. *((Y/Yn)^(1/3)) - 16    for Y/Yn >  0.008856
    L = 903.3*(Y/Yn)                 for Y/Yn <= 0.008856
    a = 500. * (f(X/Xn) - f(Y/Yn))
    b = 200. * (f(Y/Yn) - f(Z/Zn))
    where f(t)=t^(1/3)               for t >  0.008856
    f(t)=7.787*t+16/116              for t <= 0.008856
    These values are quantized and scaled to the 8-bit range of 0 to 255 for ippiBGRToLab_8u_C3R.
    L =   L * 255. / 100.
    a = (a + 128.)
    b = (a + 128.)
    and they are quantized and scaled to the 16-bit range of 0 to 65535 for ippiBGRToLab_8u16u_C3R
    L =  L * 65535. / 100.
    a = (a + 128.)* 255
    b = (a + 128.)* 255
    where:
      normalizing multipliers
    Yn = 1.0      * 255
    Xn = 0.950455 * 255
    Zn = 1.088753 * 255

    L component values are in the range [0..100], a and b component values are
    in the range [-128..127].

    The CIELab to RGB conversion is performed as follows. At first
    a Lab image is converted to the XYZ image
      for ippiLabToBGR_8u_C3R
    L =  L * 100./ 255.
    a = (a - 128.)
    b = (a - 128.)
      or for ippiLabToBGR_16u8u_C3R
    L =  L * 100./ 65535.
    a = (a / 255 - 128.)
    b = (b / 255 - 128.)
    X = Xn * ( P + a / 500 )^3
    Y = Yn * P^3
    Z = Zn * ( P - b / 200 )^3
    where P = (L + 16) / 116
    Then the XYZ image is converted to the RGB color model (see the function
     ippXYZToRGB_8u_C3R).
}

 function ippiBGRToLab_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToLab_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiLabToBGR_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLabToRGB_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiBGRToLab_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToLab_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiLabToBGR_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLabToRGB_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiBGRToLab_8u16u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLabToBGR_16u8u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:       ippiReduceBits_8u1u_C1R
 Purpose:    Reduces the bit resolution of an image.
 Parameters:
     pSrc          - Pointer to the source image.
     pDst          - Pointer to the destination image.
     dstBitOffset  - Offset in the first byte of the destination image row.
     roiSize       - Size of ROI in pixels.
     srcStep       - Step in bytes through the source image to jump on the next line
     dstStep       - Step in bytes through the destination image to jump on the next line
     noise         - The number specifying the amount of noise added (as a percentage of a range [0..100]). Future plans
     seed          - The seed value used by the pseudo-random number generation. Future plans
     dtype         - The type of dithering to be used. The following types are supported:
        ippDitherNone     no dithering is done;
        ippDitherStucki   Stucki's dithering algorithm.
        The next types are not supported:
        ippDitherFS       Floid-Steinberg's dithering algorithm. Future plans;
        ippDitherJJN      Jarvice-Judice-Ninke's dithering algorithm. Future plans;
        ippDitherBayer    Bayer's dithering algorithm.  Future plans.
     threshold     - Threshold level.
    pBuffer        - Pointer to the buffer for internal calculations. Size of the buffer is calculated by ippiReduceBitsGetBufferSize.
 Returns:
    ippStsNoErr           - Ok.
    ippStsNullPtrErr      - Error when any of the specified pointers is NULL.
    ippStsSizeErr         - Error when the roiSize has a zero or negative value.
    ippStsDitherTypeErr   - Error when the dithering type is not supported.
}

 function ippiReduceBits_8u1u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; noise : Int32 ; seed : Int32 ; dtype : IppiDitherType ; threshold : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippReduceBits
  Purpose:    Reduces the bit resolution of an image.
  Parameters:
     pSrc       - Pointer to the source image.
     pDst       - Pointer to the destination image.
     roiSize    - Size of ROI in pixels.
     srcStep    - Step in bytes through the source image to jump on the next line.
     dstStep    - Step in bytes through the destination image to jump on the next line.
     noise      - The number specifying the amount of noise added (as a percentage of a range [0..100]).
     levels     - The number of output levels for halftoning (dithering)[2.. MAX_LEVELS],
                  where  MAX_LEVELS is  0x01 << depth, and depth is depth of the destination image.
     dtype      - The type of dithering to be used. The following types are supported:
        ippDitherNone     no dithering is done;
        ippDitherStucki   Stucki's dithering algorithm;
        ippDitherFS       Floid-Steinberg's dithering algorithm;
        ippDitherJJN      Jarvice-Judice-Ninke's dithering algorithm;
        ippDitherBayer    Bayer's dithering algorithm.
    pBuffer     - Pointer to the buffer for internal calculations. Size of the buffer is calculated by ippiReduceBitsGetBufferSize.

 Note:
      RGB  values for the 32f data type should be in the range [0..1]
 Returns:
    ippStsNoErr           - Ok.
    ippStsNullPtrErr      - Error when any of the specified pointers is NULL.
    ippStsStepErr         - Error when srcStep or dstStep is less than or equal to zero.
    ippStsSizeErr         - Error when the roiSize has a zero or negative value.
    ippStsNoiseValErr     - Error when the noise is less then 0 or greater then 100.
    ippStsDitherLevelsErr - Error when the levels value is out of admissible range.
    ippStsDitherTypeErr   - Error when the dithering type is not supported.
}

 function ippiReduceBits_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiReduceBits_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiReduceBits_16u8u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16u8u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16u8u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16u8u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiReduceBits_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiReduceBits_16s8u_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16s8u_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16s8u_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_16s8u_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiReduceBits_32f8u_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_32f8u_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_32f8u_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_32f8u_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiReduceBits_32f16u_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_32f16u_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_32f16u_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_32f16u_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiReduceBits_32f16s_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_32f16s_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_32f16s_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiReduceBits_32f16s_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; levels : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:     ippiReduceBitsGetBufferSize
  Purpose:   Get the size (in bytes) of the buffer for ippiReduceBits functions.
  Parameters:
    ippChan     - IPP channels name of of the source images. Possible values are ippC1,  ippC3 or ippC4.
    roiSize     - Size, in pixels,  of the source images.
    noise       - The number specifying the amount of noise added (as a percentage of a range [0..100]).
    dtype       - The type of dithering to be used. The supported types are the same as for ippiReduceBits functions.
    pBufferSize - Pointer to the calculated buffer size (in bytes).
  Returns:
    ippStsNoErr          - Ok.
    ippStsNullPtrErr     - Error when any of the specified pointers is NULL.
    ippStsSizeErr        - Error when the roiSize has a zero or negative value.
    ippStsChannelErr     - Error when the ippChan has an illegal value.
    ippStsNoiseValErr    - Error when the noise is less then 0 or greater then 100.
    ippStsDitherTypeErr  - Error when the dithering type is not supported.
}

 function ippiReduceBitsGetBufferSize( ippChan : IppChannels ; roiSize : IppiSize ; noise : Int32 ; dtype : IppiDitherType ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiColorTwist

  Purpose:    Applies a color-twist matrix to an image.
              |R|   | t11 t12 t13 t14 |   |r|
              |G| = | t21 t22 t23 t24 | * |g|
              |B|   | t31 t32 t33 t34 |   |b|

               R = t11*r + t12*g + t13*b + t14
               G = t21*r + t22*g + t23*b + t24
               B = t31*r + t32*g + t33*b + t34

  Returns:
    ippStsNullPtrErr      One of the pointers is NULL
    ippStsSizeErr         roiSize has a field with zero or negative value
    ippStsStepErr         One of the step values is zero or negative
    ippStsNoErr           OK

  Parameters:
    pSrc            Pointer to the source image
    srcStep         Step through the source image
    pDst            Pointer to the  destination image
    dstStep         Step through the destination image
    pSrcDst         Pointer to the source/destination image (in-place flavors)
    srcDstStep      Step through the source/destination image (in-place flavors)
    roiSize         Size of the ROI
    twist           An array of color-twist matrix elements
}

 function ippiColorTwist32f_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi

 function ippiColorTwist32f_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_16u_P3R( pSrc : Ipp16u_3Ptr ; srcStep : Int32 ; pDst : Ipp16u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi

 function ippiColorTwist32f_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_16s_P3R( pSrc : Ipp16s_3Ptr ; srcStep : Int32 ; pDst : Ipp16s_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi

 function ippiColorTwist_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist_32f_P3R( pSrc : Ipp32f_3Ptr ; srcStep : Int32 ; pDst : Ipp32f_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi

 function ippiColorTwist32f_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_8u_IP3R( pSrcDst : Ipp8u_3Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi

 function ippiColorTwist32f_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_16u_IP3R( pSrcDst : Ipp16u_3Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi

 function ippiColorTwist32f_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist32f_16s_IP3R( pSrcDst : Ipp16s_3Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi

 function ippiColorTwist_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi
 function ippiColorTwist_32f_IP3R( pSrcDst : Ipp32f_3Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_3_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiColorTwist_32f_C4R

  Purpose:    Applies a color-twist matrix to an image.
              |R|   | t11 t12 t13 t14 |   |r|
              |G| = | t21 t22 t23 t24 | * |g|
              |B|   | t31 t32 t33 t34 |   |b|
              |W|   | t41 t42 t43 t44 |   |w|
               R = t11*r + t12*g + t13*b + t14*w
               G = t21*r + t22*g + t23*b + t24*w
               B = t31*r + t32*g + t33*b + t34*w
               W = t41*r + t42*g + t43*b + t44*w

  Returns:
    ippStsNullPtrErr      One of the pointers is NULL
    ippStsSizeErr         roiSize has a field with zero or negative value
    ippStsStepErr         One of the step values is zero or negative
    ippStsNoErr           OK

  Parameters:
    pSrc                  Pointer  to the source image
    srcStep               Step through the source image
    pDst                  Pointer to the  destination image
    dstStep               Step through the destination image
    roiSize               Size of the ROI
    twist                 An array of color-twist matrix elements
}

 function ippiColorTwist_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const twist : Ipp32f_4_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiGammaFwd,      ippiGammaInv

  Purpose:  Performs gamma-correction of an RGB image (ippiGammaFwd);
            converts a gamma-corrected RGB image back to the original (ippiGammaInv).
                  1). Gamma-correction:
                      for R,G,B < 0.018
                          R' = 4.5 * R
                          G' = 4.5 * G
                          B' = 4.5 * B
                      for R,G,B >= 0.018
                          R' = 1.099 * (R**0.45) - 0.099
                          G' = 1.099 * (G**0.45) - 0.099
                          B' = 1.099 * (B**0.45) - 0.099

                  2). Conversion to the original:
                      for R',G',B' < 0.0812
                          R = R' / 4.5
                          G = G' / 4.5
                          B = B' / 4.5
                      for R',G',B' >= 0.0812
                          R = (( R' + 0.099 ) / 1.099 )** 1 / 0.45
                          G = (( G' + 0.099 ) / 1.099 )** 1 / 0.45
                          B = (( B' + 0.099 ) / 1.099 )** 1 / 0.45

                  Note: example for range[0,1].

  Parameters:
    pSrc                  Pointer  to the source image (pixel-order data). An array
                          of pointers to separate source color planes (planar data)
    srcStep               Step through the source image
    pDst                  Pointer to the  destination image (pixel-order data). An array
                          of pointers to separate destination color planes (planar data)
    dstStep               Step through the destination image
    pSrcDst               Pointer to the source/destination image (in-place flavors)
    srcDstStep            Step through the source/destination image (in-place flavors)
    roiSize               Size of the ROI
    vMin, vMax            Minimum and maximum values of the input 32f data.
  Returns:
    ippStsNullPtrErr      One of the pointers is NULL
    ippStsSizeErr         roiSize has a field with zero or negative value
    ippStsStepErr         One of the step values is less than or equal to zero
    ippStsGammaRangeErr   vMax - vMin <= 0 (for 32f)
    ippStsNoErr           OK
}

 function ippiGammaFwd_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaFwd_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaFwd_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiGammaFwd_16u_P3R( pSrc : Ipp16u_3Ptr ; srcStep : Int32 ; pDst : Ipp16u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaFwd_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaFwd_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiGammaFwd_32f_P3R( pSrc : Ipp32f_3Ptr ; srcStep : Int32 ; pDst : Ipp32f_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiGammaFwd_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiGammaFwd_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi

 function ippiGammaInv_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaInv_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaInv_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiGammaInv_16u_P3R( pSrc : Ipp16u_3Ptr ; srcStep : Int32 ; pDst : Ipp16u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaInv_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaInv_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiGammaInv_32f_P3R( pSrc : Ipp32f_3Ptr ; srcStep : Int32 ; pDst : Ipp32f_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiGammaInv_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiGammaInv_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi

 function ippiGammaFwd_8u_IP3R( pSrcDst : Ipp8u_3Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaFwd_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaFwd_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiGammaInv_8u_IP3R( pSrcDst : Ipp8u_3Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaInv_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaInv_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiGammaFwd_16u_IP3R( pSrcDst : Ipp16u_3Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaFwd_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaFwd_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiGammaInv_16u_IP3R( pSrcDst : Ipp16u_3Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaInv_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiGammaInv_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiGammaFwd_32f_IP3R( pSrcDst : Ipp32f_3Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiGammaFwd_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiGammaFwd_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi

 function ippiGammaInv_32f_IP3R( pSrcDst : Ipp32f_3Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiGammaInv_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiGammaInv_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:     ippiToneMapLinear_32f8u_C1R ippiToneMapMean_32f8u_C1R
  Purpose:   Convert HDRI into the LDRI. In the other words they map a dst Image into the range [0..255]

 Input Arguments:
    pSrc     - pointer to the HDRI.
    srcStep  - step through the source image
  Output Arguments:
    pDst     - pointer to the LDRI.
    dstStep  - step through the source image
  Returns:
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value
  Notes:
          ippiToneMapLinear_32f_C1RI - applies Linear Scale-Factor method to src image.
          ippiToneMapMean_32f_C1RI   - applies Mean Value method to src image.
}

 function ippiToneMapLinear_32f8u_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiToneMapMean_32f8u_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:     ippiYCbCr420To411_8u_P3R  ippiYCbCr420To411_8u_P3R  ippiYCbCr1620To420_8u_P3R
  Purpose:   Converts an YCbCr420 to YCbCr411 image, 
                         YCbCr411 to YCbCr420 image, 
                         YCbCr420 to YCbCr1620 image, 
                         YCbCr1620 to YCbCr420 image.

 Input Arguments:
    pSrc     - pointer to the source image.
    srcStep  - step through the source image
    roiSize  - Size of the ROI
  Output Arguments:
    pDst     - pointer to the destination image.
    dstStep  - step through the destination image
  Returns:
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value
}

 function ippiYCbCr420To411_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr411To420_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420To1620_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr1620To420_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:        ippiCFAToRGB_8u_C1C3R
                ippiCFAToRGB_16u_C1C3R

  Purpose:      Bayer transform. Converts color filter array image to RGB image
  Returns:
    ippStsNoErr         No errors
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsBadArgErr     Wrong value of grid
    ippStsSizeErr       The srcSize.width<2 or the srcSize.height<2 or
                        the roiSize has a field with negative or zero value
  Parameters:
    pSrc                Pointers to the source image
    srcRoi              ROI in source image(top left corner and size)
    srcSize             Size of source image
    srcStep             Steps through the source image
    pDst                Pointer to the destination image
    dstStep             Step through the destination image
    grid                Type of baeyers grid
    interpolation       Reserved, must be 0
}

type
  IppiBayerGrid = 
    ( ippiBayerBGGR,
      ippiBayerRGGB,
      ippiBayerGBRG,
      ippiBayerGRBG);

 function ippiCFAToRGB_8u_C1C3R( pSrc : Ipp8uPtr ; srcRoi : IppiRect ; srcSize : IppiSize ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; grid : IppiBayerGrid ; interpolation : Int32 ): IppStatus; _ippapi
 function ippiCFAToRGB_16u_C1C3R( pSrc : Ipp16uPtr ; srcRoi : IppiRect ; srcSize : IppiSize ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; grid : IppiBayerGrid ; interpolation : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiCbYCr422ToYCbCr420_Interlace_8u_C2P3R,
              ippiYCbCr420ToCbYCr422_Interlace_8u_P3C2R
              ippiYCbCr422To420_Interlace_8u_P3R
              ippiYCbCr420To422_Interlace_8u_P3R
  Purpose:    Converts 2-channel interlaced UYVY,  YUYV C2 and P3 images
              to the P3 YUV420 image and vice versa

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize.width less than 2 or roiSize.height less than 4
    ippStsDoubleSize         roiSize.width  is not multiples of 2 or
                             roiSize.height is not multiples of 4

  Parameters:
    pSrc          Pointer(an array of pointers) to the source image
    srcStep       Step(an array of steps) through the source image
    roiSize       Size of the ROI,  should be multiple of 2(width) and 4(height)
    pDst          Pointer(an array of pointers)  to destination image.
    dstStep       Step(an array of steps) through the destination image
  Notes:
    UYVU422 to YUV420 uses following formulas, 
       Yd = Ys
       U(V)d0 = (3*U(V)s0 +     U(V)s2 + 2) / 4
       U(V)d1 = (  U(V)s1 + 3 * U(V)s3 + 2) / 4,
       where    Us0(1), Us2(3) are interleaved adjacent lines

    YUV420 to UYVU422 uses following formulas, 
       U(V)d0 = (5*U(V)s0 + 3*U(V)s2 + 4) / 8;
       U(V)d1 = (7*U(V)s1 +   U(V)s3 + 4) / 8;
       U(V)d2 = (  U(V)s0 + 7*U(V)s2 + 4) / 8;
       U(V)d3 = (3*U(V)s1 + 5*U(V)s3 + 4) / 8;


}

 function ippiCbYCr422ToYCbCr420_Interlace_8u_C2P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr422To420_Interlace_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420ToCbYCr422_Interlace_8u_P3C2R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiYCbCr420To422_Interlace_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32_3 ; pDst : Ipp8u_3Ptr ; dstStep : Int32_3 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:        ippiDemosaicAHD_8u_C1C3R
                ippiDemosaicAHD_16u_C1C3R

  Purpose:      Converts color filter array image to RGB image wih AHD algorithm.
                Reference: K. Hirakawa, T.W. Parks, "Adaptive Homogeneity-Directed Demosaicing Algorithm, "
                IEEE Trans. Image Processing,  March 2005, 
                Link: http://www.accidentalmark.com/research/papers/Hirakawa05MNdemosaicTIP.pdf

  Returns:
    ippStsNoErr         No errors
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsBadArgErr     Wrong value of grid
    ippStsSizeErr       The srcSize.width<5 or the srcSize.height<5 or
                        the roiSize has a field with negative or zero value
  Parameters:
    pSrc                Pointers to the source image
    srcRoi              ROI in source image(top left corner and size)
    srcSize             Size of source image
    srcStep             Steps through the source image
    pDst                Pointer to the destination image
    dstStep             Step through the destination image
    grid                Type of baeyers grid
    pTmp                Pointer to the temporary image of (srcRoi.width + 6, 30) size
    tmpStep             Steps through the temporary image
}

 function ippiDemosaicAHD_8u_C1C3R( pSrc : Ipp8uPtr ; srcRoi : IppiRect ; srcSize : IppiSize ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; grid : IppiBayerGrid ; pTmp : Ipp8uPtr ; tmpStep : Int32 ): IppStatus; _ippapi
 function ippiDemosaicAHD_16u_C1C3R( pSrc : Ipp16uPtr ; srcRoi : IppiRect ; srcSize : IppiSize ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; grid : IppiBayerGrid ; pTmp : Ipp16uPtr ; tmpStep : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:
    ippiRGBToYCoCg_8u_C3P3R

  Purpose:
    RGB to YCoCg color conversion

  Parameter:
    pSrc      pointer to the input RGB data
    srcStep   line offset in input data
    pDst      pointer to pointers to the output YCoCg data.
    dstStep   line offset in output data
    roiSize   ROI size

  Returns:
    IppStatus
}

 function ippiRGBToYCoCg_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:
    ippiYCoCgToRGB_8u_P3C3R

  Purpose:
    YCoCg to RGB  color conversion

  Parameter:
    pSrc      pointer to pointers to the input YCoCg data.
    srcStep   line offset in input data
    pDst      pointer to the output RGB data.
    dstStep   line offset in output data
    roiSize   ROI size

  Returns:
    IppStatus
}

 function ippiYCoCgToRGB_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi



{
              Intel(R) Integrated Performance Primitives
              Data Compression Library (ippDC)
}

{ ----------------------------------------------------------------------------

                   Functions declarations

{ ----------------------------------------------------------------------------

  Name:       ippdcGetLibVersion
  Purpose:    getting of the library version
  Returns:    the structure of information about version
              of ippDC library
  Parameters:

  Notes:      not necessary to release the returned structure
}

 function ippdcGetLibVersion: IppLibraryVersionPtr; _ippapi

{ Move To Front }

{ ----------------------------------------------------------------------------

 Name:                ippsMTFInit_8u
 Purpose:             Initializes parameters for the MTF transform

 Parameters:
    pMTFState         Pointer to the structure containing parameters for
                      the MTF transform

 Return:
    ippStsNullPtrErr  Pointer to structure is NULL
    ippStsNoErr       No errors
}

 function ippsMTFInit_8u( pMTFState : IppMTFState_8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippsMTFGetSize_8u
 Purpose:             Computes the size of necessary memory (in bytes) for
                      structure of the MTF transform

 Parameters:
    pMTFStateSize     Pointer to the computed size of structure

 Return:
    ippStsNullPtrErr  Pointer is NULL
    ippStsNoErr       No errors
}

 function ippsMTFGetSize_8u( pMTFStateSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsMTFFwd_8u
  Purpose:            Performs the forward MTF transform

  Parameters:
    pSrc              Pointer to the source vector
    pDst              Pointer to the destination vector
    len               Length of source/destination vectors
    pMTFState         Pointer to the structure containing parameters for
                      the MTF transform
  Return:
    ippStsNullPtrErr  One or several pointer(s) is NULL
    ippStsSizeErr     Length of the source vector is less or equal zero
    ippStsNoErr       No errors
}

 function ippsMTFFwd_8u( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; pMTFState : IppMTFState_8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsMTFInv_8u
  Purpose:            Performs the inverse MTF transform

  Parameters:
    pSrc              Pointer to the source vector
    pDst              Pointer to the destination vector
    len               Length of source/destination vectors
    pMTFState         Pointer to the structure containing parameters for
                      the MTF transform
  Return:
    ippStsNullPtrErr  One or several pointer(s) is NULL
    ippStsSizeErr     Length of the source vector is less or equal zero
    ippStsNoErr       No errors
}

 function ippsMTFInv_8u( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; pMTFState : IppMTFState_8uPtr ): IppStatus; _ippapi

{ Burrows - Wheeler Transform }
{ ----------------------------------------------------------------------------

 Name:                ippsBWTFwdGetSize_8u
 Purpose:             Computes the size of necessary memory (in bytes) for
                      additional buffer for the forward BWT transform

 Parameters:
    wndSize           Window size for the BWT transform
    pBWTFwdBuffSize   Pointer to the computed size of buffer

 Return:
    ippStsNullPtrErr  Pointer is NULL
    ippStsNoErr       No errors
}
{ not used }

 function ippsBWTFwdGetSize_8u( wndSize : Int32 ; pBWTFwdBuffSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsBWTFwd_8u
  Purpose:            Performs the forward BWT transform

  Parameters:
    pSrc              Pointer to the source vector
    pDst              Pointer to the destination vector
    len               Length of source/destination vectors
    index             Pointer to the index of first position for
                      the inverse BWT transform
    pBWTFwdBuff       Pointer to the additional buffer

  Return:
    ippStsNullPtrErr  One or several pointer(s) is NULL
    ippStsSizeErr     Length of source/destination vectors is less or equal zero
    ippStsNoErr       No errors
}
{ not used }

 function ippsBWTFwd_8u( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; index : Int32Ptr ; pBWTFwdBuff : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippsBWTFwdGetBufSize_SelectSort_8u
 Purpose:             Computes the size of necessary memory (in bytes) for
                      additional buffer for the forward BWT transform

 Parameters:
    wndSize           Window size for the BWT transform
    pBWTFwdBufSize    Pointer to the computed size of buffer
    sortAlgorithmHint Strategy hint for Sort algorithm selection

 Return:
    ippStsNullPtrErr  Pointer is NULL
    ippStsNoErr       No errors
}

 function ippsBWTFwdGetBufSize_SelectSort_8u( wndSize : Ipp32u ; pBWTFwdBufSize : Ipp32uPtr ; sortAlgorithmHint : IppBWTSortAlgorithmHint ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsBWTFwd_SelectSort_8u
  Purpose:            Performs the forward BWT transform

  Parameters:
    pSrc              Pointer to the source vector
    pDst              Pointer to the destination vector
    len               Length of source/destination vectors
    index             Pointer to the index of first position for
                      the inverse BWT transform
    pBWTFwdBuf        Pointer to the additional buffer
    sortAlgorithmHint Strategy hint for Sort algorithm selection

  Return:
    ippStsNullPtrErr  One or several pointer(s) is NULL
    ippStsSizeErr     Length of source/destination vectors is less or equal zero
    ippStsNoErr       No errors
}

 function ippsBWTFwd_SelectSort_8u( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Ipp32u ; index : Ipp32uPtr ; pBWTFwdBuf : Ipp8uPtr ; sortAlgorithmHint : IppBWTSortAlgorithmHint ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippsBWTInvGetSize_8u
 Purpose:             Computes the size of necessary memory (in bytes) for
                      additional buffer for the inverse BWT transform

 Parameters:
    wndSize           Window size for the BWT transform
    pBWTInvBuffSize   Pointer to the computed size of buffer

 Return:
    ippStsNullPtrErr  Pointer is NULL
    ippStsNoErr       No errors
}
{ not used }

 function ippsBWTInvGetSize_8u( wndSize : Int32 ; pBWTInvBuffSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsBWTInv_8u
  Purpose:            Performs the inverse BWT transform

  Parameters:
    pSrc              Pointer to the source vector
    pDst              Pointer to the destination vector
    len               Length of source/destination vectors
    index             Index of first position for the inverse BWT transform
    pBWTInvBuff       Pointer to the additional buffer

  Return:
    ippStsNullPtrErr  One or several pointer(s) is NULL
    ippStsSizeErr     Length of source/destination vectors is less or
                      equal zero or index greater or equal srcLen
    ippStsNoErr       No errors
}
{ not used }

 function ippsBWTInv_8u( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; index : Int32 ; pBWTInvBuff : Ipp8uPtr ): IppStatus; _ippapi

{ Ziv Lempel Storer Szymanski (LZSS) functions }

{ ----------------------------------------------------------------------------

  Name:               ippsLZSSGetSize_8u
  Purpose:            Finds out size of LZSS internal state structure in bytes

  Parameters:
    pLZSSStateSize    Pointer to the size of LZSS internal encoding state
  Return:
    ippStsNullPtrErr  Pointer to LZSSStateSize is NULL
    ippStsNoErr       No errors
}

 function ippsLZSSGetSize_8u( pLZSSStateSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsEncodeLZSSInit_8u
  Purpose:            Initializes the LZSS internal state for encoding

  Parameters:
    pLZSSState        Pointer to memory allocated for LZSS internal state
  Return:
    ippStsNullPtrErr  Pointer to internal LZSS state structure is NULL
    ippStsNoErr       No errors
}

 function ippsEncodeLZSSInit_8u( pLZSSState : IppLZSSState_8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsEncodeLZSS_8u
  Purpose:            Performs LZSS encoding

  Parameters:
    ppSrc             Double pointer to the source vector
    pSrcLen           Pointer to the length of source vector
    ppDst             Double pointer to the destination vector
    pDstLen           Pointer to the length of destination vector
    pLZSSState        Pointer to LZSS internal state for encoding
  Return:
    ippStsNullPtrErr           One or several pointer(s) is NULL
    ippStsSizeErr              Bad length arguments
    ippStsDstSizeLessExpected  Destination buffer is full
    ippStsNoErr                No errors
}

 function ippsEncodeLZSS_8u( ppSrc : Ipp8uPtrPtr ; pSrcLen : Int32Ptr ; ppDst : Ipp8uPtrPtr ; pDstLen : Int32Ptr ; pLZSSState : IppLZSSState_8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsEncodeLZSSFlush_8u
  Purpose:            Flushes the last few bits from the bit stream and alignes
                      output data on the byte boundary

  Parameters:
    ppDst             Double pointer to the destination vector
    pDstLen           Pointer to the length of destination vector
    pLZSSState        Pointer to the LZSS internal state for encoding
  Return:
    ippStsNullPtrErr           One or several pointer(s) is NULL
    ippStsSizeErr              Bad length arguments
    ippStsDstSizeLessExpected  Destination buffer is full
    ippStsNoErr                No errors
}

 function ippsEncodeLZSSFlush_8u( ppDst : Ipp8uPtrPtr ; pDstLen : Int32Ptr ; pLZSSState : IppLZSSState_8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsDecodeLZSSInit_8u
  Purpose:            Initializes the LZSS internal state for decoding

  Parameters:
    pLZSSState        Pointer to memory allocated for LZSS internal state
  Return:
    ippStsNullPtrErr  Pointer to internal LZSS state structure is NULL
    ippStsNoErr       No errors
}

 function ippsDecodeLZSSInit_8u( pLZSSState : IppLZSSState_8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsDecodeLZSS_8u
  Purpose:            Performs LZSS decoding

  Parameters:
    ppSrc             Double pointer to the source vector
    pSrcLen           Pointer to the length of source vector
    ppDst             Double pointer to the destination vector
    pDstLen           Pointer to the length of destination vector
    pLZSSState        Pointer to LZSS internal state
  Return:
    ippStsNullPtrErr           One or several pointer(s) is NULL
    ippStsSizeErr              Bad length arguments
    ippStsDstSizeLessExpected  Destination buffer is full
    ippStsNoErr                No errors
}

 function ippsDecodeLZSS_8u( ppSrc : Ipp8uPtrPtr ; pSrcLen : Int32Ptr ; ppDst : Ipp8uPtrPtr ; pDstLen : Int32Ptr ; pLZSSState : IppLZSSState_8uPtr ): IppStatus; _ippapi


{ rfc1950, 1951, 1952 - compatible functions }



{ ----------------------------------------------------------------------------

  Name:               ippsAdler32
  Purpose:            Computes the adler32(ITUT V.42) checksum for the source vector.

  Parameters:
   pSrc               Pointer to the source vector.
   srcLen             Length of the source vector.
   pAdler32           Pointer to the checksum value.
  Return:
   ippStsNoErr        Indicates no error.
   ippStsNullPtrErr   Indicates an error when the pSrc pointer is NULL.
   ippStsSizeErr      Indicates an error when the length of the source vector is less
                      than or equal to zero.
}

 function ippsAdler32_8u( pSrc : Ipp8uPtr ; srcLen : Int32 ; pAdler32 : Ipp32uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsCRC32
  Purpose:            Computes the CRC32(ITUT V.42) checksum for the source vector.

  Parameters:
   pSrc               Pointer to the source vector.
   srcLen             Length of the source vector.
   pCRC32             Pointer to the checksum value.
  Return:
   ippStsNoErr        Indicates no error.
   ippStsNullPtrErr   Indicates an error when the pSrc pointer is NULL.
   ippStsSizeErr      Indicates an error when the length of the source vector is less
                      than or equal to zero.
}

 function ippsCRC32_8u( pSrc : Ipp8uPtr ; srcLen : Int32 ; pCRC32 : Ipp32uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsCRC32C
  Purpose:            Computes the CRC32C (the polinomial 0x11EDC6F41) value
                      for the source vector.
                      Reference: "Optimization of cyclic redundancy-check
                      codes with 24 and 32 parity bits". Castagnoli, G.;
                      Brauer, S.; Herrmann, M.; Communications,
                      IEEE Transactions on Volume 41,  Issue 6, 
                      June 1993 Page(s):883 - 892.

  Parameters:
   pSrc               Pointer to the source vector
   srcLen             Length of the source vector
   pCRC32C            Pointer to the CRC32C value
  Return:
   ippStsNoErr        No errors
   ippStsNullPtrErr   One or several pointer(s) is NULL
   ippStsSizeErr      Length of the source vector is equal zero
}

 function ippsCRC32C_8u( pSrc : Ipp8uPtr ; srcLen : Ipp32u ; pCRC32C : Ipp32uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsInflateBuildHuffTable
  Purpose:            Builds literal/length and distance Huffman code table for
                      decoding a block that was compressed with usage dynamic Huffman codes
                      according to the "deflate" format (rfc1951)

  Parameters:
    pCodeLens         Pointer to the common array with literal/length and distance
                      Huffman code lengths
    nLitCodeLens      Number of literal/length Huffman code lengths
    nDistCodeLens     Number of distance Huffman code lengths
  Return:
    ippStsNullPtrErr  One or several pointer(s) is NULL
    ippStsSizeErr     nLitCodeLens is greater than 286,  or nLitCodeLens is greater than 30
                      (according to rfc1951)
    ippStsSrcDataErr  Invalid literal/length and distance set has been met
                      in the common lengths array
    ippStsNoErr       No errors
}

 function ippsInflateBuildHuffTable( pCodeLens : Ipp16uPtr ; nLitCodeLens : Word32 ; nDistCodeLens  : Word32 ; pIppInflateState : IppInflateStatePtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsInflate_8u
  Purpose:            Decodes of the "deflate" format (rfc1951)
                      according to the type of Huffman code tables

  Parameters:
    ppSrc             Double pointer to the source vector
    pSrcLen           Pointer to the length of the source vector
    pCode             Pointer to the bit buffer
    pCodeLenBits      Number of valid bits in the bit buffer
    winIdx            Index of the sliding window start position
    ppDst             Double pointer to the destination vector
    pDstLen           Pointer to the length of the destination vector
    dstIdx            Index of the current position in the destination vector
    pMode             Pointer to the current decode mode
    pIppInflateState  Pointer to the structure that contains decode parameters
  Return:
    ippStsNullPtrErr  One or several pointer(s) is NULL
    ippStsSizeErr     codeLenBits is greater than 32,  or
                      winIdx is greater than pIppInflateState->winSize, or
                      dstIdx is greater than dstLen
    ippStsSrcDataErr  Invalid literal/length and distance set has been met
                      during decoding
    ippStsNoErr       No errors
}

 function ippsInflate_8u( ppSrc : Ipp8uPtrPtr ; pSrcLen : Word32Ptr ; pCode : Ipp32uPtr ; pCodeLenBits : Word32Ptr ; winIdx  : Word32 ; ppDst : Ipp8uPtrPtr ; pDstLen  : Word32Ptr ; dstIdx : Word32 ; pMode : IppInflateModePtr ; pIppInflateState : IppInflateStatePtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsDeflateLZ77_8u
  Purpose:            Perform LZ77 encoding according to
                      the compression level

  Parameters:
    ppSrc             Double pointer to the source vector
    pSrcLen           Pointer to the length of the source vector
    pSrcIdx           Pointer to the index of the current position in
                      the source vector. This parameter is used by
                      the function for correlation current possition of
                      the source vector and indexes in the hash tables.
                      The normalization of this index and the hash tables
                      must only be done every 2GB of the source data
                      instead of 64K (the zlib approach)
    pWindow           Pointer to the sliding window,  which is used as
                      the dictionary for LZ77 encoding
    winSize           Size of the window and the hash prev table
    pHashHead         Pointer to heads of the hash chains. This table is
                      initialized with (-winSize) value for correct processing
                      of the first bytes of the source vector
    pHashPrev         Pointer to links to older strings with the same
                      hash index
    hashSize          Size of the hash head table
    pLitFreqTable     Pointer to the literals/lengths frequency table
    pDistFreqTable    Pointer to the distances frequency table
    pLitDst           Pointer to the literals/lengths destination vector
    pDistDst          Pointer to the distances destination vector
    pDstLen           Pointer to the length of the destination vectors
    comprLevel        Compression level. It is like the zlib compression level
    flush             Flush value
  Return:
    ippStsNullPtrErr  One or several pointer(s) is NULL
    ippStsNoErr       No errors
}

 function ippsDeflateLZ77_8u( ppSrc : Ipp8uPtrPtr ; pSrcLen : Ipp32uPtr ; pSrcIdx : Ipp32uPtr ; pWindow : Ipp8uPtr ; winSize : Ipp32u ; pHashHead : Ipp32sPtr ; pHashPrev : Ipp32sPtr ; hashSize : Ipp32u ; pLitFreqTable : IppDeflateFreqTable286Ptr ; pDistFreqTable : IppDeflateFreqTable30Ptr ; pLitDst : Ipp8uPtr ; pDistDst : Ipp16uPtr ; pDstLen : Ipp32uPtr ; comprLevel : Int32 ; flush : IppLZ77Flush ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:              ippsDeflateHuff_8u
  Purpose:           Performs Huffman encoding

  Parameters:
    pLitSrc          Pointer to the literals/lengths source vector
    pDistSrc         Pointer to the distances source vector
    pSrcLen          Pointer to the length of the source vectors
    pCode            Pointer to the bit buffer
    pCodeLenBits     Pointer to the number of valid bits in the bit buffer
    pLitHuffCodes    Pointer to the literals/lengths Huffman codes
    pDistHuffCodes   Pointer to the distances Huffman codes
    pDst             Pointer to the destination vector
    pDstIdx          Pointer to the index in the destination vector,  the zlib
                     uses the knowingly sufficient intermediate buffer for
                     the Huffman encoding,  so we need to know indexes of
                     the first (input parameter) and the last (output parameter)
                     symbols, which are written by the function
  Return:
    ippStsNullPtrErr One or several pointer(s) is NULL
    ippStsNoErr      No errors
}

 function ippsDeflateHuff_8u( pLitSrc : Ipp8uPtr ; pDistSrc : Ipp16uPtr ; srcLen : Ipp32u ; pCode : Ipp16uPtr ; pCodeLenBits : Ipp32uPtr ; pLitHuffCodes : IppDeflateHuffCode286Ptr ; pDistHuffCodes : IppDeflateHuffCode30Ptr; pDst : Ipp8uPtr ; pDstIdx : Ipp32uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:              ippsDeflateDictionarySet_8u
  Purpose:           Presets the user`s dictionary for LZ77 encoding

  Parameters:
    pDictSrc         Pointer to the user`s dictionary
    dictLen          Length of the user`s dictionary
    pHashHeadDst     Pointer to heads of the hash chains
    hashSize         Size of the hash head table
    pHashPrevDst     Pointer to links to older strings with the same
                     hash index
    pWindowDst       Pointer to the sliding window,  which is used as
                     the dictionary for LZ77 encoding
    winSize          Size of the window and the hash prev table in elements
    comprLevel       Compression level. It is like the zlib compression level
  Return:
    ippStsNullPtrErr One or several pointer(s) is NULL
    ippStsSizeErr    wndSize less or equal 256 or more than 32768, 
                     hashSize less or equal 256 or more than 65536
    ippStsNoErr      No errors
}

 function ippsDeflateDictionarySet_8u( pDictSrc : Ipp8uPtr ; dictLen : Ipp32u ; pHashHeadDst : Ipp32sPtr ; hashSize : Ipp32u ; pHashPrevDst : Ipp32sPtr ; pWindowDst : Ipp8uPtr ; winSize : Ipp32u ; comprLevel : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:              ippsDeflateUpdateHash_8u
  Purpose:           Updates hash tables according to the source context

  Parameters:
    pDictSrc         Pointer to the source vector
    srcIdx           Index of the current position in the source vector.
                     This parameter is used by the function
                     for correlation current possition of the source vector
                     and indexes in the hash tables.
                     The normalization of this index and the hash tables
                     must only be done every 2GB of the source data
                     instead of 64K (the zlib approach)
    srcLen           Length of the source vector
    pHashHeadDst     Pointer to heads of the hash chains
    hashSize         Size of the hash head table
    pHashPrevDst     Pointer to links to older strings with the same
                     hash index
    winSize          Size of the window and the hash prev table in elements
    comprLevel       Compression level. It is like the zlib compression level
  Return:
    ippStsNullPtrErr One or several pointer(s) is NULL
    ippStsSizeErr    wndSize less or equal 256 or more than 32768, 
                     hashSize less or equal 256 or more than 65536
    ippStsNoErr      No errors
}

 function ippsDeflateUpdateHash_8u( pSrc : Ipp8uPtr ; srcIdx : Ipp32u ; srcLen : Ipp32u ; pHashHeadDst : Ipp32sPtr ; hashSize : Ipp32u ; pHashPrevDst : Ipp32sPtr ; winSize : Ipp32u ; comprLevel : Int32 ): IppStatus; _ippapi

{ bzip2 - compatible functions }

{ ----------------------------------------------------------------------------

  Name:               ippsRLEGetSize_BZ2_8u
  Purpose:            Calculates the size of internal state for bzip2-specific RLE.
                      Specific function for bzip2 compatibility.

  Parameters:
    pRLEStateSize             Pointer to the size of internal state for bzip2-specific RLE

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsNoErr               No errors
}

 function ippsRLEGetSize_BZ2_8u( pRLEStateSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsEncodeRLEInit_BZ2_8u
  Purpose:            Initializes the elements of the bzip2-specific internal state for RLE.
                      Specific function for bzip2 compatibility.

  Parameters:
    pRLEState         Pointer to internal state structure for bzip2 specific RLE

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsNoErr               No errors
}

 function ippsEncodeRLEInit_BZ2_8u( pRLEState : IppRLEState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsEncodeRLE_BZ2_8u
  Purpose:            Performs the RLE encoding with thresholding = 4.
                      Specific function for bzip2 compatibility.

  Parameters:
    ppSrc             Double pointer to the source vector
    pSrcLen           Pointer to the length of source vector
    pDst              Pointer to the destination vector
    pDstLen           Pointer to the size of destination buffer on input, 
                      pointer to the resulting length of the destination vector
                      on output
    pRLEState         Pointer to internal state structure for bzip2 specific RLE

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsDstSizeLessExpected The size of destination vector less expected
    ippStsNoErr               No errors
}

 function ippsEncodeRLE_BZ2_8u( ppSrc : Ipp8uPtrPtr ; pSrcLen : Int32Ptr ; pDst : Ipp8uPtr ; pDstLen : Int32Ptr ; pRLEState : IppRLEState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsEncodeRLEFlush_BZ2_8u
  Purpose:            Performs flushing the rest of data after RLE encoding with thresholding = 4.
                      Specific function for bzip2 compatibility.

  Parameters:
    pDst              Pointer to the destination vector
    pDstLen           Pointer to the size of destination buffer on input, 
                      pointer to the resulting length of the destination vector
                      on output
    pRLEState         Pointer to internal state structure for bzip2 specific RLE

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsNoErr               No errors
}

 function ippsEncodeRLEFlush_BZ2_8u( pDst : Ipp8uPtr ; pDstLen : Int32Ptr ; pRLEState : IppRLEState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsDecodeRLEStateInit_BZ2_8u
  Purpose:            Initializes the elements of the bzip2-specific internal state for RLE.
                      Specific function for bzip2 compatibility.

  Parameters:
    pRLEState         Pointer to internal state structure for bzip2 specific RLE

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsNoErr               No errors
}

 function ippsDecodeRLEStateInit_BZ2_8u( pRLEState : IppRLEState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsDecodeRLEState_BZ2_8u
  Purpose:            Performs the RLE decoding with thresholding = 4.
                      Specific function for bzip2 compatibility.

  Parameters:
    ppSrc             Double pointer to the source vector
    pSrcLen           Pointer to the length of source vector
    pDst              Double pointer to the destination vector
    pDstLen           Pointer to the size of destination buffer on input, 
                      pointer to the resulting length of the destination vector
                      on output
    pRLEState         Pointer to internal state structure for bzip2 specific RLE

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsDstSizeLessExpected The size of destination vector less expected
    ippStsNoErr               No errors
}

 function ippsDecodeRLEState_BZ2_8u( ppSrc : Ipp8uPtrPtr ; pSrcLen : Ipp32uPtr ; ppDst : Ipp8uPtrPtr ; pDstLen : Ipp32uPtr ; pRLEState : IppRLEState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsDecodeRLEStateFlush_BZ2_8u
  Purpose:            Performs flushing the rest of data after RLE decoding with thresholding = 4.
                      Specific function for bzip2 compatibility.

  Parameters:
    pRLEState         Pointer to internal state structure for bzip2 specific RLE
    ppDst             Double pointer to the destination vector
    pDstLen           Pointer to the size of destination buffer on input, 
                      pointer to the resulting length of the destination vector
                      on output

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsNoErr               No errors
}

 function ippsDecodeRLEStateFlush_BZ2_8u( pRLEState : IppRLEState_BZ2Ptr ; ppDst : Ipp8uPtrPtr ; pDstLen : Ipp32uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsRLEGetInUseTable_8u
  Purpose:            Service function: gets the pointer to the inUse vector from internal state
                      of type IppRLEState_BZ2. Specific function for bzip2 compatibility.

  Parameters:
    inUse             Pointer to the inUse vector
    pRLEState         Pointer to internal state structure for bzip2 specific RLE

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsNoErr               No errors
}

 function ippsRLEGetInUseTable_8u( inUse : Ipp8u_256 ; pRLEState : IppRLEState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsEncodeZ1Z2_BZ2_8u16u
  Purpose:            Performs the Z1Z2 encoding.
                      Specific function for bzip2 compatibility.

  Parameters:
    ppSrc             Double pointer to the source vector
    pSrcLen           Pointer to the length of source vector on input, 
                      pointer to the size of remainder on output
    pDst              Pointer to the destination vector
    pDstLen           Pointer to the size of destination buffer on input, 
                      pointer to the resulting length of the destination vector
                      on output.
    freqTable[258]    Table of frequencies collected for alphabet symbols.

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsDstSizeLessExpected The size of destination vector less expected
    ippStsNoErr               No errors
}

 function ippsEncodeZ1Z2_BZ2_8u16u( ppSrc : Ipp8uPtrPtr ; pSrcLen : Int32Ptr ; pDst : Ipp16uPtr ; pDstLen : Int32Ptr ; freqTable : Int32_258 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsDecodeZ1Z2_BZ2_16u8u
  Purpose:            Performs the Z1Z2 decoding.
                      Specific function for bzip2 compatibility.

  Parameters:
    ppSrc             Double pointer to the source vector
    pSrcLen           Pointer to the length of source vector on input, 
                      pointer to the size of remainder on output
    pDst              Pointer to the destination vector
    pDstLen           Pointer to the size of destination buffer on input, 
                      pointer to the resulting length of the destination vector
                      on output.

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsDstSizeLessExpected The size of destination vector less expected
    ippStsNoErr               No errors
}

 function ippsDecodeZ1Z2_BZ2_16u8u( ppSrc : Ipp16uPtrPtr ; pSrcLen : Int32Ptr ; pDst : Ipp8uPtr ; pDstLen : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsReduceDictionary_8u_I
  Purpose:            Performs the dictionary reducing.

  Parameters:
    inUse[256]        Table of 256 values of type : Ipp8u.
    pSrcDst           Pointer to the source/destination vector
    srcDstLen         Length of source/destination vector.
    pSizeDictionary   Pointer to the size of dictionary on input and to the size
                      of reduced dictionary on output.

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsNoErr               No errors
}

 function ippsReduceDictionary_8u_I( const inUse : Ipp8u_256 ; pSrcDst : Ipp8uPtr ; srcDstLen : Int32 ; pSizeDictionary : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsExpandDictionary_8u_I
  Purpose:            Performs the dictionary expanding.

  Parameters:
    inUse[256]        Table of 256 values of type : Ipp8u.
    pSrcDst           Pointer to the source/destination vector
    srcDstLen         Length of source/destination vector.
    sizeDictionary    The size of reduced dictionary on input.

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsNoErr               No errors
}

 function ippsExpandDictionary_8u_I( const inUse : Ipp8u_256 ; pSrcDst : Ipp8uPtr ; srcDstLen : Int32 ; sizeDictionary : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsCRC32_BZ2_8u
  Purpose:            Performs the CRC32 checksum calculation according to the direct algorithm,  which is used in bzip2.

  Parameters:
    pSrc              Pointer to the source data vector
    srcLen            The length of source vector
    pCRC32            Pointer to the value of accumulated CRC32

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Length of the source vector is less or equal zero
    ippStsNoErr               No errors
}

 function ippsCRC32_BZ2_8u( pSrc : Ipp8uPtr ; srcLen : Int32 ; pCRC32 : Ipp32uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsEncodeHuffGetSize_BZ2_16u8u
  Purpose:            Calculates the size of internal state for bzip2-specific Huffman coding.
                      Specific function for bzip2 compatibility.

  Parameters:
    wndSize                          Size of the block to be processed
    pEncodeHuffStateSize             Pointer to the size of internal state for bzip2-specific Huffman coding

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsNoErr               No errors
}

 function ippsEncodeHuffGetSize_BZ2_16u8u( wndSize : Int32 ; pEncodeHuffStateSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsEncodeHuffInit_BZ2_16u8u
  Purpose:            Initializes the elements of the bzip2-specific internal state for Huffman coding.
                      Specific function for bzip2 compatibility.

  Parameters:
    sizeDictionary     The size of the dictionary
    freqTable          Table of frequencies of symbols
    pSrc               Pointer to the source vector
    srcLen             Length of the source vector
    pEncodeHuffState   Pointer to internal state structure for bzip2 specific Huffman coding

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsNoErr               No errors
}

 function ippsEncodeHuffInit_BZ2_16u8u( sizeDictionary : Int32 ; const freqTable : Int32_258 ; pSrc : Ipp16uPtr ; srcLen : Int32 ; pEncodeHuffState : IppEncodeHuffState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsPackHuffContext_BZ2_16u8u
  Purpose:            Performs the bzip2-specific encoding of Huffman context.
                      Specific function for bzip2 compatibility.

  Parameters:
    pCode             Pointer to the bit buffer
    pCodeLenBits      Number of valid bits in the bit buffer
    pDst              Pointer to the destination vector
    pDstLen           Pointer to the size of destination buffer on input, 
                      pointer to the resulting length of the destination vector
                      on output
    pEncodeHuffState  Pointer to internal state structure for bzip2 specific Huffman coding

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsDstSizeLessExpected The size of destination vector less expected
    ippStsNoErr               No errors
}

 function ippsPackHuffContext_BZ2_16u8u( pCode : Ipp32uPtr ; pCodeLenBits : Int32Ptr ; pDst : Ipp8uPtr ; pDstLen : Int32Ptr ; pEncodeHuffState : IppEncodeHuffState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsEncodeHuff_BZ2_16u8u
  Purpose:            Performs the bzip2-specific Huffman encoding.
                      Specific function for bzip2 compatibility.

  Parameters:
    pCode             Pointer to the bit buffer
    pCodeLenBits      Number of valid bits in the bit buffer
    ppSrc             Double pointer to the source vector
    pSrcLen           Pointer to the length of source vector
    pDst              Pointer to the destination vector
    pDstLen           Pointer to the size of destination buffer on input, 
                      pointer to the resulting length of the destination vector
                      on output
    pEncodeHuffState  Pointer to internal state structure for bzip2 specific Huffman coding

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsDstSizeLessExpected The size of destination vector less expected
    ippStsNoErr               No errors
}

 function ippsEncodeHuff_BZ2_16u8u( pCode : Ipp32uPtr ; pCodeLenBits : Int32Ptr ; ppSrc : Ipp16uPtrPtr ; pSrcLen : Int32Ptr ; pDst : Ipp8uPtr ; pDstLen : Int32Ptr ; pEncodeHuffState : IppEncodeHuffState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsDecodeHuffGetSize_BZ2_8u16u
  Purpose:            Calculates the size of internal state for bzip2-specific Huffman decoding.
                      Specific function for bzip2 compatibility.

  Parameters:
    wndSize                    Size of the block to be processed
    pDecodeHuffStateSize       Pointer to the size of internal state for bzip2-specific Huffman decoding

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsNoErr               No errors
}

 function ippsDecodeHuffGetSize_BZ2_8u16u( wndSize : Int32 ; pDecodeHuffStateSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsDecodeHuffInit_BZ2_8u16u
  Purpose:            Initializes the elements of the bzip2-specific internal state for Huffman decoding.
                      Specific function for bzip2 compatibility.

  Parameters:
    sizeDictionary           The size of the dictionary
    pDecodeHuffState         Pointer to internal state structure for bzip2 specific Huffman decoding

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsNoErr               No errors
}

 function ippsDecodeHuffInit_BZ2_8u16u( sizeDictionary : Int32 ; pDecodeHuffState : IppDecodeHuffState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsUnpackHuffContext_BZ2_8u16u
  Purpose:            Performs the bzip2-specific decoding of Huffman context.
                      Specific function for bzip2 compatibility.

  Parameters:
    pCode                   Pointer to the bit buffer
    pCodeLenBits            Number of valid bits in the bit buffer
    pSrc                    Pointer to the destination vector
    pSrcLen                 Pointer to the size of destination buffer on input, 
                            pointer to the resulting length of the destination vector
                            on output
    pDecodeHuffState        Pointer to internal state structure for bzip2 specific Huffman decoding.

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsDstSizeLessExpected The size of destination vector less expected
    ippStsNoErr               No errors
}

 function ippsUnpackHuffContext_BZ2_8u16u( pCode : Ipp32uPtr ; pCodeLenBits : Int32Ptr ; ppSrc : Ipp8uPtrPtr ; pSrcLen : Int32Ptr ; pDecodeHuffState : IppDecodeHuffState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsDecodeHuff_BZ2_8u16u
  Purpose:            Performs the bzip2-specific Huffman decoding.
                      Specific function for bzip2 compatibility.

  Parameters:
    pCode                   Pointer to the bit buffer
    pCodeLenBits            Number of valid bits in the bit buffer
    ppSrc                   Double pointer to the source vector
    pSrcLen                 Pointer to the length of source vector
    pDst                    Pointer to the destination vector
    pDstLen                 Pointer to the size of destination buffer on input, 
                            pointer to the resulting length of the destination vector
                            on output
    pDecodeHuffState        Pointer to internal state structure for bzip2 specific Huffman decoding.

  Return:
    ippStsNullPtrErr          One or several pointer(s) is NULL
    ippStsSizeErr             Lengths of the source/destination vector are less
                              or equal zero
    ippStsDstSizeLessExpected The size of destination vector less expected
    ippStsNoErr               No errors
}

 function ippsDecodeHuff_BZ2_8u16u( pCode : Ipp32uPtr ; pCodeLenBits : Int32Ptr ; ppSrc : Ipp8uPtrPtr ; pSrcLen : Int32Ptr ; pDst : Ipp16uPtr ; pDstLen : Int32Ptr ; pDecodeHuffState : IppDecodeHuffState_BZ2Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippsDecodeBlockGetSize_BZ2_8u
 Purpose:             Computes the size of necessary memory (in bytes) for
                      additional buffer for the bzip2-specific decoding.
                      Specific function for bzip2 compatibility.

 Parameters:
    blockSize         Block size for the bzip2-specific decoding
    pBuffSize         Pointer to the computed size of buffer

 Return:
    ippStsNullPtrErr  Pointer is NULL
    ippStsNoErr       No errors
}

 function ippsDecodeBlockGetSize_BZ2_8u( blockSize : Int32 ; pBuffSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippsDecodeBlockGetSize_BZ2_8u
  Purpose:            Performs the bzip2-specific block decoding.
                      Specific function for bzip2 compatibility.

 Parameters:
    pSrc              Pointer to the source vector
    pSrcLen           Pointer to the length of source vector
    pDst              Pointer to the destination vector
    pDstLen           Pointer to the size of destination buffer on input, 
                      pointer to the resulting length of the destination buffer
                      on output
    index             Index of first position for the inverse BWT transform
    dictSize          The size of reduced dictionary
    inUse             Table of 256 values of type : Ipp8u
    pBuff             Pointer to the additional buffer

 Return:
    ippStsNullPtrErr  One or several pointer(s) is NULL
    ippStsSizeErr     Length of source/destination vectors is less or
                      equal zero or index greater or equal srcLen
    ippStsNoErr       No errors
}

 function ippsDecodeBlock_BZ2_16u8u( pSrc : Ipp16uPtr ; srcLen : Int32 ; pDst : Ipp8uPtr ; pDstLen : Int32Ptr ; index : Int32 ; dictSize : Int32 ; const inUse : Ipp8u_256 ; pBuff : Ipp8uPtr ): IppStatus; _ippapi


{ ----------------------------------------------------------------------------
  IPP LZO Definitions
  ----------------------------------------------------------------------------

  Name:       ippsEncodeLZOGetSize
  Purpose:    returns structure size necessary for compression

  Arguments:
     method           LZO method to be used during compression
     maxInputLen      maximum length of input buffer,  which will be processed by Encode
     pSize            pointer to size variable

  Return:
      ippStsBadArgErr          illegal method
      ippStsNullPtrErr         NULL pointer detected
      ippStsNoErr              no error
}

 function ippsEncodeLZOGetSize( method : IppLZOMethod ; maxInputLen : Ipp32u ; pSize : Ipp32uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsEncodeLZO_8u
  Purpose:    compresses specified input buffer

  Arguments:
      pSrc                   input data address
      srcLen                 input data length
      pDst                   output buffer address
      pDstLen                pointer to resulting length variable,  must contain output buffer length upon start
      pLZOState              pointer to IppLZOState structure variable

  Return:
      ippStsNullPtrErr            one of the pointers is NULL
      ippStsDstSizeLessExpected   output buffer is too short for compressed data
      ippStsNoErr                 no error detected
}

 function ippsEncodeLZO_8u( pSrc : Ipp8uPtr ; srcLen : Ipp32u ; pDst : Ipp8uPtr ; pDstLen : Ipp32uPtr ; pLZOState : IppLZOState_8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsEncodeLZOInit
  Purpose:    initializes IppLZOSate_8u structure

  Arguments:
      method                  LZO compression method desired
      maxInputLen             maximum length of input buffer,  which will be processed by Encode
      pLZOState               pointer to IppLZOState structure variable

  Return:
      ippStsNullPtrErr            one of the pointers is NULL
      ippStsBadArgErr             illegal method
      ippStsNoErr                 no error detected
}

 function ippsEncodeLZOInit_8u( method : IppLZOMethod ; maxInputLen : Ipp32u ; pLZOState : IppLZOState_8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsDecodeLZO_8u
      Purpose:    decompresses specified input buffer to output buffer,  returns decompressed data length
  Name:       ippsDecodeLZOSafe_8u
      Purpose:    decompresses specified input buffer to output buffer with checking output buffer boundaries,  returns decompressed data length

  Arguments:
      pSrc                  pointer to input buffer
      srcLen                input data length
      pDst                  pointer to output buffer
      pDstLen               pointer to output data length variable. Initially contains output buffer length

  Return:
      ippStsNullPtrErr            one of the pointers is NULL
      ippStsDstSizeLessExpected   output buffer is too short for compressed data
      ippStsSrcSizeLessExpected   input buffer data is not complete,  i.e. no EOF found
      ippStsBrokenLzoStream       ippsDecodeLZOSafe_8u detected output buffer boundary violation
      ippStsNoErr                 no error detected
}

 function ippsDecodeLZO_8u( pSrc : Ipp8uPtr ; srcLen : Ipp32u ; pDst : Ipp8uPtr ; pDstLen : Ipp32uPtr ): IppStatus; _ippapi
 function ippsDecodeLZOSafe_8u( pSrc : Ipp8uPtr ; srcLen : Ipp32u ; pDst : Ipp8uPtr ; pDstLen : Ipp32uPtr ): IppStatus; _ippapi


{
              Intel(R) Integrated Performance Primitives
              Computer Vision (ippCV)
}


{ ----------------------------------------------------------------------------

                   Functions declarations

{ ----------------------------------------------------------------------------

  Name:       ippcvGetLibVersion

  Purpose:    getting of the library version

  Returns:    the structure of information about  version of ippcv library

  Parameters:

  Notes:      not necessary to release the returned structure
}

 function ippcvGetLibVersion: IppLibraryVersionPtr; _ippapi


{ ----------------------------------------------------------------------------
                        Copy with Subpixel Precision
  ----------------------------------------------------------------------------

  Name: ippiCopySubpix_8u_C1R,              ippiCopySubpix_16u_C1R,
        ippiCopySubpix_8u16u_C1R_Sfs,       ippiCopySubpix_16u32f_C1R,
        ippiCopySubpix_8u32f_C1R,           ippiCopySubpix_32f_C1R

  Purpose:   copies source image to destination image with interpolation

  Returns:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     Pointer to source image
    srcStep                  Step in source image
    pDst                     Pointer to destination image
    dstStep                  Step in destination image
    roiSize                  Source and destination image ROI size.
    dx                       x coeff of linear interpolation
    dy                       y coeff of linear interpolation
    scaleFactor              Output scale factor, >= 0

  Notes:
}

 function ippiCopySubpix_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; dx : Ipp32f ; dy : Ipp32f ): IppStatus; _ippapi
 function ippiCopySubpix_8u16u_C1R_Sfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; dx : Ipp32f ; dy : Ipp32f ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiCopySubpix_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; dx : Ipp32f ; dy : Ipp32f ): IppStatus; _ippapi
 function ippiCopySubpix_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; dx : Ipp32f ; dy : Ipp32f ): IppStatus; _ippapi
 function ippiCopySubpix_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; dx : Ipp32f ; dy : Ipp32f ): IppStatus; _ippapi
 function ippiCopySubpix_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; dx : Ipp32f ; dy : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name: ippiCopySubpixIntersect_8u_C1R,              ippiCopySubpixIntersect_16u_C1R,
        ippiCopySubpixIntersect_8u16u_C1R_Sfs,       ippiCopySubpixIntersect_16u32f_C1R,
        ippiCopySubpixIntersect_8u32f_C1R,           ippiCopySubpixIntersect_32f_C1R

  Purpose:   finds intersection of centered window in the source image and copies
             in to destination image with the border
             border pixel are taken from the source image or replicated if they are outside it

  Returns:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     Pointer to source image
    srcStep                  Step in source image
    srcRoiSize               Source image ROI size.
    pDst                     Pointer to destination image
    dstStep                  Step in destination image
    dstRoiSize               Destination image ROI size.
    point                    Center of dst window in src image (subpixel)
    pMin                     Top left corner of dst filled part
    pMax                     Bottom right corner of dst filled part
    scaleFactor              Output scale factor, >= 0

  Notes:                     For integer point.x or point.y pixels from the last row
                             or column are not copied. Branches are possible.
}

 function ippiCopySubpixIntersect_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; point : IppiPoint_32f ; pMin : IppiPointPtr ; pMax : IppiPointPtr ): IppStatus; _ippapi
 function ippiCopySubpixIntersect_8u16u_C1R_Sfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; point : IppiPoint_32f ; pMin : IppiPointPtr ; pMax : IppiPointPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiCopySubpixIntersect_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; point : IppiPoint_32f ; pMin : IppiPointPtr ; pMax : IppiPointPtr ): IppStatus; _ippapi
 function ippiCopySubpixIntersect_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; point : IppiPoint_32f ; pMin : IppiPointPtr ; pMax : IppiPointPtr ): IppStatus; _ippapi
 function ippiCopySubpixIntersect_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; point : IppiPoint_32f ; pMin : IppiPointPtr ; pMax : IppiPointPtr ): IppStatus; _ippapi
 function ippiCopySubpixIntersect_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; point : IppiPoint_32f ; pMin : IppiPointPtr ; pMax : IppiPointPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                             Line sampling                                     
  ----------------------------------------------------------------------------
  Name:    ippiSampleLine_8u_C1R, ippiSampleLine_8u_C3R,
           ippiSampleLine_16u_C1R, ippiSampleLine_16u_C3R,
           ippiSampleLine_32f_C1R, ippiSampleLine_32f_C3R,

  Purpose: Reads values of pixels on the raster
           line between two given points and write them to buffer.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsOutOfRangeErr      At least one of the points is outside the image ROI.

  Parameters:
    pSrc                     Source image
    srcStep                  Its step
    roiSize                  ROI size
    pBuffer                  Pointer to buffer where the pixels are stored.
                             It must have size >= max(abs(pt2.y - pt1.y)+1,
                                                      abs(pt2.x - pt1.x)+1)*
                                                  <size_of_pixel>.
    pt1                      Starting point of the line segment.
                             The pixel value will be stored to buffer first.
    pt2                      Ending point of the line segment.
                             The pixel value will be stored to buffer last.
}

 function ippiSampleLine_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pDst : Ipp8uPtr ; pt1 : IppiPoint ; pt2 : IppiPoint ): IppStatus; _ippapi
 function ippiSampleLine_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pDst : Ipp8uPtr ; pt1 : IppiPoint ; pt2 : IppiPoint ): IppStatus; _ippapi
 function ippiSampleLine_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pDst : Ipp16uPtr ; pt1 : IppiPoint ; pt2 : IppiPoint ): IppStatus; _ippapi
 function ippiSampleLine_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pDst : Ipp16uPtr ; pt1 : IppiPoint ; pt2 : IppiPoint ): IppStatus; _ippapi
 function ippiSampleLine_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pDst : Ipp32fPtr ; pt1 : IppiPoint ; pt2 : IppiPoint ): IppStatus; _ippapi
 function ippiSampleLine_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pDst : Ipp32fPtr ; pt1 : IppiPoint ; pt2 : IppiPoint ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                            Accumulation                                       
  ----------------------------------------------------------------------------

  Name:       ippiAdd_8u32f_C1IR,   ippiAdd_8s32f_C1IR,
              ippiAdd_16u32f_C1IR,
              ippiAdd_8u32f_C1IMR,  ippiAdd_8s32f_C1IMR,
              ippiAdd_16u32f_C1IMR, ippiAdd_32f_C1IMR

  Purpose:    Add image to accumulator.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            Step is too small to fit image.
    ippStsNotEvenStepErr     Step is not multiple of element.

  Arguments:
    pSrc                     Pointer to source image
    srcStep                  Step in the source image
    pMask                    Pointer to mask
    maskStep                 Step in the mask image
    pSrcDst                  Pointer to accumulator image
    srcDstStep               Step in the accumulator image
    roiSize                  Image size
}

 function ippiAdd_8u32f_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAdd_16u32f_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi


 function ippiAdd_8u32f_C1IMR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAdd_16u32f_C1IMR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAdd_32f_C1IMR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiAddSquare_8u32f_C1IR,   ippiAddSquare_8s32f_C1IR,
          ippiAddSquare_16u32f_C1IR,  ippiAddSquare_32f_C1IR,
          ippiAddSquare_8u32f_C1IMR,  ippiAddSquare_8s32f_C1IMR,
          ippiAddSquare_16u32f_C1IMR, ippiAddSquare_32f_C1IMR

  Purpose:    Add squared image (i.e. multiplied by itself) to accumulator.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            Step is too small to fit image.
    ippStsNotEvenStepErr     Step is not multiple of element.

  Arguments:
    pSrc                     Pointer to source image
    srcStep                  Step in the source image
    pMask                    Pointer to mask
    maskStep                 Step in the mask image
    pSrcDst                  Pointer to accumulator image
    srcDstStep               Step in the accumulator image
    roiSize                  Image size
}

 function ippiAddSquare_8u32f_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddSquare_16u32f_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddSquare_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddSquare_8u32f_C1IMR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddSquare_16u32f_C1IMR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddSquare_32f_C1IMR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name: ippiAddProduct_8u32f_C1IR,   ippiAddProduct_8s32f_C1IR,
        ippiAddProduct_16u32f_C1IR,  ippiAddProduct_32f_C1IR,
        ippiAddProduct_8u32f_C1IMR,  ippiAddProduct_8s32f_C1IMR,
        ippiAddProduct_16u32f_C1IMR, ippiAddProduct_32f_C1IMR

  Purpose:  Add product of two images to accumulator.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            Step is too small to fit image.
    ippStsNotEvenStepErr     Step is not multiple of element.

  Arguments:
    pSrc1                    Pointer to first source image
    src1Step                 Step in the first source image
    pSrc2                    Pointer to second source image
    src2Step                 Step in the second source image
    pMask                    Pointer to mask
    maskStep                 Step in the mask image
    pSrcDst                  Pointer to accumulator image
    srcDstStep               Step in the accumulator image
    roiSize                  Image size
}

 function ippiAddProduct_8u32f_C1IR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddProduct_16u32f_C1IR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddProduct_32f_C1IR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddProduct_8u32f_C1IMR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddProduct_16u32f_C1IMR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddProduct_32f_C1IMR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name: ippiAddWeighted_8u32f_C1IR,  ippiAddWeighted_8s32f_C1IR,
        ippiAddWeighted_16u32f_C1IR, ippiAddWeighted_32f_C1IR,
        ippiAddWeighted_8u32f_C1IMR, ippiAddWeighted_8s32f_C1IMR,
        ippiAddWeighted_16u32f_C1IMR,ippiAddWeighted_32f_C1IMR
        ippiAddWeighted_32f_C1R

  Purpose:  Add image,  multiplied by alpha,  to accumulator,  multiplied by (1 - alpha).

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            Step is too small to fit image.
    ippStsNotEvenStepErr     Step is not multiple of element.

  Arguments:
    pSrc1                    Pointer to first source image
    src1Step                 Step in the first source image
    pSrc2                    Pointer to second source image
    src2Step                 Step in the second source image
    pMask                    Pointer to mask
    maskStep                 Step in the mask image
    pSrcDst                  Pointer to accumulator image
    srcDstStep               Step in the accumulator image
    pDst                     Pointer to destination image
    dstStep                  Step in the destination image
    roiSize                  Image size
    alpha                    Weight of source image
}

 function ippiAddWeighted_8u32f_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alpha : Ipp32f ): IppStatus; _ippapi
 function ippiAddWeighted_16u32f_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alpha : Ipp32f ): IppStatus; _ippapi
 function ippiAddWeighted_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alpha : Ipp32f ): IppStatus; _ippapi
 function ippiAddWeighted_8u32f_C1IMR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alpha : Ipp32f ): IppStatus; _ippapi
 function ippiAddWeighted_16u32f_C1IMR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alpha : Ipp32f ): IppStatus; _ippapi
 function ippiAddWeighted_32f_C1IMR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alpha : Ipp32f ): IppStatus; _ippapi
 function ippiAddWeighted_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; alpha : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                         Absolute difference                                   
  ----------------------------------------------------------------------------
  Name:    ippiAbsDiff_8u_C1R, ippiAbsDiff_8u_C3R, ippiAbsDiff_16u_C1R, ippiAbsDiff_32f_C1R,

  Purpose: Calculate absolute difference between corresponding pixels of the two images
           or between image pixels and scalar.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc1                    Source image
    src1Step                 Its step
    pSrc2                    Second source image
    src2Step                 Its step
    pDst                     Destination image
    dstStep                  Its step
    roiSize                  ROI size
}

 function ippiAbsDiff_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbsDiff_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbsDiff_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbsDiff_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiAbsDiffC_8u_C1R, ippiAbsDiffC_16u_C1R, ippiAbsDiffC_32f_C1R,

  Purpose: Calculate absolute difference between image pixels and scalar.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     Source image
    srcStep                  Its step
    pDst                     Destination image: dst(x,y) = abs(src(x,y) - value)
    dstStep                  Its step
    roiSize                      ROI size
    value                    Scalar value to compare with. For 8u function
                             If scalar is not within [0,255], it is clipped
                             ( value = value < 0 ? 0 : value > 255 ? value 255)
}

 function ippiAbsDiffC_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; value : Int32 ): IppStatus; _ippapi
 function ippiAbsDiffC_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; value : Int32 ): IppStatus; _ippapi
 function ippiAbsDiffC_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; value : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                        Morphological Operations                               
  ----------------------------------------------------------------------------

  Name:   ippiMorphologyBorderGetSize_16u_C1R,     ippiMorphologyBorderGetSize_16s_C1R,
          ippiMorphologyBorderGetSize_1u_C1R,      ippiMorphologyBorderGetSize_8u_C1R,
          ippiMorphologyBorderGetSize_8u_C3R,      ippiMorphologyBorderGetSize_8u_C4R,
          ippiMorphologyBorderGetSize_32f_C1R,     ippiMorphologyBorderGetSize_32f_C3R
          ippiMorphologyBorderGetSize_32f_C4R


  Purpose:  Gets the size of the internal state or specification structure for morphological operations.

  Return:
    ippStsNoErr              Ok.
    ippStsNullPtrErr         One of the pointers is NULL.
    ippStsSizeErr            Width of the image,  or width or height of the structuring
                             element is less than, or equal to zero.

  Parameters:
    roiWidth                 Width of the image ROI in pixels.
    pMask                    Pointer to the structuring element (mask).
    maskSize                 Size of the structuring element.
    pSize                    Pointer to the state structure length.
    pSpecSize                Pointer to the specification structure size.
    pBufferSize              Pointer to the buffer size value for the morphological initialization function.
}

 function ippiMorphologyBorderGetSize_8u_C1R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphologyBorderGetSize_8u_C3R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphologyBorderGetSize_8u_C4R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphologyBorderGetSize_32f_C1R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphologyBorderGetSize_32f_C3R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphologyBorderGetSize_32f_C4R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphologyBorderGetSize_16u_C1R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphologyBorderGetSize_16s_C1R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphologyBorderGetSize_1u_C1R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiMorphologyBorderInit_16u_C1R,        ippiMorphologyBorderInit_16s_C1R
          ippiMorphologyBorderInit_1u_C1R,         ippiMorphologyBorderInit_8u_C1R
          ippiMorphologyBorderInit_8u_C3R,         ippiMorphologyBorderInit_8u_C4R
          ippiMorphologyBorderInit_32f_C1R,        ippiMorphologyBorderInit_32f_C3R,
          ippiMorphologyBorderInit_32f_C4R,

  Purpose:  Initialize the internal state or specification structure for morphological operation.

  Return:
    ippStsNoErr              Ok.
    ippStsNullPtrErr         One of the pointers is NULL.
    ippStsSizeErr            Width of the image or width or height of the structuring
                             element is less than,  or equal to zero.
    ippStsAnchorErr          Anchor point is outside the structuring element.

  Parameters:
    roiWidth                 Width of the image ROI in pixels.
    pMask                    Pointer to the structuring element (mask).
    maskSize                 Size of the structuring element.
    anchor                   Anchor of the structuring element.
    pState                   Pointer to the morphology state structure.
    pMorphSpec               Pointer to the morphology specification structure.
    pBuffer                  Pointer to the external work buffer.
}

 function ippiMorphologyBorderInit_16u_C1R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphologyBorderInit_16s_C1R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphologyBorderInit_1u_C1R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphologyBorderInit_8u_C1R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphologyBorderInit_8u_C3R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphologyBorderInit_8u_C4R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphologyBorderInit_32f_C1R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphologyBorderInit_32f_C3R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphologyBorderInit_32f_C4R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiDilateBorder_8u_C1R,    ippiDilateBorder_8u_C3R,
          ippiDilateBorder_8u_C4R,    ippiDilateBorder_32f_C1R,
          ippiDilateBorder_32f_C3R,   ippiDilateBorder_32f_C4R

          ippiErodeBorder_8u_C1R,     ippiErodeBorder_8u_C3R,
          ippiErodeBorder_8u_C4R,     ippiErodeBorder_32f_C1R,
          ippiErodeBorder_32f_C3R,    ippiErodeBorder_32f_C4R,

          ippiDilateBorder_16u_C1R,            ippiDilateBorder_16s_C1R,
          ippiDilateBorder_1u_C1R

  Purpose:    Perform erosion/dilation of the image arbitrary shape structuring element.

  Return:
    ippStsNoErr              Ok.
    ippStsNullPtrErr         One of the pointers is NULL.
    ippStsSizeErr            The ROI width or height is less than 1, 
                             or ROI width is bigger than ROI width in the state structure.
    ippStsStepErr            Step is too small to fit the image.
    ippStsNotEvenStepErr     Step is not multiple of the element.
    ippStsBadArgErr          Incorrect border type.


  Parameters:
    pSrc                     Pointer to the source image.
    srcStep                  Step in the source image.
    pDst                     Pointer to the destination image.
    dstStep                  Step in the destination image.
    roiSize                  ROI size.
    borderType               Type of border (ippBorderRepl now).
    borderValue              Value for the constant border.
    pState                   Pointer to the morphology state structure.
    pMorphSpec               Pointer to the morphology specification structure.
    pBuffer                  Pointer to the external work buffer.
}

 function ippiDilateBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDilateBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_3 ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDilateBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_4 ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDilateBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDilateBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_3 ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDilateBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_4 ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDilateBorder_1u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcBitOffset : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDilateBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16u ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDilateBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiErodeBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiErodeBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_3 ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiErodeBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_4 ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiErodeBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiErodeBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_3 ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiErodeBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_4 ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiErodeBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16u ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiErodeBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiErodeBorder_1u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcBitOffset : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorphSpec : IppiMorphStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
               Advanced Morphological Operations                               
  ---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------

  Name:   ippiMorphAdvGetSize_8u_C1R,            ippiMorphAdvGetSize_32f_C1R,
          ippiMorphAdvGetSize_8u_C3R,            ippiMorphAdvGetSize_32f_C3R,
          ippiMorphAdvGetSize_8u_C4R,            ippiMorphAdvGetSize_32f_C4R,
          ippiMorphAdvGetSize_16u_C1R,           ippiMorphAdvGetSize_16s_C1R,
          ippiMorphAdvGetSize_1u_C1R

  Purpose:  Gets the size of the internal state or specification structure for advanced morphological operations.

  Return:
    ippStsNoErr              Ok.
    ippStsNullPtrErr         One of the pointers is NULL.
    ippStsSizeErr            Width of the image,  or width or height of the structuring.
                             element is less than,  or equal to zero.

  Parameters:
    roiSize                  Maximum size of the image ROI,  in pixels.
    pMask                    Pointer to the structuring element (mask).
    maskSize                 Size of the structuring element.
    pSize                    Pointer to the state structure length.
    pSpecSize                Pointer to the specification structure size.
    pBufferSize              Pointer to the buffer size value for the morphology initialization function.
}

 function ippiMorphAdvGetSize_16u_C1R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphAdvGetSize_16s_C1R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphAdvGetSize_1u_C1R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphAdvGetSize_8u_C1R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphAdvGetSize_8u_C3R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphAdvGetSize_8u_C4R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphAdvGetSize_32f_C1R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphAdvGetSize_32f_C3R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiMorphAdvGetSize_32f_C4R( roiSize : IppiSize ; maskSize : IppiSize ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiMorphAdvInit_8u_C1R,               ippiMorphAdvInit_32f_C1R,
          ippiMorphAdvInit_8u_C3R,               ippiMorphAdvInit_32f_C3R,
          ippiMorphAdvInit_8u_C4R,               ippiMorphAdvInit_32f_C4R,
          ippiMorphAdvInit_16u_C1R,              ippiMorphAdvInit_16s_C1R,
          ippiMorphAdvInit_1u_C1R

  Purpose:  Initialize the internal state or specification structure for advanced morphological operations.

  Return:
    ippStsNoErr              Ok.
    ippStsNullPtrErr         One of the pointers is NULL.
    ippStsSizeErr            Width of the image or width or height of the structuring
                             element is less than,  or equal to zero.
    ippStsAnchorErr          Anchor point is outside the structuring element.

  Parameters:
    pState                   Pointer to the morphological state structure (Init).
    roiSize                  Maximum size of the image ROI, in pixels.
    pMask                    Pointer to the structuring element (mask).
    maskSize                 Size of the structuring element.
    anchor                   Anchor of the structuring element.
    pMorphSpec               Pointer to the advanced morphology specification structure.
    pBuffer                  Pointer to the external work buffer.
}

 function ippiMorphAdvInit_8u_C1R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphAdvInit_8u_C3R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphAdvInit_8u_C4R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphAdvInit_16u_C1R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphAdvInit_16s_C1R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphAdvInit_1u_C1R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphAdvInit_32f_C1R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphAdvInit_32f_C3R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphAdvInit_32f_C4R( roiSize : IppiSize ; pMask : Ipp8uPtr ; maskSize : IppiSize ; pMorphSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiMorphCloseBorder_8u_C1R,             ippiMorphCloseBorder_8u_C3R,
          ippiMorphCloseBorder_8u_C4R,             ippiMorphCloseBorder_32f_C1R,
          ippiMorphCloseBorder_32f_C3R,            ippiMorphCloseBorder_32f_C4R

          ippiMorphOpenBorder_8u_C1R,              ippiMorphOpenBorder_8u_C3R,
          ippiMorphOpenBorder_8u_C4R,              ippiMorphOpenBorder_32f_C1R,
          ippiMorphOpenBorder_32f_C3R,             ippiMorphOpenBorder_32f_C4R,

          ippiMorphCloseBorder_16u_C1R,            ippiMorphOpenBorder_16u_C1R,
          ippiMorphCloseBorder_16s_C1R,            ippiMorphOpenBorder_16s_C1R,
          ippiMorphCloseBorder_1u_C1R,             ippiMorphOpenBorder_1u_C1R,

          ippiMorphTophatBorder_8u_C1R,            ippiMorphTophatBorder_8u_C3R,
          ippiMorphTophatBorder_8u_C4R,            ippiMorphTophatBorder_32f_C1R,
          ippiMorphTophatBorder_32f_C3R,           ippiMorphTophatBorder_32f_C4R,

          ippiMorphBlackhatBorder_8u_C1R,          ippiMorphBlackhatBorder_8u_C3R,
          ippiMorphBlackhatBorder_8u_C4R,          ippiMorphBlackhatBorder_32f_C1R,
          ippiMorphBlackhatBorder_32f_C3R,         ippiMorphBlackhatBorder_32f_C4R,

          ippiMorphGradientBorder_8u_C1R,     ippiMorphGradientBorder_8u_C3R,
          ippiMorphGradientBorder_8u_C4R,     ippiMorphGradientBorder_32f_C1R,
          ippiMorphGradientBorder_32f_C3R,    ippiMorphGradientBorder_32f_C4R,

  Purpose:    Perform advanced morphologcal operations on the image arbitrary shape structuring element.

  Return:
    ippStsNoErr              Ok.
    ippStsNullPtrErr         One of the pointers is NULL.
    ippStsSizeErr            The ROI width or height is less than 1, 
                             or ROI width is bigger than ROI width in the state structure.
    ippStsStepErr            Step is too small to fit the image.
    ippStsNotEvenStepErr     Step is not multiple of the element.
    ippStsBadArgErr          Incorrect border type.

  Parameters:
    pSrc                     Pointer to the source image.
    srcStep                  Step in the source image.
    pDst                     Pointer to the destination image.
    dstStep                  Step in the destination image.
    roiSize                  ROI size.
    borderType               Type of border (ippBorderRepl now).
    borderValue              Value for the constant border.
    pState                   Pointer to the morphology operation state structure.
    pMorphSpec               Pointer to the morphology specification structure.
    pBuffer                  Pointer to the external work buffer.
}

 function ippiMorphOpenBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphOpenBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphOpenBorder_1u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcBitOffset : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphOpenBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphOpenBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_3 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphOpenBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_4 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiMorphCloseBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphCloseBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_3 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphCloseBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_4 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiMorphCloseBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphCloseBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphCloseBorder_1u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcBitOffset : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphOpenBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphOpenBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_3 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphOpenBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_4 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphCloseBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphCloseBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_3 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphCloseBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_4 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiMorphTophatBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphTophatBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphTophatBorder_1u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcBitOffset : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphTophatBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphTophatBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_3 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphTophatBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_4 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphTophatBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphTophatBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_3 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphTophatBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_4 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiMorphBlackhatBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphBlackhatBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphBlackhatBorder_1u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcBitOffset : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphBlackhatBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphBlackhatBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_3 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphBlackhatBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_4 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphBlackhatBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphBlackhatBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_3 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphBlackhatBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_4 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiMorphGradientBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphGradientBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphGradientBorder_1u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcBitOffset : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphGradientBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphGradientBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_3 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphGradientBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u_4 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphGradientBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphGradientBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_3 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMorphGradientBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f_4 ; pMorthSpec : IppiMorphAdvStatePtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiMorphGrayGetSize_8u_C1R,            ippiMorphGrayGetSize_32f_C1R

  Purpose:  Gets size of internal state of gray-kernel morphological operation.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of image or width or height of structuring
                             element is less or equal zero.

  Arguments:
    roiSize                  Maximal image ROI in pixels
    pMask                    Pointer to structuring element
    maskSize                 Size of structuring element
    pSize                    Pointer to state length
}

 function ippiMorphGrayGetSize_8u_C1R( roiSize : IppiSize ; pMask : Ipp32sPtr ; maskSize : IppiSize ; var pSize : Int32 ): IppStatus; _ippapi
 function ippiMorphGrayGetSize_32f_C1R( roiSize : IppiSize ; pMask : Ipp32fPtr ; maskSize : IppiSize ; var pSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:   ippiMorphGrayInit_8u_C1R,               ippiMorphGrayInit_32f_C1R

  Purpose:  Initialize internal state of gray-scale morphological operation.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of image or width or height of structuring
                             element is less or equal zero.
    ippStsAnchorErr          Anchor point is outside the structuring element

  Arguments:
    roiSize                  Maximal image roiSize in pixels
    pMask                    Pointer to structuring element (mask)
    maskSize                 Size of structuring element
    anchor                   Anchor of the structuring element
    pState                   Pointer to morphological state (Init)
}

 function ippiMorphGrayInit_8u_C1R( pState : IppiMorphGrayState_8uPtr ; roiSize : IppiSize ; pMask : Ipp32sPtr ; maskSize : IppiSize ; anchor : IppiPoint ): IppStatus; _ippapi
 function ippiMorphGrayInit_32f_C1R( pState : IppiMorphGrayState_32fPtr ; roiSize : IppiSize ; pMask : Ipp32fPtr ; maskSize : IppiSize ; anchor : IppiPoint ): IppStatus; _ippapi


{ ----------------------------------------------------------------------------
  Name:   ippiGrayDilateBorder_8u_C1R,    ippiGrayDilateBorder_32f_C1R,
          ippiGrayErodeBorder_8u_C1R,     ippiGrayErodeBorder_32f_C1R

  Purpose:    Perform erosion/dilation of image with gray-scale structuring element.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The ROI width or height is less than 1
                             or ROI width is bigger than ROI width in state
    ippStsStepErr            Step is too small to fit image.
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsBadArgErr          Bad border type

  Arguments:
    pSrc                     The pointer to source image
    srcStep                  The step in source image
    pDst                     The pointer to destination image
    dstStep                  The step in destination image
    roiSize                  ROI size
    border                   Type of border (ippBorderRepl now)
    pState                   Pointer to morphological operation state
}

 function ippiGrayErodeBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; border : IppiBorderType ; pState : IppiMorphGrayState_8uPtr ): IppStatus; _ippapi
 function ippiGrayErodeBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; border : IppiBorderType ; pState : IppiMorphGrayState_32fPtr ): IppStatus; _ippapi

 function ippiGrayDilateBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; border : IppiBorderType ; pState : IppiMorphGrayState_8uPtr ): IppStatus; _ippapi
 function ippiGrayDilateBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; border : IppiBorderType ; pState : IppiMorphGrayState_32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name: ippiMorphReconstructGetBufferSize

  Purpose:   returns buffer size for morphological reconstruction

  Returns:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    roiSize                  The maximal ROI size.
    dataType                 The type of data
    numChannels              The number of channels
    p(Buf)Size               The pointer to the buffer size.

  Notes:
}

 function ippiMorphReconstructGetBufferSize( roiSize : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name: ippiMorphReconstructDilate_8u_C1IR,              ippiMorphReconstructErode_8u_C1IR
        ippiMorphReconstructDilate_16u_C1IR,             ippiMorphReconstructErode_16u_C1IR,
        ippiMorphReconstructDilate_32f_C1IR,             ippiMorphReconstructErode_32f_C1IR
        ippiMorphReconstructDilate_64f_C1IR,             ippiMorphReconstructErode_64f_C1IR

  Purpose:   performs morphological reconstruction of pSrcDst under/above pSrc

  Returns:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     The pointer to source above/under image
    srcStep                  The step in source image
    pSrcDst                  The pointer to image to reconstruct
    srcDstStep               The step in destination image
    roiSize                  The source and destination image ROI size.
    norm                     The norm type for dilation
                                  ippiNormInf = Linf norm (8-connectivity)
                                  ippiNormL1  = L1 norm   (4-connectivity)
    pBuffer                  The pointer to working buffer

  Notes:
}

 function ippiMorphReconstructDilate_8u_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuf : Ipp8uPtr ; norm : IppiNorm ): IppStatus; _ippapi
 function ippiMorphReconstructErode_8u_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuf : Ipp8uPtr ; norm : IppiNorm ): IppStatus; _ippapi
 function ippiMorphReconstructDilate_16u_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuf : Ipp8uPtr ; norm : IppiNorm ): IppStatus; _ippapi
 function ippiMorphReconstructErode_16u_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuf : Ipp8uPtr ; norm : IppiNorm ): IppStatus; _ippapi
 function ippiMorphReconstructDilate_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuf : Ipp32fPtr ; norm : IppiNorm ): IppStatus; _ippapi
 function ippiMorphReconstructErode_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuf : Ipp32fPtr ; norm : IppiNorm ): IppStatus; _ippapi
 function ippiMorphReconstructDilate_64f_C1IR( pSrc : Ipp64fPtr ; srcStep : Int32 ; pSrcDst : Ipp64fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuf : Ipp8uPtr ; norm : IppiNorm ): IppStatus; _ippapi
 function ippiMorphReconstructErode_64f_C1IR( pSrc : Ipp64fPtr ; srcStep : Int32 ; pSrcDst : Ipp64fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuf : Ipp8uPtr ; norm : IppiNorm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                           Min/Max Filters                                     
  ---------------------------------------------------------------------------- }



{ ----------------------------------------------------------------------------
                           Separable Filters                                   
  ---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------

  Name:  ippiFilterRowBorderPipelineGetBufferSize_8u16s_C1R,   ippiFilterRowBorderPipelineGetBufferSize_8u16s_C3R
         ippiFilterRowBorderPipelineGetBufferSize_16s_C1R,     ippiFilterRowBorderPipelineGetBufferSize_16s_C3R
         ippiFilterRowBorderPipelineGetBufferSize_16u_C1R,     ippiFilterRowBorderPipelineGetBufferSize_16u_C3R
         ippiFilterRowBorderPipelineGetBufferSize_Low_16s_C1R, ippiFilterRowBorderPipelineGetBufferSize_Low_16s_C3R
         ippiFilterRowBorderPipelineGetBufferSize_32f_C1R,     ippiFilterRowBorderPipelineGetBufferSize_32f_C3R

  Purpose:    Get size of external buffer.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of the image or kernel size are less or equal zero

  Parameters:
    roiSize                  The image ROI size
    kernelSize               The size of the kernel
    pBufferSize              The pointer to the buffer size
}

 function ippiFilterRowBorderPipelineGetBufferSize_8u16s_C1R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterRowBorderPipelineGetBufferSize_8u16s_C3R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterRowBorderPipelineGetBufferSize_16s_C1R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterRowBorderPipelineGetBufferSize_16s_C3R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterRowBorderPipelineGetBufferSize_16u_C1R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterRowBorderPipelineGetBufferSize_16u_C3R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterRowBorderPipelineGetBufferSize_Low_16s_C1R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterRowBorderPipelineGetBufferSize_Low_16s_C3R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterRowBorderPipelineGetBufferSize_32f_C1R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterRowBorderPipelineGetBufferSize_32f_C3R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiFilterRowBorderPipeline_8u16s_C1R,  ippiFilterRowBorderPipeline_8u16s_C3R
             ippiFilterRowBorderPipeline_16s_C1R,    ippiFilterRowBorderPipeline_16s_C3R
             ippiFilterRowBorderPipeline_16u_C1R,    ippiFilterRowBorderPipeline_16u_C3R
             ippiFilterRowBorderPipeline_Low_16s_C1R, ippiFilterRowBorderPipeline_Low_16s_C3R
             ippiFilterRowBorderPipeline_32f_C1R,    ippiFilterRowBorderPipeline_32f_C3R

  Purpose:   Convolves source image rows with the row kernel

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsAnchorErr          The anchor outside the kernel
    ippStsBadArgErr          Wrong border type or zero divisor

  Parameters:
    pSrc                     The pointer to the source image
    srcStep                  The step in the source image
    ppDst                    The double pointer to the destination image
    roiSize                  The image ROI size
    pKernel                  The pointer to the kernel
    kernelSize               The size of the kernel
    xAnchor                  The anchor value , (0<=xAnchor<kernelSize)
    borderType               The type of the border
    borderValue              The value for the constant border
    divisor                  The value to divide output pixels by , (for integer functions)
    pBuffer                  The pointer to the working buffer
    Notes:                   The output is the doulble pointer to support the circle buffer
}

 function ippiFilterRowBorderPipeline_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; ppDst : Ipp16sPtrPtr ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; xAnchor : Int32 ; borderType : IppiBorderType ; borderValue : Ipp8u ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRowBorderPipeline_8u16s_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; ppDst : Ipp16sPtrPtr ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; xAnchor : Int32 ; borderType : IppiBorderType ; borderValue : Ipp8u_3 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRowBorderPipeline_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; ppDst : Ipp16sPtrPtr ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; xAnchor : Int32 ; borderType : IppiBorderType ; borderValue : Ipp16s ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRowBorderPipeline_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; ppDst : Ipp16sPtrPtr ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; xAnchor : Int32 ; borderType : IppiBorderType ; borderValue : Ipp16s_3 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRowBorderPipeline_Low_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; ppDst : Ipp16sPtrPtr ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; xAnchor : Int32 ; borderType : IppiBorderType ; borderValue : Ipp16s ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRowBorderPipeline_Low_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; ppDst : Ipp16sPtrPtr ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; xAnchor : Int32 ; borderType : IppiBorderType ; borderValue : Ipp16s_3 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRowBorderPipeline_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; ppDst : Ipp16uPtrPtr ; roiSize : IppiSize ; pKernel : Ipp16uPtr ; kernelSize : Int32 ; xAnchor : Int32 ; borderType : IppiBorderType ; borderValue : Ipp16u ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRowBorderPipeline_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; ppDst : Ipp16uPtrPtr ; roiSize : IppiSize ; pKernel : Ipp16uPtr ; kernelSize : Int32 ; xAnchor : Int32 ; borderType : IppiBorderType ; borderValue : Ipp16u_3 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRowBorderPipeline_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; ppDst : Ipp32fPtrPtr ; roiSize : IppiSize ; pKernel : Ipp32fPtr ; kernelSize : Int32 ; xAnchor : Int32 ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRowBorderPipeline_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; ppDst : Ipp32fPtrPtr ; roiSize : IppiSize ; pKernel : Ipp32fPtr ; kernelSize : Int32 ; xAnchor : Int32 ; borderType : IppiBorderType ; borderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiFilterColumnPipelineGetBufferSize_16s_C1R,       ippiFilterColumnPipelineGetBufferSize_16s_C3R
             ippiFilterColumnPipelineGetBufferSize_16u_C1R,       ippiFilterColumnPipelineGetBufferSize_16u_C3R
             ippiFilterColumnPipelineGetBufferSize_Low_16s_C1R,   ippiFilterColumnPipelineGetBufferSize_Low_16s_C3R
             ippiFilterColumnPipelineGetBufferSize_16s8u_C1R,     ippiFilterColumnPipelineGetBufferSize_16s8u_C3R
             ippiFilterColumnPipelineGetBufferSize_16s8s_C1R,     ippiFilterColumnPipelineGetBufferSize_16s8s_C3R
             ippiFilterColumnPipelineGetBufferSize_32f_C1R,       ippiFilterColumnPipelineGetBufferSize_32f_C3R

  Purpose:    Get size of external buffer.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of the image or kernel size are less or equal zero

  Parameters:
    roiSize                  The image ROI size
    kernelSize               The size of the kernel
    pBufferSize              The pointer to the buffer size
}


 function ippiFilterColumnPipelineGetBufferSize_16s_C1R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterColumnPipelineGetBufferSize_16s_C3R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterColumnPipelineGetBufferSize_Low_16s_C1R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterColumnPipelineGetBufferSize_Low_16s_C3R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterColumnPipelineGetBufferSize_16u_C1R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterColumnPipelineGetBufferSize_16u_C3R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterColumnPipelineGetBufferSize_16s8u_C1R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterColumnPipelineGetBufferSize_16s8u_C3R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterColumnPipelineGetBufferSize_16s8s_C1R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterColumnPipelineGetBufferSize_16s8s_C3R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterColumnPipelineGetBufferSize_32f_C1R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterColumnPipelineGetBufferSize_32f_C3R( roiSize : IppiSize ; kernelSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:      ippiFilterColumnPipeline_16s_C1R,     ippiFilterColumnPipeline_16s_C3R
             ippiFilterColumnPipeline_16u_C1R,     ippiFilterColumnPipeline_16u_C3R
             ippiFilterColumnPipeline_Low_16s_C1R, ippiFilterColumnPipeline_Low_16s_C3R
             ippiFilterColumnPipeline_16s8u_C1R,   ippiFilterColumnPipeline_16s8u_C3R
             ippiFilterColumnPipeline_16s8s_C1R,   ippiFilterColumnPipeline_16s8s_C3R
             ippiFilterColumnPipeline_32f_C1R,     ippiFilterColumnPipeline_32f_C3R
  Purpose:   Convolves source image rows with the row kernel

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsBadArgErr          Zero divisor

  Parameters:
    ppSrc                    The double pointer to the source image
    pDst                     The pointer to the destination image
    dstStep                  The step in the destination image
    roiSize                  The image ROI size
    pKernel                  The pointer to the kernel
    kernelSize               The size of the kernel
    divisor                  The value to divide output pixels by , (for integer functions)
    pBuffer                  The pointer to the working buffer
    Notes:                   The input is the doulble pointer to support the circle buffer
}

 function ippiFilterColumnPipeline_16s_C1R( ppSrc : Ipp16sPtrPtr ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterColumnPipeline_16s_C3R( ppSrc : Ipp16sPtrPtr ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterColumnPipeline_Low_16s_C1R( ppSrc : Ipp16sPtrPtr ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterColumnPipeline_Low_16s_C3R( ppSrc : Ipp16sPtrPtr ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterColumnPipeline_16u_C1R( ppSrc : Ipp16uPtrPtr ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp16uPtr ; kernelSize : Int32 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterColumnPipeline_16u_C3R( ppSrc : Ipp16uPtrPtr ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp16uPtr ; kernelSize : Int32 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterColumnPipeline_16s8u_C1R( ppSrc : Ipp16sPtrPtr ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterColumnPipeline_16s8u_C3R( ppSrc : Ipp16sPtrPtr ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterColumnPipeline_16s8s_C1R( ppSrc : Ipp16sPtrPtr ; pDst : Ipp8sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterColumnPipeline_16s8s_C3R( ppSrc : Ipp16sPtrPtr ; pDst : Ipp8sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp16sPtr ; kernelSize : Int32 ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterColumnPipeline_32f_C1R( ppSrc : Ipp32fPtrPtr ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp32fPtr ; kernelSize : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterColumnPipeline_32f_C3R( ppSrc : Ipp32fPtrPtr ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pKernel : Ipp32fPtr ; kernelSize : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                           Fixed Filters                                       
  ---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------

  Name:   ippiFilterSobelCrossGetBufferSize_8u16s_C1R,  ippiFilterLaplacianGetBufferSize_8u16s_C1R,
          ippiFilterLowpassGetBufferSize_8u_C1R,        ippiFilterSobelCrossGetBufferSize_32f_C1R,
          ippiFilterLaplacianGetBufferSize_32f_C1R,     ippiFilterLowpassGetBufferSize_32f_C1R


  Purpose:    Perform convolution operation with fixed kernels 3x3 and 5x5

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of the image is less or equal zero
    ippStsMaskSizeErr        Wrong mask size

  Parameters:
    roiSize                  The image ROI size
    mask                     The mask size
    pBufferSize              The pointer to the buffer size
}

 function ippiFilterSobelCrossGetBufferSize_8u16s_C1R( roiSize : IppiSize ; mask : IppiMaskSize ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterLaplacianGetBufferSize_8u16s_C1R( roiSize : IppiSize ; mask : IppiMaskSize ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterLowpassGetBufferSize_8u_C1R( roiSize : IppiSize ; mask : IppiMaskSize ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterSobelCrossGetBufferSize_32f_C1R( roiSize : IppiSize ; mask : IppiMaskSize ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterLaplacianGetBufferSize_32f_C1R( roiSize : IppiSize ; mask : IppiMaskSize ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterLowpassGetBufferSize_32f_C1R( roiSize : IppiSize ; mask : IppiMaskSize ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:   ippiFilterSobelCrossBorder_8u16s_C1R,  ippiFilterLaplacianBorder_8u16s_C1R
          ippiFilterLowpassBorder_8u_C1R,        ippiFilterSobelCrossBorder_32f_C1R
          ippiFilterLowpassBorder_32f_C1R,       ippiFilterLaplacianBorder_32f_C1R

  Purpose:    Perform convolution operation with fixed kernels 3x3 and 5x5

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsMaskSizeErr        Wrong mask size
    ippStsBadArgErr          Wrong border type or zero divisor

  Parameters:
    pSrc                     The pointer to the source image
    srcStep                  The step in the source image
    pDst                     The pointer to the destination image
    dstStep                  The step in the destination image
    roiSize                  The image ROI size
    mask                     The mask size
    borderType               The type of the border
    borderValue              The value for the constant border
    pBuffer                  The pointer to the working buffer
    divisor                  The value to divide output pixels by , (for integer functions)
}

 function ippiFilterSobelCrossBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplacianBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLowpassBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobelCrossBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLowpassBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplacianBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiGenSobelKernel_16s,       ippiGenSobelKernel_32f

  Purpose:    Generate kernel for Sobel differential operator

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The size of kernel is less or equal zero
    ippStsBadArgErr          derivative order is less than 0

  Parameters:
    pDst                     The pointer to the destination kernel
    kernelSize               The kernel size, odd
    dx                       The order of derivative (0<=dx<kernelSize)
    sign                     Reverse signs in sign < 0
}

 function ippiGenSobelKernel_16s( pDst : Ipp16sPtr ; kernelSize : Int32 ; dx : Int32 ; sign : Int32 ): IppStatus; _ippapi
 function ippiGenSobelKernel_32f( pDst : Ipp32fPtr ; kernelSize : Int32 ; dx : Int32 ; sign : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                           Image Integrals                                    
  ---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------

  Name: ippiIntegral, ippiTiltedIntegral
        ippiSqrIntegral, ippiTiltedSqrIntegral

  Purpose:   calculates pixel sum on subimage

  Returns:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     The pointer to source image
    srcStep                  The step in source image
    pDst                     The pointer to destination integral image
    dstStep                  The step in destination image
    pSq                      The pointer to destination square integral image
    sqStep                   The step in destination image
    roiSize                  The source and destination image ROI size.
    val                      The value to add to pDst image pixels.
    valSqr                   The value to add to pSq image pixels.
}

 function ippiIntegral_8u32s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; srcRoiSize : IppiSize ; val : Ipp32s ): IppStatus; _ippapi
 function ippiIntegral_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; srcRoiSize : IppiSize ; val : Ipp32f ): IppStatus; _ippapi
 function ippiIntegral_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; srcRoiSize : IppiSize ): IppStatus; _ippapi

 function ippiTiltedIntegral_8u32s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; val : Ipp32s ): IppStatus; _ippapi
 function ippiTiltedIntegral_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; val : Ipp32f ): IppStatus; _ippapi

 function ippiSqrIntegral_8u32s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; pSqr : Ipp32sPtr ; sqrStep : Int32 ; roi : IppiSize ; val : Ipp32s ; valSqr : Ipp32s ): IppStatus; _ippapi
 function ippiSqrIntegral_8u32s64f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; pSqr : Ipp64fPtr ; sqrStep : Int32 ; roiSize : IppiSize ; val : Ipp32s ; valSqr : Ipp64f ): IppStatus; _ippapi
 function ippiSqrIntegral_8u32f64f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pSqr : Ipp64fPtr ; sqrStep : Int32 ; roiSize : IppiSize ; val : Ipp32f ; valSqr : Ipp64f ): IppStatus; _ippapi

 function ippiTiltedSqrIntegral_8u32s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; pSqr : Ipp32sPtr ; sqrStep : Int32 ; roi : IppiSize ; val : Ipp32s ; valSqr : Ipp32s ): IppStatus; _ippapi
 function ippiTiltedSqrIntegral_8u32s64f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; pSqr : Ipp64fPtr ; sqrStep : Int32 ; roiSize : IppiSize ; val : Ipp32s ; valSqr : Ipp64f ): IppStatus; _ippapi
 function ippiTiltedSqrIntegral_8u32f64f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pSqr : Ipp64fPtr ; sqrStep : Int32 ; roiSize : IppiSize ; val : Ipp32f ; valSqr : Ipp64f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                         Image Mean and Variance                               
  ---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------
  Name: ippiMean_8u_C1MR,   ippiMean_16u_C1MR,  ippiMean_32f_C1MR,
        ippiMean_8u_C3CMR,  ippiMean_16u_C3CMR, ippiMean_32f_C3CMR

  Purpose:  Find mean value for selected region

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsCOIErr             COI index is illegal (coi<1 || coi>3)

  Parameters:
    pSrc                     Pointer to image
    srcStep                  Image step
    pMask                    Pointer to mask image
    maskStep                 Step in the mask image
    roiSize                  Size of image ROI
    coi                      Index of color channel (1..3) (if color image)
    pMean                    Returned mean value

  Notes:
}

 function ippiMean_8u_C1MR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pMean : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_8u_C3CMR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMean : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_16u_C1MR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pMean : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_16u_C3CMR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMean : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_32f_C1MR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pMean : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_32f_C3CMR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMean : Ipp64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name: ippiMean_StdDev_8u_C1R,   ippiMean_StdDev_32f_C1R,
        ippiMean_StdDev_16u_C1R,  ippiMean_StdDev_32f_C3CR,
        ippiMean_StdDev_8u_C3CR,  ippiMean_StdDev_16u_C3CR,

  Purpose:  Find mean and standard deviation values for selected region

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsCOIErr             COI index is illegal (coi<1 || coi>3)

  Parameters:
    pSrc                     Pointer to image
    srcStep                  Image step
    roiSize                  Size of image ROI
    coi                      Index of color channel (1..3) (if color image)
    pMean                    Returned mean value
    pStdDev                  Returned standard deviation

  Notes:
}

 function ippiMean_StdDev_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; var pMean : Ipp64f ; var pStdDev : Ipp64f ): IppStatus; _ippapi
 function ippiMean_StdDev_8u_C3CR( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; var pMean : Ipp64f ; var pStdDev : Ipp64f ): IppStatus; _ippapi
 function ippiMean_StdDev_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; var pMean : Ipp64f ; var pStdDev : Ipp64f ): IppStatus; _ippapi
 function ippiMean_StdDev_16u_C3CR( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; var pMean : Ipp64f ; var pStdDev : Ipp64f ): IppStatus; _ippapi
 function ippiMean_StdDev_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; var pMean : Ipp64f ; var pStdDev : Ipp64f ): IppStatus; _ippapi
 function ippiMean_StdDev_32f_C3CR( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; var pMean : Ipp64f ; var pStdDev : Ipp64f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name: ippiMean_StdDev_8u_C1MR,   ippiMean_StdDev_8u_C3CMR,
        ippiMean_StdDev_16u_C1MR,  ippiMean_StdDev_16u_C3CMR,
        ippiMean_StdDev_32f_C1MR,  ippiMean_StdDev_32f_C3CMR,

  Purpose:  Find mean and standard deviation values for selected region

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     Pointer to image
    srcStep                  Image step
    pMask                    Pointer to mask image
    maskStep                 Step in the mask image
    roiSize                  Size of image ROI
    coi                      Index of color channel (1..3) (if color image)
    pMean                    Returned mean value
    pStdDev                  Returned standard deviation

  Notes:
}

 function ippiMean_StdDev_8u_C1MR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pMean : Ipp64fPtr ; pStdDev : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_StdDev_8u_C3CMR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMean : Ipp64fPtr ; pStdDev : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_StdDev_16u_C1MR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pMean : Ipp64fPtr ; pStdDev : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_StdDev_16u_C3CMR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMean : Ipp64fPtr ; pStdDev : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_StdDev_32f_C1MR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pMean : Ipp64fPtr ; pStdDev : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_StdDev_32f_C3CMR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMean : Ipp64fPtr ; pStdDev : Ipp64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                           Variance on Window                                  
  ---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------
  Name: ippiRectStdDev, ippiTiltedRectStdDev

  Purpose:   Calculates standard deviation on rectangular window

  Returns:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     The pointer to source image of integrals
    srcStep                  The step in source image
    pSqr                     The pointer to destination square integral image
    sqrStep                  The step in destination image
    pDst                     The pointer to destination image
    dstStep                  The step in destination image
    roiSize                  The destination image ROI size.
    rect                     The rectangular window for standard deviation calculation.
    scaleFactor              Output scale factor

  Notes:
}

 function ippiRectStdDev_32s_C1RSfs( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSqr : Ipp32sPtr ; sqrStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roi : IppiSize ; rect : IppiRect ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiRectStdDev_32s32f_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSqr : Ipp64fPtr ; sqrStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; rect : IppiRect ): IppStatus; _ippapi
 function ippiRectStdDev_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSqr : Ipp64fPtr ; sqrStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; rect : IppiRect ): IppStatus; _ippapi

 function ippiTiltedRectStdDev_32s32f_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSqr : Ipp64fPtr ; sqrStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; rect : IppiRect ): IppStatus; _ippapi
 function ippiTiltedRectStdDev_32s_C1RSfs( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSqr : Ipp32sPtr ; sqrStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roi : IppiSize ; rect : IppiRect ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiTiltedRectStdDev_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSqr : Ipp64fPtr ; sqrStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; rect : IppiRect ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                           Image Minimum and Maximum                           
  ---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------
  Name: ippiMinMaxIndx_8u_C1R,   ippiMinMaxIndx_8u_C3CR,
        ippiMinMaxIndx_16u_C1R,  ippiMinMaxIndx_16u_C3CR,
        ippiMinMaxIndx_32f_C1R,  ippiMinMaxIndx_32f_C3CR,

  Purpose:  Finds minimum and maximum values in the image and their coordinates

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     Pointer to image
    srcStep                  Image step
    roiSize                  Size of image ROI
    coi                      Index of color channel (1..3) (if color image)
    pMinVal                  Pointer to minimum value
    pMaxVal                  Pointer to maximum value
    pMinIndex                Minimum`s coordinates
    pMaxIndex                Maximum`s coordinates

  Notes:
    Any of output parameters is optional
}

 function ippiMinMaxIndx_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi
 function ippiMinMaxIndx_8u_C3CR( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi
 function ippiMinMaxIndx_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi
 function ippiMinMaxIndx_16u_C3CR( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi
 function ippiMinMaxIndx_32f_C1R( pSrc : Ipp32fPtr ; step : Int32 ; roiSize : IppiSize ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi
 function ippiMinMaxIndx_32f_C3CR( pSrc : Ipp32fPtr ; step : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name: ippiMinMaxIndx_8u_C1MR,   ippiMinMaxIndx_8u_C3CMR,
        ippiMinMaxIndx_16u_C1MR,  ippiMinMaxIndx_16u_C3CMR,
        ippiMinMaxIndx_32f_C1MR,  ippiMinMaxIndx_32f_C3CMR,

  Purpose:  Finds minimum and maximum values in the image and their coordinates

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     Pointer to image
    srcStep                  Image step
    pMask                    Pointer to mask image
    maskStep                 Step in the mask image
    roiSize                  Size of image ROI
    coi                      Index of color channel (1..3) (if color image)
    pMinVal                  Pointer to minimum value
    pMaxVal                  Pointer to maximum value
    pMinIndex                Minimum`s coordinates
    pMaxIndex                Maximum`s coordinates

  Notes:
    Any of output parameters is optional
}

 function ippiMinMaxIndx_8u_C1MR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi
 function ippiMinMaxIndx_8u_C3CMR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi
 function ippiMinMaxIndx_16u_C1MR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi
 function ippiMinMaxIndx_16u_C3CMR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi
 function ippiMinMaxIndx_32f_C1MR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi
 function ippiMinMaxIndx_32f_C3CMR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pMinVal : Ipp32fPtr ; pMaxVal : Ipp32fPtr ; pMinIndex : IppiPointPtr ; pMaxIndex : IppiPointPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                             Image Norms                                       
  ---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------
  Names: ippiNorm_Inf_8u_C1MR,       ippiNorm_Inf_32f_C1MR,
         ippiNorm_Inf_16u_C1MR,      ippiNorm_Inf_8u_C3CMR,
         ippiNorm_Inf_16u_C3CMR,     ippiNorm_Inf_32f_C3CMR,
         ippiNormDiff_Inf_8u_C1MR,   ippiNormDiff_Inf_8u_C3CMR,
         ippiNormDiff_Inf_16u_C1MR,  ippiNormDiff_Inf_32f_C1MR,
         ippiNormDiff_Inf_16u_C3CMR, ippiNormDiff_Inf_32f_C3CMR,
         ippiNormRel_Inf_8u_C1MR,    ippiNormRel_Inf_8u_C3CMR,
         ippiNormRel_Inf_16u_C1MR,   ippiNormRel_Inf_32f_C1MR,
         ippiNormRel_Inf_16u_C3CMR,  ippiNormRel_Inf_32f_C3CMR,

         ippiNorm_L1_8u_C1MR,        ippiNorm_L1_8u_C3CMR,
         ippiNorm_L1_16u_C1MR,       ippiNorm_L1_32f_C1MR,
         ippiNorm_L1_16u_C3CMR,      ippiNorm_L1_32f_C3CMR,
         ippiNormDiff_L1_8u_C1MR,    ippiNormDiff_L1_8u_C3CMR,
         ippiNormDiff_L1_16u_C1MR,   ippiNormDiff_L1_32f_C1MR,
         ippiNormDiff_L1_16u_C3CMR,  ippiNormDiff_L1_32f_C3CMR,
         ippiNormRel_L1_8u_C1MR,     ippiNormRel_L1_8u_C3CMR,
         ippiNormRel_L1_16u_C1MR,    ippiNormRel_L1_32f_C1MR,
         ippiNormRel_L1_16u_C3CMR,   ippiNormRel_L1_32f_C3CMR,

         ippiNorm_L2_8u_C1MR,        ippiNorm_L2_8u_C3CMR,
         ippiNorm_L2_16u_C1MR,       ippiNorm_L2_32f_C1MR,
         ippiNorm_L2_16u_C3CMR,      ippiNorm_L2_32f_C3CMR,
         ippiNormDiff_L2_8u_C1MR,    ippiNormDiff_L2_8u_C3CMR,
         ippiNormDiff_L2_16u_C1MR,   ippiNormDiff_L2_32f_C1MR,
         ippiNormDiff_L2_16u_C3CMR,  ippiNormDiff_L2_32f_C3CMR,
         ippiNormRel_L2_8u_C1MR,     ippiNormRel_L2_8u_C3CMR,
         ippiNormRel_L2_16u_C1MR,    ippiNormRel_L2_32f_C1MR,
         ippiNormRel_L2_16u_C3CMR,   ippiNormRel_L2_32f_C3CMR

  Purpose: Calculates ordinary, differential or relative norms of one or two images
           in an arbitrary image region.

  Returns:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc, pSrc1              Pointers to source and mask images
    pSrc2, pMask
    srcStep, src1Step        Their steps
    src2Step, maskStep
    roiSize                  Their size or ROI size
    coi                      COI index (1..3) (if 3-channel images)
    pNorm                    The pointer to calculated norm

  Notes:
}

{  8uC1 flavor }

 function ippiNorm_Inf_8u_C1MR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_Inf_16u_C1MR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_Inf_32f_C1MR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_Inf_8u_C3CMR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_Inf_16u_C3CMR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_Inf_32f_C3CMR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippiNormDiff_Inf_8u_C1MR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_Inf_16u_C1MR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_Inf_32f_C1MR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_Inf_8u_C3CMR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_Inf_16u_C3CMR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_Inf_32f_C3CMR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippiNormRel_Inf_8u_C1MR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_Inf_16u_C1MR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_Inf_32f_C1MR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_Inf_8u_C3CMR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_Inf_16u_C3CMR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_Inf_32f_C3CMR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippiNorm_L1_8u_C1MR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L1_16u_C1MR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L1_32f_C1MR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L1_8u_C3CMR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L1_16u_C3CMR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L1_32f_C3CMR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippiNormDiff_L1_8u_C1MR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L1_16u_C1MR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L1_32f_C1MR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L1_8u_C3CMR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L1_16u_C3CMR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L1_32f_C3CMR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippiNormRel_L1_8u_C1MR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L1_16u_C1MR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L1_32f_C1MR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L1_8u_C3CMR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L1_16u_C3CMR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L1_32f_C3CMR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippiNorm_L2_8u_C1MR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L2_16u_C1MR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L2_32f_C1MR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L2_8u_C3CMR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L2_16u_C3CMR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L2_32f_C3CMR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippiNormDiff_L2_8u_C1MR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L2_16u_C1MR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L2_32f_C1MR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L2_8u_C3CMR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L2_16u_C3CMR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L2_32f_C3CMR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippiNormRel_L2_8u_C1MR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L2_16u_C1MR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L2_32f_C1MR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L2_8u_C3CMR( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L2_16u_C3CMR( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L2_32f_C3CMR( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; coi : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                           Edge/Corner detection                               
  ---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------
  Name:    ippiCannyGetSize

  Purpose: Calculates size of temporary buffer,  required to run Canny function.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         Pointer bufferSize is NULL
    ippStsSizeErr            roiSize has a field with zero or negative value

  Parameters:
    roiSize                  Size of image ROI in pixel
    bufferSize               Pointer to the variable that returns the size of the temporary buffer
}

 function ippiCannyGetSize( roiSize : IppiSize ; bufferSize : Int32Ptr ): IppStatus; _ippapi


{ ----------------------------------------------------------------------------
  Name:    ippiCanny_16s8u_C1IR,     ippiCanny_32f8u_C1IR

  Purpose: Creates binary image of source's image edges, 
                using derivatives of the first order.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsBadArgErr          Bad thresholds

  Parameters:
    pSrcDx                   Pointers to the source image ( first derivatives  with respect to X )
    srcDxStep                Step in bytes through the source image pSrcDx
    pSrcDy                   Pointers to the source image ( first derivatives  with respect to Y )
    srcDyStep                Step in bytes through the source image pSrcDy

    roiSize                  Size of the source images ROI in pixels
    lowThresh                Low threshold for edges detection
    highThresh               Upper threshold for edges detection
    pBuffer                  Pointer to the pre-allocated temporary buffer,  which size can be
                             calculated using ippiCannyGetSize function
}

 function ippiCanny_16s8u_C1R( pSrcDx : Ipp16sPtr ; srcDxStep : Int32 ; pSrcDy : Ipp16sPtr ; srcDyStep : Int32 ; pDstEdges : Ipp8uPtr ; dstEdgeStep : Int32 ; roiSize : IppiSize ; lowThresh : Ipp32f ; highThresh : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiCanny_32f8u_C1R( pSrcDx : Ipp32fPtr ; srcDxStep : Int32 ; pSrcDy : Ipp32fPtr ; srcDyStep : Int32 ; pDstEdges : Ipp8uPtr ; dstEdgeStep : Int32 ; roiSize : IppiSize ; lowThresh : Ipp32f ; highThresh : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiEigenValsVecsGetBufferSize_8u32f_C1R, ippiEigenValsVecsGetBufferSize_32f_C1R

  Purpose: Calculates size of temporary buffer,  required to run one of EigenValsVecs***
           functions.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width is less or equal zero or bad window size

  Parameters:
    roiSize                  roiSize size in pixels
    apertureSize             Linear size of derivative filter aperture
    avgWindow                Linear size of averaging window
    bufferSize               Output parameter. Calculated buffer size.
}

 function ippiEigenValsVecsGetBufferSize_8u32f_C1R( roiSize : IppiSize ; apertureSize : Int32 ; avgWindow : Int32 ; bufferSize : Int32Ptr ): IppStatus; _ippapi
 function ippiEigenValsVecsGetBufferSize_32f_C1R( roiSize : IppiSize ; apertureSize : Int32 ; avgWindow : Int32 ; bufferSize : Int32Ptr ): IppStatus; _ippapi


{ ----------------------------------------------------------------------------
  Name:    ippiEigenValsVecs_8u32f_C1R, ippiEigenValsVecs_32f_C1R

  Purpose: Calculate both eigen values and eigen vectors of 2x2 autocorrelation
           gradient matrix for every pixel. Can be used for sophisticated
           edge and corner detection

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
                             or bad window size
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     Source image
    srcStep                  Its step in bytes
    pEigenVV                 Image, which is 6 times wider that source image, 
                             filled with 6-tuples:
                             (eig_val1, eig_val2, eig_vec1_x, eig_vec1_y,
                             eig_vec2_x, eig_vec2_y)
    eigStep                  Output image step in bytes
    roiSize                  ROI size in pixels
    kernType                 Kernel type (Scharr 3x3 or Sobel 3x3,  5x5)
    apertureSize             Linear size of derivative filter aperture
    avgWindow                Linear size of averaging window
    pBuffer                  Preallocated temporary buffer,  which size can be calculated
                             using ippiEigenValsVecsGetSize function
}

 function ippiEigenValsVecs_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pEigenVV : Ipp32fPtr ; eigStep : Int32 ; roiSize : IppiSize ; kernType : IppiKernelType ; apertureSize : Int32 ; avgWindow : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiEigenValsVecs_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pEigenVV : Ipp32fPtr ; eigStep : Int32 ; roiSize : IppiSize ; kernType : IppiKernelType ; apertureSize : Int32 ; avgWindow : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiEigenValsVecsBorder_8u32f_C1R, ippiEigenValsVecsBorder_32f_C1R

  Purpose: Calculate both eigen values and eigen vectors of 2x2 autocorrelation
           gradient matrix for every pixel. Can be used for sophisticated
           edge and corner detection

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
                             or bad window size
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     Source image
    srcStep                  Its step in bytes
    pEigenVV                 Image, which is 6 times wider that source image, 
                             filled with 6-tuples:
                             (eig_val1, eig_val2, eig_vec1_x, eig_vec1_y,
                             eig_vec2_x, eig_vec2_y)
    eigStep                  Output image step in bytes
    roiSize                  ROI size in pixels
    kernType                 Kernel type (Scharr 3x3 or Sobel 3x3,  5x5)
    apertureSize             Linear size of derivative filter aperture
    avgWindow                Linear size of averaging window
    border                   Type of the border
    borderValue              Constant value to assign to pixels of the constant border. 
                             if border type equals ippBorderConstant
    pBuffer                  Preallocated temporary buffer,  which size can be calculated
                             using ippiEigenValsVecsGetSize function
}

 function ippiEigenValsVecsBorder_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pEigenVV : Ipp32fPtr ; eigStep : Int32 ; roiSize : IppiSize ; kernType : IppiKernelType ; apertureSize : Int32 ; avgWindow : Int32 ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiEigenValsVecsBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pEigenVV : Ipp32fPtr ; eigStep : Int32 ; roiSize : IppiSize ; kernType : IppiKernelType ; apertureSize : Int32 ; avgWindow : Int32 ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiMinEigenValGetBufferSize_8u32f_C1R, ippiMinEigenValGetBufferSize_32f_C1R

  Purpose: Calculates size of temporary buffer,  required to run one of MinEigenVal***
           functions.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width is less or equal zero or bad window size

  Parameters:
    roiSize                  roiSize size in pixels
    apertureSize             Linear size of derivative filter aperture
    avgWindow                Linear size of averaging window
    bufferSize               Output parameter. Calculated buffer size.
}

 function ippiMinEigenValGetBufferSize_8u32f_C1R( roiSize : IppiSize ; apertureSize : Int32 ; avgWindow : Int32 ; bufferSize : Int32Ptr ): IppStatus; _ippapi
 function ippiMinEigenValGetBufferSize_32f_C1R( roiSize : IppiSize ; apertureSize : Int32 ; avgWindow : Int32 ; bufferSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiMinEigenVal_8u32f_C1R, ippiMinEigenVal_32f_C1R

  Purpose: Calculate minimal eigen value of 2x2 autocorrelation gradient matrix
           for every pixel. Pixels with relatively large minimal eigen values
           are strong corners on the picture.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
                             or bad window size
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     Source image
    srcStep                  Its step in bytes
    pMinEigenVal             Image, filled with minimal eigen values for every pixel
    minValStep               Its step in bytes
    roiSize                  ROI size in pixels
    kernType                 Kernel type (Scharr 3x3 or Sobel 3x3,  5x5)
    apertureSize             Linear size of derivative filter aperture
    avgWindow                Linear size of averaging window
    pBuffer                  Preallocated temporary buffer,  which size can be calculated
                             using ippiMinEigenValGetSize function
}

 function ippiMinEigenVal_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMinEigenVal : Ipp32fPtr ; minValStep : Int32 ; roiSize : IppiSize ; kernType : IppiKernelType ; apertureSize : Int32 ; avgWindow : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMinEigenVal_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMinEigenVal : Ipp32fPtr ; minValStep : Int32 ; roiSize : IppiSize ; kernType : IppiKernelType ; apertureSize : Int32 ; avgWindow : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
    Name:    ippiMinEigenValBorder_8u32f_C1R
             ippiMinEigenValBorder_32f_C1R

  Purpose: Calculate minimal eigen value of 2x2 autocorrelation gradient matrix
           for every pixel. Pixels with relatively large minimal eigen values
           are strong corners on the picture.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
                             or bad window size
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     Source image
    srcStep                  Its step in bytes
    pMinEigenVal             Image, filled with minimal eigen values for every pixel
    minValStep               Its step in bytes
    roiSize                  ROI size in pixels
    kernType                 Kernel type (Scharr 3x3 or Sobel 3x3,  5x5)
    apertureSize             Linear size of derivative filter aperture
    avgWindow                Linear size of averaging window
    border                   Type of the border
    borderValue              Constant value to assign to pixels of the constant border. if border type equals ippBorderConstant
    pBuffer                  Preallocated temporary buffer,  which size can be calculated
                             using ippiMinEigenValGetSize function
}

 function ippiMinEigenValBorder_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pEigenVV : Ipp32fPtr ; eigStep : Int32 ; roiSize : IppiSize ; kernType : IppiKernelType ; apertureSize : Int32 ; avgWndSize : Int32 ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMinEigenValBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pEigenVV : Ipp32fPtr ; eigStep : Int32 ; roiSize : IppiSize ; kernType : IppiKernelType ; apertureSize : Int32 ; avgWndSize : Int32 ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                           Distance Transform                                  
  ----------------------------------------------------------------------------

  Name:  ippiTrueDistanceTransformGetBufferSize_8u32f_C1R

  Purpose:    Get size of external buffer.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            Indicates an error condition if roiSize has a field with zero
                             or negative value.

  Parameters:
    roiSize                  The image ROI size
    pBufferSize              The pointer to the buffer size
}

 function ippiTrueDistanceTransformGetBufferSize_8u32f_C1R( roiSize : IppiSize ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiDistanceTransform_3x3_8u32f_C1R, ippiDistanceTransform_5x5_8u32f_C1R,
           ippiDistanceTransform_3x3_8u16u_C1R, ippiDistanceTransform_5x5_8u16u_C1R,
           ippiDistanceTransform_3x3_8u_C1R,    ippiDistanceTransform_5x5_8u_C1R,
           ippiDistanceTransform_3x3_8u_C1IR,   ippiDistanceTransform_5x5_8u_C1IR,
           ippiTrueDistanceTransform_8u32f_C1R

  Purpose: For every non-zero pixel in the source image,  the functions calculate
           distance between that pixel and nearest zero pixel.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsCoeffErr           Zero mask coefficient

  Parameters:
    pSrc                     Source image
    pSrcDst                  Pointer to the input and output image
    srcStep                  Its step
    pDst                     Output image with distances
    dstStep                  Its step
    roiSize                  ROI size
    pMetrics                 Array that determines metrics used.
    scaleFactor              Scale factor
    pBuffer                  The pointer to the working buffer
}

 function ippiDistanceTransform_3x3_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMetrics : Ipp32fPtr ): IppStatus; _ippapi
 function ippiDistanceTransform_5x5_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMetrics : Ipp32fPtr ): IppStatus; _ippapi
 function ippiDistanceTransform_3x3_8u16u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMetrics : Ipp32sPtr ): IppStatus; _ippapi
 function ippiDistanceTransform_5x5_8u16u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMetrics : Ipp32sPtr ): IppStatus; _ippapi
 function ippiDistanceTransform_3x3_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMetrics : Ipp32sPtr ): IppStatus; _ippapi
 function ippiDistanceTransform_5x5_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMetrics : Ipp32sPtr ): IppStatus; _ippapi
 function ippiDistanceTransform_3x3_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pMetrics : Ipp32sPtr ): IppStatus; _ippapi
 function ippiDistanceTransform_5x5_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pMetrics : Ipp32sPtr ): IppStatus; _ippapi
 function ippiTrueDistanceTransform_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiGetDistanceTransformMask_32f,    ippiGetDistanceTransformMask_32s
           ippiGetDistanceTransformMask (deprecated name of ippiGetDistanceTransformMask_32f)

  Purpose: Calculates optimal mask for given type of metrics and given mask size

  Return:
    ippStsOk                 Succeed
    ippStsNullPtrErr         One of pointers is NULL
    ippStsBadArgErr          Bad kernel size or norm or maskType

  Parameters:
    kerSize                  Kernel size (3,5)
    norm                     Norm type (L1,L2,Inf)
    maskType                 Type of distance:
                                30 - 3x3 aperture for infinify norm, 
                                31 - 3x3 aperture for L1 norm, 
                                32 - 3x3 aperture for L2 norm, 
                                50 - 5x5 aperture for infinify norm, 
                                51 - 5x5 aperture for L1 norm, 
                                52 - 5x5 aperture for L2 norm
    pMetrics                 Pointer to resultant metrics
}

 function ippiGetDistanceTransformMask_32f( kerSize : Int32 ; norm : IppiNorm ; pMetrics : Ipp32fPtr ): IppStatus; _ippapi
 function ippiGetDistanceTransformMask_32s( kerSize : Int32 ; norm : IppiNorm ; pMetrics : Ipp32sPtr ): IppStatus; _ippapi
 function ippiGetDistanceTransformMask( maskType : Int32 ; pMetrics : Ipp32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiFastMarchingGetBufferSize_8u32f_C1R

  Purpose:    Get size of external buffer.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of the image or kernel size are less or equal zero

  Parameters:
    roiSize                  The image ROI size
    pBufferSize              The pointer to the buffer size
}

 function ippiFastMarchingGetBufferSize_8u32f_C1R( roiSize : IppiSize ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiFastMarching_8u32f_C1R

  Purpose:    Calculate distance transform by fast marching method

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of the image or kernel size are less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.

  Parameters:
    pSrc                     Source image
    srcStep                  Its step
    pDst                     Output image with distances
    dstStep                  Its step
    roiSize                  The image ROI size
    radius                   The radius of external neighborhood
    pBuffer                  Pointer to working buffer

  Note: dst = min((src1+src1+sqrt(2-(src1-src2)**2))/2,min(src1,src2)+1)
        for four neighbour pairs
}

 function ippiFastMarching_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; radius : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi


{ ----------------------------------------------------------------------------
                              Flood Fill                                       
  ----------------------------------------------------------------------------
  Name:    ippiFloodFillGetSize_4Con, ippiFloodFillGetSize_8Con
           ippiFloodFillGetSize_Grad4Con, ippiFloodFillGetSize_Grad8Con

  Purpose: The functions calculate size of temporary buffer,  required to run
           one of the corresponding flood fill functions.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero

  Parameters:
    roiSize                  ROI size
    pBufSize                 Temporary buffer size
}

 function ippiFloodFillGetSize( roiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiFloodFillGetSize_Grad( roiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Names:   ippiFloodFill_4Con_8u_C1IR
           ippiFloodFill_8Con_8u_C1IR
           ippiFloodFill_4Con_16u_C1IR
           ippiFloodFill_8Con_16u_C1IR
           ippiFloodFill_4Con_32f_C1IR
           ippiFloodFill_8Con_32f_C1IR
           ippiFloodFill_4Con_32s_C1IR
           ippiFloodFill_8Con_32s_C1IR
           ippiFloodFill_4Con_8u_C3IR
           ippiFloodFill_8Con_8u_C3IR
           ippiFloodFill_4Con_16u_C3IR
           ippiFloodFill_8Con_16u_C3IR
           ippiFloodFill_4Con_32f_C3IR
           ippiFloodFill_8Con_32f_C3IR
           ippiFloodFill_Grad4Con_8u_C1IR
           ippiFloodFill_Grad8Con_8u_C1IR
           ippiFloodFill_Grad4Con_16u_C1IR
           ippiFloodFill_Grad8Con_16u_C1IR
           ippiFloodFill_Grad4Con_32f_C1IR
           ippiFloodFill_Grad8Con_32f_C1IR
           ippiFloodFill_Grad4Con_8u_C3IR
           ippiFloodFill_Grad8Con_8u_C3IR
           ippiFloodFill_Grad4Con_16u_C3IR
           ippiFloodFill_Grad8Con_16u_C3IR
           ippiFloodFill_Grad4Con_32f_C3IR
           ippiFloodFill_Grad8Con_32f_C3IR
           ippiFloodFill_Range4Con_8u_C1IR
           ippiFloodFill_Range8Con_8u_C1IR
           ippiFloodFill_Range4Con_16u_C1IR
           ippiFloodFill_Range8Con_16u_C1IR
           ippiFloodFill_Range4Con_32f_C1IR
           ippiFloodFill_Range8Con_32f_C1IR
           ippiFloodFill_Range4Con_8u_C3IR
           ippiFloodFill_Range8Con_8u_C3IR
           ippiFloodFill_Range4Con_16u_C3IR
           ippiFloodFill_Range8Con_16u_C3IR
           ippiFloodFill_Range4Con_32f_C3IR
           ippiFloodFill_Range8Con_32f_C3IR

  Purpose: The functions fill the seed pixel enewValirons inside which all pixel
           values are equal to (first 4 funcs) or not far from each other (the others).

  Return:
    ippStsNoErr              Ok.
    ippStsNullPtrErr         One of pointers is NULL.
    ippStsSizeErr            The width or height of images is less or equal zero.
    ippStsStepErr            The steps in images are too small.
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsOutOfRangeErr      Indicates an error condition if the seed point is out of ROI.

  Parameters:
    pImage                   Pointer to ROI of initial image (in the beginning)
                             which is "repainted" during the function action, 
    imageStep                Full string length of initial image (in bytes),
    roi                      Size of image ROI, 
    seed                     Coordinates of the seed point inside image ROI, 
    newVal                   Value to fill with for one-channel data, 
    pNewVal                  Pointer to the vector containing values to fill with
                             for three-channel data, 
    minDelta                 Minimum difference between neighbor pixels for one-channel data, 
    maxDelta                 Maximum difference between neighbor pixels for one-channel data, 
    pMinDelta                Pointer to the minimum differences between neighbor pixels for
                             three-channel images, 
    pMaxDelta                Pointer to the maximum differences between neighbor pixels for
                             three-channel images, 
    pRegion                  Pointer to repainted region properties structure, 
    pBuffer                  Buffer needed for calculations (its size must be
                             calculated by ippiFloodFillGetSize_Grad function).

  Notes:   This function uses a rapid non-recursive algorithm.
}

 function ippiFloodFill_4Con_8u_C1IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp8u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_8Con_8u_C1IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp8u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_4Con_16u_C1IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp16u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_8Con_16u_C1IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp16u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_4Con_32f_C1IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp32f ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_8Con_32f_C1IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp32f ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_4Con_32s_C1IR( pImage : Ipp32sPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp32s ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_8Con_32s_C1IR( pImage : Ipp32sPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp32s ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad4Con_8u_C1IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp8u ; minDelta : Ipp8u ; maxDelta : Ipp8u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad8Con_8u_C1IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp8u ; minDelta : Ipp8u ; maxDelta : Ipp8u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad4Con_16u_C1IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp16u ; minDelta : Ipp16u ; maxDelta : Ipp16u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad8Con_16u_C1IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp16u ; minDelta : Ipp16u ; maxDelta : Ipp16u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad4Con_32f_C1IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp32f ; minDelta : Ipp32f ; maxDelta : Ipp32f ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad8Con_32f_C1IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp32f ; minDelta : Ipp32f ; maxDelta : Ipp32f ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range4Con_8u_C1IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp8u ; minDelta : Ipp8u ; maxDelta : Ipp8u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range8Con_8u_C1IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp8u ; minDelta : Ipp8u ; maxDelta : Ipp8u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range4Con_16u_C1IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp16u ; minDelta : Ipp16u ; maxDelta : Ipp16u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range8Con_16u_C1IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp16u ; minDelta : Ipp16u ; maxDelta : Ipp16u ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range4Con_32f_C1IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp32f ; minDelta : Ipp32f ; maxDelta : Ipp32f ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range8Con_32f_C1IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; newVal : Ipp32f ; minDelta : Ipp32f ; maxDelta : Ipp32f ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFloodFill_4Con_8u_C3IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp8uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_8Con_8u_C3IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp8uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_4Con_16u_C3IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp16uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_8Con_16u_C3IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp16uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_4Con_32f_C3IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp32fPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_8Con_32f_C3IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp32fPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad4Con_8u_C3IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp8uPtr ; pMinDelta : Ipp8uPtr ; pMaxDelta : Ipp8uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad8Con_8u_C3IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp8uPtr ; pMinDelta : Ipp8uPtr ; pMaxDelta : Ipp8uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad4Con_16u_C3IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp16uPtr ; pMinDelta : Ipp16uPtr ; pMaxDelta : Ipp16uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad8Con_16u_C3IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp16uPtr ; pMinDelta : Ipp16uPtr ; pMaxDelta : Ipp16uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad4Con_32f_C3IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp32fPtr ; pMinDelta : Ipp32fPtr ; pMaxDelta : Ipp32fPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Grad8Con_32f_C3IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp32fPtr ; pMinDelta : Ipp32fPtr ; pMaxDelta : Ipp32fPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range4Con_8u_C3IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp8uPtr ; pMinDelta : Ipp8uPtr ; pMaxDelta : Ipp8uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range8Con_8u_C3IR( pImage : Ipp8uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp8uPtr ; pMinDelta : Ipp8uPtr ; pMaxDelta : Ipp8uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range4Con_16u_C3IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp16uPtr ; pMinDelta : Ipp16uPtr ; pMaxDelta : Ipp16uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range8Con_16u_C3IR( pImage : Ipp16uPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp16uPtr ; pMinDelta : Ipp16uPtr ; pMaxDelta : Ipp16uPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range4Con_32f_C3IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp32fPtr ; pMinDelta : Ipp32fPtr ; pMaxDelta : Ipp32fPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFloodFill_Range8Con_32f_C3IR( pImage : Ipp32fPtr ; imageStep : Int32 ; roiSize : IppiSize ; seed : IppiPoint ; pNewVal : Ipp32fPtr ; pMinDelta : Ipp32fPtr ; pMaxDelta : Ipp32fPtr ; pRegion : IppiConnectedCompPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                              Motion Templates                                 
  ----------------------------------------------------------------------------

  Name:      ippiUpdateMotionHistory_8u32f_C1IR,  ippiUpdateMotionHistory_16u32f_C1IR
             ippiUpdateMotionHistory_32f_C1IR

  Purpose:   Sets motion history image (MHI) pixels to the current time stamp
             when the corrensonding pixels in the silhoette image are non zero.
             Else (silhouette pixels are zero) MHI pixels are
             cleared if their values are too small (less than timestamp - mhiDuration),
             i.e. they were updated far ago last time. Else MHI pixels remain unchanged.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsOutOfRangeErr      Maximal duration is negative

  Arguments:
    pSilhouette              The pointer to silhouette image
    silhStep                 The step in silhouette image
    pMHI                     The pointer to motion history image
    mhiStep                  The step in mhi image
    roiSize                  ROI size
    timestamp                Current time stamp (milliseconds)
    mhiDuration              Maximal duration of motion track (milliseconds)
}

 function ippiUpdateMotionHistory_8u32f_C1IR( pSilhouette : Ipp8uPtr ; silhStep : Int32 ; pMHI : Ipp32fPtr ; mhiStep : Int32 ; roiSize : IppiSize ; timestamp : Ipp32f ; mhiDuration : Ipp32f ): IppStatus; _ippapi
 function ippiUpdateMotionHistory_16u32f_C1IR( pSilhouette : Ipp16uPtr ; silhStep : Int32 ; pMHI : Ipp32fPtr ; mhiStep : Int32 ; roiSize : IppiSize ; timestamp : Ipp32f ; mhiDuration : Ipp32f ): IppStatus; _ippapi
 function ippiUpdateMotionHistory_32f_C1IR( pSilhouette : Ipp32fPtr ; silhStep : Int32 ; pMHI : Ipp32fPtr ; mhiStep : Int32 ; roiSize : IppiSize ; timestamp : Ipp32f ; mhiDuration : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                                Optical Flow                                   
  ----------------------------------------------------------------------------

  Name:       ippiOpticalFlowPyrLKGetSize

  Purpose:    Computes the size of the pyramidal optical flow structure

  Return:
    ippStsNoErr              Indicates no error. Any other value indicates an error or a warning.
    ippStsNullPtrErr         Indicates an error Indicates an error if pStateSize is NULL.
    ippStsDataTypeErr        Indicates an error when dataType has an illegal value.
    ippStsSizeErr            Indicates an error condition if roiSize has a field with zero
                               or negative value or if winSize is equal to or less than 0.

  Arguments:
    winSize                  Size of search window (2*winSize+1)
    roi                      Maximal image ROI
    dataType                 The type of data
    hint                     Option to select the algorithmic implementation of the function
    pStateSize               Pointer to the size value of state structure.
}

 function ippiOpticalFlowPyrLKGetSize( winSize : Int32 ; roi : IppiSize ; dataType : IppDataType ; hint : IppHintAlgorithm ; pStateSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiOpticalFlowPyrLKInit_8u_C1R, ippiOpticalFlowPyrLKInit_16u_C1R,
              ippiOpticalFlowPyrLKInit_32f_C1R

  Purpose:    Initializes a structure for pyramidal L-K algorithm

  Return:
    ippStsNoErr              Indicates no error. Any other value indicates an error or a warning.
    ippStsNullPtrErr         Indicates an error if ppState or pStateBuf are NULL.
    ippStsSizeErr            Indicates an error condition if roiSize has a field with zero
                               or negative value or if winSize is equal to or less than 0.
    ippStsMemAllocErr        Memory allocation error

  Arguments:
    ppState                  Pointer to the pointer to the optical flow structure being initialized
    roiSize                  Size of the source image (zero level of the pyramid) ROI in pixels.
    winSize                  Size of search window (2*winSize+1) of each pyramid level.
    hint                     Option to select the algorithmic implementation of the function
    pStateBuf                Pointer to the work buffer for State structure.
}


 function ippiOpticalFlowPyrLKInit_8u_C1R( ppState : IppiOptFlowPyrLK_8u_C1RPtrPtr ; roi : IppiSize ; winSize : Int32 ; hint : IppHintAlgorithm ; pStateBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiOpticalFlowPyrLKInit_16u_C1R( ppState : IppiOptFlowPyrLK_16u_C1RPtrPtr ; roi : IppiSize ; winSize : Int32 ; hint : IppHintAlgorithm ; pStateBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiOpticalFlowPyrLKInit_32f_C1R( ppState : IppiOptFlowPyrLK_32f_C1RPtrPtr ; roi : IppiSize ; winSize : Int32 ; hint : IppHintAlgorithm ; pStateBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name: ippiOpticalFlowPyrLK_8u_C1R, ippiOpticalFlowPyrLK_16u_C1R,
        ippiOpticalFlowPyrLK_32f_C1R

  Purpose:
    Pyramidal version of Lucas - Kanade method of optical flow calculation

  Returns:
    ippStsNoErr              Indicates no error. Any other value indicates an error or a warning
    ippStsNullPtrErr         Indicates an error if one of the specified pointer is NULL
    ippStsSizeErr            Indicates an error condition if numFeat or winSize has zero or
                               negative value.
    ippStsBadArgErr          Indicates an error condition if maxLev or threshold has negative
                               value, or maxIter has zero or negative value.

  Arguments:
    pPyr1                    Pointer to the first image pyramid (time t)
    pPyr2                    Pointer to the second image pyramid (time t+dt)
    pPrev                    Array of points,  for which the flow needs to be found
    pNext                    Array of new positions of pPrev points
    pError                   Array of differences between pPrev and pNext points
    pStatus                  Array of result indicator (0 - not calculated)
    numFeat                  Number of points to calculate optical flow
    winSize                  Size of search window (2*winSize+1)
    maxLev                   Pyramid level to start the operation
    maxIter                  Maximum number of algorithm iterations for each pyramid level
    threshold                Threshold value to stop new position search
    pState                   Pointer to the pyramidal optical flow structure

    Notes:  For calculating spatial derivatives 3x3 Scharr operator is used.
            The values of pixels beyond the image are determined using replication mode.
}

 function ippiOpticalFlowPyrLK_8u_C1R( pPyr1 : IppiPyramidPtr ; pPyr2Ptr : IppiPyramid ; pPrev : IppiPoint_32fPtr ; pNext : IppiPoint_32fPtr ; pStatus : Ipp8sPtr ; pError : Ipp32fPtr ; numFeat : Int32 ; winSize : Int32 ; maxLev : Int32 ; maxIter : Int32 ; threshold : Ipp32f ; pState : IppiOptFlowPyrLK_8u_C1RPtr ): IppStatus; _ippapi
 function ippiOpticalFlowPyrLK_16u_C1R( pPyr1 : IppiPyramidPtr ; pPyr2Ptr : IppiPyramid ; pPrev : IppiPoint_32fPtr ; pNext : IppiPoint_32fPtr ; pStatus : Ipp8sPtr ; pError : Ipp32fPtr ; numFeat : Int32 ; winSize : Int32 ; maxLev : Int32 ; maxIter : Int32 ; threshold : Ipp32f ; pState : IppiOptFlowPyrLK_16u_C1RPtr ): IppStatus; _ippapi
 function ippiOpticalFlowPyrLK_32f_C1R( pPyr1 : IppiPyramidPtr ; pPyr2Ptr : IppiPyramid ; pRrev : IppiPoint_32fPtr ; pNext : IppiPoint_32fPtr ; pStatus : Ipp8sPtr ; pError : Ipp32fPtr ; numFeat : Int32 ; winSize : Int32 ; maxLev : Int32 ; maxIter : Int32 ; threshold : Ipp32f ; pState : IppiOptFlowPyrLK_32f_C1RPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                            Universal Pyramids                                 
  ----------------------------------------------------------------------------

  Name:       ippiPyramidGetSize

  Purpose:    Computes the size of the structure for pyramids and the size
              of the required work buffer (in bytes)

  Arguments:
    pPyrSize              Pointer to the size value of pyramid structure
    pSizeBuf              Pointer to the size value of the pyramid external work buffer
    level                 Maximal number pyramid level.
    roiSize               Zero level image ROI size.
    rate                  Neighbour levels ratio (1<rate<=10)

  Return:
    ippStsNoErr           Ok
    ippStsNullPtrErr      One of pointers is NULL
    ippStsSizeErr         roiSize has a field with zero or negative value.
    ippStsBadArgErr       level is equal to or less than 0 or if rate has wrong value.
}

 function ippiPyramidGetSize( pPyrSize : Int32Ptr ; var pBufSize : Int32 ; level : Int32 ; roiSize : IppiSize ; rate : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiPyramidInit

  Purpose:    Initializes structure for pyramids,  calculates ROI for layers.

  Arguments:
    pPyr                  Pointer to the pointer to the pyramid structure.
    level                 Maximal number pyramid level.
    roiSize               Zero level image ROI size.
    rate                  Neighbour levels ratio (1<rate<=10).
    pPyrBuffer            Pointer to the buffer to initialize structure for pyramids.
    pBuffer               Pointer to the work buffer.

  Return:
    ippStsNoErr           Ok
    ippStsNullPtrErr      One of pointers is NULL
    ippStsSizeErr         roiSize has a field with zero or negative value.
    ippStsBadArgErr       level is equal to or less than 0 or if rate has wrong value.
}

 function ippiPyramidInit( pPyr : IppiPyramidPtrPtr ; level : Int32 ; roiSize : IppiSize ; rate : Ipp32f ; pPyrBuffer : Ipp8uPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiPyramidLayerDownGetSize_8u_C1R,   ippiPyramidLayerDownGetSize_8u_C3R
              ippiPyramidLayerDownGetSize_16u_C1R,  ippiPyramidLayerDownGetSize_16u_C3R
              ippiPyramidLayerDownGetSize_32f_C1R,  ippiPyramidLayerDownGetSize_32f_C3R
              ippiPyramidLayerUpGetSize_8u_C1R,     ippiPyramidLayerUpGetSize_8u_C3R
              ippiPyramidLayerUpGetSize_16u_C1R,    ippiPyramidLayerUpGetSize_16u_C3R
              ippiPyramidLayerUpGetSizec_32f_C1R,   ippiPyramidLayerUpGetSize_32f_C3R

  Purpose:    Calculates the size of structure for creating a lower(an upper) pyramid layer and the size
              of the temporary  buffer (in bytes).

  Arguments:
    srcRoi                   Source image ROI size.
    dstRoi                   Destination image ROI size.
    rate                     Neighbour levels ratio (1<rate<=10)
    kerSize                  Kernel size
    pStateSize               Pointer to the size value of pyramid state structure.
    pBufSize                 Pointer to the size value of the external work buffer.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsBadArgErr          Bad rate or kernel size
}

 function ippiPyramidLayerDownGetSize_8u_C1R( srcRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiPyramidLayerDownGetSize_16u_C1R( srcRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiPyramidLayerDownGetSize_32f_C1R( srcRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiPyramidLayerDownGetSize_8u_C3R( srcRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiPyramidLayerDownGetSize_16u_C3R( srcRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiPyramidLayerDownGetSize_32f_C3R( srcRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ; var pBufSize : Int32 ): IppStatus; _ippapi

 function ippiPyramidLayerUpGetSize_8u_C1R( dstRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ): IppStatus; _ippapi
 function ippiPyramidLayerUpGetSize_16u_C1R( dstRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ): IppStatus; _ippapi
 function ippiPyramidLayerUpGetSize_32f_C1R( dstRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ): IppStatus; _ippapi
 function ippiPyramidLayerUpGetSize_8u_C3R( dstRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ): IppStatus; _ippapi
 function ippiPyramidLayerUpGetSize_16u_C3R( dstRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ): IppStatus; _ippapi
 function ippiPyramidLayerUpGetSize_32f_C3R( dstRoi : IppiSize ; rate : Ipp32f ; kerSize : Int32 ; pStateSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiPyramidLayerDownInit_8u_C1R,   ippiPyramidLayerDownInit_8u_C3R
              ippiPyramidLayerDownInit_16u_C1R,  ippiPyramidLayerDownInit_16u_C3R
              ippiPyramidLayerDownInit_32f_C1R,  ippiPyramidLayerDownInit_32f_C3R
              ippiPyramidLayerUpInit_8u_C1R,     ippiPyramidLayerUpInit_8u_C3R
              ippiPyramidLayerUpInit_16u_C1R,    ippiPyramidLayerUpInit_16u_C3R
              ippiPyramidLayerUpInit_32f_C1R,    ippiPyramidLayerUpInit_32f_C3R

  Purpose:    Initializes a structure for creating a lower(an upper) pyramid layer.

  Arguments:
    ppState                  Pointer to the pointer to initialized pyramid state structure
    srcRoi                   Source image ROI size.
    dstRoi                   Destination image ROI size.
    rate                     Neighbour levels ratio (1<rate<=10)
    pKernel                  Separable symmetric kernel of odd length
    kerSize                  Kernel size
    mode                     IPPI_INTER_LINEAR - bilinear interpolation
    StateBuf                 Pointer to the buffer to initialize state structure for pyramids.
    pBuffer                  Pointer to the work buffer.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsBadArgErr          Bad mode,  rate or kernel size
}

 function ippiPyramidLayerDownInit_8u_C1R( ppState : IppiPyramidDownState_8u_C1RPtrPtr ; srcRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp16sPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ; Buffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiPyramidLayerDownInit_16u_C1R( ppState : IppiPyramidDownState_16u_C1RPtrPtr ; srcRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp16sPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ; Buffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiPyramidLayerDownInit_32f_C1R( pState : IppiPyramidDownState_32f_C1RPtrPtr ; srcRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp32fPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ; Buffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiPyramidLayerDownInit_8u_C3R( ppState : IppiPyramidDownState_8u_C3RPtrPtr ; srcRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp16sPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ; Buffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiPyramidLayerDownInit_16u_C3R( ppState : IppiPyramidDownState_16u_C3RPtrPtr ; srcRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp16sPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ; Buffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiPyramidLayerDownInit_32f_C3R( ppState : IppiPyramidDownState_32f_C3RPtrPtr ; srcRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp32fPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ; Buffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiPyramidLayerUpInit_8u_C1R( ppState : IppiPyramidUpState_8u_C1RPtrPtr ; dstRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp16sPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiPyramidLayerUpInit_16u_C1R( ppState : IppiPyramidUpState_16u_C1RPtrPtr ; dstRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp16sPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiPyramidLayerUpInit_32f_C1R( ppState : IppiPyramidUpState_32f_C1RPtrPtr ; dstRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp32fPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiPyramidLayerUpInit_8u_C3R( ppState : IppiPyramidUpState_8u_C3RPtrPtr ; dstRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp16sPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiPyramidLayerUpInit_16u_C3R( ppState : IppiPyramidUpState_16u_C3RPtrPtr ; dstRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp16sPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiPyramidLayerUpInit_32f_C3R( ppState : IppiPyramidUpState_32f_C3RPtrPtr ; dstRoi : IppiSize ; rate : Ipp32f ; pKernel : Ipp32fPtr ; kerSize : Int32 ; mode : Int32 ; StateBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiGetPyramidDownROI, ippiGetPyramidUpROI

  Purpose:    Calculate possible size of destination ROI.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            Wrong src roi
    ippStsBadArgErr          Wrong rate

  Arguments:
    srcRoi                   Source image ROI size.
    pDstRoi                  Pointer to destination image ROI size (down).
    pDstRoiMin               Pointer to minimal destination image ROI size (up).
    pDstRoiMax               Pointer to maximal destination image ROI size (up).
    rate                     Neighbour levels ratio (1<rate<=10)

  Notes:                     For up case destination size belongs to interval
                             max((Int32)((float)((src-1)*rate)),src+1)<=dst<=
                             max((Int32)((float)(src)*rate)),src+1)
}

 function ippiGetPyramidDownROI( srcRoi : IppiSize ; pDstRoi : IppiSizePtr ; rate : Ipp32f ): IppStatus; _ippapi
 function ippiGetPyramidUpROI( srcRoi : IppiSize ; pDstRoiMin : IppiSizePtr ; pDstRoiMax : IppiSizePtr ; rate : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiPyramidLayerDown_8u_C1R, ippiPyramidLayerDown_16u_C1R, ippiPyramidLayerDown_32f_C1R
              ippiPyramidLayerDown_8u_C3R, ippiPyramidLayerDown_16u_C3R, ippiPyramidLayerDown_32f_C3R
              ippiPyramidLayerUp_8u_C1R,   ippiPyramidLayerUp_16u_C1R,   ippiPyramidLayerUp_32f_C1R
              ippiPyramidLayerUp_8u_C3R,   ippiPyramidLayerUp_16u_C3R,   ippiPyramidLayerUp_32f_C3R

  Purpose:    Perform downsampling/upsampling of the image with 5x5 gaussian.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of the specified pointers is NULL
    ippStsSizeErr            The srcRoiSize or dstRoiSize has a fild with zero or negativ value
    ippStsStepErr            The steps in images are too small
    ippStsBadArgErr          pState->rate has wrong value
    ippStsNotEvenStepErr     One of the step values is not divisibly by 4 for floating-point
                             images, or by 2 for short-integer images.
  Arguments:
    pSrc                     Pointer to the source image
    srcStep                  Step in byte through the source image
    srcRoiSize               Size of the source image ROI in pixel.
    dstRoiSize               Size of the destination image ROI in pixel.
    pDst                     Pointer to destination image
    dstStep                  Step in byte through the destination image
    pState                   Pointer to the pyramid layer structure
}

 function ippiPyramidLayerDown_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidDownState_8u_C1RPtr ): IppStatus; _ippapi
 function ippiPyramidLayerDown_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidDownState_8u_C3RPtr ): IppStatus; _ippapi
 function ippiPyramidLayerDown_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidDownState_16u_C1RPtr ): IppStatus; _ippapi
 function ippiPyramidLayerDown_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidDownState_16u_C3RPtr ): IppStatus; _ippapi
 function ippiPyramidLayerDown_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidDownState_32f_C1RPtr ): IppStatus; _ippapi
 function ippiPyramidLayerDown_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidDownState_32f_C3RPtr ): IppStatus; _ippapi

 function ippiPyramidLayerUp_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidUpState_8u_C1RPtr ): IppStatus; _ippapi
 function ippiPyramidLayerUp_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidUpState_8u_C3RPtr ): IppStatus; _ippapi
 function ippiPyramidLayerUp_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidUpState_16u_C1RPtr ): IppStatus; _ippapi
 function ippiPyramidLayerUp_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidUpState_16u_C3RPtr ): IppStatus; _ippapi
 function ippiPyramidLayerUp_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidUpState_32f_C1RPtr ): IppStatus; _ippapi
 function ippiPyramidLayerUp_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiPyramidUpState_32f_C3RPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                             Haar Classifier                                   
  ---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------

  Name:      ippiHaarClassifierInit  ippiTiltedHaarClassifierInit

  Purpose:   Initializes memory for the stage of the Haar classifier.

  Arguments:
    pState                   The pointer to the pointer to the Haar classifier structure.
    pFeature                 The pointer to the array of features.
    pWeight                  The pointer to the array of feature weights.
    pThreshold               The pointer to the array of classifier thresholds [length].
    pVal1, pVal2             Pointers to arrays of classifier results [length].
    pNum                     The pointer to the array of classifier lengths [length].
    length                   The number of classifiers in the stage.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The number of classifiers or features is less or equal zero
    ippStsbadArgErr          The bad feature rectangular
    ippStsMemAllocErr        Memory allocation error

  Notes:  For integer version feature weights pWeight are in Q0,  classifier thresholds
          pThreshold are in QT (see ApplyHaarClassifier), pVal1 and pVal2 are scale as
          stage thresholds threshold of ApplyHaarClassifier function
}

 function ippiHaarClassifierInit_32f( pState : IppiHaarClassifier_32fPtr ; pFeature : IppiRectPtr ; pWeight : Ipp32fPtr ; pThreshold : Ipp32fPtr ; pVal1 : Ipp32fPtr ; pVal2 : Ipp32fPtr ; pNum : Int32Ptr ; length : Int32 ): IppStatus; _ippapi
 function ippiHaarClassifierInit_32s( pState : IppiHaarClassifier_32sPtr ; pFeature : IppiRectPtr ; pWeight : Ipp32sPtr ; pThreshold : Ipp32sPtr ; pVal1 : Ipp32sPtr ; pVal2 : Ipp32sPtr ; pNum : Int32Ptr ; length : Int32 ): IppStatus; _ippapi
 function ippiTiltedHaarClassifierInit_32f( pState : IppiHaarClassifier_32fPtr ; pFeature : IppiRectPtr ; pWeight : Ipp32fPtr ; pThreshold : Ipp32fPtr ; pVal1 : Ipp32fPtr ; pVal2 : Ipp32fPtr ; pNum : Int32Ptr ; length : Int32 ): IppStatus; _ippapi
 function ippiTiltedHaarClassifierInit_32s( pState : IppiHaarClassifier_32sPtr ; pFeature : IppiRectPtr ; pWeight : Ipp32sPtr ; pThreshold : Ipp32sPtr ; pVal1 : Ipp32sPtr ; pVal2 : Ipp32sPtr ; pNum : Int32Ptr ; length : Int32 ): IppStatus; _ippapi

 function ippiHaarClassifierGetSize( dataType : IppDataType ; roiSize : IppiSize ; pNum : Int32Ptr ; length : Int32 ; var pSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiTiltHaarFeatures_32f,  ippiTiltHaarFeatures_32s
  Purpose:   Tilts marked feature on -45 degree
  Arguments:
    pMask                    The mask of feature to tilt.
    flag                     1 - left bottom  -45 degree
                             0 - left top     +45 degree
    pState                   The pointer to the Haar classifier structure.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
  Notes:  The mask length is equal to the number of classifiers in the classifier
          If pMask[i] != 0 i-th feature is tilted
          Classifiers with tilted features require two input integral images and
          can be used by rippiApplyMixedHaarClassifier functions
}

 function ippiTiltHaarFeatures_32f( pMask : Ipp8uPtr ; flag : Int32 ; pState : IppiHaarClassifier_32fPtr ): IppStatus; _ippapi
 function ippiTiltHaarFeatures_32s( pMask : Ipp8uPtr ; flag : Int32 ; pState : IppiHaarClassifier_32sPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiGetHaarClassifierSize_32f,      ippiGetHaarClassifierSize_32s
  Purpose:    Returns the size of the Haar classifier.
  Arguments:
    pState    Pointer to the Haar classifier structure.
    pSize        Pointer to the returned value of Haar classifier size.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
}

 function ippiGetHaarClassifierSize_32f( pState : IppiHaarClassifier_32fPtr ; pSize : IppiSizePtr ): IppStatus; _ippapi
 function ippiGetHaarClassifierSize_32s( pState : IppiHaarClassifier_32sPtr ; pSize : IppiSizePtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiApplyHaarClassifier,    ippiApplyMixedHaarClassifier
  Purpose:   Applies the stage of Haar classifiers to the image.
  Arguments:
    pSrc                     The pointer  to the source image of integrals.
    srcStep                  The step in bytes through the source image.
    pNorm                    The pointer  to the source image of norm factors.
    normStep                 The step  in bytes through the image of norm factors.
    pMask                    The pointer  to the source and destination image of classification decisions.
    maskStep                 The step  in bytes through the image of classification decisions.
    pPositive                The pointer to the number of positive decisions.
    roiSize                  The size of source and destination images ROI in pixels.
    threshold                The stage threshold value.
    pState                   The pointer to the Haar classifier structure.
    scaleFactor              Scale factor for classifier threshold*norm,  <= 0
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The number of classifiers or features is less or equal zero
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
}

 function ippiApplyHaarClassifier_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pNorm : Ipp32fPtr ; normStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pPositive : Int32Ptr ; threshold : Ipp32f ; pState : IppiHaarClassifier_32fPtr ): IppStatus; _ippapi
 function ippiApplyHaarClassifier_32s32f_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pNorm : Ipp32fPtr ; normStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pPositive : Int32Ptr ; threshold : Ipp32f ; pState : IppiHaarClassifier_32fPtr ): IppStatus; _ippapi
 function ippiApplyHaarClassifier_32s_C1RSfs( pSrc : Ipp32sPtr ; srcStep : Int32 ; pNorm : Ipp32sPtr ; normStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pPositive : Int32Ptr ; threshold : Ipp32s ; pState : IppiHaarClassifier_32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiApplyMixedHaarClassifier_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pTilt : Ipp32fPtr ; tiltStep : Int32 ; pNorm : Ipp32fPtr ; normStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pPositive : Int32Ptr ; threshold : Ipp32f ; pState : IppiHaarClassifier_32fPtr ): IppStatus; _ippapi
 function ippiApplyMixedHaarClassifier_32s32f_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pTilt : Ipp32sPtr ; tiltStep : Int32 ; pNorm : Ipp32fPtr ; normStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pPositive : Int32Ptr ; threshold : Ipp32f ; pState : IppiHaarClassifier_32fPtr ): IppStatus; _ippapi
 function ippiApplyMixedHaarClassifier_32s_C1RSfs( pSrc : Ipp32sPtr ; srcStep : Int32 ; pTilt : Ipp32sPtr ; tiltStep : Int32 ; pNorm : Ipp32sPtr ; normStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; pPositive : Int32Ptr ; threshold : Ipp32s ; pState : IppiHaarClassifier_32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                      Correction of Camera Distortions                         
  ---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------
  Name:    ippiUndistortGetSize

  Purpose: calculate the buffer size for Undistort functions

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero

  Parameters:
    roiSize                  Maximal image size
    pBufsize                 Pointer to work buffer size

  Notes:
}

 function ippiUndistortGetSize( roiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiCreateMapCameraUndistort_32f_C1R

  Purpose: initialize x and y maps for undistortion by ippiRemap function

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         pxMap or pyMap is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsBadArgErr          Bad fx or fy

  Parameters:
    pxMap                    Pointer to x map (result, free by ippiFree)
    xStep                    Pointer to x map row step (result)
    pyMap                    Pointer to x map (result, free by ippiFree)
    yStep                    Pointer to x map row step (result)
    roiSize                  Maximal image size
    fx, fy                   Focal lengths
    cx, cy                   Coordinates of principal point
    k1, k2                   Coeffs of radial distortion
    p1, p2                   Coeffs of tangential distortion
    pBuffer                  Pointer to work buffer

  Notes:
    fx, fy != 0
}

 function ippiCreateMapCameraUndistort_32f_C1R( pxMap : Ipp32fPtr ; xStep : Int32 ; pyMap : Ipp32fPtr ; yStep : Int32 ; roiSize : IppiSize ; fx : Ipp32f ; fy : Ipp32f ; cx : Ipp32f ; cy : Ipp32f ; k1 : Ipp32f ; k2 : Ipp32f ; p1 : Ipp32f ; p2 : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi


{ ----------------------------------------------------------------------------
  Name:    ippiUndistortRadial_8u_C1R,  ippiUndistortRadial_8u_C3R,
           ippiUndistortRadial_16u_C1R, ippiUndistortRadial_16u_C3R
           ippiUndistortRadial_32f_C1R, ippiUndistortRadial_32f_C3R

  Purpose: correct camera distortion

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         pSrc or pDst is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsStepErr            The steps in images are too small
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsBadArgErr          Bad fx or fy

  Parameters:
    pSrc                     Source image
    srcStep                  Step in source image
    pDst                     Pointer to destination image
    dstStep                  Step in destination image
    roiSize                  Source and destination image ROI size.
    fx, fy                   Focal lengths
    cx, cy                   Coordinates of principal point
    k1, k2                   Coeffs of radial distortion
    pBuffer                  Pointer to work buffer

  Notes:
}

 function ippiUndistortRadial_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; fx : Ipp32f ; fy : Ipp32f ; cx : Ipp32f ; cy : Ipp32f ; k1 : Ipp32f ; k2 : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiUndistortRadial_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; fx : Ipp32f ; fy : Ipp32f ; cx : Ipp32f ; cy : Ipp32f ; k1 : Ipp32f ; k2 : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiUndistortRadial_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; fx : Ipp32f ; fy : Ipp32f ; cx : Ipp32f ; cy : Ipp32f ; k1 : Ipp32f ; k2 : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiUndistortRadial_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; fx : Ipp32f ; fy : Ipp32f ; cx : Ipp32f ; cy : Ipp32f ; k1 : Ipp32f ; k2 : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiUndistortRadial_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; fx : Ipp32f ; fy : Ipp32f ; cx : Ipp32f ; cy : Ipp32f ; k1 : Ipp32f ; k2 : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiUndistortRadial_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; fx : Ipp32f ; fy : Ipp32f ; cx : Ipp32f ; cy : Ipp32f ; k1 : Ipp32f ; k2 : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiGradientColorToGray_8u_C3C1R,
           ippiGradientColorToGray_16u_C3C1R,
           ippiGradientColorToGray_32f_C3C1R

  Purpose: Calculate gray gradient from 3-channel gradient image.

  Return:
    ippStsNoErr         Ok
    ippStsNullPtrErr    One of pointers is NULL
    ippStsSizeErr       The width or height of images is less or equal zero
    ippStsStepErr       The steps in images are too small

  Parameters:
    pSrc                The source image
    srcStep             Its step
    pDst                The destination image
    dstStep             Its step
    roiSize             ROI size
    norm                The norm type
                                  rippiNormInf = max(|a|,|b|,|c|)
                                  rippiNormL1  = (|a|+|b|+|c|)/3
                                  rippiNormL2  = sqrt((a*a+b*b+c*c)/3)

  Note:                 For integer flavors,  the result is scaled to the full range of the
                        destination data type
}

 function ippiGradientColorToGray_8u_C3C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; norm : IppiNorm ): IppStatus; _ippapi
 function ippiGradientColorToGray_16u_C3C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; norm : IppiNorm ): IppStatus; _ippapi
 function ippiGradientColorToGray_32f_C3C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; norm : IppiNorm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiInpaintGetSize

  Purpose:    Computes the size of the State structure  and the size
              of the required work buffer (in bytes).

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of the image are less or equal zero
    ippStsStepErr            The step in distance image is too small
    ippStsBadArgErr          Wrong radius or flags
    ippStsNumChannensErr     Specified number of channels is invalid or unsupported

  Parameters:
    pMask                    Pointer to the mask image ROI
    maskStep                 Distance in bytes between starts of consecutive lines in the mask image
    roiSize                  Size of the image ROI in pixels.
    radius                   Neighborhood radius (dist<=radius pixels are processed)
    flags                    Inpainting flags
                                IPP_INPAINT_TELEA  Telea algorithm is used
                                IPP_INPAINT_NS     Navier-Stokes equation is used
    channels                 number of image channels
    pStateSize               Pointer to the size value state structure.
    pBufSize                 Pointer to the size value of the external work buffer.
}

 function ippiInpaintGetSize( pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; radius : Ipp32f ; flags : IppiInpaintFlag ; channels : Int32 ; pStateSize : Int32Ptr ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiInpaintInit_8u_C1R,    ippiInpaintInit_8u_C3R

  Purpose:    Initializes a structure for direct inpainting algorithm

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of the image  are less or equal zero
    ippStsStepErr            The steps in distance image or mask image ROI are too small
    ippStsNotEvenStepErr     Step is not multiple of element
    ippStsBadArgErr          Wrong radius or flags

  Parameters:
    ppState                  Double pointer to the state structure for the image
                             inpaiting.
    pDist                    Pointer to the ROI of the image of distances.
    distStep                 Distance in bytes between starts of consecutive lines in
                             the image of distances.
    pMask                    Pointer to the mask image ROI.
    maskStep                 Distance in bytes between starts of consecutive lines in
                             the mask image.
    roiSize                  Size of the image ROI in pixels
    radius                   Neighborhood radius (dist<=radius pixels are processed)
    flags                    Specifies algorithm for image inpainting; following values
                             are possible:
                                IPP_INPAINT_TELEA  Telea algorithm is used
                                IPP_INPAINT_NS     Navier-Stokes equation is used
    StateBuf                 Pointer to the buffer to initialize state structure.
    pBuffer                  Pointer to the work buffer.
}

 function ippiInpaintInit_8u_C1R( ppState : IppiInpaintState_8u_C1RPtrPtr ; pDist : Ipp32fPtr ; distStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; radius : Ipp32f ; flags : IppiInpaintFlag ; pStateBuf : Ipp8uPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiInpaintInit_8u_C3R( ppState : IppiInpaintState_8u_C3RPtrPtr ; pDist : Ipp32fPtr ; distStep : Int32 ; pMask : Ipp8uPtr ; maskStep : Int32 ; roiSize : IppiSize ; radius : Ipp32f ; flags : IppiInpaintFlag ; pStateBuf : Ipp8uPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiInpaint_8u_C1R,    ippiInpaint_8u_C3R

  Purpose:    restores damaged image area by direct inpainting

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of the image  are less or equal zero or different from init
    ippStsStepErr            The steps in images are too small

  Parameters:
    pSrc                     Pointer to the source image ROI.
    srcStep                  Distance in bytes between starts of consecutive lines in the source image.
    pDst                     Pointer to the destination image ROI.
    dstStep                  Distance in bytes between starts of consecutive lines in the
                             destination image.
    roiSize                  Size of the image ROI in pixels.
    pState                   Pointer to inpainting structure
    pBuffer                  Pointer to work buffer
}

 function ippiInpaint_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pState : IppiInpaintState_8u_C1RPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiInpaint_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pState : IppiInpaintState_8u_C1RPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiSegmentGradientGetBufferSize_8u_C1R
         ippiSegmentGradientGetBufferSize_8u_C3R

  Purpose:    Get size of external buffer.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of the image or kernel size are less or equal zero

  Parameters:
    roiSize                  The image ROI size
    pBufSize                 The pointer to the buffer size
}

 function ippiSegmentGradientGetBufferSize_8u_C1R( roiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiSegmentGradientGetBufferSize_8u_C3R( roiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiSegmentGradient_8u_C1R, ippiSegmentGradient_8u_C3R

  Purpose:    Draw bounds between image segments

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of the image or kernel size are less or equal zero
    ippStsStepErr            The steps in images are too small

  Parameters:
    pSrc                     Source image
    srcStep                  Its step
    pMarker                  Source and destination marker image
    markerStep               Its step
    roiSize                  Image ROI size
    norm                     Type of norm to form the mask for maximum search:
                                rippiNormInf   Infinity norm (8-connectivity, 3x3 rectangular mask).
                                rippiNormL1    L1 norm (4-connectivity, 3x3 cross mask).
    flag                     Flags
                                IPP_SEGMENT_BORDER_4 Draw L1 segment borders.
                                IPP_SEGMENT_BORDER_8 Draw Linf segment borders.
    pBuffer                  Pointer to working buffer
}

 function ippiSegmentGradient_8u_C3IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMarker : Ipp8uPtr ; markerStep : Int32 ; roiSize : IppiSize ; norm : IppiNorm ; flags : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi


 function ippiSegmentGradient_8u_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMarker : Ipp8uPtr ; markerStep : Int32 ; roiSize : IppiSize ; norm : IppiNorm ; flags : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiSegmentWatershedGetBufferSize

  Purpose:   Get size of external buffer.

  Parameters:
    roiSize        - Size, in pixels,  of the ROI.
    pBufferSize    - Pointer to the calculated buffer size (in bytes).

  Return:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when roiSize has a zero or negative value.
}

 function ippiSegmentWatershedGetBufferSize_8u_C1R    ( roiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiSegmentWatershedGetBufferSize_8u16u_C1R( roiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiSegmentWatershedGetBufferSize_32f16u_C1R( roiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiSegmentWatershed

  Purpose:    Draw bounds between image segments

  Parameters:
    pSrc           - Pointers to the source image ROI.
    srcStep        - Distances, in bytes,  between the starting points of consecutive lines in the source image.
    pMarker        - Pointers to the marker image ROI.
    markerStep     - Distances, in bytes,  between the starting points of consecutive lines in the marker image.
    roiSize        - Size, in pixels,  of the ROI.
    norm           - Type of norm to form the mask for maximum search:
                         ippiNormInf   Infinity norm (8-connectivity, 3x3 rectangular mask);
                         ippiNormL1    L1 norm (4-connectivity, 3x3 cross mask);
                         ippiNormL2    approximation of L2 norm  (8-connectivity, 3x3 mask 11, 15);
                         ippiNormFM    Fast marching distance (4-connectivity).
    flag           - Flags
                         IPP_SEGMENT_QUEUE    Via priority queue (not supported for Ipp32f data).
                         IPP_SEGMENT_DISTANCE Via distance transform.
                         IPP_SEGMENT_BORDER_4 Draw L1 segment borders.
                         IPP_SEGMENT_BORDER_8 Draw Linf segment borders.
    pBuffer        - Pointer to the buffer for internal calculations.

  Return:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when roiSize has a zero or negative value.
    ippStsStepErr    - Error when The steps in images are too small.
}

 function ippiSegmentWatershed_8u_C1IR    ( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMarker : Ipp8uPtr; markerStep : Int32 ; roiSize : IppiSize ; norm : IppiNorm ; flag : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiSegmentWatershed_8u16u_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pMarker : Ipp16uPtr ; markerStep : Int32 ; roiSize : IppiSize ; norm : IppiNorm ; flag : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiSegmentWatershed_32f16u_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pMarker : Ipp16uPtr ; markerStep : Int32 ; roiSize : IppiSize ; norm : IppiNorm ; flag : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiBoundSegments_8u_C1IR,  ippiBoundSegments_16u_C1IR

  Purpose:    Draw bounds between image segments

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of the image or kernel size are less or equal zero
    ippStsStepErr            The steps in images are too small

  Parameters:
    pMarker                  Source and destination marker image
    markerStep               Its step
    roiSize                  Image ROI size
    norm                     Type of norm to form the mask for maximum search:
                                ippiNormInf   Infinity norm (8-connectivity, 3x3 rectangular mask).
                                ippiNormL1    L1 norm (4-connectivity, 3x3 cross mask).
}

 function ippiBoundSegments_8u_C1IR( pMarker : Ipp8uPtr ; markerStep : Int32 ; roiSize : IppiSize ; val : Ipp8u ; norm : IppiNorm ): IppStatus; _ippapi
 function ippiBoundSegments_16u_C1IR( pMarker : Ipp16uPtr ; markerStep : Int32 ; roiSize : IppiSize ; val : Ipp16u ; norm : IppiNorm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiLabelMarkersGetBufferSize_8u_C1R
           ippiLabelMarkersGetBufferSize_8u32s_C1R
           ippiLabelMarkersGetBufferSize_16u_C1R

  Purpose: The functions calculate size of temporary buffer,  required to run
           marker labeling function

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero

  Parameters:
    roiSize                  ROI size
    pBufSize                 Temporary buffer size
}

 function ippiLabelMarkersGetBufferSize_8u_C1R( roiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiLabelMarkersGetBufferSize_8u32s_C1R( roiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiLabelMarkersGetBufferSize_16u_C1R( roiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiLabelMarkers_8u_C1IR
         ippiLabelMarkers_8u32s_C1R
         ippiLabelMarkers_16u_C1IR

  Purpose:    Labels connected non-zero components with different label values

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width of the image or kernel size are less or equal zero
    ippStsStepErr            The steps in images are too small

  Parameters:
    pMarker                  Source and destination marker image
    markerStep               Its step
    roiSize                  Image ROI size
    minLabel                 Minimal label value > 0
    maxLabel                 Maximal label value < 255
    norm                     Type of norm to form the mask for maximum search:
                                ippiNormL1    L1 norm (4-connectivity, 3x3 cross mask).
                                ippiNormInf   Infinity norm (8-connectivity, 3x3 rectangular mask).
    pNumber                  Pointer to number of markers
    pBuffer                  Pointer to working buffer
}

 function ippiLabelMarkers_8u_C1IR( pMarker : Ipp8uPtr ; markerStep : Int32 ; roiSize : IppiSize ; minLabel : Int32 ; maxLabel : Int32 ; norm : IppiNorm ; pNumber : Int32Ptr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiLabelMarkers_8u32s_C1R( pSrcMarker : Ipp8uPtr ; srcMarkerStep : Int32 ; pDstMarker : Ipp32sPtr ; dstMarkerStep : Int32 ; roiSize : IppiSize ; minLabel : Int32 ; maxLabel : Int32 ; norm : IppiNorm ; pNumber : Int32Ptr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiLabelMarkers_16u_C1IR( pMarker : Ipp16uPtr ; markerStep : Int32 ; roiSize : IppiSize ; minLabel : Int32 ; maxLabel : Int32 ; norm : IppiNorm ; pNumber : Int32Ptr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiFilterGaussianGetBufferSize

  Purpose:    Computes the size of the working buffer for the Gaussian filter

  Return:
     ippStsNoErr          Ok. Any other value indicates an error or a warning.
     ippStsNullPtrErr     One of the pointers is NULL.
     ippStsSizeErr        maxRoiSize  has a field with zero or negative value.
     ippStsDataTypeErr    Indicates an error when dataType has an illegal value.
     ippStsBadArgErr      Indicates an error if kernelSize is even or is less than 3.
     ippStsChannelErr     Indicates an error when numChannels has an illegal value.

  Arguments:
     maxRoiSize           Maximal size of the image ROI in pixels.
     kernelSize           Size of the Gaussian kernel (odd, greater or equal to 3).
     dataType             Data type of the source and destination images.
     numChannels          Number of channels in the images. Possible values are 1 and 3.
     pSpecSize            Pointer to the computed size (in bytes) of the Gaussian
                            specification structure.
     pBufferSize          Pointer to the computed size (in bytes) of the external buffer.
}

 function ippiFilterGaussianGetBufferSize( maxRoiSize : IppiSize ; KernelSize : Ipp32u ; dataType : IppDataType ; numChannels : Int32 ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiFilterGaussianInit

  Purpose:    initialization of Spec for Gaussian filter

  Return:
     ippStsNoErr          Ok. Any other value indicates an error or a warning.
     ippStsNullPtrErr     One of the pointers is NULL.
     ippStsSizeErr        roiSize has a field with zero or negative value.
     ippStsDataTypeErr    Indicates an error when borderType has an illegal value.
     ippStsBadArgErr      kernelSize is even or is less than 3.
     ippStsChannelErr     Indicates an error when numChannels has an illegal value.
     ippStsBorderErr      Indicates an error condition if borderType has a illegal
                           value.

  Arguments:
     roiSize              Size of the image ROI in pixels.
     kernelSize           Size of the Gaussian kernel (odd, greater or equal to 3).
     sigma                Standard deviation of the Gaussian kernel.
     borderType           One of border supported types.
     dataType             Data type of the source and destination images.
     numChannels          Number of channels in the images. Possible values are 1 and 3.
     pSpec                Pointer to the Spec.
     pBuffer              Pointer to the buffer:
}

 function ippiFilterGaussianInit( roiSize : IppiSize ; KernelSize : Ipp32u ; sigma : Ipp32f ; borderType : IppiBorderType ; dataType : IppDataType ; numChannels : Int32 ; pSpec : IppFilterGaussianSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiFilterGaussianBorder

  Purpose:    Applies Gaussian filter with borders

  Return:
     ippStsNoErr      Ok. Any other value indicates an error or a warning.
     ippStsNullPtrErr One of the specified pointers is NULL.
     ippStsSizeErr    roiSize has a field with zero or negative value.
     ippStsStepErr    Indicates an error condition if srcStep or dstStep is less
                        than  roiSize.width * <pixelSize>.
     ippStsNotEvenStepErr One of the step values is not divisible by 4 for floating-point images.
     ippStsBadArgErr  kernelSize is less than 3 or sigma is less or equal than 0.

  Arguments:
     pSrc             Pointer to the source image ROI.
     srcStep          Distance in bytes between starts of consecutive lines in the source image.
     pDst             Pointer to the destination image ROI.
     dstStep          Distance in bytes between starts of consecutive lines in the destination image.
     roiSize          Size of the source and destination image ROI.
     borderValue      Constant value to assign to pixels of the constant border. if border type equals ippBorderConstant
     pSpec            Pointer to the Gaussian specification structure.
     pBuffer          Pointer to the working buffer.
}

 function ippiFilterGaussianBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderValue : Ipp32f ; pSpec : IppFilterGaussianSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterGaussianBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderValue : Ipp16u ; pSpec : IppFilterGaussianSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterGaussianBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderValue : Ipp16s ; pSpec : IppFilterGaussianSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterGaussianBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderValue : Ipp8u ; pSpec : IppFilterGaussianSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterGaussianBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderValue : Ipp32f_3 ; pSpec : IppFilterGaussianSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterGaussianBorder_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderValue : Ipp16u_3 ; pSpec : IppFilterGaussianSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterGaussianBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderValue : Ipp16s_3 ; pSpec : IppFilterGaussianSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterGaussianBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; borderValue : Ipp8u_3 ; pSpec : IppFilterGaussianSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiFindPeaks3x3GetBufferSize

  Purpose:    Computes the size of the working buffer for the peak search

  Return:
     ippStsNoErr      Ok. Any other value indicates an error or a warning.
     ippStsNullPtrErr Indicates an error condition if the pointer pBufferSize is NULL.
     ippStsSizeErr    Indicates an error condition if maskSize has a field with zero
                      or negative value,  or if roiWidth is less than 1.

  Arguments:
     roiWidth         Maximal image width (in pixels).
     pBufferSize      Pointer to the computed size of the buffer.
}

 function ippiFindPeaks3x3GetBufferSize_32f_C1R( roiWidth : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFindPeaks3x3GetBufferSize_32s_C1R( roiWidth : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiFindPeaks3x3

  Purpose:    Finds coordinates of peaks (maximums or minimums) with absolute value
              exceeding threshold value

  Return:
     ippStsNoErr      Ok. Any other value indicates an error or a warning.
     ippStsNullPtrErr One of the specified pointers is NULL.
     ippStsSizeErr    Indicates an error condition if roiSize has a field
                      with zero or negative value or if maxPeakCount is less
                      than or equal to zero,  or if Border is less than 1 or
                      greater than 0.5* roiSize.width or. greater than 0.5* roiSize.hight
     ippStsStepErr    Indicates an error condition if srcStep is less than roiSize.width * <pixelSize>
     ippStsNotEvenStepErr Indicates an error condition if one of the step values is
                      not divisible by 4 for floating-point or 32-bit integer images.
     ippStsBadArgErr  Indicates an error condition if norm value is wrong.

  Arguments:
     pSrc             Pointer to the source image ROI.
     srcStep          Distance in bytes between starts of consecutive lines in the source image.
     roiSize          Size of the image ROI in pixels.
     threshold        Threshold value.
     pPeak            Pointer to the maximum coordinates [maxPeakCount].
     maxPeakCount     Maximal number of peaks.
     pPeakCount       Number of detected peaks.
     norm             Type of norm to form the mask for maximum search:
                      ippiNormInf Infinity norm (8-connectivity, 3x3 rectangular mask).
                      ippiNormL1 L1 norm (4-connectivity, 3x3 cross mask).
     Border           Border value,  only pixel with distance from the edge of the image
                      greater than Border are processed.
     pBuffer          Pointer to the working buffer.
}

 function ippiFindPeaks3x3_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ; pPeak : IppiPointPtr ; maxPeakCount : Int32 ; pPeakCount : Int32Ptr ; norm : IppiNorm ; Border : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi


 function ippiFindPeaks3x3_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32s ; pPeak : IppiPointPtr ; maxPeakCount : Int32 ; pPeakCount : Int32Ptr ; norm : IppiNorm ; Border : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiHoughLineGetSize_8u_C1R()


  Purpose:   Calculate the size of temporary buffer for ippiHoughLine_8u32f_C1R function.

  Arguments:
    roiSize                  The size of source ROI.
    delta                    Discretization step,  delta.rho - distance resolution in pixels,  delta.theta - angle resolution in radians
    maxLineCount             The size of detected line buffer
    pBufSize                 Pointer to the computed size of the temporary buffer

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         pBufSize is NULL
    ippStsSizeErr            The roiSize or delta has a field with zero or negative value
    ippStsOverflow           The size of buffer too big. Overflow.
}

 function ippiHoughLineGetSize_8u_C1R( roiSize : IppiSize ; delta : IppPointPolar ; maxLineCount : Int32 ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiHoughLine_8u32f_C1R()


  Purpose:   Perform Hough transform algorithm


  Arguments:
    pSrc                     Pointer to the source image ROI
    srcStep                  Distance in bytes between starts of consecutive lines in the source image
    roiSize                  The size of source ROI.
    delta                    Discretization step,  delta.rho - distance resolution in pixels,  delta.theta - angle resolution in radians
    threshold                Threshold for a line is detected (if accumulator value > threshold)
    pLine                    Pointer to output array of detected lines
    maxLineCount             Size of output array pLine in elements
    pLineCount               Number of detected lines.  If founded more than maxLineCount lines than function returns "ippStsDstSizeLessExpected" status
    pBuffer                  Pointer to the pre-allocated temporary buffer

  Return:
    ippStsNoErr               Ok
    ippStsNullPtrErr          pSrc or pLine or pLineCount or pBuffer is NULL
    ippStsStepErr             srcStep is not valid
    ippStsSizeErr             roiSize has a field with zero or negative value or maxLineCount is zero or negative
    ippStsBadArgErr           threshold or is less than or equal to zero or delta.rho less 0 or more ROI width+height or delta.theta less 0 or more PI
    ippStsDstSizeLessExpected Ok,  but lines detected more than maxLineCount
}

 function ippiHoughLine_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; delta : IppPointPolar ; threshold : Int32 ; pLine : IppPointPolarPtr ; maxLineCount : Int32 ; pLineCount : Int32Ptr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{
  Name:      ippiHoughLine_Region_8u32f_C1R


  Purpose:   Perform Hough transform algorithm in defined region


  Arguments:
    pSrc                     Pointer to the source image ROI
    srcStep                  Distance in bytes between starts of consecutive lines in the source image
    roiSize                  The size of source ROI.
    pLine                    Pointer to output array of detected lines
    dstRoi                   Bottom left and top right corners of searched lines. All founded lines must be
                             in this area. (line[n].rho>=dstRoi[0].rho && line[n].theta>=dstRoi[0].theta &&
                                            line[n].rho<=dstRoi[1].rho && line[n].theta<=dstRoi[1].theta)
    maxLineCount             Size of output array pLine in elements
    pLineCount               Number of detected lines.  If founded more than maxLineCount lines than function returns "ippStsDstSizeLessExpected" status
    delta                    Discretization step,  delta.rho - distance resolution in pixels,  delta.theta - angle resolution in radians
    threshold                Threshold for a line is detected (if accumulator value > threshold)
    pBuffer                  Pointer to the pre-allocated temporary buffer

  Return:
    ippStsNoErr               Ok
    ippStsNullPtrErr          pSrc or pLine or pLineCount or pBuffer is NULL
    ippStsStepErr             srcStep is not valid
    ippStsSizeErr             roiSize has a field with zero or negative value or maxLineCount is zero or negative
    ippStsBadArgErr           threshold or is less than or equal to zero or delta.rho less 0 or more ROI width+height or
                              delta.theta less 0 or more PI or dstRoi[0].rho more dstRoi[1].rho or dstRoi[0].theta more dstRoi[1].theta
    ippStsDstSizeLessExpected Ok,  but lines detected more than maxLineCount
}

 function ippiHoughLine_Region_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pLine : IppPointPolarPtr ; dstRoi : IppPointPolar_2 ; maxLineCount : Int32 ; pLineCount : Int32Ptr ; delta : IppPointPolar ; threshold : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHoughProbLineGetSize_8u_C1R( roiSize : IppiSize ; delta : IppPointPolar ; var pSpecSize : Int32 ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiHoughProbLineInit_8u32f_C1R( roiSize : IppiSize ; delta : IppPointPolar ; hint : IppHintAlgorithm ; pSpec : IppiHoughProbSpecPtr ): IppStatus; _ippapi
 function ippiHoughProbLine_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; threshold : Int32 ; lineLength : Int32 ; lineGap : Int32 ; pLine :  IppiPointPtr ; maxLineCount : Int32 ; pLineCount : Int32Ptr ; pBuffer : Ipp8uPtr ; const pSpec : IppiHoughProbSpecPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiCannyBorder_8u_C1R
  Purpose: Perform convolution operation with fixed kernels 3x3 and 5x5 and creates binary image of source`s image edges, 
                using derivatives of the first order.
  Parameters:
    pSrc                     The pointer to the source image
    srcStep                  The step in the source image
    pDst                     The pointer to the destination image
    dstStep                  The step in the destination image
    roiSize                  The image ROI size
    filterType               the filter type(ippFilterSobel,ippFilterScharr)
    mask                     The mask size(ippMskSize3x3,ippMskSize5x5)
    borderType               Type of border. Possible values are:
                     ippBorderConst Values of all border pixels are set to constant.
                     ippBorderRepl Border is replicated from the edge pixels.
                     ippBorderInMem Border is obtained from the source image pixels in memory.
                     Mixed borders are also supported. They can be obtained by the bitwise operation OR between ippBorderRepl and ippBorderInMemTop,  ippBorderInMemBottom, ippBorderInMemLeft, ippBorderInMemRight.
    borderValue              The value for the constant border
    lowThresh                Low threshold for edges detection
    highThresh               Upper threshold for edges detection
    norm                     Norm type (ippNormL1,ippNormL2)
    pBuffer                  Pointer to the pre-allocated temporary buffer,  which size can be
                             calculated using ippiCannyEdgeDetectionGetSize function
  Return:
    ippStsNoErr              Ok
    ippStsMaskSizeErr        Indicates an error when mask has an illegal value.
    ippStsNullPtrErr         One of pointers is NULL
    ippStsSizeErr            The width or height of images is less or equal zero
    ippStsNotEvenStepErr     Step is not multiple of element.
    ippStsBadArgErr          Bad thresholds
}

 function ippiCannyBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; filterType : IppiDifferentialKernel ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; lowThresh : Ipp32f ; highThresh : Ipp32f ; norm : IppNormType ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name:    ippiCannyBorderGetSize

  Purpose: Calculates size of temporary buffer,  required to run ippiCannyBorder_8u_C1R function.
  Parameters:
    roiSize           Size of image ROI in pixel
    filterType        The filter type(ippFilterSobel,ippFilterScharr)
    mask              The mask size(ippMskSize3x3,ippMskSize5x5)
    dataType          Data type of the image. Possible values are Ipp8u,  Ipp16u, Ipp16s, or Ipp32f.
    pBufferSize       Pointer to the variable that returns the size of the temporary buffer

  Return:
    ippStsNoErr       Ok
    ippStsNullPtrErr  Pointer bufferSize is NULL
    ippStsMaskSizeErr Indicates an error when mask has an illegal value.
    ippStsDataTypeErr Indicates an error when dataType has an illegal value.
    ippStsSizeErr     roiSize has a field with zero or negative value
}

 function ippiCannyBorderGetSize( roiSize : IppiSize ; filterType : IppiDifferentialKernel ; mask : IppiMaskSize ; dataType : IppDataType ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiHarrisCornerGetBufferSize

  Purpose:            Computes the size of the external buffer for ippiHarrisCorner function

  Parameters:
   roiSize            Size of the source and destination ROI in pixels.
   filterMask         Linear size of derivative filter aperture.
   avgWndSize         Neighborhood block size for smoothing
   dataType           Data type of the source image.
   numChannels        Number of channels in the images. Possible values is 1.
   pBufferSize        Pointer to the size (in bytes) of the external work buffer.

  Return Values:
   ippStsNoErr          Indicates no error.
   ippStsNullPtrErr     Indicates an error when pBufferSize is NULL.
   ippStsSizeErr        Indicates an error in the two cases:
                          if roiSize is negative,  or equal to zero;
                          if avgWndSize is equal to zero.
   ippStsFilterTypeErr  Indicates an error when filterType has illegal value.
   ippStsMaskSizeErr    Indicates an error condition if mask has a wrong value.
   ippStsDataTypeErr    Indicates an error when dataType has an illegal value.
   ippStsNumChannelsErr Indicates an error when numChannels has an illegal value.
}

 function ippiHarrisCornerGetBufferSize( roiSize : IppiSize ; filterMask : IppiMaskSize ; avgWndSize : Ipp32u ; dataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:                 ippiHarrisCorner
  Purpose:              Performs Harris corner detector operations

  Parameters:
    pSrc                Pointer to the source image
    srcStep             Step through the source image
    pDst                Pointer to the destination image
    dstStep             Step through the destination image in pixels.
    roiSize             Size of the source and destination image ROI.
    filterType          Type of derivative operator
    filterMask          Predefined mask of IppiMaskSize type.
    avgWndSize          Size of a rectangle Window for computing an average value
    k                   Harris Corner free coefficient
    scale               Destination image scale factor
    border              Type of the border
    borderValue         Constant value to assign to pixels of the constant border. if border type equals ippBorderConstant
    pBuffer             Pointer to the work buffer

  Return Values:
    ippStsNoErr          Indicates no error.
    ippStsNullPtrErr     Indicates an error condition if pSrc,  pDst or pBufferSize is NULL.
    ippStsSizeErr        Indicates an error in the two cases:
                            if roiSize is negative,  or equal to zero;
                            if avgWndSize is equal to zero.
    ippStsNotEvenStepErr Indicated an error when dstStep is not divisible by 4.
    ippStsFilterTypeErr  Indicates an error when filterType has illegal value.
    ippStsMaskSizeErr    Indicates an error condition if mask has an illegal value.
    ippStsBorderErr      Indicates an error when borderType has illegal value.
    ippStsStepErr        Indicates an error condition,   if srcStep or dstStep has negative value
    ippStsInplaceModeNotSupportedErr Indicates an error condition,  if the pSrc and pDst points to the same image
}

 function ippiHarrisCorner_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; filterType : IppiDifferentialKernel ; filterMask : IppiMaskSize ; avgWndSize : Ipp32u ; k : float ; scale : float ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHarrisCorner_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; filterType : IppiDifferentialKernel ; filterMask : IppiMaskSize ; avgWndSize : Ipp32u ; k : float ; scale : float ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiLineSuppressionGetBufferSize

  Purpose:            Computes the size of the external buffer for ippiLineSuppression function

  Parameters:
   roiSize            Size of the source and destination ROI in pixels.
   filterMask         Linear size of derivative filter aperture.
   avgWndSize         Neighborhood block size for smoothing
   dataType           Data type of the source image.
   numChannels        Number of channels in the images. Possible values is 1.
   pBufferSize        Pointer to the size (in bytes) of the external work buffer.

  Return Values:
   ippStsNoErr          Indicates no error.
   ippStsNullPtrErr     Indicates an error when pBufferSize is NULL.
   ippStsSizeErr        Indicates an error in the two cases:
                          if roiSize is negative,  or equal to zero;
                          if avgWndSize is equal to zero.
   ippStsFilterTypeErr  Indicates an error when filterType has illegal value.
   ippStsMaskSizeErr    Indicates an error condition if mask has a wrong value.
   ippStsDataTypeErr    Indicates an error when dataType has an illegal value.
   ippStsNumChannelsErr Indicates an error when numChannels has an illegal value.
}

 function ippiLineSuppressionGetBufferSize( roiSize : IppiSize ; filterMask : IppiMaskSize ; avgWndSize : Ipp32u ; dataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:                 ippiLineSuppression
  Purpose:              Performs Line Suppression algorithm

  Parameters:
    pSrc                Pointer to the source image
    srcStep             Step through the source image
    pFeature            Pointer to the feature points image
    featureStep         Step through the feature points image
    pDst                Pointer to the destination image
    dstStep             Step through the destination image in pixels.
    roiSize             Size of the source and destination image ROI.
    filterType          Type of derivative operator
    filterMask          Predefined mask of IppiMaskSize type.
    avgWndSize          Size of a rectangle Window for computing an average value
    threshold           Line suppression threshold
    border              Type of the border
    borderValue         Constant value to assign to pixels of the constant border. if border type equals ippBorderConstant
    pBuffer             Pointer to the work buffer

  Return Values:
    ippStsNoErr          Indicates no error.
    ippStsNullPtrErr     Indicates an error condition if pSrc,  pFeature, pDst or pBufferSize is NULL.
    ippStsSizeErr        Indicates an error in the two cases:
                            if roiSize is negative,  or equal to zero;
                            if avgWndSize is equal to zero.
    ippStsFilterTypeErr  Indicates an error when filterType has illegal value.
    ippStsMaskSizeErr    Indicates an error condition if mask has an illegal value.
    ippStsBorderErr      Indicates an error when borderType has illegal value.
    ippStsStepErr        Indicates an error condition,  if srcStep or dstStep has negative value
    ippStsInplaceModeNotSupportedErr Indicates an error condition if the pFeature and pDst points to the same image
}

 function ippiLineSuppression_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pFeature : Ipp8uPtr ; featureStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; filterType : IppiDifferentialKernel ; filterMask : IppiMaskSize ; avgWndSize : Ipp32u ; threshold : float ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiMarkSpecklesGetBufferSize

  Purpose:            Computes the size of the external buffer for ippiFilterSpeckle function

  Parameters:
   dstRoiSize         Size of destination ROI in pixels.
   dataType           Data type of the source and destination images.
   numChannels        Number of channels in the images. Possible value is 1.
   pBufferSize        Pointer to the size (in bytes) of the external work buffer.

  Return Values:
   ippStsNoErr        Indicates no error.
   ippStsNullPtrErr   Indicates an error when pBufferSize is NULL.
   ippStsSizeErr      Indicates an error when roiSize is negative,  or equal to zero.
   ippStsDataTypeErr  Indicates an error when dataType has an illegal value.
   ippStsNumChannelsErr Indicates an error when numChannels has an illegal value.
}

 function ippiMarkSpecklesGetBufferSize( roiSize : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:                ippiMarkSpeckles
  Purpose:             Performs filtering of small noise blobs (speckles)
                       in the image

  Parameters:
    pSrcDst            Pointer to the source and destination image
    srcDstStep         Step through the source and destination image
    roiSize            Size of the source and destination image ROI.
    speckleVal         The disparity value used to paint-off the speckles
    maxSpeckleSize     The maximum speckle size to consider it a speckle.
    maxPixDiff         Maximum difference between neighbor pixels to put them into the same blob.
    norm               Specifies type of the norm to form the mask for marker propagation:
                          ippiNormInf Infinity norm (8-connectivity);
                          ippiNormL1  L1 norm (4-connectivity).
    pBuffer            Pointer to the work buffer

  Return Values:
    ippStsNoErr        Indicates no error.
    ippStsNullPtrErr   Indicates an error condition if pSrc,  pDst or pBufferSize is NULL.
    ippStsSizeErr      Indicates an error when roiSize is negative,  or equal to zero.
    ippStsNotEvenStepErr Indicated an error when one of the step values is not divisible by 4
                       for floating-point images,  or by 2 for short-integer images.
    ippStsNormErr      Indicates an error when norm is incorrect or not supported
}

 function ippiMarkSpeckles_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; speckleVal : Ipp8u ; maxSpeckleSize : Int32 ; maxPixDiff : Ipp8u ; norm : IppiNorm ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMarkSpeckles_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; speckleVal : Ipp16u ; maxSpeckleSize : Int32 ; maxPixDiff : Ipp16u ; norm : IppiNorm ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMarkSpeckles_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; speckleVal : Ipp16s ; maxSpeckleSize : Int32 ; maxPixDiff : Ipp16s ; norm : IppiNorm ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMarkSpeckles_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; speckleVal : Ipp32f ; maxSpeckleSize : Int32 ; maxPixDiff : Ipp32f ; norm : IppiNorm ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ -------------------------- FastN ------------------------------------------- }

{ ----------------------------------------------------------------------------

  Name:               ippiFastNGetSize
  Purpose:            initialization of Spec for FastN

  Parameters:
    srcSize           Roi size (in pixels) of source image what will be applied
                      for processing
    circleRadius      Radius for corner finding. Possible values are 1,  3, 5, 7, 9.
    N                 Critical number of pixels that have different value.
    orientationBins   The number bins for defining dirrection
    option            defines the moded of processing
    dataType          Data type of the source images. Possible value is Ipp8u.
    nChannels         Number of channels in the images. Possible value is 1.
    pSpecSize         Pointer to the size (in bytes) of the spec.
  Return:
    ippStsNoErr               OK
    ippStsNullPtrErr          pointer to pSpecSize is NULL
    ippStsSizeErr             size of srcSize is less or equal 0
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsNumChannelsErr      Indicates an error when numChannels has an illegal value.
    ippStsOutOfRangeErr       Indicates an error when orientation Bins or N have an illegal value.
    ippStsBadArgErr           Indicates an error when option or circleRadius have an illegal value.
}

 function ippiFastNGetSize( srcSize : IppiSize ; circleRadius : Int32 ; N : Int32 ; orientationBins : Int32 ; option : Int32 ; dataType : IppDataType ; nChannels : Int32 ; var pSpecSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiFastNInit
  Purpose:            to define spec size for FastN

  Parameters:
    srcSize           Roi size (in pixels) of source image what will be applied
                      for processing
    circleRadius      Radius for corner finding. Possible values are 1,  3, 5, 7, 9.
    N                 Critical number of pixels that have different value.
    orientationBins   The number bins for defining dirrection
    option            defines the moded of processing
    threshold         the level for definition of critical pixels
    dataType          Data type of the source images. Possible value is Ipp8u.
    nChannels         Number of channels in the images. Possible value is 1.
    pSpec             pointer to Spec
  Return:
    ippStsNoErr               OK
    ippStsNullPtrErr          pointer to pSpecSize is NULL
    ippStsSizeErr             size of srcSize is less or equal 0
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsNumChannelsErr      Indicates an error when numChannels has an illegal value.
    ippStsOutOfRangeErr       Indicates an error when orientation Bins or N have an illegal value.
    ippStsBadArgErr           Indicates an error when option or circleRadius have an illegal value.
    ippStsThresholdErr        threshold ia less 0
}

 function ippiFastNInit( srcSize : IppiSize ; circleRadius : Int32 ; N : Int32 ; orientationBins : Int32 ; option : Int32 ; threshold : Ipp32f ; dataType : IppDataType ; nChannels : Int32 ; pSpec : IppiFastNSpecPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiFastNGetBufferSize
  Purpose:            to define size of working buffer for FastN

  Parameters:
    pSpec             pointer to Spec
    dstRoiSiz         Roi size (in pixels) of destination image what will be applied
                      for processing
    pBufSize          Pointer to the size (in bytes) of the working buffer.
}

 function ippiFastNGetBufferSize( pSpec : IppiFastNSpecPtr ; dstRoiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiFastN_8u_C1R
  Purpose:            corner finding FastN

  Parameters:
    pSrc              Pointer to the source image
    srcStep           Step through the source image
    pDstCorner        Pointer to the destinartion corner image
    dstCornerStep     Step through the destinartion corner image
    pDstScore         Pointer to the destinartion score image
    dstScoreStep      Step through the destinartion score image
    pNumCorner        pointer to number of corners in source image
    srcRoiOffset      offset in source image
    dstRoiSize        Roi size (in pixels) of destination image what will be applied
                      for processing
    pSpec             pointer to Spec
    pBuffer           pointer to working buffer
  Return:
    ippStsNoErr               OK
    ippStsNullPtrErr          pointer to Src,  DstCorner, Spec or Buffer is NULL
    ippStsSizeErr             sizes of srcSize or dstRoiSize are less or equal 0
    ippStsContextMatchErr     spec is not match
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsNumChannelsErr      Indicates an error when numChannels has an illegal value.
    ippStsOutOfRangeErr       Indicates an error when orientation Bins or N have an illegal value.
    ippStsBadArgErr           Indicates an error when option or circleRadius have an illegal value.
    ippStsThresholdErr        threshold ia less 0
}

 function ippiFastN_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDstCorner : Ipp8uPtr ; dstCornerStep : Int32 ; pDstScore : Ipp8uPtr ; dstScoreStep : Int32 ; pNumCorner : Int32Ptr ; srcRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiFastNSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiFastN_8u_C1R
  Purpose:            corner finding FastN

  Parameters:
    pSrcCorner        Pointer to the source corner image
    srcCornerStep     Step through the source corner image
    pSrcScore         Pointer to the source score image
    srcScoreStep      Step through the source score image
    pDst              pointer to array of structures
    SrcRoiSize        Roi size (in pixels) of source images what will be applied
    maxLen            length of array of structures
    pNumCorners       pointer to number of corners
    pSpec             pointer to Spec
  Return:
    ippStsNoErr               OK
    ippStsNullPtrErr          pointer to pSrcCorner,  pSrcScore, pDst or Spec is NULL
    ippStsSizeErr             sizes of srcSize or dstRoiSize are less or equal 0
    ippStsContextMatchErr     spec is not match
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsNumChannelsErr      Indicates an error when numChannels has an illegal value.
    ippStsOutOfRangeErr       Indicates an error when orientation Bins or N have an illegal value.
    ippStsBadArgErr           Indicates an error when option or circleRadius have an illegal value.
    ippStsThresholdErr        threshold ia less 0
}

 function ippiFastN2DToVec_8u( pSrcCorner : Ipp8uPtr ; srcCornerStep : Int32 ; pSrcScore : Ipp8uPtr ; srcScoreStep : Int32 ; pDst : IppiCornerFastNPtr ; srcRoiSize : IppiSize ; maxLen : Int32 ; pNumCorners : Int32Ptr ; pSpec : IppiFastNSpecPtr ): IppStatus; _ippapi

 function ippiFGMMGetBufferSize_8u_C3R( roi : IppiSize ; maxNGauss : Int32 ; var pSpecSize : Int32 ): IppStatus; _ippapi
 function ippiFGMMInit_8u_C3R( roi : IppiSize ; maxNGauss : Int32 ; pModel : IppFGMModelPtr ; pState : IppFGMMState_8u_C3RPtr ): IppStatus; _ippapi
 function ippiFGMMForeground_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roi : IppiSize ; pState : IppFGMMState_8u_C3RPtr ; pModel : IppFGMModelPtr ; learning_rate : double ): IppStatus; _ippapi
 function ippiFGMMBackground_8u_C3R( pDst : Ipp8uPtr ; dstStep : Int32 ; roi : IppiSize ; pState : IppFGMMState_8u_C3RPtr ): IppStatus; _ippapi


{
              Intel(R) Integrated Performance Primitives
              Image Processing
}

{ ----------------------------------------------------------------------------

                   Functions declarations

{ ----------------------------------------------------------------------------

  Name:       ippiGetLibVersion
  Purpose:    gets the version of the library
  Returns:    structure containing information about the current version of
  the Intel IPP library for image processing
  Parameters:

  Notes:      there is no need to release the returned structure
}

 function ippiGetLibVersion: IppLibraryVersionPtr; _ippapi

{ ----------------------------------------------------------------------------

                   Memory Allocation Functions
{ ----------------------------------------------------------------------------


  Name:       ippiMalloc
  Purpose:    allocates memory with 32-byte aligned pointer for ippIP images, 
              every line of the image is aligned due to the padding characterized
              by pStepBytes
  Parameter:
    widthPixels   width of image in pixels
    heightPixels  height of image in pixels
    pStepBytes    pointer to the image step,  it is an output parameter
                  calculated by the function

  Returns:    pointer to the allocated memory or NULL if out of memory or wrong parameters
  Notes:      free the allocated memory using the function ippiFree only
}

 function ippiMalloc_8u_C1( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp8uPtr; _ippapi
 function ippiMalloc_16u_C1( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp16uPtr; _ippapi
 function ippiMalloc_16s_C1( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp16sPtr; _ippapi
 function ippiMalloc_32s_C1( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32sPtr; _ippapi
 function ippiMalloc_32f_C1( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32fPtr; _ippapi
 function ippiMalloc_32sc_C1( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32scPtr; _ippapi
 function ippiMalloc_32fc_C1( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32fcPtr; _ippapi

 function ippiMalloc_8u_C2( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp8uPtr; _ippapi
 function ippiMalloc_16u_C2( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp16uPtr; _ippapi
 function ippiMalloc_16s_C2( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp16sPtr; _ippapi
 function ippiMalloc_32s_C2( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32sPtr; _ippapi
 function ippiMalloc_32f_C2( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32fPtr; _ippapi
 function ippiMalloc_32sc_C2( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32scPtr; _ippapi
 function ippiMalloc_32fc_C2( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32fcPtr; _ippapi

 function ippiMalloc_8u_C3( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp8uPtr; _ippapi
 function ippiMalloc_16u_C3( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp16uPtr; _ippapi
 function ippiMalloc_16s_C3( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp16sPtr; _ippapi
 function ippiMalloc_32s_C3( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32sPtr; _ippapi
 function ippiMalloc_32f_C3( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32fPtr; _ippapi
 function ippiMalloc_32sc_C3( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32scPtr; _ippapi
 function ippiMalloc_32fc_C3( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32fcPtr; _ippapi

 function ippiMalloc_8u_C4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp8uPtr; _ippapi
 function ippiMalloc_16u_C4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp16uPtr; _ippapi
 function ippiMalloc_16s_C4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp16sPtr; _ippapi
 function ippiMalloc_32s_C4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32sPtr; _ippapi
 function ippiMalloc_32f_C4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32fPtr; _ippapi
 function ippiMalloc_32sc_C4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32scPtr; _ippapi
 function ippiMalloc_32fc_C4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32fcPtr; _ippapi

 function ippiMalloc_8u_AC4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp8uPtr; _ippapi
 function ippiMalloc_16u_AC4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp16uPtr; _ippapi
 function ippiMalloc_16s_AC4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp16sPtr; _ippapi
 function ippiMalloc_32s_AC4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32sPtr; _ippapi
 function ippiMalloc_32f_AC4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ):Ipp32fPtr; _ippapi
 function ippiMalloc_32sc_AC4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ): Ipp32scPtr; _ippapi
 function ippiMalloc_32fc_AC4( widthPixels : Int32 ; heightPixels : Int32 ; pStepBytes : Int32Ptr ): Ipp32fcPtr; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiFree
  Purpose:    frees memory allocated by the ippiMalloc functions
  Parameter:
    ptr       pointer to the memory allocated by the ippiMalloc functions

  Notes:      use this function to free memory allocated by ippiMalloc
}

procedure ippiFree(ptr : Pointer ); _ippapi

{ ----------------------------------------------------------------------------

                  Arithmetic Functions
{ ----------------------------------------------------------------------------


  Name:  ippiAdd_8u_C1RSfs,  ippiAdd_8u_C3RSfs,  ippiAdd_8u_C4RSfs,  ippiAdd_8u_AC4RSfs,
         ippiAdd_16s_C1RSfs, ippiAdd_16s_C3RSfs, ippiAdd_16s_C4RSfs, ippiAdd_16s_AC4RSfs,
         ippiAdd_16u_C1RSfs, ippiAdd_16u_C3RSfs, ippiAdd_16u_C4RSfs, ippiAdd_16u_AC4RSfs,
         ippiSub_8u_C1RSfs,  ippiSub_8u_C3RSfs,  ippiSub_8u_C4RSfs,  ippiSub_8u_AC4RSfs,
         ippiSub_16s_C1RSfs, ippiSub_16s_C3RSfs, ippiSub_16s_C4RSfs, ippiSub_16s_AC4RSfs,
         ippiSub_16u_C1RSfs, ippiSub_16u_C3RSfs, ippiSub_16u_C4RSfs, ippiSub_16u_AC4RSfs,
         ippiMul_8u_C1RSfs,  ippiMul_8u_C3RSfs,  ippiMul_8u_C4RSfs,  ippiMul_8u_AC4RSfs,
         ippiMul_16s_C1RSfs, ippiMul_16s_C3RSfs, ippiMul_16s_C4RSfs, ippiMul_16s_AC4RSfs
         ippiMul_16u_C1RSfs, ippiMul_16u_C3RSfs, ippiMul_16u_C4RSfs, ippiMul_16u_AC4RSfs

  Purpose:    Adds, subtracts, or multiplies pixel values of two
              source images and places the scaled result in the destination image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            Width or height of images is less than or equal to zero

  Parameters:
    pSrc1, pSrc2             Pointers to the source images
    src1Step, src2Step       Steps through the source images
    pDst                     Pointer to the destination image
    dstStep                  Step through the destination image
    roiSize                  Size of the ROI
    scaleFactor              Scale factor
}

 function ippiAdd_8u_C1RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_8u_C3RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_8u_C4RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_8u_AC4RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16s_C1RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16s_C3RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16s_C4RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16s_AC4RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16u_C1RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16u_C3RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16u_C4RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16u_AC4RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_8u_C1RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_8u_C3RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_8u_C4RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_8u_AC4RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16s_C1RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16s_C3RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16s_C4RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16s_AC4RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16u_C1RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16u_C3RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16u_C4RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16u_AC4RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_8u_C1RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_8u_C3RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_8u_C4RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_8u_AC4RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16s_C1RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16s_C3RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16s_C4RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16s_AC4RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16u_C1RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16u_C3RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16u_C4RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16u_AC4RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name: ippiAddC_8u_C1IRSfs,  ippiAddC_8u_C3IRSfs,  ippiAddC_8u_C4IRSfs,   ippiAddC_8u_AC4IRSfs,
        ippiAddC_16s_C1IRSfs, ippiAddC_16s_C3IRSfs, ippiAddC_16s_C4IRSfs,  ippiAddC_16s_AC4IRSfs,
        ippiAddC_16u_C1IRSfs, ippiAddC_16u_C3IRSfs, ippiAddC_16u_C4IRSfs,  ippiAddC_16u_AC4IRSfs,
        ippiSubC_8u_C1IRSfs,  ippiSubC_8u_C3IRSfs,  ippiSubC_8u_C4IRSfs,   ippiSubC_8u_AC4IRSfs,
        ippiSubC_16s_C1IRSfs, ippiSubC_16s_C3IRSfs, ippiSubC_16s_C4IRSfs,  ippiSubC_16s_AC4IRSfs,
        ippiSubC_16u_C1IRSfs, ippiSubC_16u_C3IRSfs, ippiSubC_16u_C4IRSfs,  ippiSubC_16u_AC4IRSfs,
        ippiMulC_8u_C1IRSfs,  ippiMulC_8u_C3IRSfs,  ippiMulC_8u_C4IRSfs,   ippiMulC_8u_AC4IRSfs,
        ippiMulC_16s_C1IRSfs, ippiMulC_16s_C3IRSfs, ippiMulC_16s_C4IRSfs,  ippiMulC_16s_AC4IRSfs
        ippiMulC_16u_C1IRSfs, ippiMulC_16u_C3IRSfs, ippiMulC_16u_C4IRSfs,  ippiMulC_16u_AC4IRSfs

  Purpose:    Adds, subtracts, or multiplies pixel values of an image and a constant
              and places the scaled results in the same image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         Pointer is NULL
    ippStsSizeErr            Width or height of an image is less than or equal to zero

  Parameters:
    value                    Constant value (constant vector for multi-channel images)
    pSrcDst                  Pointer to the image
    srcDstStep               Step through the image
    roiSize                  Size of the ROI
    scaleFactor              Scale factor
}

 function ippiAddC_8u_C1IRSfs( value : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_8u_C3IRSfs(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_8u_C4IRSfs(const value : Ipp8u_4 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_8u_AC4IRSfs(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16s_C1IRSfs( value : Ipp16s ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16s_C3IRSfs(const value : Ipp16s_3 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16s_C4IRSfs(const value : Ipp16s_4 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16s_AC4IRSfs(const value : Ipp16s_3 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16u_C1IRSfs( value : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16u_C3IRSfs(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16u_C4IRSfs(const value : Ipp16u_4 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16u_AC4IRSfs(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_8u_C1IRSfs( value : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_8u_C3IRSfs(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_8u_C4IRSfs(const value : Ipp8u_4 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_8u_AC4IRSfs(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16s_C1IRSfs( value : Ipp16s ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16s_C3IRSfs(const value : Ipp16s_3 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16s_C4IRSfs(const value : Ipp16s_4 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16s_AC4IRSfs(const value : Ipp16s_3 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16u_C1IRSfs( value : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16u_C3IRSfs(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16u_C4IRSfs(const value : Ipp16u_4 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16u_AC4IRSfs(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_8u_C1IRSfs( value : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_8u_C3IRSfs(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_8u_C4IRSfs(const value : Ipp8u_4 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_8u_AC4IRSfs(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16s_C1IRSfs( value : Ipp16s ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16s_C3IRSfs(const value : Ipp16s_3 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16s_C4IRSfs(const value : Ipp16s_4 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16s_AC4IRSfs(const value : Ipp16s_3 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16u_C1IRSfs( value : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16u_C3IRSfs(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16u_C4IRSfs(const value : Ipp16u_4 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16u_AC4IRSfs(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name: ippiAddC_8u_C1RSfs,  ippiAddC_8u_C3RSfs,  ippiAddC_8u_C4RSfs   ippiAddC_8u_AC4RSfs,
        ippiAddC_16s_C1RSfs, ippiAddC_16s_C3RSfs, ippiAddC_16s_C4RSfs, ippiAddC_16s_AC4RSfs,
        ippiAddC_16u_C1RSfs, ippiAddC_16u_C3RSfs, ippiAddC_16u_C4RSfs, ippiAddC_16u_AC4RSfs,
        ippiSubC_8u_C1RSfs,  ippiSubC_8u_C3RSfs,  ippiSubC_8u_C4RSfs,  ippiSubC_8u_AC4RSfs,
        ippiSubC_16s_C1RSfs, ippiSubC_16s_C3RSfs, ippiSubC_16s_C4RSfs, ippiSubC_16s_AC4RSfs,
        ippiSubC_16u_C1RSfs, ippiSubC_16u_C3RSfs, ippiSubC_16u_C4RSfs, ippiSubC_16u_AC4RSfs,
        ippiMulC_8u_C1RSfs,  ippiMulC_8u_C3RSfs,  ippiMulC_8u_C4RSfs,  ippiMulC_8u_AC4RSfs,
        ippiMulC_16s_C1RSfs, ippiMulC_16s_C3RSfs, ippiMulC_16s_C4RSfs, ippiMulC_16s_AC4RSfs
        ippiMulC_16u_C1RSfs, ippiMulC_16u_C3RSfs, ippiMulC_16u_C4RSfs, ippiMulC_16u_AC4RSfs

  Purpose:    Adds, subtracts, or multiplies pixel values of a source image
              and constant : a ; and places the scaled results in the destination image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            Width or height of images is less than or equal to zero

  Parameters:
    value                    Constant value (constant vector for multi-channel images)
    pSrc                     Pointer to the source image
    srcStep                  Step through the source image
    pDst                     Pointer to the destination image
    dstStep                  Step through the destination image
    roiSize                  Size of the ROI
    scaleFactor              Scale factor
}

 function ippiAddC_8u_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_8u_C3RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_8u_C4RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_8u_AC4RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16s_C1RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; value : Ipp16s ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16s_C3RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16s_C4RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_4 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16s_AC4RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16u_C1RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16u_C3RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16u_C4RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAddC_16u_AC4RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_8u_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_8u_C3RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_8u_C4RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_8u_AC4RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16s_C1RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; value : Ipp16s ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16s_C3RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16s_C4RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_4 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16s_AC4RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16u_C1RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16u_C3RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16u_C4RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSubC_16u_AC4RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_8u_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_8u_C3RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_8u_C4RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_8u_AC4RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16s_C1RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; value : Ipp16s ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16s_C3RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16s_C4RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_4 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16s_AC4RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16u_C1RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16u_C3RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16u_C4RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMulC_16u_AC4RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name: ippiAdd_8u_C1IRSfs,  ippiAdd_8u_C3IRSfs,  ippiAdd_8u_C4IRSfs,  ippiAdd_8u_AC4IRSfs,
        ippiAdd_16s_C1IRSfs, ippiAdd_16s_C3IRSfs, ippiAdd_16s_C4IRSfs, ippiAdd_16s_AC4IRSfs,
        ippiAdd_16u_C1IRSfs, ippiAdd_16u_C3IRSfs, ippiAdd_16u_C4IRSfs, ippiAdd_16u_AC4IRSfs,
        ippiSub_8u_C1IRSfs,  ippiSub_8u_C3IRSfs,  ippiSub_8u_C4IRSfs,  ippiSub_8u_AC4IRSfs,
        ippiSub_16s_C1IRSfs, ippiSub_16s_C3IRSfs, ippiSub_16s_C4IRSfs  ippiSub_16s_AC4IRSfs,
        ippiSub_16u_C1IRSfs, ippiSub_16u_C3IRSfs, ippiSub_16u_C4IRSfs  ippiSub_16u_AC4IRSfs,
        ippiMul_8u_C1IRSfs,  ippiMul_8u_C3IRSfs,  ippiMul_8u_C4IRSfs,  ippiMul_8u_AC4IRSfs,
        ippiMul_16s_C1IRSfs, ippiMul_16s_C3IRSfs, ippiMul_16s_C4IRSfs, ippiMul_16s_AC4IRSfs
        ippiMul_16u_C1IRSfs, ippiMul_16u_C3IRSfs, ippiMul_16u_C4IRSfs, ippiMul_16u_AC4IRSfs

  Purpose:    Adds, subtracts, or multiplies pixel values of two source images
              and places the scaled results in the first source image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            Width or height of images is less than or equal to zero

  Parameters:
    pSrc                     Pointer to the second source image
    srcStep                  Step through the second source image
    pSrcDst                  Pointer to the first source/destination image
    srcDstStep               Step through the first source/destination image
    roiSize                  Size of the ROI
    scaleFactor              Scale factor
}

 function ippiAdd_8u_C1IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_8u_C3IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_8u_C4IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_8u_AC4IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16s_C1IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16s_C3IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16s_C4IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16s_AC4IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16u_C1IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16u_C3IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16u_C4IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiAdd_16u_AC4IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_8u_C1IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_8u_C3IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_8u_C4IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_8u_AC4IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16s_C1IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16s_C3IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16s_C4IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16s_AC4IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16u_C1IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16u_C3IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16u_C4IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSub_16u_AC4IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_8u_C1IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_8u_C3IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_8u_C4IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_8u_AC4IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16s_C1IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16s_C3IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16s_C4IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16s_AC4IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16u_C1IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16u_C3IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16u_C4IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiMul_16u_AC4IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name: ippiAddC_32f_C1R, ippiAddC_32f_C3R, ippiAddC_32f_C4R,  ippiAddC_32f_AC4R,
        ippiSubC_32f_C1R, ippiSubC_32f_C3R, ippiSubC_32f_C4R,  ippiSubC_32f_AC4R,
        ippiMulC_32f_C1R, ippiMulC_32f_C3R, ippiMulC_32f_C4R,  ippiMulC_32f_AC4R

  Purpose:    Adds, subtracts, or multiplies pixel values of a source image
              and a constant,  and places the results in a destination image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            Width or height of images is less than or equal to zero

  Parameters:
    value                    The constant value for the specified operation
    pSrc                     Pointer to the source image
    srcStep                  Step through the source image
    pDst                     Pointer to the destination image
    dstStep                  Step through the destination image
    roiSize                  Size of the ROI
}

 function ippiAddC_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; value : Ipp32f ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddC_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddC_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_4 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddC_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSubC_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; value : Ipp32f ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSubC_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSubC_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_4 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSubC_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulC_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; value : Ipp32f ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulC_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulC_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_4 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulC_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name: ippiAddC_32f_C1IR, ippiAddC_32f_C3IR, ippiAddC_32f_C4IR, ippiAddC_32f_AC4IR,
        ippiSubC_32f_C1IR, ippiSubC_32f_C3IR, ippiSubC_32f_C4IR, ippiSubC_32f_AC4IR,
        ippiMulC_32f_C1IR, ippiMulC_32f_C3IR, ippiMulC_32f_C4IR, ippiMulC_32f_AC4IR

  Purpose:    Adds, subtracts, or multiplies pixel values of an image
              and a constant,  and places the results in the same image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         Pointer is NULL
    ippStsSizeErr            Width or height of an image is less than or equal to zero

  Parameters:
    value                    The constant value for the specified operation
    pSrcDst                  Pointer to the image
    srcDstStep               Step through the image
    roiSize                  Size of the ROI
}

 function ippiAddC_32f_C1IR( value : Ipp32f ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddC_32f_C3IR(const value : Ipp32f_3 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddC_32f_C4IR(const value : Ipp32f_4 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAddC_32f_AC4IR(const value : Ipp32f_3 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSubC_32f_C1IR( value : Ipp32f ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSubC_32f_C3IR(const value : Ipp32f_3 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSubC_32f_C4IR(const value : Ipp32f_4 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSubC_32f_AC4IR(const value : Ipp32f_3 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulC_32f_C1IR( value : Ipp32f ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulC_32f_C3IR(const value : Ipp32f_3 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulC_32f_C4IR(const value : Ipp32f_4 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulC_32f_AC4IR(const value : Ipp32f_3 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name: ippiAdd_32f_C1IR, ippiAdd_32f_C3IR, ippiAdd_32f_C4IR, ippiAdd_32f_AC4IR,
        ippiSub_32f_C1IR, ippiSub_32f_C3IR, ippiSub_32f_C4IR, ippiSub_32f_AC4IR,
        ippiMul_32f_C1IR, ippiMul_32f_C3IR, ippiMul_32f_C4IR, ippiMul_32f_AC4IR

  Purpose:    Adds, subtracts, or multiplies pixel values of two source images
              and places the results in the first image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            Width or height of images is less than or equal to zero

  Parameters:
    pSrc                     Pointer to the second source image
    srcStep                  Step through the second source image
    pSrcDst                  Pointer to the  first source/destination image
    srcDstStep               Step through the first source/destination image
    roiSize                  Size of the ROI
}

 function ippiAdd_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAdd_32f_C3IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAdd_32f_C4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAdd_32f_AC4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSub_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSub_32f_C3IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSub_32f_C4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSub_32f_AC4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMul_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMul_32f_C3IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMul_32f_C4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMul_32f_AC4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name: ippiAdd_32f_C1R, ippiAdd_32f_C3R, ippiAdd_32f_C4R, ippiAdd_32f_AC4R,
        ippiSub_32f_C1R, ippiSub_32f_C3R, ippiSub_32f_C4R, ippiSub_32f_AC4R,
        ippiMul_32f_C1R, ippiMul_32f_C3R, ippiMul_32f_C4R, ippiMul_32f_AC4R

  Purpose:    Adds, subtracts, or multiplies pixel values of two
              source images and places the results in a destination image.

  Returns:
    ippStsNoErr            OK
    ippStsNullPtrErr       One of the pointers is NULL
    ippStsSizeErr          Width or height of images is less than or equal to zero

  Parameters:
    pSrc1, pSrc2           Pointers to the source images
    src1Step, src2Step     Steps through the source images
    pDst                   Pointer to the destination image
    dstStep                Step through the destination image

    roiSize                Size of the ROI
}

 function ippiAdd_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAdd_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAdd_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAdd_32f_AC4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSub_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSub_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSub_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSub_32f_AC4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMul_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMul_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMul_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMul_32f_AC4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiDiv_32f_C1R, ippiDiv_32f_C3R ippiDiv_32f_C4R ippiDiv_32f_AC4R

  Purpose:    Divides pixel values of an image by pixel values of another image
              and places the results in a destination image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field with zero or negative value
    ippStsStepErr            At least one step value is less than or equal to zero
    ippStsDivByZero          A warning that a divisor value is zero,  the function
                             execution is continued.
                             If a dividend is equal to zero,  then the result is NAN_32F;
                             if it is greater than zero,  then the result is INF_32F, 
                             if it is less than zero,  then the result is INF_NEG_32F

  Parameters:
    pSrc1                    Pointer to the divisor source image
    src1Step                 Step through the divisor source image
    pSrc2                    Pointer to the dividend source image
    src2Step                 Step through the dividend source image
    pDst                     Pointer to the destination image
    dstStep                  Step through the destination image
    roiSize                  Size of the ROI
}

 function ippiDiv_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDiv_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDiv_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDiv_32f_AC4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiDiv_16s_C1RSfs, ippiDiv_8u_C1RSfs, ippiDiv_16u_C1RSfs,
              ippiDiv_16s_C3RSfs, ippiDiv_8u_C3RSfs, ippiDiv_16u_C3RSfs,
              ippiDiv_16s_C4RSfs, ippiDiv_8u_C4RSfs, ippiDiv_16u_C4RSfs,
              ippiDiv_16s_AC4RSfs,ippiDiv_8u_AC4RSfs,ippiDiv_16u_AC4RSfs

  Purpose:    Divides pixel values of an image by pixel values of
              another image and places the scaled results in a destination
              image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field with zero or negative value
    ippStsStepErr            At least one step value is less than or equal to zero
    ippStsDivByZero          A warning that a divisor value is zero,  the function
                             execution is continued.
                    If a dividend is equal to zero,  then the result is zero;
                    if it is greater than zero,  then the result is IPP_MAX_16S,  or IPP_MAX_8U,  or IPP_MAX_16U
                    if it is less than zero (16s : for ), then the result is IPP_MIN_16S

  Parameters:
    pSrc1                    Pointer to the divisor source image
    src1Step                 Step through the divisor source image
    pSrc2                    Pointer to the dividend source image
    src2Step                 Step through the dividend source image
    pDst                     Pointer to the destination image
    dstStep                  Step through the destination image
    roiSize                  Size of the ROI
    scaleFactor              Scale factor
}

 function ippiDiv_16s_C1RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16s_C3RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16s_C4RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16s_AC4RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_8u_C1RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_8u_C3RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_8u_C4RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_8u_AC4RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16u_C1RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16u_C3RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16u_C4RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16u_AC4RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiDivC_32f_C1R, ippiDivC_32f_C3R
              ippiDivC_32f_C4R, ippiDivC_32f_AC4R

  Purpose:    Divides pixel values of a source image by a constant
              and places the results in a destination image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field with zero or negative value
    ippStsStepErr            step value is less than or equal to zero
    ippStsDivByZeroErr       The constant is equal to zero

  Parameters:
    value                    The constant divisor
    pSrc                     Pointer to the source image
    pDst                     Pointer to the destination image
    roiSize                  Size of the ROI
}

 function ippiDivC_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; value : Ipp32f ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDivC_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDivC_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const val : Ipp32f_4 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDivC_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiDivC_16s_C1RSfs, ippiDivC_8u_C1RSfs, ippiDivC_16u_C1RSfs,
              ippiDivC_16s_C3RSfs, ippiDivC_8u_C3RSfs, ippiDivC_16u_C3RSfs,
              ippiDivC_16s_C4RSfs, ippiDivC_8u_C4RSfs, ippiDivC_16u_C4RSfs,
              ippiDivC_16s_AC4RSfs,ippiDivC_8u_AC4RSfs,ippiDivC_16u_AC4RSfs

  Purpose:    Divides pixel values of a source image by a constant
              and places the scaled results in a destination image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field with zero or negative value
    ippStsStepErr            Step value is less than or equal to zero
    ippStsDivByZeroErr       The constant is equal to zero

  Parameters:
    value                    Constant divisor
    pSrc                     Pointer to the source image
    pDst                     Pointer to the destination image
    roiSize                  Size of the ROI
    scaleFactor              Scale factor
}

 function ippiDivC_16s_C1RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; value : Ipp16s ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16s_C3RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16s_C4RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_4 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16s_AC4RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_8u_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_8u_C3RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_8u_C4RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_8u_AC4RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16u_C1RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16u_C3RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16u_C4RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16u_AC4RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiDiv_32f_C1IR, ippiDiv_32f_C3IR ippiDiv_32f_C4IR ippiDiv_32f_AC4IR

  Purpose:    Divides pixel values of an image by pixel values of
              another image and places the results in the dividend source
              image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field with zero or negative value
    ippStsStepErr            At least one step value is less than or equal to zero
    ippStsDivByZero          A warning that a divisor value is zero,  the function
                             execution is continued.
                             If a dividend is equal to zero,  then the result is NAN_32F;
                             if it is greater than zero,  then the result is INF_32F, 
                             if it is less than zero,  then the result is INF_NEG_32F

  Parameters:
    pSrc                     Pointer to the divisor source image
    srcStep                  Step through the divisor source image
    pSrcDst                  Pointer to the dividend source/destination image
    srcDstStep               Step through the dividend source/destination image
    roiSize                  Size of the ROI
}

 function ippiDiv_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDiv_32f_C3IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDiv_32f_C4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDiv_32f_AC4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiDiv_16s_C1IRSfs, ippiDiv_8u_C1IRSfs, ippiDiv_16u_C1IRSfs,
              ippiDiv_16s_C3IRSfs, ippiDiv_8u_C3IRSfs, ippiDiv_16u_C3IRSfs,
              ippiDiv_16s_C4IRSfs, ippiDiv_8u_C4IRSfs, ippiDiv_16u_C4IRSfs,
              ippiDiv_16s_AC4IRSfs,ippiDiv_8u_AC4IRSfs,ippiDiv_16u_AC4IRSfs

  Purpose:    Divides pixel values of an image by pixel values of
              another image and places the scaled results in the dividend
              source image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field with zero or negative value
    ippStsStepErr            At least one step value is less than or equal to zero
    ippStsDivByZero          A warning that a divisor value zero : is ; the function
                             execution is continued.
                    If a dividend is equal zero : to ; then the result is zero;
                    if it is greater zero : than ; then the result IPP_MAX_16S : is ; IPP_MAX_8U : or ; or IPP_MAX_16U
                    if it is less than zero (16s : for ), then the result is IPP_MIN_16S

  Parameters:
    pSrc                     Pointer to the divisor source image
    srcStep                  Step through the divisor source image
    pSrcDst                  Pointer to the dividend source/destination image
    srcDstStep               Step through the dividend source/destination image
    roiSize                  Size of the ROI
    scaleFactor              Scale factor
}

 function ippiDiv_16s_C1IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16s_C3IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16s_C4IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16s_AC4IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_8u_C1IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_8u_C3IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_8u_C4IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_8u_AC4IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16u_C1IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16u_C3IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16u_C4IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_16u_AC4IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiDivC_32f_C1IR, ippiDivC_32f_C3IR,
              ippiDivC_32f_C4IR, ippiDivC_32f_AC4IR

  Purpose:    Divides pixel values of a source image by a constant
              and places the results in the same image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         The pointer is NULL
    ippStsSizeErr            The roiSize has a field with zero or negative value
    ippStsStepErr            The step value is less than or equal to zero
    ippStsDivByZeroErr       The constant is equal to zero

  Parameters:
    value                    The constant divisor
    pSrcDst                  Pointer to the source/destination image
    srcDstStep               Step through the source/destination image
    roiSize                  Size of the ROI
}

 function ippiDivC_32f_C1IR( value : Ipp32f ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDivC_32f_C3IR(const value : Ipp32f_3 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDivC_32f_C4IR(const val : Ipp32f_4 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDivC_32f_AC4IR(const Ipp32f_3 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiDivC_16s_C1IRSfs, ippiDivC_8u_C1IRSfs, ippiDivC_16u_C1IRSfs,
              ippiDivC_16s_C3IRSfs, ippiDivC_8u_C3IRSfs, ippiDivC_16u_C3IRSfs,
              ippiDivC_16s_C4IRSfs, ippiDivC_8u_C4IRSfs, ippiDivC_16u_C4IRSfs,
              ippiDivC_16s_AC4IRSfs,ippiDivC_8u_AC4IRSfs,ippiDivC_16u_AC4IRSfs

  Purpose:    Divides pixel values of a source image by a constant
              and places the scaled results in the same image.

  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         The pointer is NULL
    ippStsSizeErr            The roiSize has a field with zero or negative value
    ippStsStepErr            The step value is less than or equal to zero
    ippStsDivByZeroErr       The constant is equal to zero

  Parameters:
    value                    The constant divisor
    pSrcDst                  Pointer to the source/destination image
    srcDstStep               Step through the source/destination image
    roiSize                  Size of the ROI
    scaleFactor              Scale factor
}

 function ippiDivC_16s_C1IRSfs( value : Ipp16s ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16s_C3IRSfs(const value : Ipp16s_3 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16s_C4IRSfs(const val : Ipp16s_4 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16s_AC4IRSfs(const val : Ipp16s_3 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_8u_C1IRSfs( value : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_8u_C3IRSfs(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_8u_C4IRSfs(const val : Ipp8u_4 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_8u_AC4IRSfs(const val : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16u_C1IRSfs( value : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16u_C3IRSfs(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16u_C4IRSfs(const val : Ipp16u_4 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDivC_16u_AC4IRSfs(const val : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiAbs_16s_C1R
              ippiAbs_16s_C3R
              ippiAbs_16s_C4R
              ippiAbs_16s_AC4R
              ippiAbs_32f_C1R
              ippiAbs_32f_C3R
              ippiAbs_32f_C4R
              ippiAbs_32f_AC4R

              ippiAbs_16s_C1IR
              ippiAbs_16s_C3IR
              ippiAbs_16s_C4IR
              ippiAbs_16s_AC4IR
              ippiAbs_32f_C1IR
              ippiAbs_32f_C3IR
              ippiAbs_32f_C4IR
              ippiAbs_32f_AC4IR

  Purpose:    computes absolute value of each pixel of a source image and
              places results in the destination image;
              for in-place flavors - in the same source image
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  One of the pointers is NULL
   ippStsSizeErr     The roiSize has a field with negative or zero value

  Parameters:
   pSrc       pointer to the source image
   srcStep    step through the source image
   pDst       pointer to the destination image
   dstStep    step through the destination image
   pSrcDst    pointer to the source/destination image (for in-place function)
   srcDstStep step through the source/destination image (for in-place function)
   roiSize    size of the ROI
}

 function ippiAbs_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_16s_C4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAbs_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiSqr_8u_C1RSfs
              ippiSqr_8u_C3RSfs
              ippiSqr_8u_AC4RSfs
              ippiSqr_8u_C4RSfs
              ippiSqr_16u_C1RSfs
              ippiSqr_16u_C3RSfs
              ippiSqr_16u_AC4RSfs
              ippiSqr_16u_C4RSfs
              ippiSqr_16s_C1RSfs
              ippiSqr_16s_C3RSfs
              ippiSqr_16s_AC4RSfs
              ippiSqr_16s_C4RSfs
              ippiSqr_32f_C1R
              ippiSqr_32f_C3R
              ippiSqr_32f_AC4R
              ippiSqr_32f_C4R

              ippiSqr_8u_C1IRSfs
              ippiSqr_8u_C3IRSfs
              ippiSqr_8u_AC4IRSfs
              ippiSqr_8u_C4IRSfs
              ippiSqr_16u_C1IRSfs
              ippiSqr_16u_C3IRSfs
              ippiSqr_16u_AC4IRSfs
              ippiSqr_16u_C4IRSfs
              ippiSqr_16s_C1IRSfs
              ippiSqr_16s_C3IRSfs
              ippiSqr_16s_AC4IRSfs
              ippiSqr_16s_C4IRSfs
              ippiSqr_32f_C1IR
              ippiSqr_32f_C3IR
              ippiSqr_32f_AC4IR
              ippiSqr_32f_C4IR

  Purpose:    squares pixel values of an image and
              places results in the destination image;
              for in-place flavors - in  the same image
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  One of the pointers is NULL
   ippStsSizeErr     The roiSize has a field with negative or zero value

  Parameters:
   pSrc       pointer to the source image
   srcStep    step through the source image
   pDst       pointer to the destination image
   dstStep    step through the destination image
   pSrcDst    pointer to the source/destination image (for in-place function)
   srcDstStep step through the source/destination image (for in-place function)
   roiSize    size of the ROI
   scaleFactor scale factor
}

 function ippiSqr_8u_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_8u_C3RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_8u_AC4RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_8u_C4RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16u_C1RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16u_C3RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16u_AC4RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16u_C4RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16s_C1RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16s_C3RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16s_AC4RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16s_C4RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqr_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqr_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqr_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqr_8u_C1IRSfs( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_8u_C3IRSfs( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_8u_AC4IRSfs( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_8u_C4IRSfs( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16u_C1IRSfs( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16u_C3IRSfs( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16u_AC4IRSfs( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16u_C4IRSfs( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16s_C1IRSfs( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16s_C3IRSfs( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16s_AC4IRSfs( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_16s_C4IRSfs( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqr_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqr_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqr_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqr_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiSqrt_8u_C1RSfs
              ippiSqrt_8u_C3RSfs
              ippiSqrt_8u_AC4RSfs
              ippiSqrt_16u_C1RSfs
              ippiSqrt_16u_C3RSfs
              ippiSqrt_16u_AC4RSfs
              ippiSqrt_16s_C1RSfs
              ippiSqrt_16s_C3RSfs
              ippiSqrt_16s_AC4RSfs
              ippiSqrt_32f_C1R
              ippiSqrt_32f_C3R
              ippiSqrt_32f_AC4R

              ippiSqrt_8u_C1IRSfs
              ippiSqrt_8u_C3IRSfs
              ippiSqrt_8u_AC4IRSfs
              ippiSqrt_16u_C1IRSfs
              ippiSqrt_16u_C3IRSfs
              ippiSqrt_16u_AC4IRSfs
              ippiSqrt_16s_C1IRSfs
              ippiSqrt_16s_C3IRSfs
              ippiSqrt_16s_AC4IRSfs
              ippiSqrt_32f_C1IR
              ippiSqrt_32f_C3IR
              ippiSqrt_32f_AC4IR
              ippiSqrt_32f_C4IR
  Purpose:    computes square roots of pixel values of a source image and
              places results in the destination image;
              for in-place flavors - in the same image
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  One of pointers is NULL
   ippStsSizeErr     The roiSize has a field with negative or zero value
   ippStsSqrtNegArg  Source image pixel has a negative value

  Parameters:
   pSrc       pointer to the source image
   srcStep    step through the source image
   pDst       pointer to the destination image
   dstStep    step through the destination image
   pSrcDst    pointer to the source/destination image (for in-place function)
   srcDstStep step through the source/destination image (for in-place function)
   roiSize    size of the ROI
   scaleFactor scale factor
}

 function ippiSqrt_8u_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_8u_C3RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_8u_AC4RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16u_C1RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16u_C3RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16u_AC4RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16s_C1RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16s_C3RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16s_AC4RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqrt_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqrt_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqrt_8u_C1IRSfs( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_8u_C3IRSfs( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_8u_AC4IRSfs( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16u_C1IRSfs( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16u_C3IRSfs( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16u_AC4IRSfs( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16s_C1IRSfs( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16s_C3IRSfs( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_16s_AC4IRSfs( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiSqrt_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqrt_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqrt_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSqrt_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:
  ippiLn_32f_C1IR   ippiLn_16s_C1IRSfs  ippiLn_8u_C1IRSfs ippiLn_16u_C1IRSfs
  ippiLn_32f_C3IR   ippiLn_16s_C3IRSfs  ippiLn_8u_C3IRSfs ippiLn_16u_C3IRSfs
  ippiLn_32f_C1R    ippiLn_16s_C1RSfs   ippiLn_8u_C1RSfs  ippiLn_16u_C1RSfs
  ippiLn_32f_C3R    ippiLn_16s_C3RSfs   ippiLn_8u_C3RSfs  ippiLn_16u_C3RSfs
  Purpose:
     computes the natural logarithm of each pixel values of a source image
     and places the results in the destination image;
     for in-place flavors - in the same image
  Parameters:
    pSrc         Pointer to the source image.
    pDst         Pointer to the destination image.
    pSrcDst      Pointer to the source/destination image for in-place functions.
    srcStep      Step through the source image.
    dstStep      Step through the destination image.
    srcDstStep   Step through the source/destination image for in-place functions.
    roiSize      Size of the ROI.
    scaleFactor  Scale factor for integer data.
  Returns:
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsSizeErr       The roiSize has a field with negative or zero value
    ippStsStepErr       One of the step values is less than or equal to zero
    ippStsLnZeroArg     The source pixel has a zero value
    ippStsLnNegArg      The source pixel has a negative value
    ippStsNoErr         otherwise
}

 function ippiLn_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLn_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLn_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLn_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiLn_16s_C1IRSfs( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiLn_16s_C3IRSfs( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiLn_16s_C1RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiLn_16s_C3RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiLn_16u_C1RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ScalFact : Int32 ): IppStatus; _ippapi
 function ippiLn_16u_C3RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ScalFact : Int32 ): IppStatus; _ippapi

 function ippiLn_8u_C1IRSfs( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiLn_8u_C3IRSfs( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiLn_8u_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiLn_8u_C3RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiLn_16u_C1IRSfs( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScalFact : Int32 ): IppStatus; _ippapi
 function ippiLn_16u_C3IRSfs( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; ScalFact : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:
  ippiExp_32f_C1IR   ippiExp_16s_C1IRSfs  ippiExp_8u_C1IRSfs ippiExp_16u_C1IRSfs
  ippiExp_32f_C3IR   ippiExp_16s_C3IRSfs  ippiExp_8u_C3IRSfs ippiExp_16u_C3IRSfs
  ippiExp_32f_C1R    ippiExp_16s_C1RSfs   ippiExp_8u_C1RSfs  ippiExp_16u_C1RSfs
  ippiExp_32f_C3R    ippiExp_16s_C3RSfs   ippiExp_8u_C3RSfs  ippiExp_16u_C3RSfs
  Purpose:
     computes the exponential of pixel values in a source image
  Parameters:
    pSrc         Pointer to the source image.
    pDst         Pointer to the destination image.
    pSrcDst      Pointer to the source/destination image for in-place functions.
    srcStep      Step through the source image.
    dstStep      Step through the in destination image.
    srcDstStep   Step through the source/destination image for in-place functions.
    roiSize      Size of the ROI.
    scaleFactor  Scale factor for integer data.

  Returns:
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsSizeErr       The roiSize has a field with negative or zero value
    ippStsStepErr       One of the step values is less than or equal to zero
    ippStsNoErr         otherwise
}


 function ippiExp_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiExp_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiExp_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiExp_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiExp_16s_C1IRSfs( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiExp_16s_C3IRSfs( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiExp_16s_C1RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiExp_16s_C3RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiExp_16u_C1IRSfs( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; sFact : Int32 ): IppStatus; _ippapi
 function ippiExp_16u_C3IRSfs( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; sFact : Int32 ): IppStatus; _ippapi

 function ippiExp_8u_C1IRSfs( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiExp_8u_C3IRSfs( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiExp_8u_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiExp_8u_C3RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiExp_16u_C1RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; sFact : Int32 ): IppStatus; _ippapi
 function ippiExp_16u_C3RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; sFact : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                      Multiplication with Scaling
---------------------------------------------------------------------------- }
{
  Names:              ippiMulScale, ippiMulCScale

  Purpose:            Multiplies pixel values of two images (MulScale),
                      or pixel values of an image by a constant (MulScaleC) and scales the products

  Parameters:
   value              The constant value (constant vector for multi-channel images)
   pSrc               Pointer to the source image
   srcStep            Step through the source image
   pSrcDst            Pointer to the source/destination image (in-place operations)
   srcDstStep         Step through the source/destination image (in-place operations)
   pSrc1              Pointer to the first source image
   src1Step           Step through the first source image
   pSrc2              Pointer to the second source image
   src2Step           Step through the second source image
   pDst               Pointer to the destination image
   dstStep            Step through the destination image
   roiSize            Size of the image ROI

  Returns:
   ippStsNullPtrErr   One of the pointers is NULL
   ippStsStepErr      One of the step values is less than or equal to zero
   ippStsSizeErr      The roiSize has a field with negative or zero value
   ippStsNoErr        otherwise
}

 function ippiMulScale_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_8u_AC4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_8u_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_8u_C3IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_8u_C4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_8u_AC4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_8u_C1IR( value : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_8u_C3IR(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_8u_C4IR(const value : Ipp8u_4 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_8u_AC4IR(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiMulScale_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_16u_AC4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_16u_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_16u_C3IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_16u_C4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulScale_16u_AC4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_16u_C1IR( value : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_16u_C3IR(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_16u_C4IR(const value : Ipp16u_4 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulCScale_16u_AC4IR(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

              Dot product of two images
{ ----------------------------------------------------------------------------


  Name:           ippiDotProd
  Purpose:        Computes the dot product of two images
  Context:
  Returns:        IppStatus
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsStepErr      One of the step values is equal to zero
  Parameters:
    pSrc1       Pointer to the first source image.
    src1Step    Step in bytes through the first source image
    pSrc2       Pointer to the second source image.
    src2Step    Step in bytes through the  source image
    roiSize     Size of the source image ROI.
    pDp         Pointer to the result (one-channel data) or array (multi-channel data) containing computed dot products of channel values of pixels in the source images.
    hint        Option to select the algorithmic implementation of the function
  Notes:
}

 function ippiDotProd_8u64f_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64fPtr ): IppStatus; _ippapi
 function ippiDotProd_16u64f_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64fPtr ): IppStatus; _ippapi
 function ippiDotProd_16s64f_C1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64fPtr ): IppStatus; _ippapi
 function ippiDotProd_32u64f_C1R( pSrc1 : Ipp32uPtr ; src1Step : Int32 ; pSrc2 : Ipp32uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64fPtr ): IppStatus; _ippapi
 function ippiDotProd_32s64f_C1R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64fPtr ): IppStatus; _ippapi
 function ippiDotProd_32f64f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi

 function ippiDotProd_8u64f_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ): IppStatus; _ippapi
 function ippiDotProd_16u64f_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ): IppStatus; _ippapi
 function ippiDotProd_16s64f_C3R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ): IppStatus; _ippapi
 function ippiDotProd_32u64f_C3R( pSrc1 : Ipp32uPtr ; src1Step : Int32 ; pSrc2 : Ipp32uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ): IppStatus; _ippapi
 function ippiDotProd_32s64f_C3R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ): IppStatus; _ippapi
 function ippiDotProd_32f64f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ; hint : IppHintAlgorithm ): IppStatus; _ippapi

 function ippiDotProd_8u64f_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_4 ): IppStatus; _ippapi
 function ippiDotProd_16u64f_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_4 ): IppStatus; _ippapi
 function ippiDotProd_16s64f_C4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_4 ): IppStatus; _ippapi
 function ippiDotProd_32u64f_C4R( pSrc1 : Ipp32uPtr ; src1Step : Int32 ; pSrc2 : Ipp32uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_4 ): IppStatus; _ippapi
 function ippiDotProd_32s64f_C4R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_4 ): IppStatus; _ippapi
 function ippiDotProd_32f64f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_4 ; hint : IppHintAlgorithm ): IppStatus; _ippapi

 function ippiDotProd_8u64f_AC4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ): IppStatus; _ippapi
 function ippiDotProd_16u64f_AC4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ): IppStatus; _ippapi
 function ippiDotProd_16s64f_AC4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ): IppStatus; _ippapi
 function ippiDotProd_32u64f_AC4R( pSrc1 : Ipp32uPtr ; src1Step : Int32 ; pSrc2 : Ipp32uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ): IppStatus; _ippapi
 function ippiDotProd_32s64f_AC4R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ): IppStatus; _ippapi
 function ippiDotProd_32f64f_AC4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pDp : Ipp64f_3 ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

              Dot product of taps vector cand olumns, 
                  which are placed in stripe of rows
  ----------------------------------------------------------------------------

  Name:       ippiDotProdCol_32f_L2
              ippiDotProdCol_64f_L2

  Purpose:    Calculates the dot product of taps vector and columns, 
      which are placed in stripe of rows; useful for external vertical
      filtering pipeline implementation.

  Parameters:
    ppSrcRow              pointer to set of rows
    pTaps                 pointer to taps vector
    tapsLen               taps length and (equal to number of rows)
    pDst                  pointer where to store the result row
    width                 width of source and destination rows

  Returns:
    ippStsNoErr           OK
    ippStsNullPtrErr      one of the pointers is NULL
    ippStsSizeErr         width is less than or equal to zero
}

 function ippiDotProdCol_32f_L2( ppSrcRow : Ipp32fPtr ; pTaps : Ipp32fPtr ; tapsLen : Int32 ; pDst : Ipp32fPtr ; width : Int32 ): IppStatus; _ippapi
 function ippiDotProdCol_64f_L2( ppSrcRow : Ipp64fPtr ; pTaps : Ipp64fPtr ; tapsLen : Int32 ; pDst : Ipp64fPtr ; width : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

              Vector Multiplication of Images in RCPack2D Format
---------------------------------------------------------------------------- }
{  Name:               ippiMulPack, ippiMulPackConj

  Purpose:            Multiplies pixel values of two images in RCPack2D format
                      and store the result also in PCPack2D format

  Returns:
      ippStsNoErr       No errors
      ippStsNullPtrErr  One of the pointers is NULL
      ippStsStepErr     One of the step values is zero or negative
      ippStsSizeErr     The roiSize has a field with negative or zero value

  Parameters:
      pSrc            Pointer to the source image for in-place operation
      pSrcDst         Pointer to the source/destination image for in-place operation
      srcStep         Step through the source image for in-place operation
      srcDstStep      Step through the source/destination image for in-place operation
      pSrc1           Pointer to the first source image
      src1Step        Step through the first source image
      pSrc2           Pointer to the second source image
      src1Step        Step through the second source image
      pDst            Pointer to the destination image
      dstStep         Step through the destination image
      roiSize         Size of the source and destination ROI
      scaleFactor     Scale factor

  Notes:              Both in-place and not-in-place operations are supported
                      ippiMulPackConj functions are only for float data
}

 function ippiMulPack_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPack_32f_C3IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPack_32f_C4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPack_32f_AC4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiMulPack_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPack_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPack_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPack_32f_AC4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiMulPackConj_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPackConj_32f_C3IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPackConj_32f_C4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPackConj_32f_AC4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiMulPackConj_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPackConj_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPackConj_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMulPackConj_32f_AC4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiPackToCplxExtend

  Purpose:        Converts an image in RCPack2D format to a complex data image.

  Returns:
      ippStsNoErr            No errors
      ippStsNullPtrErr       pSrc == NULL, or pDst == NULL
      ippStsStepErr          One of the step values is less zero or negative
      ippStsSizeErr          The srcSize has a field with zero or negative value

  Parameters:
    pSrc        Pointer to the source image data (point to pixel (0,0))
    srcSize     Size of the source image
    srcStep     Step through  the source image
    pDst        Pointer to the destination image
    dstStep     Step through the destination image
  Notes:
}

 function ippiPackToCplxExtend_32f32fc_C1R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; pDst : Ipp32fcPtr ; dstStep : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiCplxExtendToPack

  Purpose:        Converts an image in complex data format to RCPack2D image.

  Returns:
      ippStsNoErr            No errors
      ippStsNullPtrErr       pSrc == NULL, or pDst == NULL
      ippStsStepErr          One of the step values is less zero or negative
      ippStsSizeErr          The srcSize has a field with zero or negative value

  Parameters:
    pSrc        Pointer to the source image data (point to pixel (0,0))
    srcSize     Size of the source image
    srcStep     Step through  the source image
    pDst        Pointer to the destination image
    dstStep     Step through the destination image
  Notes:
}

 function ippiCplxExtendToPack_32fc32f_C1R( pSrc : Ipp32fcPtr ; srcStep : Int32 ; srcSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ): IppStatus; _ippapi
 function ippiCplxExtendToPack_32fc32f_C3R( pSrc : Ipp32fcPtr ; srcStep : Int32 ; srcSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:         ippiPhasePack
 Purpose:       Computes the phase (in radians) of elements of an image in RCPack2D packed format.
 Parameters:
    pSrc        - Pointer to the source image.
    srcStep     - Distances, in bytes,  between the starting points of consecutive lines in the source images.
    pDst        - Pointer to the destination image.
    dstStep     - Distance, in bytes,  between the starting points of consecutive lines in the destination image.
    dstRoiSize  - Size, in pixels,  of the destination ROI.
    pBuffer     - Pointer to the buffer for internal calculations. Size of the buffer is calculated by ippiPhasePackGetBufferSize_32f.
    scaleFactor - Scale factor (only for integer data).
 Returns:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when dstRoiSize has a field with value less than 1.
    ippStsStepErr    - Error when srcStep or dstStep has a zero or negative value.
}

 function ippiPhasePack_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiPhasePack_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:         ippiPhasePackGetBufferSize_32f
 Purpose:       Gets the size (in bytes) of the buffer for ippiPhasePack internal calculations.
 Parameters:
    numChannels - Number of image channels. Possible values are 1 and 3.
    dstRoiSize  - Size, in pixels,  of the destination ROI.
    pSize       - Pointer to the calculated buffer size (in bytes).
 Return:
    ippStsNoErr          - OK.
    ippStsNullPtrErr     - Error when pSize pointer is NULL.
    ippStsSizeErr        - Error when dstRoiSize has a field with value less than 1.
    ippStsNumChannelsErr - Error when the numChannels value differs from 1 or 3.
}

 function ippiPhasePackGetBufferSize_32f( numChannels : Int32 ; dstRoiSize : IppiSize ; var pSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:         ippiMagnitudePack
 Purpose:       Computes magnitude of elements of an image in RCPack2D packed format.
 Parameters:
    pSrc        - Pointer to the source image.
    srcStep     - Distances, in bytes,  between the starting points of consecutive lines in the source images.
    pDst        - Pointer to the destination image.
    dstStep     - Distance, in bytes,  between the starting points of consecutive lines in the destination image.
    dstRoiSize  - Size, in pixels,  of the destination ROI.
    pBuffer     - Pointer to the buffer for internal calculations. Size of the buffer is calculated by ippiMagnitudePackGetBufferSize_32f.
    scaleFactor - Scale factor (only for integer data).
 Returns:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when dstRoiSize has a field with value less than 1.
    ippStsStepErr    - Error when srcStep or dstStep has a zero or negative value.
}

 function ippiMagnitudePack_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMagnitudePack_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:         ippiMagnitudePackGetBufferSize_32f
 Purpose:       Gets the size (in bytes) of the buffer for ippiMagnitudePack internal calculations.
 Parameters:
    numChannels - Number of image channels. Possible values are 1 and 3.
    dstRoiSize  - Size, in pixels,  of the destination ROI.
    pSize       - Pointer to the calculated buffer size (in bytes).
 Return:
    ippStsNoErr          - OK.
    ippStsNullPtrErr     - Error when pSize pointer is NULL.
    ippStsSizeErr        - Error when dstRoiSize has a field with value less than 1.
    ippStsNumChannelsErr - Error when the numChannels value differs from 1 or 3.
}

 function ippiMagnitudePackGetBufferSize_32f( numChannels : Int32 ; dstRoiSize : IppiSize ; var pSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:  ippiMagnitude_32fc32f_C1R
          ippiMagnitude_32fc32f_C3R
          ippiMagnitude_32sc32s_C1RSfs
          ippiMagnitude_32sc32s_C3RSfs
          ippiMagnitude_16sc16s_C1RSfs
          ippiMagnitude_16sc16s_C3RSfs
          ippiMagnitude_16uc16u_C1RSfs
          ippiMagnitude_16uc16u_C3RSfs
  Purpose:
    Computes magnitude of elements of a complex data image.
  Parameters:
    pSrc        Pointer to the source image in common complex data format
    srcStep     Step through the source image
    pDst        Pointer to the destination image to store magnitude components
    dstStep     Step through the destination image
    roiSize     Size of the ROI
    scaleFactor Scale factor (only for integer data)
  Returns:
    ippStsNullPtrErr    pSrc or pDst is NULL
    ippStsSizeErr       The width or height of images is less than or equal to zero
    ippStsStepErr       srcStep or dstStep is less than or equal to zero
    ippStsNoErr         Otherwise
}

 function ippiMagnitude_32fc32f_C1R( pSrc : Ipp32fcPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMagnitude_32fc32f_C3R( pSrc : Ipp32fcPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:   ippiPhase_32fc32f_C1R
           ippiPhase_32fc32f_C3R
           ippiPhase_16sc16s_C1RSfs
           ippiPhase_16sc16s_C3RSfs
           ippiPhase_16uc16u_C1RSfs
           ippiPhase_16uc16u_C3RSfs
  Purpose:
    Computes the phase (in radians) of elements of a complex data image
  Parameters:
    pSrc         Pointer to the source image in common complex data format
    srcStep      Step through the source image
    pDst         Pointer to the destination image to store the phase components
    dstStep      Step through the destination image
    roiSize      Size of the ROI
    scaleFactor  Scale factor (only for integer data)
  Returns:
    ippStsNullPtrErr    pSrc or pDst is NULL
    ippStsSizeErr       The width or height of images is less than or equal to zero
    ippStsStepErr       srcStep or dstStep is less than or equal to zero
    ippStsNoErr         Otherwise
}

 function ippiPhase_32fc32f_C1R( pSrc : Ipp32fcPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiPhase_32fc32f_C3R( pSrc : Ipp32fcPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
                  Alpha Compositing Operations
---------------------------------------------------------------------------- }
{
  Contents:
      ippiAlphaPremul_8u_AC4R,  ippiAlphaPremul_16u_AC4R
      ippiAlphaPremul_8u_AC4IR, ippiAlphaPremul_16u_AC4IR
      ippiAlphaPremul_8u_AP4R,  ippiAlphaPremul_16u_AP4R
      ippiAlphaPremul_8u_AP4IR, ippiAlphaPremul_16u_AP4IR
   Pre-multiplies pixel values of an image by its alpha values.

      ippiAlphaPremulC_8u_AC4R,  ippiAlphaPremulC_16u_AC4R
      ippiAlphaPremulC_8u_AC4IR, ippiAlphaPremulC_16u_AC4IR
      ippiAlphaPremulC_8u_AP4R,  ippiAlphaPremulC_16u_AP4R
      ippiAlphaPremulC_8u_AP4IR, ippiAlphaPremulC_16u_AP4IR
      ippiAlphaPremulC_8u_C4R,   ippiAlphaPremulC_16u_C4R
      ippiAlphaPremulC_8u_C4IR,  ippiAlphaPremulC_16u_C4IR
      ippiAlphaPremulC_8u_C3R,   ippiAlphaPremulC_16u_C3R
      ippiAlphaPremulC_8u_C3IR,  ippiAlphaPremulC_16u_C3IR
      ippiAlphaPremulC_8u_C1R,   ippiAlphaPremulC_16u_C1R
      ippiAlphaPremulC_8u_C1IR,  ippiAlphaPremulC_16u_C1IR
   Pre-multiplies pixel values of an image by constant alpha values.

      ippiAlphaComp_8u_AC4R, ippiAlphaComp_16u_AC4R
      ippiAlphaComp_8u_AC1R, ippiAlphaComp_16u_AC1R
   Combines two images using alpha values of both images

      ippiAlphaCompC_8u_AC4R, ippiAlphaCompC_16u_AC4R
      ippiAlphaCompC_8u_AP4R, ippiAlphaCompC_16u_AP4R
      ippiAlphaCompC_8u_C4R,  ippiAlphaCompC_16u_C4R
      ippiAlphaCompC_8u_C3R,  ippiAlphaCompC_16u_C3R
      ippiAlphaCompC_8u_C1R,  ippiAlphaCompC_16u_C1R
   Combines two images using constant alpha values

  Types of compositing operation (alphaType)
      OVER   ippAlphaOver   ippAlphaOverPremul
      IN     ippAlphaIn     ippAlphaInPremul
      OUT    ippAlphaOut    ippAlphaOutPremul
      ATOP   ippAlphaATop   ippAlphaATopPremul
      XOR    ippAlphaXor    ippAlphaXorPremul
      PLUS   ippAlphaPlus   ippAlphaPlusPremul

  Type  result pixel           result pixel (Premul)    result alpha
  OVER  aA*A+(1-aA)*aB*B         A+(1-aA)*B             aA+(1-aA)*aB
  IN    aA*A*aB                  A*aB                   aA*aB
  OUT   aA*A*(1-aB)              A*(1-aB)               aA*(1-aB)
  ATOP  aA*A*aB+(1-aA)*aB*B      A*aB+(1-aA)*B          aA*aB+(1-aA)*aB
  XOR   aA*A*(1-aB)+(1-aA)*aB*B  A*(1-aB)+(1-aA)*B      aA*(1-aB)+(1-aA)*aB
  PLUS  aA*A+aB*B                A+B                    aA+aB
      Here 1 corresponds significance VAL_MAX,  multiplication is performed
      with scaling
          X * Y => (X * Y) / VAL_MAX
      and VAL_MAX is the maximum presentable pixel value:
          VAL_MAX == IPP_MAX_8U  for 8u
          VAL_MAX == IPP_MAX_16U for 16u
}

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaPremul_8u_AC4R,  ippiAlphaPremul_16u_AC4R
                  ippiAlphaPremul_8u_AC4IR, ippiAlphaPremul_16u_AC4IR
                  ippiAlphaPremul_8u_AP4R,  ippiAlphaPremul_16u_AP4R
                  ippiAlphaPremul_8u_AP4IR, ippiAlphaPremul_16u_AP4IR

  Purpose:        Pre-multiplies pixel values of an image by its alpha values
                  for 4-channel images
               For channels 1-3
                      dst_pixel = (src_pixel * src_alpha) / VAL_MAX
               For alpha-channel (channel 4)
                      dst_alpha = src_alpha
  Parameters:
     pSrc         Pointer to the source image for pixel-order data, 
                  array of pointers to separate source color planes for planar data
     srcStep      Step through the source image
     pDst         Pointer to the destination image for pixel-order data, 
                  array of pointers to separate destination color planes for planar data
     dstStep      Step through the destination image
     pSrcDst      Pointer to the source/destination image,  or array of pointers
                  to separate source/destination color planes for in-place functions
     srcDstStep   Step through the source/destination image for in-place functions
     roiSize      Size of the source and destination ROI
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc == NULL, or pDst == NULL, or pSrcDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
}

 function ippiAlphaPremul_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremul_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiAlphaPremul_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremul_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiAlphaPremul_8u_AP4R( pSrc : Ipp8u_4Ptr ; srcStep : Int32 ; pDst : Ipp8u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremul_16u_AP4R( pSrc : Ipp16u_4Ptr ; srcStep : Int32 ; pDst : Ipp16u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiAlphaPremul_8u_AP4IR( pSrcDst : Ipp8u_4Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremul_16u_AP4IR( pSrcDst : Ipp16u_4Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaPremulC_8u_AC4R,  ippiAlphaPremulC_16u_AC4R
                  ippiAlphaPremulC_8u_AC4IR, ippiAlphaPremulC_16u_ACI4R
                  ippiAlphaPremulC_8u_AP4R,  ippiAlphaPremulC_16u_AP4R
                  ippiAlphaPremulC_8u_AP4IR, ippiAlphaPremulC_16u_API4R

  Purpose:        Pre-multiplies pixel values of an image by constant alpha values
                  for 4-channel images
               For channels 1-3
                      dst_pixel = (src_pixel * const_alpha) / VAL_MAX
               For alpha-channel (channel 4)
                      dst_alpha = const_alpha
  Parameters:
     pSrc         Pointer to the source image for pixel-order data, 
                  array of pointers to separate source color planes for planar data
     srcStep      Step through the source image
     pDst         Pointer to the destination image for pixel-order data, 
                  array of pointers to separate destination color planes for planar data
     dstStep      Step through the destination image
     pSrcDst      Pointer to the source/destination image,  or array of pointers
                  to separate source/destination color planes for in-place functions
     srcDstStep   Step through the source/destination image for in-place functions
     alpha        The constant alpha value
     roiSize      Size of the source and destination ROI
  Returns:
     ippStsNoErr            no errors
     ippStsNullPtrErr       pSrc == NULL, or pDst == NULL, or pSrcDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value

  Notes:          Value becomes 0 <= alpha <= VAL_MAX
}

 function ippiAlphaPremulC_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; alpha : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremulC_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; alpha : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiAlphaPremulC_8u_AC4IR( alpha : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremulC_16u_AC4IR( alpha : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiAlphaPremulC_8u_AP4R( pSrc : Ipp8u_4Ptr ; srcStep : Int32 ; alpha : Ipp8u ; pDst : Ipp8u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremulC_16u_AP4R( pSrc : Ipp16u_4Ptr ; srcStep : Int32 ; alpha : Ipp16u ; pDst : Ipp16u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiAlphaPremulC_8u_AP4IR( alpha : Ipp8u ; pSrcDst : Ipp8u_4Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremulC_16u_AP4IR( alpha : Ipp16u ; pSrcDst : Ipp16u_4Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaPremulC_8u_C4R,  ippiAlphaPremulC_16u_C4R
                  ippiAlphaPremulC_8u_C4IR, ippiAlphaPremulC_16u_C4IR

  Purpose:        Pre-multiplies pixel values of an image by constant alpha values
                  for 4-channel images:
                      dst_pixel = (src_pixel * const_alpha) / VAL_MAX
  Parameters:
     pSrc         Pointer to the source image
     srcStep      Step through the source image
     pDst         Pointer to the destination image
     dstStep      Step through the destination image
     pSrcDst      Pointer to the source/destination image for in-place functions
     srcDstStep   Step through the source/destination image for in-place functions
     alpha        The constant alpha value
     roiSize      Size of the source and destination ROI
  Returns:
     ippStsNoErr            no errors
     ippStsNullPtrErr       pSrc == NULL, or pDst == NULL, or pSrcDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value

  Notes:          Value becomes 0 <= alpha <= VAL_MAX
}

 function ippiAlphaPremulC_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; alpha : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremulC_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; alpha : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiAlphaPremulC_8u_C4IR( alpha : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremulC_16u_C4IR( alpha : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaPremulC_8u_C3R,  ippiAlphaPremulC_16u_C3R
                  ippiAlphaPremulC_8u_C3IR, ippiAlphaPremulC_16u_C3IR
  Purpose:        Pre-multiplies pixel values of an image by constant alpha values
                  for 3-channel images:
                      dst_pixel = (src_pixel * const_alpha) / VAL_MAX
  Parameters:
     pSrc         Pointer to the source image
     srcStep      Step through the source image
     pDst         Pointer to the destination image
     dstStep      Step through the destination image
     pSrcDst      Pointer to the source/destination image for in-place functions
     srcDstStep   Step through the source/destination image for in-place functions
     alpha        The constant alpha value
     roiSize      Size of the source and destination ROI
  Returns:
     ippStsNoErr            no errors
     ippStsNullPtrErr       pSrc == NULL, or pDst == NULL, or pSrcDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value

  Notes:          Value becomes 0 <= alpha <= VAL_MAX
}

 function ippiAlphaPremulC_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; alpha : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremulC_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; alpha : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiAlphaPremulC_8u_C3IR( alpha : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremulC_16u_C3IR( alpha : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaPremulC_8u_C1R,  ippiAlphaPremulC_16u_C1R
                  ippiAlphaPremulC_8u_C1IR, ippiAlphaPremulC_16u_C1IR
  Purpose:        Pre-multiplies pixel values of an image by constant alpha values
                  for 1-channel images:
                      dst_pixel = (src_pixel * const_alpha) / VAL_MAX
  Parameters:
     pSrc         Pointer to the source image
     srcStep      Step through the source image
     pDst         Pointer to the destination image
     dstStep      Step through the destination image
     pSrcDst      Pointer to the source/destination image for in-place functions
     srcDstStep   Step through the source/destination image for in-place functions
     alpha        The constant alpha value
     roiSize      Size of the source and destination ROI
  Returns:
     ippStsNoErr            no errors
     ippStsNullPtrErr       pSrc == NULL, or pDst == NULL, or pSrcDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value

  Notes:          Value becomes 0 <= alpha <= VAL_MAX
}


 function ippiAlphaPremulC_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; alpha : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremulC_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; alpha : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiAlphaPremulC_8u_C1IR( alpha : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAlphaPremulC_16u_C1IR( alpha : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaComp_8u_AC4R, ippiAlphaComp_16u_AC4R
                  ippiAlphaComp_8s_AC4R, ippiAlphaComp_16s_AC4R
                  ippiAlphaComp_32s_AC4R,ippiAlphaComp_32u_AC4R
                  ippiAlphaComp_8u_AP4R, ippiAlphaComp_16u_AP4R

  Purpose:        Combines two 4-channel images using alpha values of both images

  Parameters:
     pSrc1        Pointer to the first source image for pixel-order data, 
                  array of pointers to separate source color planes for planar data
     src1Step     Step through the first source image
     pSrc2        Pointer to the second source image for pixel-order data, 
                  array of pointers to separate source color planes for planar data
     src2Step     Step through the second source image
     pDst         Pointer to the destination image for pixel-order data, 
                  array of pointers to separate destination color planes for planar data
     dstStep      Step through the destination image
     roiSize      Size of the source and destination ROI
     alphaType    The type of composition to perform
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc1== NULL, or pSrc2== NULL, or pDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsAlphaTypeErr     The alphaType is incorrect
     Note:                  Result is wrong,  if Alpha < 0 for signed types
}

 function ippiAlphaComp_8u_AC4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_16u_AC4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_16s_AC4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_32s_AC4R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_32u_AC4R( pSrc1 : Ipp32uPtr ; src1Step : Int32 ; pSrc2 : Ipp32uPtr ; src2Step : Int32 ; pDst : Ipp32uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_32f_AC4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_8u_AP4R( pSrc1 : Ipp8u_4Ptr ; src1Step : Int32 ; pSrc2 : Ipp8u_4Ptr ; src2Step : Int32 ; pDst : Ipp8u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_16u_AP4R( pSrc1 : Ipp16u_4Ptr ; src1Step : Int32 ; pSrc2 : Ipp16u_4Ptr ; src2Step : Int32 ; pDst : Ipp16u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaComp_8u_AC1R, ippiAlphaComp_16u_AC1R
                  ippiAlphaComp_8s_AC1R, ippiAlphaComp_16s_AC1R
                  ippiAlphaComp_32s_AC1R, ippiAlphaComp_32u_AC1R
  Purpose:        Combines two 1-channel images using alpha values of both images

  Parameters:
     pSrc1        Pointer to the first source image
     src1Step     Step through the first source image
     pSrc2        Pointer to the second source image
     src2Step     Step through the second source image
     pDst         Pointer to the destination image
     dstStep      Step through the destination image
     roiSize      Size of the source and destination ROI
     alphaType    The type of composition to perform
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc1== NULL, or pSrc2== NULL, or pDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsAlphaTypeErr     The alphaType is incorrect
     Note:                  Result is wrong,  if Alpha < 0 for signed types
}

 function ippiAlphaComp_8u_AC1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_16u_AC1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_16s_AC1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_32s_AC1R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_32u_AC1R( pSrc1 : Ipp32uPtr ; src1Step : Int32 ; pSrc2 : Ipp32uPtr ; src2Step : Int32 ; pDst : Ipp32uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_32f_AC1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaCompC_8u_AC4R, ippiAlphaCompC_16u_AC4R
                  ippiAlphaCompC_8u_AP4R, ippiAlphaCompC_16u_AP4R

  Purpose:        Combines two 4-channel images using constant alpha values

  Parameters:
     pSrc1        Pointer to the first source image for pixel-order data, 
                  array of pointers to separate source color planes for planar data
     src1Step     Step through the first source image
     pSrc2        Pointer to the second source image for pixel-order data, 
                  array of pointers to separate source color planes for planar data
     src2Step     Step through the second source image
     pDst         Pointer to the destination image for pixel-order data, 
                  array of pointers to separate destination color planes for planar data
     dstStep      Step through the destination image
     roiSize      Size of the source and destination ROI
     alpha1       The constant alpha value for the first source image
     alpha2       The constant alpha value for the second source image
     alphaType    The type of composition to perform
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc1== NULL, or pSrc2== NULL, or pDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsAlphaTypeErr     The alphaType is incorrect

  Notes:          Alpha-channel values (channel 4) remain without modifications
                  Value becomes 0 <= alphaA <= VAL_MAX
                                0 <= alphaB <= VAL_MAX
}

 function ippiAlphaCompC_8u_AC4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; alpha1 : Ipp8u ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; alpha2 : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16u_AC4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; alpha1 : Ipp16u ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; alpha2 : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

 function ippiAlphaCompC_8u_AP4R( pSrc1 : Ipp8u_4Ptr ; src1Step : Int32 ; alpha1 : Ipp8u ; pSrc2 : Ipp8u_4Ptr ; src2Step : Int32 ; alpha2 : Ipp8u ; pDst : Ipp8u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16u_AP4R( pSrc1 : Ipp16u_4Ptr ; src1Step : Int32 ; alpha1 : Ipp16u ; pSrc2 : Ipp16u_4Ptr ; src2Step : Int32 ; alpha2 : Ipp16u ; pDst : Ipp16u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaCompC_8u_C4R, ippiAlphaCompC_16u_C4R

  Purpose:        Combines two 4-channel images using constant alpha values

  Parameters:
     pSrc1        Pointer to the first source image
     src1Step     Step through the first source image
     pSrc2        Pointer to the second source image
     src2Step     Step through the second source image
     pDst         Pointer to the destination image
     dstStep      Step through the destination image
     roiSize      Size of the source and destination ROI
     alpha1       The constant alpha value for the first source image
     alpha2       The constant alpha value for the second source image
     alphaType    The type of composition to perform
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc1== NULL, or pSrc2== NULL, or pDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsAlphaTypeErr     The alphaType is incorrect

  Notes:          Value becomes 0 <= alphaA <= VAL_MAX
                                0 <= alphaB <= VAL_MAX
}

 function ippiAlphaCompC_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; alpha1 : Ipp8u ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; alpha2 : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; alpha1 : Ipp16u ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; alpha2 : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaCompC_8u_C3R, ippiAlphaCompC_16u_C3R
  Purpose:        Combines two 3-channel images using constant alpha values
  Parameters:
     pSrc1        Pointer to the first source image
     src1Step     Step through the first source image
     pSrc2        Pointer to the second source image
     src2Step     Step through the second source image
     pDst         Pointer to the destination image
     dstStep      Step through the destination image
     roiSize      Size of the source and destination ROI
     alpha1       The constant alpha value for the first source image
     alpha2       The constant alpha value for the second source image
     alphaType    The type of composition to perform
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc1== NULL, or pSrc2== NULL, or pDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsAlphaTypeErr     The alphaType is incorrect

  Notes:          Value becomes 0 <= alphaA <= VAL_MAX
                                0 <= alphaB <= VAL_MAX
}

 function ippiAlphaCompC_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; alpha1 : Ipp8u ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; alpha2 : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; alpha1 : Ipp16u ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; alpha2 : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaCompC_8u_C1R, ippiAlphaCompC_16u_C1R
                  ippiAlphaCompC_8s_C1R, ippiAlphaCompC_16s_C1R
                  ippiAlphaCompC_32s_C1R, ippiAlphaCompC_32u_C1R
  Purpose:        Combines two 1-channel images using constant alpha values
  Parameters:
     pSrc1        Pointer to the first source image
     src1Step     Step through the first source image
     pSrc2        Pointer to the second source image
     src2Step     Step through the second source image
     pDst         Pointer to the destination image
     dstStep      Step through the destination image
     roiSize      Size of the source and destination ROI
     alpha1       The constant alpha value for the first source image
     alpha2       The constant alpha value for the second source image
     alphaType    The type of composition to perform
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc1== NULL, or pSrc2== NULL, or pDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsAlphaTypeErr     The alphaType is incorrect

  Notes:          Value becomes 0 <= alphaA <= VAL_MAX
                                0 <= alphaB <= VAL_MAX
}

 function ippiAlphaCompC_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; alpha1 : Ipp8u ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; alpha2 : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; alpha1 : Ipp16u ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; alpha2 : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16s_C1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; alpha1 : Ipp16s ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; alpha2 : Ipp16s ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_32s_C1R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; alpha1 : Ipp32s ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; alpha2 : Ipp32s ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_32u_C1R( pSrc1 : Ipp32uPtr ; src1Step : Int32 ; alpha1 : Ipp32u ; pSrc2 : Ipp32uPtr ; src2Step : Int32 ; alpha2 : Ipp32u ; pDst : Ipp32uPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; alpha1 : Ipp32f ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; alpha2 : Ipp32f ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaComp_8u_AC4IR, ippiAlphaComp_16u_AC4IR
                  ippiAlphaComp_8s_AC4IR, ippiAlphaComp_16s_AC4IR
                  ippiAlphaComp_32s_AC4IR,ippiAlphaComp_32u_AC4IR
                  ippiAlphaComp_8u_AP4IR, ippiAlphaComp_16u_AP4IR

  Purpose:        Combines two 4-channel images using alpha values of both images

  Parameters:
     pSrc         Pointer to the source image for pixel-order data, 
                  array of pointers to separate source color planes for planar data
     srcStep      Step through the source image
     pSrcDst      Pointer to the source/destination image for pixel-order data, 
                  array of pointers to separate source/destination color planes for planar data
     srcDstStep   Step through the source/destination image
     roiSize      Size of the source and destination ROI
     alphaType    The type of composition to perform
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc == NULL, or pSrcDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsAlphaTypeErr     The alphaType is incorrect
     Note:                  Result is wrong,  if Alpha < 0 for signed types
}

 function ippiAlphaComp_8u_AC4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_16u_AC4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_16s_AC4IR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_32s_AC4IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_32u_AC4IR( pSrc : Ipp32uPtr ; srcStep : Int32 ; pSrcDst : Ipp32uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_32f_AC4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_8u_AP4IR( pSrc : Ipp8u_4Ptr ; srcStep : Int32 ; pSrcDst : Ipp8u_4Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaComp_16u_AP4IR( pSrc : Ipp16u_4Ptr ; srcStep : Int32 ; pSrcDst : Ipp16u_4Ptr ; srcDstStep : Int32 ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaCompC_8u_AC4IR, ippiAlphaCompC_16u_AC4IR
                  ippiAlphaCompC_8u_AP4IR, ippiAlphaCompC_16u_AP4IR

  Purpose:        Combines two 4-channel images using constant alpha values

  Parameters:
     pSrc         Pointer to the source image for pixel-order data, 
                  array of pointers to separate source color planes for planar data
     srcStep      Step through the source image
     pSrcDst      Pointer to the source/destination image for pixel-order data, 
                  array of pointers to separate source/destination color planes for planar data
     srcDstStep   Step through the source/destination image
     roiSize      Size of the source and destination ROI
     alpha1       The constant alpha value for the source image
     alpha2       The constant alpha value for the source/destination image
     alphaType    The type of composition to perform
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc == NULL, or pSrcDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsAlphaTypeErr     The alphaType is incorrect

  Notes:          Alpha-channel values (channel 4) remain without modifications
                  Value becomes 0 <= alphaA <= VAL_MAX
                                0 <= alphaB <= VAL_MAX
}

 function ippiAlphaCompC_8u_AC4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; alpha1 : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; alpha2 : Ipp8u ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16u_AC4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; alpha1 : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; alpha2 : Ipp16u ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

 function ippiAlphaCompC_8u_AP4IR( pSrc : Ipp8u_4Ptr ; srcStep : Int32 ; alpha1 : Ipp8u ; pSrcDst : Ipp8u_4Ptr ; srcDstStep : Int32 ; alpha2 : Ipp8u ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16u_AP4IR( pSrc : Ipp16u_4Ptr ; srcStep : Int32 ; alpha1 : Ipp16u ; pSrcDst : Ipp16u_4Ptr ; srcDstStep : Int32 ; alpha2 : Ipp16u ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaCompC_8u_C4IR, ippiAlphaCompC_16u_C4IR

  Purpose:        Combines two 4-channel images using constant alpha values

  Parameters:
     pSrc         Pointer to the source image
     srcStep      Step through the source image
     pSrcDst      Pointer to the source/destination image
     srcDstStep   Step through the source/destination image
     roiSize      Size of the source and destination ROI
     alpha1       The constant alpha value for the source image
     alpha2       The constant alpha value for the source/destination image
     alphaType    The type of composition to perform
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc == NULL, or pSrcDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsAlphaTypeErr     The alphaType is incorrect

  Notes:          Value becomes 0 <= alphaA <= VAL_MAX
                                0 <= alphaB <= VAL_MAX
}

 function ippiAlphaCompC_8u_C4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; alpha1 : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; alpha2 : Ipp8u ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16u_C4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; alpha1 : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; alpha2 : Ipp16u ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaCompC_8u_C3IR, ippiAlphaCompC_16u_C3IR
  Purpose:        Combines two 3-channel images using constant alpha values
  Parameters:
     pSrc         Pointer to the source image
     srcStep      Step through the source image
     pSrcDst      Pointer to the source/destination image
     srcDstStep   Step through the source/destination image
     roiSize      Size of the source and destination ROI
     alpha1       The constant alpha value for the source image
     alpha2       The constant alpha value for the source/destination image
     alphaType    The type of composition to perform
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc == NULL, or pSrcDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsAlphaTypeErr     The alphaType is incorrect

  Notes:          Value becomes 0 <= alphaA <= VAL_MAX
                                0 <= alphaB <= VAL_MAX
}

 function ippiAlphaCompC_8u_C3IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; alpha1 : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; alpha2 : Ipp8u ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16u_C3IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; alpha1 : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; alpha2 : Ipp16u ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiAlphaCompC_8u_C1IR, ippiAlphaCompC_16u_C1IR
                  ippiAlphaCompC_8s_C1IR, ippiAlphaCompC_16s_C1IR
                  ippiAlphaCompC_32s_C1IR, ippiAlphaCompC_32u_C1IR
  Purpose:        Combines two 1-channel images using constant alpha values
  Parameters:
     pSrc         Pointer to the source image
     srcStep      Step through the source image
     pSrcDst      Pointer to the source/destination image
     srcDstStep   Step through the source/destination image
     roiSize      Size of the source and destination ROI
     alpha1       The constant alpha value for the source image
     alpha2       The constant alpha value for the source/destination image
     alphaType    The type of composition to perform
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pSrc == NULL, or pSrcDst == NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsAlphaTypeErr     The alphaType is incorrect

  Notes:          Value becomes 0 <= alphaA <= VAL_MAX
                                0 <= alphaB <= VAL_MAX
}

 function ippiAlphaCompC_8u_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; alpha1 : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; alpha2 : Ipp8u ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16u_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; alpha1 : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; alpha2 : Ipp16u ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_16s_C1IR( pSrc : Ipp16sPtr ; srcStep : Int32 ; alpha1 : Ipp16s ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; alpha2 : Ipp16s ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_32s_C1IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; alpha1 : Ipp32s ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; alpha2 : Ipp32s ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_32u_C1IR( pSrc : Ipp32uPtr ; srcStep : Int32 ; alpha1 : Ipp32u ; pSrcDst : Ipp32uPtr ; srcDstStep : Int32 ; alpha2 : Ipp32u ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi
 function ippiAlphaCompC_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; alpha1 : Ipp32f ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; alpha2 : Ipp32f ; roiSize : IppiSize ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Linear Transform Operations
----------------------------------------------------------------------------

                  Definitions for FFT Functions
---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------

                  FFT Context Functions
{ ----------------------------------------------------------------------------


  Name:       ippiFFTInit
  Purpose:    Initializes the FFT context structure
  Arguments:
     orderX     Base-2 logarithm of the number of samples in FFT (width)
     orderY     Base-2 logarithm of the number of samples in FFT (height)
     flag       Flag to choose the results normalization factors
     hint       Option to select the algorithmic implementation of the transform
                function
     pFFTSpec   Pointer to the FFT context structure
     pMemInit   Pointer to the temporary work buffer
  Return:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
     ippStsFftOrderErr      FFT order value is illegal
     ippStsFFTFlagErr       Incorrect normalization flag value
}

 function ippiFFTInit_C_32fc( orderX : Int32 ; orderY : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pFFTSpec : IppiFFTSpec_C_32fcPtr ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTInit_R_32f( orderX : Int32 ; orderY : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  FFT Size
{ ----------------------------------------------------------------------------


  Name:       ippiFFTGetSize
  Purpose:    Computes the size of the FFT context structure and the size
                of the required work buffer (in bytes)
  Arguments:
     orderX     Base-2 logarithm of the number of samples in FFT (width)
     orderY     Base-2 logarithm of the number of samples in FFT (height)
     flag       Flag to choose the results normalization factors
     hint       Option to select the algorithmic implementation of the transform
                function
     pSizeSpec  Pointer to the size value of FFT specification structure
     pSizeInit  Pointer to the size value of the buffer for FFT initialization function
     pSizeBuf   Pointer to the size value of the FFT external work buffer
  Return:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
     ippStsFftOrderErr      FFT order value is illegal
     ippStsFFTFlagErr       Incorrect normalization flag value
}

 function ippiFFTGetSize_C_32fc( orderX : Int32 ; orderY : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; var pSizeSpec : Int32 ; var pSizeInit : Int32 ; var pSizeBuf : Int32 ): IppStatus; _ippapi
 function ippiFFTGetSize_R_32f( orderX : Int32 ; orderY : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; var pSizeSpec : Int32 ; var pSizeInit : Int32 ; var pSizeBuf : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  FFT Transforms
{ ----------------------------------------------------------------------------


  Name:       ippiFFTFwd, ippiFFTInv
  Purpose:    Performs forward or inverse FFT of an image
  Parameters:
     pFFTSpec   Pointer to the FFT context structure
     pSrc       Pointer to the source image
     srcStep    Step through the source image
     pDst       Pointer to the destination image
     dstStep    Step through the destination image
     pSrcDst    Pointer to the source/destination image (in-place)
     srcDstStep Step through the source/destination image (in-place)
     pBuffer    Pointer to the external work buffer
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers with the exception of
                              pBuffer is NULL
     ippStsStepErr          srcStep or dstStep value is zero or negative
     ippStsContextMatchErr  Invalid context structure
     ippStsMemAllocErr      Memory allocation error
}

 function ippiFFTFwd_CToC_32fc_C1R( pSrc : Ipp32fcPtr ; srcStep : Int32 ; pDst : Ipp32fcPtr ; dstStep : Int32 ; pFFTSpec : IppiFFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTInv_CToC_32fc_C1R( pSrc : Ipp32fcPtr ; srcStep : Int32 ; pDst : Ipp32fcPtr ; dstStep : Int32 ; pFFTSpec : IppiFFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFFTFwd_RToPack_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTFwd_RToPack_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTFwd_RToPack_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTFwd_RToPack_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFFTInv_PackToR_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTInv_PackToR_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTInv_PackToR_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTInv_PackToR_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFFTFwd_CToC_32fc_C1IR( pSrcDst : Ipp32fcPtr ; srcDstStep : Int32 ; pFFTSpec : IppiFFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTInv_CToC_32fc_C1IR( pSrcDst : Ipp32fcPtr ; srcDstStep : Int32 ; pFFTSpec : IppiFFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFFTFwd_RToPack_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTFwd_RToPack_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTFwd_RToPack_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTFwd_RToPack_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFFTInv_PackToR_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTInv_PackToR_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTInv_PackToR_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFFTInv_PackToR_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pFFTSpec : IppiFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Definitions for DFT Functions
----------------------------------------------------------------------------

                  DFT Context Functions
{ ----------------------------------------------------------------------------


  Name:         ippiDFTInit
  Purpose:      Initializes the DFT context structure
  Parameters:
     roiSize    Size of the ROI
     flag       Flag to choose the results normalization factors
     hint       Option to select the algorithmic implementation of the transform
                function
     pDFTSpec   Double pointer to the DFT context structure
     pMemInit   Pointer to initialization buffer
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
     ippStsFftOrderErr      Invalid roiSize
     ippStsSizeErr          roiSize has a field with zero or negative value
     ippStsFFTFlagErr       Incorrect normalization flag value
}

 function ippiDFTInit_C_32fc( roiSize : IppiSize ; flag : Int32 ; hint : IppHintAlgorithm ; pDFTSpec : IppiDFTSpec_C_32fcPtr ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTInit_R_32f( roiSize : IppiSize ; flag : Int32 ; hint : IppHintAlgorithm ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiDFTGetSize
  Purpose:    Computes the size of the DFT context structure and the size
                of the required work buffer (in bytes)
  Parameters:
     roiSize    Size of the ROI
     flag       Flag to choose the results normalization factors
     hint       Option to select the algorithmic implementation of the transform
                function
     pSizeSpec  Pointer to the size value of DFT specification structure
     pSizeInit  Pointer to the size value of the buffer for DFT initialization function
     pSizeBuf   Pointer to the size value of the DFT external work buffer
  Return:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
     ippStsFftOrderErr      Invalid roiSize
     ippStsSizeErr          roiSize has a field with zero or negative value
     ippStsFFTFlagErr       Incorrect normalization flag value
}

 function ippiDFTGetSize_C_32fc( roiSize : IppiSize ; flag : Int32 ; hint : IppHintAlgorithm ; pSizeSpec : Int32Ptr ; pSizeInit : Int32Ptr ; pSizeBuf : Int32Ptr ): IppStatus; _ippapi
 function ippiDFTGetSize_R_32f( roiSize : IppiSize ; flag : Int32 ; hint : IppHintAlgorithm ; pSizeSpec : Int32Ptr ; pSizeInit : Int32Ptr ; pSizeBuf : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  DFT Transforms
{ ----------------------------------------------------------------------------


  Name:       ippiDFTFwd, ippiDFTInv
  Purpose:    Performs forward or inverse DFT of an image
  Parameters:
     pDFTSpec    Pointer to the DFT context structure
     pSrc        Pointer to source image
     srcStep     Step through the source image
     pDst        Pointer to the destination image
     dstStep     Step through the destination image
     pSrcDst     Pointer to the source/destination image (in-place)
     srcDstStep  Step through the source/destination image (in-place)
     pBuffer     Pointer to the external work buffer
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers with the exception of
                              pBuffer is NULL
     ippStsStepErr          srcStep or dstStep value is zero or negative
     ippStsContextMatchErr  Invalid context structure
     ippStsMemAllocErr      Memory allocation error
}

 function ippiDFTFwd_CToC_32fc_C1R( pSrc : Ipp32fcPtr ; srcStep : Int32 ; pDst : Ipp32fcPtr ; dstStep : Int32 ; pDFTSpec : IppiDFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTInv_CToC_32fc_C1R( pSrc : Ipp32fcPtr ; srcStep : Int32 ; pDst : Ipp32fcPtr ; dstStep : Int32 ; pDFTSpec : IppiDFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiDFTFwd_RToPack_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTFwd_RToPack_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTFwd_RToPack_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTFwd_RToPack_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiDFTInv_PackToR_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTInv_PackToR_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTInv_PackToR_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTInv_PackToR_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiDFTFwd_CToC_32fc_C1IR( pSrcDst : Ipp32fcPtr ; srcDstStep : Int32 ; pDFTSpec : IppiDFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTInv_CToC_32fc_C1IR( pSrcDst : Ipp32fcPtr ; srcDstStep : Int32 ; pDFTSpec : IppiDFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiDFTFwd_RToPack_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTFwd_RToPack_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTFwd_RToPack_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTFwd_RToPack_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiDFTInv_PackToR_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTInv_PackToR_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTInv_PackToR_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDFTInv_PackToR_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; pDFTSpec : IppiDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Definitions for DCT Functions
----------------------------------------------------------------------------

                  DCT Context Functions
{ ----------------------------------------------------------------------------


  Name:       ippiDCTFwdInit, ippiDCTInvInit
  Purpose:    Initializes the forward/inverse DCT context structure
  Parameters:
     pDCTSpec   Pointer to the DCT context structure
     roiSize    Size of the ROI
     pMemInit   Pointer to the temporary work buffer
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       pDCTSpec == NULL
     ippStsSizeErr          roiSize has a field with zero or negative value
}

 function ippiDCTFwdInit_32f( pDCTSpec : IppiDCTFwdSpec_32fPtr ; roiSize : IppiSize ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDCTInvInit_32f( pDCTSpec : IppiDCTInvSpec_32fPtr ; roiSize : IppiSize ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  DCT Buffer Size
{ ----------------------------------------------------------------------------


  Name:       ippiDCTFwdGetSize, ippiDCTInvGetSize
  Purpose:    Computes the size of the forward/inverse DCT context structure and the size
              of the required work buffer (in bytes)
  Parameters:
     roiSize    Size of the ROI
     pSizeSpec  Pointer to the size value of DCT context structure
     pSizeInit  Pointer to the size value of the buffer for DCT initialization function
     pSizeBuf   Pointer to the size value of the DCT external work buffer
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
     ippStsSizeErr          roiSize has a field with zero or negative value
}

 function ippiDCTFwdGetSize_32f( roiSize : IppiSize ; pSizeSpec : Int32Ptr ; pSizeInit : Int32Ptr ; pSizeBuf : Int32Ptr ): IppStatus; _ippapi
 function ippiDCTInvGetSize_32f( roiSize : IppiSize ; pSizeSpec : Int32Ptr ; pSizeInit : Int32Ptr ; pSizeBuf : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  DCT Transforms
{ ----------------------------------------------------------------------------


  Name:       ippiDCTFwd, ippiDCTInv
  Purpose:    Performs forward or inverse DCT of an image
  Parameters:
     pDCTSpec   Pointer to the DCT context structure
     pSrc       Pointer to the source image
     srcStep    Step through the source image
     pDst       Pointer to the destination image
     dstStep    Step through the destination image
     pBuffer    Pointer to the work buffer
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers with the exception of
                              pBuffer is NULL
     ippStsStepErr          srcStep or dstStep value is zero or negative
     ippStsContextMatchErr  Invalid context structure
     ippStsMemAllocErr      Memory allocation error
}

 function ippiDCTFwd_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDCTSpec : IppiDCTFwdSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDCTFwd_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDCTSpec : IppiDCTFwdSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDCTFwd_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDCTSpec : IppiDCTFwdSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDCTFwd_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDCTSpec : IppiDCTFwdSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiDCTInv_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDCTSpec : IppiDCTInvSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDCTInv_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDCTSpec : IppiDCTInvSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDCTInv_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDCTSpec : IppiDCTInvSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiDCTInv_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; pDCTSpec : IppiDCTInvSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  8x8 DCT Transforms
{ ----------------------------------------------------------------------------


  Name:      ippiDCT8x8Fwd_16s_C1, ippiDCT8x8Fwd_16s_C1I
             ippiDCT8x8Inv_16s_C1, ippiDCT8x8Inv_16s_C1I
             ippiDCT8x8Fwd_16s_C1R
             ippiDCT8x8Inv_16s_C1R
  Purpose:   Performs forward or inverse DCT in the 8x8 buffer for 16s data

  Parameters:
     pSrc       Pointer to the source buffer
     pDst       Pointer to the destination buffer
     pSrcDst    Pointer to the source and destination buffer (in-place operations)
     srcStep    Step through the source image (operations with ROI)
     dstStep    Step through the destination image (operations with ROI)
  Returns:
     ippStsNoErr         No errors
     ippStsNullPtrErr    One of the specified pointers is NULL
     ippStsStepErr       srcStep or dstStep value is zero or negative
  Notes:
     Source data for inverse DCT functions must be the result of the forward DCT
     of data from the range [-256,255]
}

 function ippiDCT8x8Fwd_16s_C1( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ): IppStatus; _ippapi
 function ippiDCT8x8Inv_16s_C1( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ): IppStatus; _ippapi

 function ippiDCT8x8Fwd_16s_C1I( pSrcDst : Ipp16sPtr  ): IppStatus; _ippapi
 function ippiDCT8x8Inv_16s_C1I( pSrcDst : Ipp16sPtr ): IppStatus; _ippapi

 function ippiDCT8x8Fwd_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ): IppStatus; _ippapi
 function ippiDCT8x8Inv_16s_C1R( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; dstStep : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiDCT8x8Inv_2x2_16s_C1, ippiDCT8x8Inv_2x2_16s_C1I
             ippiDCT8x8Inv_4x4_16s_C1, ippiDCT8x8Inv_4x4_16s_C1I
  Purpose:   Performs inverse DCT of nonzero elements in the top left quadrant
             of size 2x2 or 4x4 in the 8x8 buffer
  Parameters:
     pSrc       Pointer to the source buffer
     pDst       Pointer to the destination buffer
     pSrcDst    Pointer to the source/destination buffer (in-place operations)
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
  Notes:
     Source data for these functions must be the result of the forward DCT
     of data from the range [-256,255]
}

 function ippiDCT8x8Inv_2x2_16s_C1( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ): IppStatus; _ippapi
 function ippiDCT8x8Inv_4x4_16s_C1( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ): IppStatus; _ippapi

 function ippiDCT8x8Inv_2x2_16s_C1I( pSrcDst : Ipp16sPtr ): IppStatus; _ippapi
 function ippiDCT8x8Inv_4x4_16s_C1I( pSrcDst : Ipp16sPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiDCT8x8To2x2Inv_16s_C1, ippiDCT8x8To2x2Inv_16s_C1I
             ippiDCT8x8To4x4Inv_16s_C1, ippiDCT8x8To4x4Inv_16s_C1I
  Purpose:   Inverse Discrete Cosine Transform 8x8 for 16s data and
             downsampling of the result from 8x8 to 2x2 or 4x4 by averaging
  Arguments:
     pSrc       Pointer to the source buffer
     pDst       Pointer to the destination buffer
     pSrcDst    Pointer to the source/destination buffer (in-place operations)
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
  Notes:
     Source data for these functions must be the result of the forward DCT
     of data from the range [-256,255]
}

 function ippiDCT8x8To2x2Inv_16s_C1( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ): IppStatus; _ippapi
 function ippiDCT8x8To4x4Inv_16s_C1( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ): IppStatus; _ippapi

 function ippiDCT8x8To2x2Inv_16s_C1I( pSrcDst : Ipp16sPtr ): IppStatus; _ippapi
 function ippiDCT8x8To4x4Inv_16s_C1I( pSrcDst : Ipp16sPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiDCT8x8Inv_A10_16s_C1, ippiDCT8x8Inv_A10_16s_C1I
  Purpose:   Performs inverse DCT in the 8x8 buffer for 10 bits 16s data

  Parameters:
     pSrc       Pointer to the source buffer
     pDst       Pointer to the destination buffer
  Returns:
     ippStsNoErr         No errors
     ippStsNullPtrErr    One of the specified pointers is NULL
  Notes:
     Source data for these functions must be the result of the forward DCT
     of data from the range [-512,511]
}

 function ippiDCT8x8Inv_A10_16s_C1( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ): IppStatus; _ippapi
 function ippiDCT8x8Inv_A10_16s_C1I( pSrcDst : Ipp16sPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiDCT8x8Fwd_8u16s_C1R
             ippiDCT8x8Inv_16s8u_C1R
  Purpose:   Performs forward and inverse DCT in 8x8 buffer
             for 16s data with conversion from/to 8u
  Parameters:
     pSrc      Pointer to the source buffer
     pDst      Pointer to the destination buffer
     srcStep   Step through the source image
     dstStep   Step through the destination image
  Returns:
     ippStsNoErr        No errors
     ippStsNullPtrErr   One of the specified pointers is NULL
     ippStsStepErr      srcStep or dstStep value is zero or negative
}

 function ippiDCT8x8Fwd_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ): IppStatus; _ippapi
 function ippiDCT8x8Inv_16s8u_C1R( pSrc : Ipp16sPtr ; pDst : Ipp8uPtr ; dstStep : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiDCT8x8FwdLS_8u16s_C1R
  Purpose:   Performs forward DCT in 8x8 buffer for 16s data
             with conversion from 8u and level shift
  Parameters:
     pSrc      Pointer to start of source buffer
     pDst      Pointer to start of destination buffer
     srcStep   Step the source buffer
     addVal    Constant value adding before DCT (level shift)
  Returns:
     ippStsNoErr         No errors
     ippStsNullPtrErr    One of the specified pointers is NULL
     ippStsStepErr       srcStep value is zero or negative
}

 function ippiDCT8x8FwdLS_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; addVal : Ipp16s ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiDCT8x8InvLSClip_16s8u_C1R
  Purpose:   Performs inverse DCT in 8x8 buffer for 16s data
             with level shift,  clipping and conversion to 8u
  Parameters:
     pSrc      Pointer to the source buffer
     pDst      Pointer to the destination buffer
     dstStep   Step through the destination image
     addVal    Constant value adding after DCT (level shift)
     clipDown  Constant value for clipping (MIN)
     clipUp    Constant value for clipping (MAX)
  Returns:
     ippStsNoErr           No errors
     ippStsNullPtrErr      One of the pointers is NULL
     ippStsStepErr         dstStep value is zero or negative
}

 function ippiDCT8x8InvLSClip_16s8u_C1R( pSrc : Ipp16sPtr ; pDst : Ipp8uPtr ; dstStep : Int32 ; addVal : Ipp16s ; clipDown : Ipp8u ; clipUp : Ipp8u ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiDCT8x8Fwd_32f_C1, ippiDCT8x8Fwd_32f_C1I
             ippiDCT8x8Inv_32f_C1, ippiDCT8x8Inv_32f_C1I
  Purpose:   Performs forward or inverse DCT in the 8x8 buffer for 32f data

  Parameters:
     pSrc       Pointer to the source buffer
     pDst       Pointer to the destination buffer
     pSrcDst    Pointer to the source and destination buffer (in-place operations)
  Returns:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
}

 function ippiDCT8x8Fwd_32f_C1( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ): IppStatus; _ippapi
 function ippiDCT8x8Inv_32f_C1( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ): IppStatus; _ippapi
 function ippiDCT8x8Fwd_32f_C1I( pSrcDst : Ipp32fPtr ): IppStatus; _ippapi
 function ippiDCT8x8Inv_32f_C1I( pSrcDst : Ipp32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

          Wavelet Transform Functions for User Filter Banks
---------------------------------------------------------------------------- }

{
 Name:        ippiWTFwdGetSize_32f

 Purpose:     Get sizes,  in bytes,  of the ippiWTFwd spec structure and the work buffer.

 Parameters:
    numChannels - Number of image channels. Possible values are 1 and 3.
    lenLow      - Length of the lowpass filter.
    anchorLow   - Anchor position of the lowpass filter.
    lenHigh     - Length of the highpass filter.
    anchorHigh  - Anchor position of the highpass filter.
    pSpecSize   - Pointer to the size of the ippiWTFwd spec structure (in bytes).
    pBufSize    - Pointer to the size of the work buffer (in bytes).

 Returns:
    ippStsNoErr           - Ok.
    ippStsNullPtrErr      - Error when any of the specified pointers is NULL.
    ippStsNumChannelsErr  - Error when the numChannels value differs from 1 or 3.
    ippStsSizeErr         - Error when lenLow or lenHigh is less than 2.
    ippStsAnchorErr       - Error when anchorLow or anchorHigh is less than zero.
}

 function ippiWTFwdGetSize_32f( numChannels : Int32 ; lenLow : Int32 ; anchorLow : Int32 ; lenHigh : Int32 ; anchorHigh : Int32 ; var pSpecSize : Int32 ; var pBufSize : Int32 ): IppStatus; _ippapi

{
 Name:       ippiWTFwdInit_

 Purpose:    Initialize forward wavelet transform spec structure.

 Parameters:
   pSpec        - Pointer to pointer to allocated ippiWTFwd spec structure.
   pTapsLow     - Pointer to lowpass filter taps.
   lenLow       - Length of lowpass filter.
   anchorLow    - Anchor position of lowpass filter.
   pTapsHigh    - Pointer to highpass filter taps.
   lenHigh      - Length of highpass filter.
   anchorHigh   - Anchor position of highpass filter.

 Returns:
    ippStsNoErr           - Ok.
    ippStsNullPtrErr      - Error when any of the specified pointers is NULL.
    ippStsNumChannelsErr  - Error when the numChannels value differs from 1 or 3.
    ippStsSizeErr         - Error when lenLow or lenHigh is less than 2.
    ippStsAnchorErr       - Error when anchorLow or anchorHigh is less than zero.
}

 function ippiWTFwdInit_32f_C1R( pSpec : IppiWTFwdSpec_32f_C1RPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; anchorLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; anchorHigh : Int32 ): IppStatus; _ippapi
 function ippiWTFwdInit_32f_C3R( pSpec : IppiWTFwdSpec_32f_C3RPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; anchorLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; anchorHigh : Int32 ): IppStatus; _ippapi

{
 Name:        ippiWTFwd_32f_C1R
              ippiWTFwd_32f_C3R

 Purpose:     Performs wavelet decomposition of an image.

 Parameters:
   pSrc         Pointer to source image ROI;
   srcStep      Step in bytes through the source image;
   pApproxDst   Pointer to destination "approximation" image ROI;
   approxStep   Step in bytes through the destination approximation image;
   pDetailXDst  Pointer to the destination "horizontal details" image ROI;
   detailXStep  Step in bytes through the destination horizontal detail image;
   pDetailYDst  Pointer to the destination "vertical details" image ROI;
   detailYStep  Step in bytes through the destination "vertical details" image;
   pDetailXYDst Pointer to the destination "diagonal details" image ROI;
   detailXYStep Step in bytes through the destination "diagonal details" image;
   dstRoiSize   ROI size for all destination images.
   pSpec        Pointer to the context structure.

 Returns:
   ippStsNoErr            OK;
   ippStsNullPtrErr       One of pointers is NULL;
   ippStsSizeErr          dstRoiSize has a field with zero or negative value;
   ippStsContextMatchErr  Invalid context structure.

 Notes:
   No any fixed borders extension (wrap, symm.) will be applied!
   Source image must have valid and accessible border data outside of ROI.

   Only the same ROI sizes for destination images are supported.

   Source ROI size should be calculated by the following rule:
          srcRoiSize.width  = 2 * dstRoiSize.width;
          srcRoiSize.height = 2 * dstRoiSize.height.

   Conventional tokens for destination images have next meaning:
    "Approximation"     - image obtained by vertical
                              and horizontal lowpass filtering.
    "Horizontal detail" - image obtained by vertical highpass
                              and horizontal lowpass filtering.
    "Vertical detail"   - image obtained by vertical lowpass
                              and horizontal highpass filtering.
    "Diagonal detail"   - image obtained by vertical
                              and horizontal highpass filtering.
   These tokens are used only for identification convenience.

}

 function ippiWTFwd_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pApproxDst : Ipp32fPtr ; approxStep : Int32 ; pDetailXDst : Ipp32fPtr ; detailXStep : Int32 ; pDetailYDst : Ipp32fPtr ; detailYStep : Int32 ; pDetailXYDst : Ipp32fPtr ; detailXYStep : Int32 ; dstRoiSize : IppiSize ; pSpec : IppiWTFwdSpec_32f_C1RPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWTFwd_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pApproxDst : Ipp32fPtr ; approxStep : Int32 ; pDetailXDst : Ipp32fPtr ; detailXStep : Int32 ; pDetailYDst : Ipp32fPtr ; detailYStep : Int32 ; pDetailXYDst : Ipp32fPtr ; detailXYStep : Int32 ; dstRoiSize : IppiSize ; pSpec : IppiWTFwdSpec_32f_C3RPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{
 Name:        ippiWTInvGetSize_32f

 Purpose:     Get sizes,  in bytes,  of the WTInv spec structure and the work buffer.

 Parameters:
    numChannels - Number of image channels. Possible values are 1 and 3.
    lenLow      - Length of the lowpass filter.
    anchorLow   - Anchor position of the lowpass filter.
    lenHigh     - Length of the highpass filter.
    anchorHigh  - Anchor position of the highpass filter.
    pSpecSize   - Pointer to the size of the ippiWTInv spec structure (in bytes).
    pBufSize    - Pointer to the size of the work buffer (in bytes).

 Returns:
    ippStsNoErr           - Ok.
    ippStsNullPtrErr      - Error when any of the specified pointers is NULL.
    ippStsNumChannelsErr  - Error when the numChannels value differs from 1 or 3.
    ippStsSizeErr         - Error when lenLow or lenHigh is less than 2.
    ippStsAnchorErr       - Error when anchorLow or anchorHigh is less than zero.
}

 function ippiWTInvGetSize_32f( numChannels : Int32 ; lenLow : Int32 ; anchorLow : Int32 ; lenHigh : Int32 ; anchorHigh : Int32 ; var pSpecSize : Int32 ; var pBufSize : Int32 ): IppStatus; _ippapi

{
 Name:       ippiWTInvInit_

 Purpose:    Initialize inverse wavelet transform spec structure.

 Parameters:
   pSpec        - Pointer to pointer to allocated ippiWTInv spec structure.
   pTapsLow     - Pointer to lowpass filter taps.
   lenLow       - Length of lowpass filter.
   anchorLow    - Anchor position of lowpass filter.
   pTapsHigh    - Pointer to highpass filter taps.
   lenHigh      - Length of highpass filter.
   anchorHigh   - Anchor position of highpass filter.

 Returns:
    ippStsNoErr           - Ok.
    ippStsNullPtrErr      - Error when any of the specified pointers is NULL.
    ippStsNumChannelsErr  - Error when the numChannels value differs from 1 or 3.
    ippStsSizeErr         - Error when lenLow or lenHigh is less than 2.
    ippStsAnchorErr       - Error when anchorLow or anchorHigh is less than zero.
}

 function ippiWTInvInit_32f_C1R( pSpec : IppiWTInvSpec_32f_C1RPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; anchorLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; anchorHigh : Int32 ): IppStatus; _ippapi
 function ippiWTInvInit_32f_C3R( pSpec : IppiWTInvSpec_32f_C3RPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; anchorLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; anchorHigh : Int32 ): IppStatus; _ippapi

{
 Name:        ippiWTInv_32f_C1R
              ippiWTInv_32f_C3R

 Purpose:     Performs wavelet reconstruction of an image.

 Parameters:
   pApproxSrc    Pointer to the source "approximation" image ROI;
   approxStep    Step in bytes through the source approximation image;
   pDetailXSrc   Pointer to the source "horizontal details" image ROI;
   detailXStep   Step in bytes through the source horizontal detail image;
   pDetailYSrc   Pointer to the source "vertical details" image ROI;
   detailYStep   Step in bytes through the source "vertical details" image;
   pDetailXYSrc  Pointer to the source "diagonal details" image ROI;
   detailXYStep  Step in bytes through the source "diagonal details" image;
   srcRoiSize    ROI size for all source images.
   pDst          Pointer to the destination image ROI;
   dstStep       Step in bytes through the destination image;
   pSpec         Pointer to the context structure;
   pBuffer       Pointer to the allocated buffer for intermediate operations.

 Returns:
   ippStsNoErr            OK;
   ippStsNullPtrErr       One of the pointers is NULL;
   ippStsSizeErr          srcRoiSize has a field with zero or negative value;
   ippStsContextMatchErr  Invalid context structure.

 Notes:
   No any fixed borders extension (wrap, symm.) will be applied! Source
    images must have valid and accessible border data outside of ROI.

   Only the same ROI size for source images supported. Destination ROI size
     should be calculated by next rule:
          dstRoiSize.width  = 2 * srcRoiSize.width;
          dstRoiSize.height = 2 * srcRoiSize.height.


   Monikers for the source images are in accordance with decomposition destination.

}

 function ippiWTInv_32f_C1R( pApproxSrc : Ipp32fPtr ; approxStep : Int32 ; pDetailXSrc : Ipp32fPtr ; detailXStep : Int32 ; pDetailYSrc : Ipp32fPtr ; detailYStep : Int32 ; pDetailXYSrc : Ipp32fPtr ; detailXYStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; pSpec : IppiWTInvSpec_32f_C1RPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWTInv_32f_C3R( pApproxSrc : Ipp32fPtr ; approxStep : Int32 ; pDetailXSrc : Ipp32fPtr ; detailXStep : Int32 ; pDetailYSrc : Ipp32fPtr ; detailYStep : Int32 ; pDetailXYSrc : Ipp32fPtr ; detailXYStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; pSpec : IppiWTInvSpec_32f_C3RPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi


{ ----------------------------------------------------------------------------

                   Image resampling functions
---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------

  Name:               ippiDecimateFilterRow_8u_C1R,
                      ippiDecimateFilterColumn_8u_C1R
  Purpose:            Decimate the image with specified filters
                      in horizontal or vertical directions
  Parameters:
    pSrc              source image data
    srcStep           step in source image
    srcRoiSize        region of interest of source image
    pDst              resultant image data
    dstStep           step in destination image
    fraction          they specify fractions of decimating
  Returns:
    ippStsNoErr       no errors
    ippStsNullPtrErr  one of the pointers is NULL
    ippStsStepErr     one of the step values is zero or negative
    ippStsSizeErr     srcRoiSize has a field with negative or zero value
    ippStsDecimateFractionErr (fraction != ippPolyphase_1_2) &&
                              (fraction != ippPolyphase_3_5) &&
                              (fraction != ippPolyphase_2_3) &&
                              (fraction != ippPolyphase_7_10) &&
                              (fraction != ippPolyphase_3_4)
}

 function ippiDecimateFilterRow_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; fraction : IppiFraction ): IppStatus; _ippapi
 function ippiDecimateFilterColumn_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; fraction : IppiFraction ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                   Geometric Transform functions
  ----------------------------------------------------------------------------

  Name:        ippiMirror

  Purpose:     Mirrors an image about a horizontal
               or vertical axis,  or both

  Context:

  Returns:     IppStatus
    ippStsNoErr         No errors
    ippStsNullPtrErr    pSrc == NULL, or pDst == NULL
    ippStsSizeErr,      roiSize has a field with zero or negative value
    ippStsMirrorFlipErr (flip != ippAxsHorizontal) &&
                        (flip != ippAxsVertical) &&
                        (flip != ippAxsBoth)

  Parameters:
    pSrc       Pointer to the source image
    srcStep    Step through the source image
    pDst       Pointer to the destination image
    dstStep    Step through the destination image
    pSrcDst    Pointer to the source/destination image (in-place flavors)
    srcDstStep Step through the source/destination image (in-place flavors)
    roiSize    Size of the ROI
    flip       Specifies the axis to mirror the image about:
                 ippAxsHorizontal     horizontal axis, 
                 ippAxsVertical       vertical axis, 
                 ippAxsBoth           both horizontal and vertical axes

  Notes:
}

 function ippiMirror_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_8u_C4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi

 function ippiMirror_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16u_C4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi

 function ippiMirror_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32s_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi

 function ippiMirror_32s_C1IR( pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32s_C3IR( pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32s_AC4IR( pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32s_C4IR( pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi

 function ippiMirror_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_16s_C4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi

 function ippiMirror_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi
 function ippiMirror_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; flip : IppiAxis ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiRemap
  Purpose:            Transforms the source image by remapping its pixels
                          dst[i,j] = src[xMap[i,j], yMap[i,j]]
  Parameters:
    pSrc              Pointer to the source image (point to pixel (0,0)). An array
                      of pointers to each plane of the source image for planar data
    srcSize           Size of the source image
    srcStep           Step through the source image
    srcROI            Region if interest in the source image
    pxMap             Pointer to image with x coordinates of map
    xMapStep          The step in xMap image
    pyMap             The pointer to image with y coordinates of map
    yMapStep          The step in yMap image
    pDst              Pointer to the destination image. An array of pointers
                      to each plane of the destination image for planar data
    dstStep           Step through the destination image
    dstRoiSize        Size of the destination ROI
    interpolation     The type of interpolation to perform for image resampling
                      The following types are currently supported:
                        IPPI_INTER_NN       Nearest neighbor interpolation
                        IPPI_INTER_LINEAR   Linear interpolation
                        IPPI_INTER_CUBIC    Cubic interpolation
                        IPPI_INTER_CUBIC2P_CATMULLROM  Catmull-Rom cubic filter
                        IPPI_INTER_LANCZOS  Interpolation by Lanczos3-windowed sinc function
                      The special feature in addition to one of general methods:
                        IPPI_SMOOTH_EDGE    Edges smoothing
  Returns:
    ippStsNoErr       OK
    ippStsNullPtrErr  One of the pointers is NULL
    ippStsSizeErr     srcROI or dstRoiSize has a field with zero or negative value
    ippStsStepErr     One of the step values is zero or negative
    ippStsInterpolateErr  interpolation has an illegal value
}

 function ippiRemap_8u_C1R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_8u_C3R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_8u_C4R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_8u_AC4R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_16u_C1R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_16u_C3R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_16u_C4R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_16u_AC4R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_16s_C1R( pSrc : Ipp16sPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_16s_C3R( pSrc : Ipp16sPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_16s_C4R( pSrc : Ipp16sPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_16s_AC4R( pSrc : Ipp16sPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_32f_C1R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_32f_C3R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_32f_C4R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_32f_AC4R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp32fPtr ; xMapStep : Int32 ; pyMap : Ipp32fPtr ; yMapStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_64f_C1R( pSrc : Ipp64fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp64fPtr ; xMapStep : Int32 ; pyMap : Ipp64fPtr ; yMapStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_64f_C3R( pSrc : Ipp64fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp64fPtr ; xMapStep : Int32 ; pyMap : Ipp64fPtr ; yMapStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_64f_C4R( pSrc : Ipp64fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp64fPtr ; xMapStep : Int32 ; pyMap : Ipp64fPtr ; yMapStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi
 function ippiRemap_64f_AC4R( pSrc : Ipp64fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pxMap : Ipp64fPtr ; xMapStep : Int32 ; pyMap : Ipp64fPtr ; yMapStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation: Word32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     Resize functions
 ----------------------------------------------------------------------------

  Name:               ippiResizeFilterGetSize_8u_C1R
  Purpose:            Computes pState size for resize filter (in bytes)
  Parameters:
    srcRoiSize        region of interest of source image
    dstRoiSize        region of interest of destination image
    filter            type of resize filter
    pSize             pointer to State size
  Returns:
    ippStsNoErr       no errors
    ippStsSizeErr     width or height of images is less or equal to zero
    ippStsNotSupportedModeErr filter type is not supported
    ippStsNullPtrErr  pointer to buffer size is NULL
}

 function ippiResizeFilterGetSize_8u_C1R( srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; filter : IppiResizeFilterType ; pSize : Ipp32uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeFilterInit_8u_C1R
  Purpose:            Initialization of State for resize filter
  Parameters:
    pState            pointer to State
    srcRoiSize        region of interest of source image
    dstRoiSize        region of interest of destination image
    filter            type of resize filter
  Returns:
    ippStsNoErr       no errors
    ippStsNullPtrErr  pointer to Spec is NULL
    ippStsSizeErr     width or height of images is less or equal to zero
    ippStsNotSupportedModeErr filter type is not supported
}

 function ippiResizeFilterInit_8u_C1R( pState : IppiResizeFilterStatePtr ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; filter : IppiResizeFilterType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeFilter_8u_C1R
  Purpose:            Performs RESIZE transform using generic filter
  Parameters:
    pSrc              source image data
    srcStep           step in source image
    srcRoiSize        region of interest of source image
    pDst              resultant image data
    dstStep           step in destination image
    dstRoiSize        region of interest of destination image
    pState            pointer to filter state
  Return:
    ippStsNoErr       no errors
    ippStsNullPtrErr  pSrc == NULL or pDst == NULL or pState == NULL
    ippStsStepErr     srcStep or dstStep is less than or equal to zero
    ippStsSizeErr     width or height of images is less or equal to zero
    ippStsContextMatchErr invalid context structure
}

 function ippiResizeFilter_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pState : IppiResizeFilterStatePtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     Resize functions. YUY2 pixel format

 ----------------------------------------------------------------------------

  Name:               ippiResizeYCbCr422GetBufSize
  Purpose:            Computes the size of an external work buffer (in bytes)
  Parameters:
    srcROI            region of interest of source image
    dstRoiSize        region of interest of destination image
    interpolation     type of interpolation to perform for resizing the input image:
                        IPPI_INTER_NN      Nearest Neighbor interpolation
                        IPPI_INTER_LINEAR  Linear interpolation
                        IPPI_INTER_CUBIC   Cubic interpolation
                        IPPI_INTER_CUBIC2P_CATMULLROM Catmull-Rom cubic filter
                        IPPI_INTER_LANCZOS Lanczos3 filter
    pSize             pointer to the external buffer`s size
  Returns:
    ippStsNoErr       no errors
    ippStsNullPtrErr  pSize == NULL
    ippStsSizeErr     width of src or dst image is less than two,  or
                      height of src or dst image is less than one
    ippStsDoubleSize  width of src or dst image doesn`t multiple of two (indicates warning)
    ippStsInterpolationErr  interpolation has an illegal value
}

 function ippiResizeYCbCr422GetBufSize( srcROI : IppiRect ; dstRoiSize : IppiSize ; interpolation : Int32 ; var pSize : Int32 ): IppStatus; _ippapi

{
  Name:               ippiResizeYCbCr422_8u_C2R
  Purpose:            Performs RESIZE transform for image with YCbCr422 pixel format
  Parameters:
    pSrc              source image data
    srcSize           size of source image
    srcStep           step in source image
    srcROI            region of interest of source image
    pDst              resultant image data
    dstStep           step in destination image
    dstRoiSize        region of interest of destination image
    interpolation     type of interpolation to perform for resizing the input image:
                        IPPI_INTER_NN      Nearest Neighbor interpolation
                        IPPI_INTER_LINEAR  Linear interpolation
                        IPPI_INTER_CUBIC   Cubic interpolation
                        IPPI_INTER_CUBIC2P_CATMULLROM Catmull-Rom cubic filter
                        IPPI_INTER_LANCZOS Lanczos3 filter
    pBuffer           pointer to work buffer
  Returns:
    ippStsNoErr       no errors
    ippStsNullPtrErr  pSrc == NULL or pDst == NULL or pBuffer == NULL
    ippStsSizeErr     width of src or dst image is less than two,  or
                      height of src or dst image is less than one
    ippStsDoubleSize  width of src or dst image doesn`t multiple of two (indicates warning)
    ippStsWrongIntersectROI srcROI has not intersection with the source image,  no operation
    ippStsInterpolationErr  interpolation has an illegal value
  Note:
    YUY2 pixel format (Y0U0Y1V0,Y2U1Y3V1,.. or Y0Cb0Y1Cr0, Y2Cb1Y3Cr1,..)
}

 function ippiResizeYCbCr422_8u_C2R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     Affine Transform functions
 ----------------------------------------------------------------------------

  Name:               ippiGetAffineBound
  Purpose:            Computes the bounding rectangle of the transformed image ROI
  Parameters:
    srcROI            Source image ROI
    coeffs            The affine transform matrix
                        |X'|   |a11 a12| |X| |a13|
                        |  | = |       |*| |+|   |
                        |Y'|   |a21 a22| |Y| |a23|
    bound             Resultant bounding rectangle
  Returns:
    ippStsNoErr       OK
}

 function ippiGetAffineBound( srcROI : IppiRect ; bound : double_2_2 ; const coeffs : double_2_3): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiGetAffineQuad
  Purpose:            Computes coordinates of the quadrangle to which a source ROI is mapped
  Parameters:
    srcROI            Source image ROI
    coeffs            The affine transform matrix
                        |X'|   |a11 a12| |X| |a13|
                        |  | = |       |*| |+|   |
                        |Y'|   |a21 a22| |Y| |a23|
    quad              Resultant quadrangle
  Returns:
    ippStsNoErr       OK
}

 function ippiGetAffineQuad( srcROI : IppiRect ; quad : double_4_2 ; const coeffs : double_2_3): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiGetAffineTransform
  Purpose:            Computes coefficients to transform a source ROI to a given quadrangle
  Parameters:
      srcROI          Source image ROI.
      coeffs          The resultant affine transform matrix
                        |X'|   |a11 a12| |X| |a13|
                        |  | = |       |*| |+|   |
                        |Y'|   |a21 a22| |Y| |a23|
      quad            Vertex coordinates of the quadrangle
  Returns:
    ippStsNoErr       OK
  Notes: The function computes the coordinates of the 4th vertex of the quadrangle
         that uniquely depends on the three other (specified) vertices.
         If the computed coordinates are not equal to the ones specified in quad, 
         the function returns the warning message and continues operation with the computed values
}

 function ippiGetAffineTransform( srcROI : IppiRect ; const quad : double_4_2 ; coeffs : double_2_3 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiGetRotateShift
  Purpose:            Calculates shifts for ippiRotate function to rotate an image
                      around the specified center (xCenter, yCenter)
  Parameters:
    xCenter, yCenter  Coordinates of the center of rotation
    angle             The angle of clockwise rotation,  degrees
    xShift, yShift    Pointers to the shift values
  Returns:
    ippStsNoErr       OK
    ippStsNullPtrErr  One of the pointers to the output data is NULL
}

 function ippiGetRotateShift( xCenter : double ; yCenter : double ; angle : double ; var xShift : double ; var yShift : double ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:                  ippiGetRotateTransform
  Purpose:               Computes the affine coefficients for the transform that
                         rotates an image around (0, 0) by specified angle + shifts it
                         | cos(angle)  sin(angle)  xShift|
                         |                               |
                         |-sin(angle)  cos(angle)  yShift|
  Parameters:
    srcROI               Source image ROI
    angle                The angle of rotation in degrees
    xShift, yShift       The shift along the corresponding axis
    coeffs               Output array with the affine transform coefficients
  Returns:
    ippStsNoErr          OK
    ippStsOutOfRangeErr  Indicates an error if the angle is NaN or Infinity
}

 function ippiGetRotateTransform( angle : double ; xShift : double ; yShift : double ; var coeffs : double_2_3 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiGetPerspectiveBound
  Purpose:  Computes the bounding rectangle for the transformed image ROI
  Context:
  Returns:        IppStatus.
    ippStsNoErr   OK
  Parameters:
      srcROI  Source image ROI.
      coeffs  The perspective transform matrix
                     a11*j + a12*i + a13
                 x = -------------------
                     a31*j + a32*i + a33

                     a21*j + a22*i + a23
                 y = -------------------
                     a31*j + a32*i + a33
      bound   Output array with vertex coordinates of the bounding rectangle
  Notes:
}

 function ippiGetPerspectiveBound( srcROI : IppiRect ; var bound : double_2_2 ; const coeffs : double_3_3): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiGetPerspectiveQuad
  Purpose:    Computes the quadrangle to which the source ROI would be mapped
  Context:
  Returns:        IppStatus
    ippStsNoErr   OK
  Parameters:
      srcROI    Source image ROI
      coeffs    The perspective transform matrix
                     a11*j + a12*i + a13
                 x = -------------------
                     a31*j + a32*i + a33

                     a21*j + a22*i + a23
                 y = -------------------
                     a31*j + a32*i + a33
      quadr     Output array with vertex coordinates of the quadrangle
  Notes:
}

 function ippiGetPerspectiveQuad( srcROI : IppiRect ; var quad : double_4_2 ; const coeffs : double_3_3): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiGetPerspectiveTransform
  Purpose:  Computes perspective transform matrix to transform the source ROI
            to the given quadrangle
  Context:
  Returns:        IppStatus.
    ippStsNoErr   OK
  Parameters:
      srcROI   Source image ROI.
      coeffs   The resultant perspective transform matrix
                     a11*j + a12*i + a13
                 x = -------------------
                     a31*j + a32*i + a33

                     a21*j + a22*i + a23
                 y = -------------------
                     a31*j + a32*i + a33
      quad     Vertex coordinates of the quadrangle
  Notes:
}

 function ippiGetPerspectiveTransform( srcROI : IppiRect ; const quad : double_4_2 ; var coeffs : double_3_3 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiGetBilinearBound
  Purpose:  Computes the bounding rectangle for the transformed image ROI
  Context:
  Returns:        IppStatus.
    ippStsNoErr   OK
  Parameters:
      srcROI  Source image ROI.
      coeffs  The bilinear transform matrix
                  |X|   |a11|      |a12 a13| |J|   |a14|
                  | | = |   |*JI + |       |*| | + |   |
                  |Y|   |a21|      |a22 a23| |I|   |a24|
      bound   Output array with vertex coordinates of the bounding rectangle
  Notes:
}

 function ippiGetBilinearBound( srcROI : IppiRect ; bound : double_2_2 ; const coeffs : double_2_4): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiGetBilinearQuad
  Purpose:   Computes the quadrangle to which the source ROI would be mapped
  Context:
  Returns:        IppStatus.
    ippStsNoErr   OK
  Parameters:
      srcROI   Source image ROI.
      coeffs   The bilinear transform matrix
                  |X|   |a11|      |a12 a13| |J|   |a14|
                  | | = |   |*JI + |       |*| | + |   |
                  |Y|   |a21|      |a22 a23| |I|   |a24|
      quadr    Output array with vertex coordinates of the quadrangle
  Notes:
}

 function ippiGetBilinearQuad( srcROI : IppiRect ; quad : double_4_2 ; const coeffs : double_2_4): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiGetBilinearTransform
  Purpose:  Computes bilinear transform matrix to transform the source ROI
            to the given quadrangle
  Context:
  Returns:        IppStatus.
    ippStsNoErr        OK
  Parameters:
      srcROI         Source image ROI.
      coeffs      The resultant bilinear transform matrix
                  |X|   |a11|      |a12 a13| |J|   |a14|
                  | | = |   |*JI + |       |*| | + |   |
                  |Y|   |a21|      |a22 a23| |I|   |a24|
      quad        Vertex coordinates of the quadrangle
  Notes:
}

 function ippiGetBilinearTransform( srcROI : IppiRect ; const quad : double_4_2 ; coeffs : double_2_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiWarpBilinearGetBufferSize
  Purpose:            Computes the size of external buffer for Bilinear transform

  Context:
    ippStsNoErr             Indicates no error
    ippStsNullPtrErr        Indicates an error condition,  if one of the specified pointers is NULL
    ippStsSizeErr           Indicates an error condition,  if one of the image dimensions has zero or negative value
    ippStsWarpDirectionErr  Indicates an error when the direction value is illegal.
    ippStsCoeffErr          Indicates an error condition,  if the bilinear transformation is singular.
    ippStsInterpolationErr  Indicates an error condition,  the interpolation has an illegal value
    ippStsWrongIntersectROI Indicates a warning that no operation is performed, 
                            if the ROI has no intersection with the source or destination ROI. No operation.
    ippStsWrongIntersectQuad  Indicates a warning that no operation is performed,  if the transformed
                              source image has no intersection with the destination image.

  Parameters:
    srcSize           Size of the source image
    srcROI            Region of interest in the source image
    dstROI            Region of interest in the destination image
    coeffs            The bilinear transform matrix
    direction         Transformation direction. Possible values are:
                          ippWarpForward  - Forward transformation.
                          ippWarpBackward - Backward transformation.
    coeffs            The bilinear transform matrix
    interpolation     The type of interpolation to perform for resampling
                      the input image. Possible values:
                          IPPI_INTER_NN       Nearest neighbor interpolation
                          IPPI_INTER_LINEAR   Linear interpolation
                          IPPI_INTER_CUBIC    Cubic convolution interpolation
                          IPPI_SMOOTH_EDGE    Edges smoothing in addition to one of the
                                              above methods
    pBufSize          Pointer to the size (in bytes) of the external buffer
}

 function ippiWarpBilinearGetBufferSize( srcSize : IppiSize ; srcROI : IppiRect ; dstROI : IppiRect ; direction : IppiWarpDirection ; const coeffs : double_2_4 ; interpolation: Word32 ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiWarpBilinear
  Purpose:  Performs bilinear warping of an image
                  |X|   |a11|      |a12 a13| |J|   |a14|
                  | | = |   |*JI + |       |*| | + |   |
                  |Y|   |a21|      |a22 a23| |I|   |a24|
  Context:
    ippStsNoErr           OK
    ippStsNullPtrErr      pSrc or pDst is NULL
    ippStsSizeErr         One of the image dimensions has zero or negative value
    ippStsStepErr         srcStep or dstStep has a zero or negative value
    ippStsInterpolateErr  interpolation has an illegal value
  Parameters:
      pSrc        Pointer to the source image data (point to pixel (0,0))
      srcSize     Size of the source image
      srcStep     Step through the source image
      srcROI      Region of interest in the source image
      pDst        Pointer to  the destination image (point to pixel (0,0))
      dstStep     Step through the destination image
      dstROI      Region of interest in the destination image
      coeffs      The bilinear transform matrix
      interpolation  The type of interpolation to perform for resampling
                  the input image. Possible values:
                  IPPI_INTER_NN       Nearest neighbor interpolation
                  IPPI_INTER_LINEAR   Linear interpolation
                  IPPI_INTER_CUBIC    Cubic convolution interpolation
                  IPPI_SMOOTH_EDGE    Edges smoothing in addition to one of the
                                      above methods
      pBuffer     Pointer to the external work buffer
  Notes:
}

 function ippiWarpBilinear_8u_C1R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinear_8u_C3R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinear_8u_C4R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinear_32f_C1R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinear_32f_C3R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinear_32f_C4R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinear_16u_C1R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinear_16u_C3R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinear_16u_C4R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiWarpBilinearBack
  Purpose:  Performs an inverse bilinear warping of an image
                  |X|   |a11|      |a12 a13| |J|   |a14|
                  | | = |   |*JI + |       |*| | + |   |
                  |Y|   |a21|      |a22 a23| |I|   |a24|
  Context:
    ippStsNoErr           OK
    ippStsNullPtrErr      pSrc or pDst is NULL
    ippStsSizeErr         One of the image dimensions has zero or negative value
    ippStsStepErr         srcStep or dstStep has a zero or negative value
    ippStsInterpolateErr  interpolation has an illegal value
  Parameters:
      pSrc        Pointer to the source image data (point to pixel (0,0))
      srcSize     Size of the source image
      srcStep     Step through the source image
      srcROI      Region of interest in the source image
      pDst        Pointer to  the destination image (point to pixel (0,0))
      dstStep     Step through the destination image
      dstROI      Region of interest in the destination image
      coeffs      The bilinear transform matrix
      interpolation  The type of interpolation to perform for resampling
                     the input image. Possible values:
                  IPPI_INTER_NN       Nearest neighbor interpolation
                  IPPI_INTER_LINEAR   Linear interpolation
                  IPPI_INTER_CUBIC    Cubic convolution interpolation
      pBuffer     Pointer to the external work buffer
  Notes:
}

 function ippiWarpBilinearBack_8u_C1R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearBack_8u_C3R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearBack_8u_C4R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearBack_32f_C1R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearBack_32f_C3R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearBack_32f_C4R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearBack_16u_C1R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearBack_16u_C3R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearBack_16u_C4R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const coeffs : double_2_4 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiWarpBilinearQuadGetBufferSize
  Purpose:    Computes the size of external buffer for Bilinear warping of
              an arbitrary quadrangle in the source image to the quadrangle
              in the destination image

  Context:
    ippStsNoErr             Indicates no error
    ippStsNullPtrErr        Indicates an error condition,  if pBufSize is NULL
    ippStsSizeErr           Indicates an error condition in the following cases:
                              if one of images ROI x, y has negative value
                              if one of images ROI dimension has zero or negative value
    ippStsQuadErr           Indicates an error if either of the given quadrangles is nonconvex
                            or degenerates into triangle,  line, or point.
    ippStsInterpolateErr    Indicates an error condition,  the interpolation has an illegal value.

  Parameters:
    srcSize     Size of the source image
    srcROI      Region of interest in the source image
    srcQuad     A given quadrangle in the source image
    dstROI      Region of interest in the destination image
    dstQuad     A given quadrangle in the destination image
    pBufSize    Pointer to the size (in bytes) of the external buffer
}

 function ippiWarpBilinearQuadGetBufferSize( srcSize : IppiSize ; srcROI : IppiRect ; const srcQuad : double_4_2 ; dstROI : IppiRect ; const dstQuad : double_4_2 ; interpolation: Word32 ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiWarpBilinearQuad
  Purpose:  Performs bilinear warping of an arbitrary quadrangle in the source
            image to the quadrangle in the destination image
                  |X|   |a11|      |a12 a13| |J|   |a14|
                  | | = |   |*JI + |       |*| | + |   |
                  |Y|   |a21|      |a22 a23| |I|   |a24|
  Context:
    ippStsNoErr           OK
    ippStsNullPtrErr      pSrc or pDst is NULL
    ippStsSizeErr         One of the image dimensions has zero or negative value
    ippStsStepErr         srcStep or dstStep has a zero or negative value
    ippStsInterpolateErr  interpolation has an illegal value
  Parameters:
      pSrc        Pointer to the source image data (point to pixel (0,0))
      srcSize     Size of the source image
      srcStep     Step through the source image
      srcROI      Region of interest in the source image
      srcQuad     A given quadrangle in the source image
      pDst        Pointer to  the destination image (point to pixel (0,0))
      dstStep     Step through the destination image
      dstROI      Region of interest in the destination image
      dstQuad     A given quadrangle in the destination image
      interpolation  The type of interpolation to perform for resampling
                  the input image. Possible values:
                  IPPI_INTER_NN       Nearest neighbor interpolation
                  IPPI_INTER_LINEAR   Linear interpolation
                  IPPI_INTER_CUBIC    Cubic convolution interpolation
                  IPPI_SMOOTH_EDGE    Edges smoothing in addition to one of the
                                      above methods
      pBuffer     Pointer to the external work buffer
  Notes:
}

 function ippiWarpBilinearQuad_8u_C1R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; const srcQuad : double_4_2 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const dstQuad : double_4_2 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearQuad_8u_C3R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; const srcQuad : double_4_2 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const dstQuad : double_4_2 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearQuad_8u_C4R( pSrc : Ipp8uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; const srcQuad : double_4_2 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const dstQuad : double_4_2 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearQuad_32f_C1R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; const srcQuad : double_4_2 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstROI : IppiRect ; const dstQuad : double_4_2 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearQuad_32f_C3R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; const srcQuad : double_4_2 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstROI : IppiRect ; const dstQuad : double_4_2 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearQuad_32f_C4R( pSrc : Ipp32fPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; const srcQuad : double_4_2 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstROI : IppiRect ; const dstQuad : double_4_2 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearQuad_16u_C1R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; const srcQuad : double_4_2 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const dstQuad : double_4_2 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearQuad_16u_C3R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; const srcQuad : double_4_2 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const dstQuad : double_4_2 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpBilinearQuad_16u_C4R( pSrc : Ipp16uPtr ; srcSize : IppiSize ; srcStep : Int32 ; srcROI : IppiRect ; const srcQuad : double_4_2 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstROI : IppiRect ; const dstQuad : double_4_2 ; interpolation: Word32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     Warp Transform functions
 ----------------------------------------------------------------------------

  Name:               ippiWarpGetBufferSize
  Purpose:            Computes the size of external buffer for Warp transform

  Parameters:
    pSpec             Pointer to the Spec structure for warp transform
    dstRoiSize        Size of the output image (in pixels)
    numChannels       Number of channels,  possible values are 1 or 3 or 4
    pBufSize          Pointer to the size (in bytes) of the external buffer

  Return Values:
    ippStsNoErr           Indicates no error
    ippStsNullPtrErr      Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation     Indicates a warning if width or height of output image is zero
    ippStsContextMatchErr Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsNumChannelsErr  Indicates an error if numChannels has illegal value
    ippStsSizeErr         Indicates an error condition in the following cases:
                          - if width or height of the source image is negative, 
                          - if the calculated buffer size exceeds maximum 32 bit signed integer
                            positive value (the processed image ROIs are too large ).
    ippStsSizeWrn         Indicates a warning if the destination image size is more than
                          the destination image origin size
}

 function ippiWarpGetBufferSize( pSpec : IppiWarpSpecPtr ; dstRoiSize : IppiSize ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiWarpQuadGetSize
  Purpose:            Computes the size of Spec structure and temporal buffer
                      for warping of an arbitrary quadrangle in the source
                      image to the quadrangle in the destination image

  Parameters:
    srcSize           Size of the input image (in pixels)
    dstQuad           Given quadrangle in the source image
    dstSize           Size of the output image (in pixels)
    dstQuad           Given quadrangle in the destination image
    transform         Warp transform type. Supported values: ippWarpAffine, and ippWarpPerspective.
    dataType          Data type of the source and destination images. Possible values
                      are ipp8u,  ipp16u, ipp16s, ipp32f and ipp64f.
    interpolation     Interpolation method. Supported values: ippNearest, ippLinear and ippCubic.
    border            Type of the border
    pSpecSize         Pointer to the size (in bytes) of the Spec structure
    pInitBufSize      Pointer to the size (in bytes) of the temporal buffer

  Return Values:
    ippStsNoErr                Indicates no error
    ippStsNullPtrErr           Indicates an error if one of the specified pointers is NULL
    ippStsSizeErr              Indicates an error in the following cases:
                               -  if width or height of the source or destination image is negative, 
                                  or equal to zero
                               -  if one of the calculated sizes exceeds maximum 32 bit signed integer
                                  positive value (the size of the one of the processed images is too large).
    ippStsDataTypeErr          Indicates an error when dataType has an illegal value.
    ippStsInterpolationErr     Indicates an error if interpolation has an illegal value
    ippStsNotSupportedModeErr  Indicates an error if the requested mode is not supported.
    ippStsBorderErr            Indicates an error if border type has an illegal value
    ippStsQuadErr              Indicates an error if either of the given quadrangles is nonconvex
                               or degenerates into triangle,  line, or point
    ippStsWarpTransformTypeErr Indicates an error when the transform value is illegal.
    ippStsWrongIntersectQuad   Indicates a warning that no operation is performed in the following cases:
                               -  if the transformed source image has no intersection with the destination image.
                               -  if either of the source quadrangle or destination quadrangle has no intersection
                                   with the source or destination image correspondingly
}

 function ippiWarpQuadGetSize( srcSize : IppiSize ; const srcQuad : double_4_2 ; dstSize : IppiSize ; const dstQuad : double_4_2 ; transform : IppiWarpTransformType ; dataType : IppDataType ; interpolation : IppiInterpolationType ; borderType : IppiBorderType ; var pSpecSize : Int32 ; var pInitBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiWarpQuadNearestInit
                      ippiWarpQuadLinearInit
                      ippiWarpQuadCubicInit

  Purpose:            Initializes the Spec structure for warping of
                      an arbitrary quadrangle in the source image to the quadrangle
                      in the destination image

  Parameters:
    srcSize           Size of the input image (in pixels)
    srcQuad           Given quadrangle in the source image
    dstSize           Size of the output image (in pixels)
    dstQuad           Given quadrangle in the destination image
    transform         Warp transform type. Supported values: ippWarpAffine, and ippWarpPerspective.
    dataType          Data type of the source and destination images. Possible values
                      are ipp8u,  ipp16u, ipp16s, ipp32f and ipp64f.
    numChannels       Number of channels,  possible values are 1 or 3 or 4
    valueB            The first parameter (B) for specifying Cubic filters
    valueC            The second parameter (C) for specifying Cubic filters
    border            Type of the border
    borderValue       Pointer to the constant value(s) if border type equals ippBorderConstant
    smoothEdge        The smooth edge flag. Supported values:
                          0 - transform without edge smoothing
                          1 - transform with edge smoothing
    pSpec             Pointer to the Spec structure for resize filter
    pInitBuf          Pointer to the temporal buffer for several initialization cases

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsSizeErr             Indicates an error if width or height of the source or destination
                              image is negative,  or equal to zero
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsWarpTransformErr    Indicates an error when the transform value is illegal.
    ippStsNumChannelsErr      Indicates an error if numChannels has illegal value
    ippStsBorderErr           Indicates an error if border type has an illegal value
    ippStsQuadErr             Indicates an error if either of the given quadrangles is nonconvex
                               or degenerates into triangle,  line, or point
    ippStsWrongIntersectQuad  Indicates a warning that no operation is performed,  if the transformed
                              source image has no intersection with the destination image.
    ippStsNotSupportedModeErr Indicates an error if the requested mode is not supported.

  Notes/References:
    1. The equation shows the family of cubic filters:
           ((12-9B-6C)*|x|^3 + (-18+12B+6C)*|x|^2                  + (6-2B)  ) / 6   for |x| < 1
    K(x) = ((   -B-6C)*|x|^3 + (    6B+30C)*|x|^2 + (-12B-48C)*|x| + (8B+24C); / 6   for 1 <= |x| < 2
           0   elsewhere
    Some values of (B,C) correspond to known cubic splines: Catmull-Rom (B=0,C=0.5), B-Spline (B=1,C=0) and other.
      Mitchell, Don P.; Netravali, Arun N. (Aug. 1988). "Reconstruction filters in computer graphics"
      http://www.mentallandscape.com/Papers_siggraph88.pdf

    2. Supported border types are ippBorderTransp and ippBorderInMem
}

 function ippiWarpQuadNearestInit( srcSize : IppiSize ; const srcQuad : double_4_2 ; dstSize : IppiSize ; const dstQuad : double_4_2 ; transform : IppiWarpTransformType ; dataType : IppDataType ; numChannels : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp64fPtr ; smoothEdge : Int32 ; pSpec : IppiWarpSpecPtr ): IppStatus; _ippapi
 function ippiWarpQuadLinearInit( srcSize : IppiSize ; const srcQuad : double_4_2 ; dstSize : IppiSize ; const dstQuad : double_4_2 ; transform : IppiWarpTransformType ; dataType : IppDataType ; numChannels : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp64fPtr ; smoothEdge : Int32 ; pSpec : IppiWarpSpecPtr ): IppStatus; _ippapi
 function ippiWarpQuadCubicInit( srcSize : IppiSize ; const srcQuad : double_4_2 ; dstSize : IppiSize ; const dstQuad : double_4_2 ; transform : IppiWarpTransformType ; dataType : IppDataType ; numChannels : Int32 ; valueB : Ipp64f ; valueC : Ipp64f ; borderType : IppiBorderType ; pBorderValue : Ipp64fPtr ; smoothEdge : Int32 ; pSpec : IppiWarpSpecPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     Warp Affine Transform functions
 ----------------------------------------------------------------------------

  Name:               ippiWarpAffineGetSize
  Purpose:            Computes the size of Spec structure and temporal buffer for Affine transform

  Parameters:
    srcSize           Size of the input image (in pixels)
    dstSize           Size of the output image (in pixels)
    dataType          Data type of the source and destination images. Possible values
                      are ipp8u,  ipp16u, ipp16s, ipp32f and ipp64f.
    coeffs            The affine transform coefficients
    interpolation     Interpolation method. Supported values: ippNearest, ippLinear and ippCubic.
    direction         Transformation direction. Possible values are:
                          ippWarpForward  - Forward transformation.
                          ippWarpBackward - Backward transformation.
    border            Type of the border
    pSpecSize         Pointer to the size (in bytes) of the Spec structure
    pInitBufSize      Pointer to the size (in bytes) of the temporal buffer

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of any image is zero
    ippStsSizeErr             Indicates an error in the following cases:
                              -  if width or height of the source or destination image is negative, 
                              -  if one of the calculated sizes exceeds maximum 32 bit signed integer
                                 positive value (the size of the one of the processed images is too large).
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsWarpDirectionErr    Indicates an error when the direction value is illegal.
    ippStsInterpolationErr    Indicates an error if interpolation has an illegal value
    ippStsNotSupportedModeErr Indicates an error if the requested mode is not supported.
    ippStsCoeffErr            Indicates an error condition,  if affine transformation is singular.
    ippStsBorderErr           Indicates an error if border type has an illegal value
}

 function ippiWarpAffineGetSize( srcSize : IppiSize ; dstSize : IppiSize ; dataType : IppDataType ; const coeffs : double_2_3 ; interpolation : IppiInterpolationType ; direction : IppiWarpDirection ; borderType : IppiBorderType ; var pSpecSize : Int32 ; var pInitBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiWarpAffineNearestInit
                      ippiWarpAffineLinearInit
                      ippiWarpAffineCubicInit

  Purpose:            Initializes the Spec structure for the Warp affine transform
                      by different interpolation methods

  Parameters:
    srcSize           Size of the input image (in pixels)
    dstSize           Size of the output image (in pixels)
    dataType          Data type of the source and destination images. Possible values are:
                      ipp8u, ipp16u, ipp16s, ipp32f, ipp64f.
    coeffs            The affine transform coefficients
    direction         Transformation direction. Possible values are:
                          ippWarpForward  - Forward transformation.
                          ippWarpBackward - Backward transformation.
    numChannels       Number of channels,  possible values are 1 or 3 or 4
    valueB            The first parameter (B) for specifying Cubic filters
    valueC            The second parameter (C) for specifying Cubic filters
    border            Type of the border
    borderValue       Pointer to the constant value(s) if border type equals ippBorderConstant
    smoothEdge        The smooth edge flag. Supported values:
                          0 - transform without edge smoothing
                          1 - transform with edge smoothing
    pSpec             Pointer to the Spec structure for resize filter
    pInitBuf          Pointer to the temporal buffer for several initialization cases

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of any image is zero
    ippStsSizeErr             Indicates an error if width or height of the source or destination
                              image is negative
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsWarpDirectionErr    Indicates an error when the direction value is illegal.
    ippStsCoeffErr            Indicates an error condition,  if the affine transformation is singular.
    ippStsNumChannelsErr      Indicates an error if numChannels has illegal value
    ippStsBorderErr           Indicates an error if border type has an illegal value
    ippStsWrongIntersectQuad  Indicates a warning that no operation is performed,  if the transformed
                              source image has no intersection with the destination image.
    ippStsNotSupportedModeErr Indicates an error if the requested mode is not supported.

  Notes/References:
    1. The equation shows the family of cubic filters:
           ((12-9B-6C)*|x|^3 + (-18+12B+6C)*|x|^2                  + (6-2B)  ) / 6   for |x| < 1
    K(x) = ((   -B-6C)*|x|^3 + (    6B+30C)*|x|^2 + (-12B-48C)*|x| + (8B+24C); / 6   for 1 <= |x| < 2
           0   elsewhere
    Some values of (B,C) correspond to known cubic splines: Catmull-Rom (B=0,C=0.5), B-Spline (B=1,C=0) and other.
      Mitchell, Don P.; Netravali, Arun N. (Aug. 1988). "Reconstruction filters in computer graphics"
      http://www.mentallandscape.com/Papers_siggraph88.pdf

    2. Supported border types are ippBorderRepl,  ippBorderConst, ippBorderTransp and ippBorderInMem
}

 function ippiWarpAffineNearestInit( srcSize : IppiSize ; dstSize : IppiSize ; dataType : IppDataType ; const coeffs : double_2_3 ; direction : IppiWarpDirection ; numChannels : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp64fPtr ; smoothEdge : Int32 ; pSpec : IppiWarpSpecPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinearInit( srcSize : IppiSize ; dstSize : IppiSize ; dataType : IppDataType ; const coeffs : double_2_3 ; direction : IppiWarpDirection ; numChannels : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp64fPtr ; smoothEdge : Int32 ; pSpec : IppiWarpSpecPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubicInit( srcSize : IppiSize ; dstSize : IppiSize ; dataType : IppDataType ; const coeffs : double_2_3 ; direction : IppiWarpDirection ; numChannels : Int32 ; valueB : Ipp64f ; valueC : Ipp64f ; borderType : IppiBorderType ; pBorderValue : Ipp64fPtr ; smoothEdge : Int32 ; pSpec : IppiWarpSpecPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiWarpAffineNearest
                      ippiWarpAffineLinear
                      ippiWarpAffineCubic

  Purpose:            Performs affine transform of an image with using different interpolation methods

  Parameters:
    pSrc              Pointer to the source image
    srcStep           Distance (in bytes) between of consecutive lines in the source image
    pDst              Pointer to the destination image
    dstStep           Distance (in bytes) between of consecutive lines in the destination image
    dstRoiOffset      Offset of tiled image respectively destination image origin
    dstRoiSize        Size of the destination image (in pixels)
    border            Type of the border
    borderValue       Pointer to the constant value(s) if border type equals ippBorderConstant
    pSpec             Pointer to the Spec structure for resize filter
    pBuffer           Pointer to the work buffer

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of output image is zero
    ippStsBorderErr           Indicates an error if border type has an illegal value
    ippStsContextMatchErr     Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsNotSupportedModeErr Indicates an error if requested mode is currently not supported
    ippStsSizeErr             Indicates an error if width or height of the destination image
                              is negative
    ippStsStepErr             Indicates an error if the step value is not data type multiple
    ippStsOutOfRangeErr       Indicates an error if the destination image offset point is outside the
                              destination image origin
    ippStsSizeWrn             Indicates a warning if the destination image size is more than
                              the destination image origin size
    ippStsWrongIntersectQuad  Indicates a warning that no operation is performed if the destination
                              ROI has no intersection with the transformed source image origin.

  Notes:
    1. Supported border types are ippBorderRepl,  ippBorderConst, ippBorderTransp and ippBorderRepl
}

 function ippiWarpAffineNearest_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_64f_C1R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_64f_C3R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineNearest_64f_C4R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiWarpAffineLinear_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_64f_C1R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_64f_C3R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineLinear_64f_C4R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiWarpAffineCubic_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_64f_C1R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_64f_C3R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpAffineCubic_64f_C4R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     Warp Perspective Transform functions
 ----------------------------------------------------------------------------

  Name:               ippiWarpPerspectiveGetSize
  Purpose:            Computes the size of Spec structure and temporal buffer
                      for Perspective transform

  Parameters:
    srcSize           Size of the input image (in pixels)
    srcRoi            Region of interest in the source image
    dstSize           Size of the output image (in pixels)
    dataType          Data type of the source and destination images. Possible values
                      are ipp8u,  ipp16u, ipp16s, ipp32f and ipp64f.
    coeffs            The perspective transform coefficients
    interpolation     Interpolation method. Supported values: ippNearest, ippLinear and ippCubic.
    direction         Transformation direction. Possible values are:
                          ippWarpForward  - Forward transformation.
                          ippWarpBackward - Backward transformation.
    border            Type of the border
    pSpecSize         Pointer to the size (in bytes) of the Spec structure
    pInitBufSize      Pointer to the size (in bytes) of the temporal buffer

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of any image is zero
    ippStsSizeErr             Indicates an error in the following cases:
                              -  if width or height of the source or destination image is negative, 
                              -  if one of the calculated sizes exceeds maximum 32 bit signed integer
                                 positive value (the size of the one of the processed images is too large).
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsWarpDirectionErr    Indicates an error when the direction value is illegal.
    ippStsInterpolationErr    Indicates an error if interpolation has an illegal value
    ippStsNotSupportedModeErr Indicates an error if the requested mode is not supported.
    ippStsCoeffErr            Indicates an error condition,  if perspective transformation is singular.
    ippStsBorderErr           Indicates an error if border type has an illegal value
}

 function ippiWarpPerspectiveGetSize( srcSize : IppiSize ; srcRoi : IppiRect ; dstSize : IppiSize ; dataType : IppDataType ; const coeffs : double_3_3 ; interpolation : IppiInterpolationType ; direction : IppiWarpDirection ; borderType : IppiBorderType ; var pSpecSize : Int32 ; var pInitBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiWarpPerspectiveNearestInit
                      ippiWarpPerspectiveLinearInit
                      ippiWarpPerspectiveCubicInit

  Purpose:            Initializes the Spec structure for the Warp perspective transform
                      by different interpolation methods

  Parameters:
    srcSize           Size of the input image (in pixels)
    srcRoi            Region of interest in the source image
    dstSize           Size of the output image (in pixels)
    dataType          Data type of the source and destination images. Possible values are:
                      ipp8u, ipp16u, ipp16s, ipp32f, ipp64f.
    coeffs            The perspective transform coefficients
    direction         Transformation direction. Possible values are:
                          ippWarpForward  - Forward transformation.
                          ippWarpBackward - Backward transformation.
    numChannels       Number of channels,  possible values are 1 or 3 or 4
    valueB            The first parameter (B) for specifying Cubic filters
    valueC            The second parameter (C) for specifying Cubic filters
    border            Type of the border
    borderValue       Pointer to the constant value(s) if border type equals ippBorderConstant
    smoothEdge        The smooth edge flag. Supported values:
                          0 - transform without edge smoothing
                          1 - transform with edge smoothing
    pSpec             Pointer to the Spec structure for resize filter
    pInitBuf          Pointer to the temporal buffer for several initialization cases

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of any image is zero
    ippStsSizeErr             Indicates an error if width or height of the source or destination
                              image is negative
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsWarpDirectionErr    Indicates an error when the direction value is illegal.
    ippStsCoeffErr            Indicates an error condition,  if the perspective transformation is singular.
    ippStsNumChannelsErr      Indicates an error if numChannels has illegal value
    ippStsBorderErr           Indicates an error if border type has an illegal value
    ippStsWrongIntersectQuad  Indicates a warning that no operation is performed,  if the transformed
                              source image has no intersection with the destination image.
    ippStsNotSupportedModeErr Indicates an error if the requested mode is not supported.

  Notes/References:
    1. The equation shows the family of cubic filters:
           ((12-9B-6C)*|x|^3 + (-18+12B+6C)*|x|^2                  + (6-2B)  ) / 6   for |x| < 1
    K(x) = ((   -B-6C)*|x|^3 + (    6B+30C)*|x|^2 + (-12B-48C)*|x| + (8B+24C); / 6   for 1 <= |x| < 2
           0   elsewhere
    Some values of (B,C) correspond to known cubic splines: Catmull-Rom (B=0,C=0.5), B-Spline (B=1,C=0) and other.
      Mitchell, Don P.; Netravali, Arun N. (Aug. 1988). "Reconstruction filters in computer graphics"
      http://www.mentallandscape.com/Papers_siggraph88.pdf

    2. Supported border types are ippBorderRepl,  ippBorderConst, ippBorderTransp and ippBorderRepl
}

 function ippiWarpPerspectiveNearestInit( srcSize : IppiSize ; srcRoi : IppiRect ; dstSize : IppiSize ; dataType : IppDataType ; const coeffs : double_3_3 ; direction : IppiWarpDirection ; numChannels : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp64fPtr ; smoothEdge : Int32 ; pSpec : IppiWarpSpecPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinearInit( srcSize : IppiSize ; srcRoi : IppiRect ; dstSize : IppiSize ; dataType : IppDataType ; const coeffs : double_3_3 ; direction : IppiWarpDirection ; numChannels : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp64fPtr ; smoothEdge : Int32 ; pSpec : IppiWarpSpecPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubicInit( srcSize : IppiSize ; srcRoi : IppiRect ; dstSize : IppiSize ; dataType : IppDataType ; const coeffs : double_3_3 ; direction : IppiWarpDirection ; numChannels : Int32 ; valueB : Ipp64f ; valueC : Ipp64f ; borderType : IppiBorderType ; pBorderValue : Ipp64fPtr ; smoothEdge : Int32 ; pSpec : IppiWarpSpecPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiWarpPerspectiveNearest
                      ippiWarpPerspectiveLinear
                      ippiWarpPerspectiveCubic

  Purpose:            Performs perspective transform of an image with using
                      different interpolation methods

  Parameters:
    pSrc              Pointer to the source image
    srcStep           Distance (in bytes) between of consecutive lines in the source image
    pDst              Pointer to the destination image
    dstStep           Distance (in bytes) between of consecutive lines in the destination image
    dstRoiOffset      Offset of tiled image respectively destination image origin
    dstRoiSize        Size of the destination image (in pixels)
    border            Type of the border
    borderValue       Pointer to the constant value(s) if border type equals ippBorderConstant
    pSpec             Pointer to the Spec structure for resize filter
    pBuffer           Pointer to the work buffer

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of output image is zero
    ippStsBorderErr           Indicates an error if border type has an illegal value
    ippStsContextMatchErr     Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsNotSupportedModeErr Indicates an error if requested mode is currently not supported
    ippStsSizeErr             Indicates an error if width or height of the destination image
                              is negative
    ippStsStepErr             Indicates an error if the step value is not data type multiple
    ippStsOutOfRangeErr       Indicates an error if the destination image offset point is outside the
                              destination image origin
    ippStsSizeWrn             Indicates a warning if the destination image size is more than
                              the destination image origin size
    ippStsWrongIntersectQuad  Indicates a warning that no operation is performed if the destination
                              ROI has no intersection with the transformed source image origin.

  Notes:
    1. Supported border types are ippBorderRepl,  ippBorderConst, ippBorderTransp and ippBorderRepl
}

 function ippiWarpPerspectiveNearest_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveNearest_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveNearest_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveNearest_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveNearest_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveNearest_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveNearest_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveNearest_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveNearest_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveNearest_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveNearest_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveNearest_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiWarpPerspectiveLinear_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinear_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinear_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinear_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinear_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinear_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinear_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinear_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinear_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinear_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinear_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveLinear_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiWarpPerspectiveCubic_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubic_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubic_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubic_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubic_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubic_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubic_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubic_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubic_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubic_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubic_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWarpPerspectiveCubic_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; pSpec : IppiWarpSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                   Statistic functions
----------------------------------------------------------------------------

  Name:      ippiMomentGetStateSize_64s
             ippiMomentGetStateSize_64f

  Purpose:   Computes the size of the external buffer for the state
             structure ippiMomentsState_64s in bytes

  Returns:
    ippStsNoErr         OK
    ippStsNullPtrErr    pSize==NULL
  Parameters:
    hint                Option to specify the computation algorithm
    pSize               Pointer to the value of the buffer size
                        of the structure ippiMomentState_64s.
}

 function ippiMomentGetStateSize_64f( hint : IppHintAlgorithm ; var pSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiMomentInit64s
                  ippiMomentInit64f

  Purpose:        Initializes ippiMomentState_64s structure (without memory allocation)

  Returns:
    ippStsNoErr   No errors

  Parameters:
    pState        Pointer to the MomentState structure
    hint          Option to specify the computation algorithm
}

 function ippiMomentInit_64f( pState : IppiMomentState_64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiMoments

  Purpose:   Computes statistical moments of an image

  Returns:
    ippStsContextMatchErr   pState->idCtx != idCtxMoment
    ippStsNullPtrErr        (pSrc == NULL) or (pState == NULL)
    ippStsStepErr           pSrcStep <0
    ippStsSizeErr           (roiSize.width  <1) or (roiSize.height <1)
    ippStsNoErr             No errors

  Parameters:
    pSrc     Pointer to the source image
    srcStep  Step in bytes through the source image
    roiSize  Size of the source ROI
    pState   Pointer to the MomentState structure

  Notes:
    These functions compute moments of order 0 to 3 only
}

 function ippiMoments64f_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pCtx : IppiMomentState_64fPtr ): IppStatus; _ippapi
 function ippiMoments64f_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pCtx : IppiMomentState_64fPtr ): IppStatus; _ippapi
 function ippiMoments64f_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pCtx : IppiMomentState_64fPtr ): IppStatus; _ippapi

 function ippiMoments64f_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pCtx : IppiMomentState_64fPtr ): IppStatus; _ippapi
 function ippiMoments64f_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pCtx : IppiMomentState_64fPtr ): IppStatus; _ippapi
 function ippiMoments64f_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pCtx : IppiMomentState_64fPtr ): IppStatus; _ippapi

 function ippiMoments64f_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pCtx : IppiMomentState_64fPtr ): IppStatus; _ippapi
 function ippiMoments64f_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pCtx : IppiMomentState_64fPtr ): IppStatus; _ippapi
 function ippiMoments64f_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pCtx : IppiMomentState_64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiGetSpatialMoment()
             ippiGetCentralMoment()

  Purpose:   Retrieves the value of the image spatial/central moment.

  Returns:
    ippStsNullPtrErr      (pState == NULL) or (pValue == NULL)
    ippStsContextMatchErr pState->idCtx != idCtxMoment
    ippStsSizeErr         (mOrd+nOrd) >3 or
                          (nChannel<0) or (nChannel>=pState->nChannelInUse)
    ippStsNoErr           No errors

  Parameters:
    pState      Pointer to the MomentState structure
    mOrd        m- Order (X direction)
    nOrd        n- Order (Y direction)
    nChannel    Channel number
    roiOffset   Offset of the ROI origin (ippiGetSpatialMoment ONLY!)
    pValue      Pointer to the retrieved moment value
    scaleFactor Factor to scale the moment value (for integer data)

  NOTE:
    ippiGetSpatialMoment uses Absolute Coordinates (left-top image has 0, 0).
}

 function ippiGetSpatialMoment_64f( pState : IppiMomentState_64fPtr ; mOrd : Int32 ; nOrd : Int32 ; nChannel : Int32 ; roiOffset : IppiPoint ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiGetCentralMoment_64f( pState : IppiMomentState_64fPtr ; mOrd : Int32 ; nOrd : Int32 ; nChannel : Int32 ; pValue : Ipp64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiGetNormalizedSpatialMoment()
             ippiGetNormalizedCentralMoment()

  Purpose:   Retrieves the normalized value of the image spatial/central moment.

  Returns:
    ippStsNullPtrErr      (pState == NULL) or (pValue == NULL)
    ippStsContextMatchErr pState->idCtx != idCtxMoment
    ippStsSizeErr         (mOrd+nOrd) >3 or
                          (nChannel<0) or (nChannel>=pState->nChannelInUse)
    ippStsMoment00ZeroErr mm[0][0] < IPP_EPS52
    ippStsNoErr           No errors

  Parameters:
    pState      Pointer to the MomentState structure
    mOrd        m- Order (X direction)
    nOrd        n- Order (Y direction)
    nChannel    Channel number
    roiOffset   Offset of the ROI origin (ippiGetSpatialMoment ONLY!)
    pValue      Pointer to the normalized moment value
    scaleFactor Factor to scale the moment value (for integer data)
}

 function ippiGetNormalizedSpatialMoment_64f( pState : IppiMomentState_64fPtr ; mOrd : Int32 ; nOrd : Int32 ; nChannel : Int32 ; roiOffset : IppiPoint ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiGetNormalizedCentralMoment_64f( pState : IppiMomentState_64fPtr ; mOrd : Int32 ; nOrd : Int32 ; nChannel : Int32 ; pValue : Ipp64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiGetHuMoments()

  Purpose:   Retrieves image Hu moment invariants.

  Returns:
    ippStsNullPtrErr      (pState == NULL) or (pHu == NULL)
    ippStsContextMatchErr pState->idCtx != idCtxMoment
    ippStsSizeErr         (nChannel<0) or (nChannel>=pState->nChannelInUse)
    ippStsMoment00ZeroErr mm[0][0] < IPP_EPS52
    ippStsNoErr           No errors

  Parameters:
    pState      Pointer to the MomentState structure
    nChannel    Channel number
    pHm         Pointer to the array of the Hu moment invariants
    scaleFactor Factor to scale the moment value (for integer data)

  Notes:
    We consider Hu moments up to the 7-th order only
}

 function ippiGetHuMoments_64f( pState : IppiMomentState_64fPtr ; nChannel : Int32 ; pHm : IppiHuMoment_64f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiNorm_Inf
  Purpose:        computes the C-norm of pixel values of the image: n = MAX |src1|
  Context:
  Returns:        IppStatus
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value
  Parameters:
    pSrc        Pointer to the source image.
    srcStep     Step through the source image
    roiSize     Size of the source ROI.
    pValue      Pointer to the computed norm (one-channel data)
    value       Array of the computed norms for each channel (multi-channel data)
  Notes:
}

 function ippiNorm_Inf_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_Inf_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNorm_Inf_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNorm_Inf_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_Inf_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNorm_Inf_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNorm_Inf_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_Inf_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNorm_Inf_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNorm_Inf_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_Inf_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNorm_Inf_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiNorm_L1
  Purpose:        computes the L1-norm of pixel values of the image: n = SUM |src1|
  Context:
  Returns:        IppStatus
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value
  Parameters:
    pSrc        Pointer to the source image.
    srcStep     Step through the source image
    roiSize     Size of the source ROI.
    pValue      Pointer to the computed norm (one-channel data)
    value       Array of the computed norms for each channel (multi-channel data)
    hint        Option to specify the computation algorithm
  Notes:
}

 function ippiNorm_L1_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L1_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNorm_L1_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNorm_L1_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L1_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNorm_L1_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNorm_L1_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L1_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNorm_L1_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNorm_L1_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNorm_L1_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNorm_L1_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiNorm_L2
  Purpose:        computes the L2-norm of pixel values of the image: n = SQRT(SUM |src1|^2)
  Context:
  Returns:        IppStatus
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value
  Parameters:
    pSrc        Pointer to the source image.
    srcStep     Step through the source image
    roiSize     Size of the source ROI.
    pValue      Pointer to the computed norm (one-channel data)
    value       Array of the computed norms for each channel (multi-channel data)
    hint        Option to specify the computation algorithm
  Notes:
    simple mul is better than table for P6 family
}

 function ippiNorm_L2_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L2_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNorm_L2_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNorm_L2_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L2_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNorm_L2_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNorm_L2_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNorm_L2_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNorm_L2_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNorm_L2_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNorm_L2_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNorm_L2_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiNormDiff_Inf
  Purpose:        computes the C-norm of pixel values of two images: n = MAX |src1 - src2|
  Context:
  Returns:        IppStatus
    ippStsNoErr         OK
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsSizeErr       roiSize has a field with zero or negative value
  Parameters:
    pSrc1, pSrc2        Pointers to the source images.
    src1Step, src2Step  Steps in bytes through the source images
    roiSize             Size of the source ROI.
    pValue              Pointer to the computed norm (one-channel data)
    value               Array of the computed norms for each channel (multi-channel data)
  Notes:
}

 function ippiNormDiff_Inf_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_Inf_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormDiff_Inf_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormDiff_Inf_16s_C1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_Inf_16s_C3R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormDiff_Inf_16s_C4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormDiff_Inf_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_Inf_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormDiff_Inf_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormDiff_Inf_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_Inf_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormDiff_Inf_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiNormDiff_L1
  Purpose:        computes the L1-norm of pixel values of two images: n = SUM |src1 - src2|
  Context:
  Returns:        IppStatus
    ippStsNoErr         OK
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsSizeErr       roiSize has a field with zero or negative value
  Parameters:
    pSrc1, pSrc2        Pointers to the source images.
    src1Step, src2Step  Steps in bytes through the source images
    roiSize             Size of the source ROI.
    pValue              Pointer to the computed norm (one-channel data)
    value               Array of the computed norms for each channel (multi-channel data)
    hint                Option to specify the computation algorithm
  Notes:
}

 function ippiNormDiff_L1_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L1_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormDiff_L1_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormDiff_L1_16s_C1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L1_16s_C3R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormDiff_L1_16s_C4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormDiff_L1_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L1_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormDiff_L1_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormDiff_L1_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNormDiff_L1_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNormDiff_L1_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiNormDiff_L2
  Purpose:        computes the L2-norm of pixel values of two images:
                    n = SQRT(SUM |src1 - src2|^2)
  Context:
  Returns:        IppStatus
    ippStsNoErr         OK
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsSizeErr       roiSize has a field with zero or negative value
  Parameters:
    pSrc1, pSrc2        Pointers to the source images.
    src1Step, src2Step  Steps in bytes through the source images
    roiSize             Size of the source ROI.
    pValue              Pointer to the computed norm (one-channel data)
    value               Array of the computed norms for each channel (multi-channel data)
    hint                Option to specify the computation algorithm
  Notes:
}

 function ippiNormDiff_L2_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L2_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormDiff_L2_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormDiff_L2_16s_C1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L2_16s_C3R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormDiff_L2_16s_C4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormDiff_L2_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormDiff_L2_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormDiff_L2_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormDiff_L2_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNormDiff_L2_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNormDiff_L2_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiNormRel_Inf
  Purpose:        computes the relative error for the C-norm of pixel values of two images:
                      n = MAX |src1 - src2| / MAX |src2|
  Context:
  Returns:        IppStatus
    ippStsNoErr         OK
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsSizeErr       roiSize has a field with zero or negative value
    ippStsDivByZero     MAX |src2| == 0
  Parameters:
    pSrc1, pSrc2        Pointers to the source images.
    src1Step, src2Step  Steps in bytes through the source images
    roiSize             Size of the source ROI.
    pValue              Pointer to the computed norm (one-channel data)
    value               Array of the computed norms for each channel (multi-channel data)
  Notes:
}

 function ippiNormRel_Inf_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_Inf_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormRel_Inf_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormRel_Inf_16s_C1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_Inf_16s_C3R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormRel_Inf_16s_C4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormRel_Inf_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_Inf_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormRel_Inf_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormRel_Inf_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_Inf_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormRel_Inf_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiNormRel_L1
  Purpose:        computes the relative error for the 1-norm of pixel values of two images:
                      n = SUM |src1 - src2| / SUM |src2|
  Context:
  Returns:        IppStatus
    ippStsNoErr         OK
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsSizeErr       roiSize has a field with zero or negative value
    ippStsDivByZero     SUM |src2| == 0
  Parameters:
    pSrc1, pSrc2        Pointers to the source images.
    src1Step, src2Step  Steps in bytes through the source images
    roiSize             Size of the source ROI.
    pValue              Pointer to the computed norm (one-channel data)
    value               Array of the computed norms for each channel (multi-channel data)
    hint                Option to specify the computation algorithm
  Notes:
}

 function ippiNormRel_L1_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L1_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormRel_L1_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormRel_L1_16s_C1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L1_16s_C3R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormRel_L1_16s_C4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormRel_L1_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L1_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormRel_L1_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormRel_L1_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNormRel_L1_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNormRel_L1_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiNormRel_L2
  Purpose:        computes the relative error for the L2-norm of pixel values of two images:
                      n = SQRT(SUM |src1 - src2|^2 / SUM |src2|^2)
  Context:
  Returns:        IppStatus
    ippStsNoErr         OK
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsSizeErr       roiSize has a field with zero or negative value
    ippStsDivByZero     SUM |src2|^2 == 0
  Parameters:
    pSrc1, pSrc2        Pointers to the source images.
    src1Step, src2Step  Steps in bytes through the source images
    roiSize             Size of the source ROI.
    pValue              Pointer to the computed norm (one-channel data)
    value               Array of the computed norms for each channel (multi-channel data)
    hint                Option to specify the computation algorithm
  Notes:
}

 function ippiNormRel_L2_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L2_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormRel_L2_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormRel_L2_16s_C1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L2_16s_C3R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormRel_L2_16s_C4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormRel_L2_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ): IppStatus; _ippapi
 function ippiNormRel_L2_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ): IppStatus; _ippapi
 function ippiNormRel_L2_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ): IppStatus; _ippapi
 function ippiNormRel_L2_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pValue : Ipp64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNormRel_L2_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_3 ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiNormRel_L2_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; value : Ipp64f_4 ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiSum
  Purpose:        computes the sum of image pixel values
  Context:
  Returns:        IppStatus
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value
  Parameters:
    pSrc        Pointer to the source image.
    srcStep     Step in bytes through the source image
    roiSize     Size of the source image ROI.
    pSum        Pointer to the result (one-channel data)
    sum         Array containing the results (multi-channel data)
    hint        Option to select the algorithmic implementation of the function
  Notes:
}

 function ippiSum_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pSum : Ipp64fPtr ): IppStatus; _ippapi
 function ippiSum_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; sum : Ipp64f_3 ): IppStatus; _ippapi
 function ippiSum_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; sum : Ipp64f_4 ): IppStatus; _ippapi
 function ippiSum_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pSum : Ipp64fPtr ): IppStatus; _ippapi
 function ippiSum_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; sum : Ipp64f_3 ): IppStatus; _ippapi
 function ippiSum_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; sum : Ipp64f_4 ): IppStatus; _ippapi
 function ippiSum_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pSum : Ipp64fPtr ): IppStatus; _ippapi
 function ippiSum_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; sum : Ipp64f_3 ): IppStatus; _ippapi
 function ippiSum_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; sum : Ipp64f_4 ): IppStatus; _ippapi
 function ippiSum_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pSum : Ipp64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiSum_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; sum : Ipp64f_3 ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiSum_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; sum : Ipp64f_4 ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiMean
  Purpose:        computes the mean of image pixel values
  Context:
  Returns:        IppStatus
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value.
  Parameters:
    pSrc        Pointer to the source image.
    srcStep     Step in bytes through the source image
    roiSize     Size of the source ROI.
    pMean       Pointer to the result (one-channel data)
    mean        Array containing the results (multi-channel data)
    hint        Option to select the algorithmic implementation of the function
  Notes:
}

 function ippiMean_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMean : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; mean : Ipp64f_3 ): IppStatus; _ippapi
 function ippiMean_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; mean : Ipp64f_4 ): IppStatus; _ippapi
 function ippiMean_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMean : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; mean : Ipp64f_3 ): IppStatus; _ippapi
 function ippiMean_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; mean : Ipp64f_4 ): IppStatus; _ippapi
 function ippiMean_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMean : Ipp64fPtr ): IppStatus; _ippapi
 function ippiMean_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; mean : Ipp64f_3 ): IppStatus; _ippapi
 function ippiMean_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; mean : Ipp64f_4 ): IppStatus; _ippapi
 function ippiMean_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMean : Ipp64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiMean_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; mean : Ipp64f_3 ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiMean_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; mean : Ipp64f_4 ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:   ippiQualityIndex

  Purpose: ippiQualityIndex() function calculates the Universal Image Quality
           Index. Instead of traditional error summation methods,  the
           proposed index is designed by modeling any image distortion as a
           combination of three factors: loss of correlation,  luminance
           distortion, and contrast distortion. The dynamic range of the index
           is [-1.0, 1.0].

  Parameters:
    pSrc1          - Pointer to the first source image ROI.
    src1Step       - Distance, in bytes,  between the starting points of consecutive lines in the first source image.
    pSrc2          - Pointer to the second source image ROI.
    src2Step       - Distance, in bytes,  between the starting points of consecutive lines in the second source image.
    roiSize        - Size, in pixels,  of the 1st and 2nd source images.
    pQualityIndex  - Pointer where to store the calculated Universal Image Quality Index.
    pBuffer        - Pointer to the buffer for internal calculations. Size of the buffer is calculated by ippiQualityIndexGetBufferSize.

  Returns:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - Error when any of the specified pointers is NULL.
    ippStsSizeErr     - Error when the roiSize has a zero or negative value.
    ippStsStepErr     - Error when the src1Step or src2Step is less than or equal to zero.
}

 function ippiQualityIndex_8u32f_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pQualityIndex : Ipp32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiQualityIndex_8u32f_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pQualityIndex : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiQualityIndex_8u32f_AC4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pQualityIndex : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiQualityIndex_16u32f_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pQualityIndex : Ipp32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiQualityIndex_16u32f_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pQualityIndex : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiQualityIndex_16u32f_AC4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; roiSize : IppiSize ; pQualityIndex : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiQualityIndex_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pQualityIndex : Ipp32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiQualityIndex_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pQualityIndex : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiQualityIndex_32f_AC4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; roiSize : IppiSize ; pQualityIndex : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:     ippiQualityIndexGetBufferSize
  Purpose:   Get the size (in bytes) of the buffer for ippiQualityIndex.
  Parameters:
    srcType     - IPP data type name of the source images. Possible values are ipp8u, ipp16u or ipp32f.
    ippChan     - IPP channels name of of the source images. Possible values are ippC1, ippC3 or ippAC4.
    roiSize     - Size, in pixels,  of the source images.
    pBufferSize - Pointer to the calculated buffer size (in bytes).
  Return:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - Error when any of the specified pointers is NULL.
    ippStsSizeErr     - Error when the roiSize has a zero or negative value.
    ippStsDataTypeErr - Error when the srcType has an illegal value.
    ippStsChannelErr  - Error when the ippChan has an illegal value.
}

 function ippiQualityIndexGetBufferSize( srcType : IppDataType ; ippChan : IppChannels ; roiSize : IppiSize ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:     ippiHistogramGetBufferSize
  Purpose:   Get the sizes (in bytes) of the spec and the buffer for ippiHistogram_.
  Parameters:
    dataType    - Data type for source image. Possible values are ipp8u,  ipp16u, ipp16s or ipp32f.
    roiSize     - Size, in pixels,  of the source image.
    nLevels     - Number of levels values,  separate for each channel.
    numChannels - Number of image channels. Possible values are 1,  3, or 4.
    uniform     - Type of levels distribution: 0 - with random step,  1 - with uniform step.
    pSpecSize   - Pointer to the calculated spec size (in bytes).
    pBufferSize - Pointer to the calculated buffer size (in bytes).
  Return:
    ippStsNoErr             - OK.
    ippStsNullPtrErr        - Error when any of the specified pointers is NULL.
    ippStsSizeErr           - Error when the roiSize has a zero or negative value.
    ippStsHistoNofLevelsErr - Error when the number of levels is less than 2.
    ippStsNumChannelsErr    - Error when the numChannels value differs from 1,  3, or 4.
    ippStsDataTypeErr       - Error when the dataType value differs from the ipp8u,  ipp16u, ipp16s or ipp32f.
}

 function ippiHistogramGetBufferSize( dataType : IppDataType ; roiSize : IppiSize ; nLevels : Int32Ptr ; numChannels : Int32 ; uniform : Int32 ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:     ippiHistogramInit, ippiHistogramUniformInit
  Purpose:   Initializes the Spec for ippiHistogram.
  Parameters:
    dataType    - Data type for source image. Possible values are ipp8u,  ipp16u, ipp16s or ipp32f.
    pLevels     - Pointer to the array of level values. In case of multi-channel data,  pLevels is an array of pointers to the level values array for each channel.
    lowerLevel  - The lower levels for uniform histogram,  separate for each channel.
    upperLevel  - The upper levels for uniform histogram,  separate for each channel.
    nLevels     - Number of levels values,  separate for each channel.
    numChannels - Number of image channels. Possible values are 1,  3, or 4.
    pSpec       - Pointer to the spec object.
  Return:
    ippStsNoErr             - OK.
    ippStsNullPtrErr        - Error when any of the specified pointers is NULL.
    ippStsNumChannelsErr    - Error when the numChannels value differs from 1,  3, or 4.
    ippStsHistoNofLevelsErr - Error when the number of levels is less than 2.
    ippStsRangeErr          - Error when consecutive pLevels values don`t satisfy the condition: pLevel[i] < pLevel[i+1].
    ippStsDataTypeErr       - Error when the dataType value differs from the ipp8u,  ipp16u, ipp16s or ipp32f.
    ippStsSizeWrn           - Warning ( in case of uniform histogram of integer data type) when rated level step is less than 1.
}

 function ippiHistogramInit( dataType : IppDataType ; pLevels : Ipp32fPtr ; nLevels : Int32Ptr ; numChannels : Int32 ; pSpec : IppiHistogramSpecPtr ): IppStatus; _ippapi
 function ippiHistogramUniformInit( dataType : IppDataType ; lowerLevel : Ipp32fPtr ; upperLevel : Ipp32fptr ; nLevels : Int32Ptr ; numChannels : Int32 ; pSpec : IppiHistogramSpecPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiHistogramGetLevels
  Purpose:   Returns levels arrays stored in the pSpec object.
  Parameters:
    pSpec       - Pointer to the spec object.
    pLevels     - Pointer to the array of level values. In case of multi-channel data,  pLevels is an array of pointers to the level values array for each channel.
  Return:
    ippStsNoErr             - OK.
    ippStsNullPtrErr        - Error when any of the specified pointers is NULL.
    ippStsBadArgErr         - Error when pSpec object doesn`t initialized.
}

 function ippiHistogramGetLevels( pSpec : IppiHistogramSpecPtr ; pLevels : Ipp32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:         ippiHistogram
  Purpose:      Computes the intensity histogram of an image.
  Parameters:
    pSrc        - Pointer to the source image ROI.
    srcStep     - Distance, in bytes,  between the starting points of consecutive lines in the source image.
    roiSize     - Size, in pixels,  of the source image.
    pHist       - Pointer to the computed histogram. In case of multi-channel data,  pHist is an array of pointers to the histogram for each channel.
    pSpec       - Pointer to the spec.
    pBuffer     - Pointer to the buffer for internal calculations.
  Returns:
    ippStsNoErr             - OK.
    ippStsNullPtrErr        - Error when any of the specified pointers is NULL.
    ippStsSizeErr           - Error when the roiSize has a zero or negative value.
    ippStsStepErr           - Error when the srcStep is less than roiSize.width * sizeof( *pSrc) * nChannels.
    ippStsBadArgErr         - Error when pSpec object doesn`t initialized.
}

 function ippiHistogram_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32uPtr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHistogram_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32u_3Ptr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHistogram_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32u_4Ptr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHistogram_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32uPtr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHistogram_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32u_3Ptr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHistogram_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32u_4Ptr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHistogram_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32uPtr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHistogram_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32u_3Ptr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHistogram_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32u_4Ptr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHistogram_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32uPtr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHistogram_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32u_3Ptr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHistogram_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pHist : Ipp32u_4Ptr ; pSpec : IppiHistogramSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:          ippiLUT
 Purpose:       Performs intensity transformation of an image
                using lookup table (LUT) without interpolation or
                using lookup table (LUT) with linear interpolation or
                using lookup table (LUT) with cubic interpolation
  Parameters:
    pSrc        - Pointer to the source image.
    srcStep     - Distances, in bytes,  between the starting points of consecutive lines in the source images.
    pDst        - Pointer to the destination image.
    dstStep     - Distance, in bytes,  between the starting points of consecutive lines in the destination image.
    pSrcDst     - Pointer to the source/destination image (inplace case).
    srcDstStep  - Distance, in bytes,  between the starting points of consecutive lines in the source/destination image (inplace case).
    roiSize     - Size, in pixels,  of the ROI.
    pSpec       - Pointer to the LUT spec structure.
  Returns:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when roiSize has a field with value less than 1.
    ippStsStepErr    - Error when srcStep,  dstStep  or srcDstStep has a zero or negative value.
    ippStsBadArgErr  - Error when pSpec initialized incorect.
}

 function ippiLUT_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi

 function ippiLUT_8u_C1IR ( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_8u_C3IR ( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_8u_C4IR ( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi

 function ippiLUT_16u_C1R ( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16u_C3R ( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16u_C4R ( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi

 function ippiLUT_16u_C1IR ( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16u_C3IR ( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16u_C4IR ( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi

 function ippiLUT_16s_C1R ( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16s_C3R ( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16s_C4R ( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi

 function ippiLUT_16s_C1IR ( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16s_C3IR ( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16s_C4IR ( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi

 function ippiLUT_32f_C1R ( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_32f_C3R ( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_32f_C4R ( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi

 function ippiLUT_32f_C1IR ( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_32f_C3IR ( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_32f_C4IR ( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:          ippiLUT_GetSize
 Purpose:       Gets the size (in bytes) of the spec buffer for ippiLUT.
  Parameters:
    interp         - Interpolation type (ippCubic or ippLinear or ippNearest).
    dataType       - IPP data type name of the images. Possible values are ipp8u,  ipp16u, ipp16s or ipp32f.
    numChannels    - IPP channels name of of the images. Possible values are ippC1,  ippC3, ippC4 or ippAC4.
    roiSize        - Size, in pixels,  of the destination ROI.
    nLevels        - Number of levels,  separate for each channel.
    pSpecSize      - Pointer to the calculated spec size (in bytes).
  Returns:
    ippStsNoErr            - OK.
    ippStsNullPtrErr       - Error when any of the specified pointers is NULL.
    ippStsSizeErr          - Error when roiSize has a field with value less than 1.
    ippStsDataTypeErr      - Error when the srcType has an illegal value.
    ippStsChannelErr       - Error when the ippChan has an illegal value.
    ippStsInterpolationErr - Error when the interpolationType has an illegal value.
}

 function ippiLUT_GetSize( interp : IppiInterpolationType ; dataType : IppDataType ; ippChan : IppChannels ; roiSize : IppiSize ; constref nLevels : Int32 ; var pSpecSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:          ippiLUT_Init
 Purpose:       Initializes the spec for ippiLUT.
  Parameters:
    interp         - Interpolation type (ippCubic or ippLinear or ippNearest).
    numChannels    - IPP channels name of of the images. Possible values are ippC1,  ippC3, ippC4 or ippAC4.
    roiSize        - Size, in pixels,  of the destination ROI.
    pValues        - Ppointer to the array of intensity values,  separate for each channel.
    pLevels        - Pointer to the array of level values,  separate for each channel.
    nLevels        - Number of levels,  separate for each channel.
    pSpec          - Pointer to the LUT spec structure.
  Returns:
    ippStsNoErr            - OK.
    ippStsNullPtrErr       - Error when any of the specified pointers is NULL.
    ippStsSizeErr          - Error when roiSize has a field with value less than 1.
    ippStsChannelErr       - Error when the ippChan has an illegal value.
    ippStsLUTNofLevelsErr  - Error when the number of levels is less 2.
    ippStsInterpolationErr - Error when the interpolationType has an illegal value.
}

 function ippiLUT_Init_8u( interp : IppiInterpolationType ; ippChan : IppChannels ; roiSize : IppiSize ; pValues : Ipp32sPtr ; pLevels : Ipp32sPtr ; constref nLevels : Int32 ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_Init_16u( interp : IppiInterpolationType ; ippChan : IppChannels ; roiSize : IppiSize ; pValues : Ipp32sPtr ; pLevels : Ipp32sPtr ; constref nLevels : Int32 ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_Init_16s( interp : IppiInterpolationType ; ippChan : IppChannels ; roiSize : IppiSize ; pValues : Ipp32sPtr ; pLevels : Ipp32sPtr ; constref nLevels : Int32 ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi
 function ippiLUT_Init_32f( interp : IppiInterpolationType ; ippChan : IppChannels ; roiSize : IppiSize ; pValues : Ipp32fPtr ; pLevels : Ipp32fPtr ; constref nLevels : Int32 ; pSpec : IppiLUT_SpecPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:       ippiLUTPalette
  Purpose:     intensity transformation of image using the palette lookup table pTable
  Parameters:
    pSrc       pointer to the source image
    srcStep    line offset in input data in bytes
    alphaValue constant alpha channel
    pDst       pointer to the destination image
    dstStep    line offset in output data in bytes
    roiSize    size of source ROI in pixels
    pTable     pointer to palette table of size 2^nBitSize or
               array of pointers to each channel
    nBitSize   number of valid bits in the source image
               (range [1,8] for 8u source images and range [1,16] for 16u source images)
  Returns:
    ippStsNoErr         no errors
    ippStsNullPtrErr    pSrc == NULL or pDst == NULL or pTable == NULL
    ippStsSizeErr       width or height of ROI is less or equal zero
    ippStsOutOfRangeErr nBitSize is out of range
  Notes:
}

 function ippiLUTPalette_16u32u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp32uPtr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_16u24u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp8uPtr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_16u8u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp8uPtr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_8u32u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp32uPtr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_8u24u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp8uPtr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp8uPtr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp16uPtr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp8u_3Ptr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp16u_3Ptr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp8u_4Ptr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp16u_4Ptr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp8u_3Ptr ; nBitSize : Int32 ): IppStatus; _ippapi
 function ippiLUTPalette_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pTable : Ipp16u_3Ptr ; nBitSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:                ippiCountInRange

  Purpose:  Computes the number of pixels with intensity values within the given range

  Returns:             IppStatus
      ippStsNoErr       No errors
      ippStsNullPtrErr  pSrc == NULL
      ippStsStepErr     srcStep is less than or equal to zero
      ippStsSizeErr     roiSize has a field with zero or negative value
      ippStsRangeErr    lowerBound is greater than upperBound

  Parameters:
      pSrc             Pointer to the source buffer
      roiSize          Size of the source ROI
      srcStep          Step through the source image buffer
      counts           Number of pixels within the given intensity range
      lowerBound       Lower limit of the range
      upperBound       Upper limit of the range
}

 function ippiCountInRange_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; counts : Int32Ptr ; lowerBound : Ipp8u ; upperBound : Ipp8u ): IppStatus; _ippapi
 function ippiCountInRange_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; counts : Int32_3 ; lowerBound : Ipp8u_3 ; upperBound : Ipp8u_3 ): IppStatus; _ippapi
 function ippiCountInRange_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; counts : Int32_3 ; lowerBound : Ipp8u_3 ; upperBound : Ipp8u_3 ): IppStatus; _ippapi
 function ippiCountInRange_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; counts : Int32Ptr ; lowerBound : Ipp32f ; upperBound : Ipp32f ): IppStatus; _ippapi
 function ippiCountInRange_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; counts : Int32_3 ; lowerBound : Ipp32f_3 ; upperBound : Ipp32f_3 ): IppStatus; _ippapi
 function ippiCountInRange_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; counts : Int32_3 ; lowerBound : Ipp32f_3 ; upperBound : Ipp32f_3 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

             Non-linear Filters
---------------------------------------------------------------------------- }



{ ----------------------------------------------------------------------------

  Names:      ippiFilterMedianGetBufferSize_32f

  Purpose:  Get size of internal buffer for median filter
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  bufferSize is NULL
   ippStsSizeErr     dstRoiSize has a field with zero or negative value
   ippStsMaskSizeErr maskSize has a field with zero,  negative, or even value
   ippStsNumChannelsErr number of channels is not 3 or 4
  Parameters:
   dstRoiSize   Size of the destination ROI
   maskSize     Size of the mask in pixels
   nChannels     Number of channels
   bufferSize  reference to size buffer
}

 function ippiFilterMedianGetBufferSize_32f( dstRoiSize : IppiSize ; maskSize : IppiSize ; nChannels : Ipp32u ; var bufferSize : Ipp32u ): IppStatus; _ippapi
 function ippiFilterMedianGetBufferSize_64f( dstRoiSize : IppiSize ; maskSize : IppiSize ; nChannels : Ipp32u ; var bufferSize : Ipp32u ): IppStatus; _ippapi

{----------------------------------------------------------------------------
  Names:      ippiFilterMedian_32f_C3R
              ippiFilterMedian_32f_C4R
              ippiFilterMedian_64f_C1R

  Purpose:  Filters an image using a box median filter
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  pSrc or pDst is NULL
   ippStsSizeErr     dstRoiSize has a field with zero or negative value
   ippStsStepErr     srcStep or dstStep has zero or negative value
   ippStsMaskSizeErr maskSize has a field with zero,  negative, or even value
   ippStsAnchorErr   anchor is outside the mask

  Parameters:
   pSrc        Pointer to the source image
   srcStep     Step through the source image
   pDst        Pointer to the destination image
   dstStep     Step through the destination image
   dstRoiSize  Size of the destination ROI
   maskSize    Size of the mask in pixels
   anchor      Anchor cell specifying the mask alignment with respect to
               the position of input pixel
}

 function ippiFilterMedian_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMedian_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMedian_64f_C1R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{----------------------------------------------------------------------------
  Names:      ippiFilterMedianCross_8u_C1R
              ippiFilterMedianCross_8u_C3R
              ippiFilterMedianCross_8u_AC4R
              ippiFilterMedianCross_16s_C1R
              ippiFilterMedianCross_16s_C3R
              ippiFilterMedianCross_16s_AC4R
              ippiFilterMedianCross_16u_C1R
              ippiFilterMedianCross_16u_C3R
              ippiFilterMedianCross_16u_AC4R
  Purpose:  Filters an image using a cross median filter
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  pSrc or pDst is NULL
   ippStsSizeErr     dstRoiSize has a field with zero or negative value
   ippStsStepErr     srcStep or dstStep has zero or negative value
   ippStsMaskSizeErr Illegal value of mask

  Parameters:
   pSrc        Pointer to the source image
   srcStep     Step through the source image
   pDst        Pointer to the destination image
   dstStep     Step through the destination image
   dstRoiSize  Size of the destination ROI
   mask        Type of the filter mask
}

 function ippiFilterMedianCross_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianCross_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianCross_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianCross_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianCross_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianCross_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianCross_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianCross_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianCross_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiFilterMedianColor_8u_C3R
              ippiFilterMedianColor_8u_AC4R
              ippiFilterMedianColor_16s_C3R
              ippiFilterMedianColor_16s_AC4R
              ippiFilterMedianColor_32f_C3R
              ippiFilterMedianColor_32f_AC4R
  Purpose:  Filters an image using a box color median filter
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  pSrc or pDst is NULL
   ippStsSizeErr     dstRoiSize has a field with zero or negative value
   ippStsStepErr     srcStep or dstStep has zero or negative value
   ippStsMaskSizeErr Illegal value of mask

  Parameters:
   pSrc        Pointer to the source image
   srcStep     Step through the source image
   pDst        Pointer to the destination image
   dstStep     Step through the destination image
   dstRoiSize  Size of the destination ROI
   mask        Type of the filter mask
}

 function ippiFilterMedianColor_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianColor_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianColor_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianColor_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianColor_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi
 function ippiFilterMedianColor_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiFilterMedianWeightedCenter3x3_8u_C1R

  Purpose:  Filter an image using a median filter with kernel size 3x3 and
            enlarged weight of central pixel
  Returns:
   ippStsNoErr            OK
   ippStsNullPtrErr       pSrc or pDst is NULL
   ippStsSizeErr          dstRoiSize has a field with zero or negative value
   ippStsStepErr          srcStep or dstStep has zero or negative value
   ippStsWeightErr        weight of central Pixel has zero or negative value
   ippStsEvenMedianWeight weight of central Pixel has even value

  Parameters:
   pSrc        Pointer to the source image
   srcStep     Step through the source image
   pDst        Pointer to the destination image
   dstStep     Step through the destination image
   dstRoiSize  Size of the destination ROI
   weight      Weight of central pixel
}

 function ippiFilterMedianWeightedCenter3x3_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; weight : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiFilterMedianBorderGetBufferSize

  Purpose:            Computes the size of the external buffer for median filter with border

  Parameters:
   roiSize            Size of destination ROI in pixels.
   maskSize           Size of filter mask.
   dataType           Data type of the source an desination images.
   numChannels        Number of channels in the images. Possible values are 1,  3 or 4.
   pBufferSize        Pointer to the size (in bytes) of the external work buffer.

  Return Values:
   ippStsNoErr        Indicates no error.
   ippStsNullPtrErr   Indicates an error when pBufferSize is NULL.
   ippStsSizeErr      Indicates an error when roiSize has a field with negative or zero value.
   ippStsMaskSizeErr  Indicates an error when maskSize has a field with negative,  zero or even value.
   ippStsDataTypeErr  Indicates an error when dataType has an illegal value.
   ippStsNumChannelsErr Indicates an error when numChannels has an illegal value.
}

 function ippiFilterMedianBorderGetBufferSize( dstRoiSize : IppiSize ; maskSize : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiFilterMedianBorder_8u_C1R
                      ippiFilterMedianBorder_16s_C1R
                      ippiFilterMedianBorder_16u_C1R
                      ippiFilterMedianBorder_32f_C1R
  Purpose:            Perform median filtering of an image with border

  Parameters:
   pSrc               Pointer to the source image ROI.
   srcStep            Distance in bytes between starting points of consecutive lines in the sorce image.
   pDst               Pointer to the destination image ROI.
   dstStep            Distance in bytes between starting points of consecutive lines in the destination image.
   dstRoiSize         Size of destination ROI in pixels.
   maskSize           Size of filter mask.
   borderType         Type of border.
   borderValue        Constant value to assign to pixels of the constant border. This parameter is applicable
                      only to the ippBorderConst border type.
   pBorderValue       Pointer to constant value to assign to pixels of the constant border. This parameter is applicable
                      only to the ippBorderConst border type.
   pBuffer            Pointer to the work buffer.

  Return Values:
   ippStsNoErr        Indicates no error.
   ippStsNullPtrErr   Indicates an error when pSrc,  pDst or pBufferSize is NULL.
   ippStsSizeErr      Indicates an error when roiSize has a field with negative or zero value.
   ippStsMaskSizeErr  Indicates an error when maskSize has a field with negative,  zero or even value.
   ippStsNotEvenStepErr Indicated an error when one of the step values is not divisible by 4
                      for floating-point images,  or by 2 for short-integer images.
   ippStsBorderErr    Indicates an error when borderType has illegal value.
}

 function ippiFilterMedianBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMedianBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMedianBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMedianBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFilterMedianBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMedianBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMedianBorder_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFilterMedianBorder_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMedianBorder_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMedianBorder_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFilterMedianBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMedianBorder_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMedianBorder_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16u_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiFilterMaxBorderGetBufferSize
                      ippiFilterMinBorderGetBufferSize

  Purpose:            Computes the size of the external buffer for median filter with border

  Parameters:
   roiSize            Size of destination ROI in pixels.
   maskSize           Size of mask.
   dataType           data type of source and destination images.
   numChannels        Number of channels in the images. Possible values is 1.
   pBufferSize        Pointer to the size (in bytes) of the external work buffer.

  Return Values:
   ippStsNoErr        Indicates no error.
   ippStsNullPtrErr   Indicates an error when pBufferSize is NULL.
   ippStsSizeErr      Indicates an error when roiSize is negative,  or equal to zero.
   ippStsMaskSizeErr  Indicates an error when maskSize is negative,  or equal to zero.
   ippStsDataTypeErr  Indicates an error when dataType has an illegal value.
   ippStsNumChannelsErr Indicates an error when numChannels has an illegal value.
}

 function ippiFilterMaxBorderGetBufferSize( dstRoiSize : IppiSize ; maskSize : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterMinBorderGetBufferSize( dstRoiSize : IppiSize ; maskSize : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiFilterMaxBorder_8u_C1R
              ippiFilterMaxBorder_8u_C3R
              ippiFilterMaxBorder_8u_AC4R
              ippiFilterMaxBorder_8u_C4R
              ippiFilterMaxBorder_16s_C1R
              ippiFilterMaxBorder_16s_C3R
              ippiFilterMaxBorder_16s_AC4R
              ippiFilterMaxBorder_16s_C4R
              ippiFilterMaxBorder_16u_C1R
              ippiFilterMaxBorder_16u_C3R
              ippiFilterMaxBorder_16u_AC4R
              ippiFilterMaxBorder_16u_C4R
              ippiFilterMaxBorder_32f_C1R
              ippiFilterMaxBorder_32f_C3R
              ippiFilterMaxBorder_32f_AC4R
              ippiFilterMaxBorder_32f_C4R
              ippiFilterMinBorder_8u_C1R
              ippiFilterMinBorder_8u_C3R
              ippiFilterMinBorder_8u_AC4R
              ippiFilterMinBorder_8u_C4R
              ippiFilterMinBorder_16s_C1R
              ippiFilterMinBorder_16s_C3R
              ippiFilterMinBorder_16s_AC4R
              ippiFilterMinBorder_16s_C4R
              ippiFilterMinBorder_16u_C1R
              ippiFilterMinBorder_16u_C3R
              ippiFilterMinBorder_16u_AC4R
              ippiFilterMinBorder_16u_C4R
              ippiFilterMinBorder_32f_C1R
              ippiFilterMinBorder_32f_C3R
              ippiFilterMinBorder_32f_AC4R
              ippiFilterMinBorder_32f_C4R

 Purpose:    Max and Min Filter with Border
 Parameters:
   pSrc               Pointer to the source image ROI.
   srcStep            Distance in bytes between starting points of consecutive lines in the sorce image.
   pDst               Pointer to the destination image ROI.
   dstStep            Distance in bytes between starting points of consecutive lines in the destination image.
   dstRoiSize         Size of destination ROI in pixels.
   maskSize           Size of mask.
   borderType         Type of border.
   borderValue        Constant value to assign to pixels of the constant border. This parameter is applicable
                      only to the ippBorderConst border type.
   pBorderValue       Pointer to constant value to assign to pixels of the constant border. This parameter is applicable
                      only to the ippBorderConst border type.
   pBuffer            Pointer to the work buffer.

  Return Values:
   ippStsNoErr        Indicates no error.
   ippStsNullPtrErr   Indicates an error when pBuffer is NULL while it must be no NULL.
   ippStsSizeErr      Indicates an error when roiSize is negative,  or equal to zero.
   ippStsStepErr      Indicates an error when srcStep or dstStep is negative,  or equal to zero.
   ippStsBorderErr    Indicates an error when borderType has illegal value.
}

 function ippiFilterMaxBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16u_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMaxBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFilterMinBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp16u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16u_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterMinBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

             Linear Filters
----------------------------------------------------------------------------

  Name:               ippiFilterBoxBorderGetBufferSize
  Purpose:            Computes the size of external buffer for FilterBoxBorder

  Parameters:
    roiSize      Maximum size of the destination image ROI.
    maskSize     Size of the mask in pixels.
    dataType     Data type of the image. Possible values are ipp8u,  ipp16u, ipp16s, or ipp32f.
    numChannels  Number of channels in the image. Possible values are 1,  3, or 4.
    pBufferSize  Pointer to the size of the external work buffer.

  Return Values:
    ippStsNoErr Indicates no error.
    ippStsSizeErr Indicates an error when roiSize is negative,  or equal to zero.
    ippStsMaskSizeErr Indicates an error when mask has an illegal value.
    ippStsDataTypeErr Indicates an error when dataType has an illegal value.
    ippStsNumChannelsError Indicates an error when numChannels has an illegal value.
}

 function ippiFilterBoxBorderGetBufferSize( roiSize : IppiSize ; maskSize : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name: ippiFilterBoxBorder_32f_<desc>R / ippiFilterBoxBorder_16u_<desc>R / ippiFilterBoxBorder_8u_<desc>R / ippiFilterBoxBorder_16s_<desc>R
               <desc>  C1|C3|C4|AC4   (descriptor)
 Purpose:             Blurs an image using a simple box filter
 Parameters:
   pSrc           Pointer to the source image.
   srcStep        Distance in bytes between starting points of consecutive lines in the source image.
   pDst           Pointer to the destination image.
   dstStep        Distance in bytes between starting points of consecutive lines in the destination image.
   dstRoiSize     Size of the destination ROI in pixels.
   maskSize       Size of the mask in pixels.
   border         Type of border. Possible values are:
                     ippBorderConst Values of all border pixels are set to constant.
                     ippBorderRepl Border is replicated from the edge pixels.
                     ippBorderInMem Border is obtained from the source image pixels in memory.
                     Mixed borders are also supported. They can be obtained by the bitwise operation OR between ippBorderRepl and ippBorderInMemTop,  ippBorderInMemBottom, ippBorderInMemLeft, ippBorderInMemRight.
   borderValue    Constant value to assign to pixels of the constant border. This parameter is applicable only to the ippBorderConst border type.
   pBuffer        Pointer to the work buffer.
 Returns:
   ippStsNoErr       Indicates no error.
   ippStsNullPtrErr  Indicates an error when pSrc or pDst is NULL.
   ippStsSizeErr     Indicates an error if roiSize has a field with zero or negative value.
   ippStsMaskSizeErr Indicates an error if mask has an illegal value.
   ippStsBorderErr   Indicates an error when border has an illegal value.
}

 function ippiFilterBoxBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp32f_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp32f_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; borderValue : Ipp16sPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp8u_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBoxBorder_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp8u_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:   ippiFilterBox_64f_C1R
 Purpose:             Blurs an image using a simple box filter
 Parameters:
   pSrc               pointer to the source image
   srcStep            step in the source image
   pDst               pointer to the destination image
   dstStep            step in the destination image
   pSrcDst            pointer to the source/destination image (in-place flavors)
   srcDstStep         step in the source/destination image (in-place flavors)
   dstRoiSize         size of the destination ROI
   roiSize            size of the source/destination ROI (in-place flavors)
   maskSize           size of the mask in pixels
   anchor             the [x,y] coordinates of the anchor cell in the kernel
 Returns:
   ippStsNoErr        No errors
   ippStsNullPtrErr   pSrc == NULL or pDst == NULL or pSrcDst == NULL
   ippStsStepErr      one of the step values is zero or negative
   ippStsSizeErr      dstRoiSize or roiSize has a field with zero or negative value
   ippStsMaskSizeErr  maskSize has a field with zero or negative value
   ippStsAnchorErr    anchor is outside the mask
   ippStsMemAllocErr  memory allocation error
}


 function ippiFilterBox_64f_C1R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ): IppStatus; _ippapi

{----------------------------------------------------------------------------
 Name:   ippiSumWindowRow_8u32f_<desc>R,  ippiSumWindowColumn_8u32f_<desc>R
         ippiSumWindowRow_16u32f_<desc>R, ippiSumWindowColumn_16u32f_<desc>R
         ippiSumWindowRow_16s32f_<desc>R, ippiSumWindowColumn_16s32f_<desc>R
           <desc>  C1|C3|C4   (descriptor)
 Purpose:             Sums pixel values in the row or column mask applied to the image
 Parameters:
   pSrc               pointer to the source image
   srcStep            step in the source image
   pDst               pointer to the destination image
   dstStep            step in the destination image
   dstRoiSize         size of the destination ROI
   maskSize           size of the horizontal or vertical mask in pixels
   anchor             the anchor cell
 Returns:
   ippStsNoErr        No errors
   ippStsNullPtrErr   pSrc == NULL or pDst == NULL or pSrcDst == NULL
   ippStsSizeErr      dstRoiSize has a field with zero or negative value
   ippStsMaskSizeErr  maskSize is zero or negative value
   ippStsAnchorErr    anchor is outside the mask
   ippStsMemAllocErr  memory allocation error (ippiSumWindowColumn only)
}

 function ippiSumWindowRow_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowRow_8u32f_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowRow_8u32f_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowRow_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowRow_16u32f_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowRow_16u32f_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowRow_16s32f_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowRow_16s32f_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowRow_16s32f_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi

 function ippiSumWindowColumn_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowColumn_8u32f_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowColumn_8u32f_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowColumn_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowColumn_16u32f_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowColumn_16u32f_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowColumn_16s32f_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowColumn_16s32f_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi
 function ippiSumWindowColumn_16s32f_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : Int32 ; anchor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

             Filters with Fixed Kernel
{ ----------------------------------------------------------------------------


              Kernels:

                                1  1  1
              PrewittHoriz      0  0  0
                               -1 -1 -1


                               -1  0  1
              PrewittVert      -1  0  1
                               -1  0  1


                                0  0  0
              RobetsDown        0  1  0
                                0  0 -1


                                0  0  0
              RobertsUp         0  1  0
                               -1  0  0


                               -1 -1 -1
              Sharpen          -1 16 -1  X  1/8
                               -1 -1 -1


                                3  0  -3
              ScharrVert       10  0 -10
                                3  0  -3


                                3  10  3
              ScharrHoriz       0   0  0
                               -3 -10 -3


                               -1 -1 -1
              Laplace (3x3)    -1  8 -1
                               -1 -1 -1


                                1  2  1
              Gauss (3x3)       2  4  2  X  1/16
                                1  2  1


                                1  1  1
              Lowpass (3x3)     1  1  1  X  1/9
                                1  1  1


                               -1 -1 -1
              Hipass (3x3 )    -1  8 -1
                               -1 -1 -1


                               -1  0  1
              SobelVert (3x3)  -2  0  2
                               -1  0  1


                                1  2  1
              SobelHoriz (3x3)  0  0  0
                               -1 -2 -1


                                       1 -2  1
              SobelVertSecond (3x3)    2 -4  2
                                       1 -2  1


                                       1  2  1
              SobelHorizSecond (3x3)  -2 -4 -2
                                       1  2  1


                               -1  0  1
              SobelCross (3x3)  0  0  0
                                1  0 -1


                               -1 -3 -4 -3 -1
                               -3  0  6  0 -3
              Laplace (5x5)    -4  6 20  6 -4
                               -3  0  6  0 -3
                               -1 -3 -4 -3 -1

                                2   7  12   7   2
                                7  31  52  31   7
              Gauss (5x5)      12  52 127  52  12  X  1/571
                                7  31  52  31   7
                                2   7  12   7   2

                                1 1 1 1 1
                                1 1 1 1 1
              Lowpass (5x5)     1 1 1 1 1  X  1/25
                                1 1 1 1 1
                                1 1 1 1 1


                               -1 -1 -1 -1 -1
                               -1 -1 -1 -1 -1
              Hipass (5x5)     -1 -1 24 -1 -1
                               -1 -1 -1 -1 -1
                               -1 -1 -1 -1 -1

                               -1  -2   0   2   1
                               -4  -8   0   8   4
              SobelVert (5x5)  -6 -12   0  12   6
                               -4  -8   0   8   4
                               -1  -2   0   2   1

                                1   4   6   4   1
                                2   8  12   8   2
              SobelHoriz (5x5)  0   0   0   0   0
                               -2  -8 -12  -8  -4
                               -1  -4  -6  -4  -1

                                       1   0  -2   0   1
                                       4   0  -8   0   4
              SobelVertSecond (5x5)    6   0 -12   0   6
                                       4   0  -8   0   4
                                       1   0  -2   0   1

                                       1   4   6   4   1
                                       0   0   0   0   0
              SobelHorizSecond (5x5)  -2  -8 -12  -8  -2
                                       0   0   0   0   0
                                       1   4   6   4   1

                               -1  -2   0   2   1
                               -2  -4   0   4   2
              SobelCross (5x5)  0   0   0   0   0
                                2   4   0  -4  -2
                                1   2   0  -2  -1
}

{ ----------------------------------------------------------------------------

  Name:               ippiFilterSobelHorizBorderGetBufferSize
                      ippiFilterSobelVertBorderGetBufferSize
                      ippiFilterScharrHorizMaskBorderGetBufferSize
                      ippiFilterScharrVertMaskBorderGetBufferSize
                      ippiFilterPrewittHorizBorderGetBufferSize
                      ippiFilterPrewittVertBorderGetBufferSize
                      ippiFilterRobertsDownBorderGetBufferSize
                      ippiFilterRobertsUpBorderGetBufferSize
                      ippiFilterSobelHorizSecondBorderGetBufferSize
                      ippiFilterSobelVertSecondBorderGetBufferSize
                      ippiFilterSobelNegVertBorderGetBufferSize

  Purpose:            Computes the size of the external buffer for fixed filter with border

  Parameters:
   roiSize            Size of destination ROI in pixels.
   mask               Predefined mask of IppiMaskSize type.
   srcDataType        Data type of the source image.
   dstDataType        Data type of the destination image.
   numChannels        Number of channels in the images.
   pBufferSize        Pointer to the size (in bytes) of the external work buffer.

  Return Values:
   ippStsNoErr        Indicates no error.
   ippStsNullPtrErr   Indicates an error when pBufferSize is NULL.
   ippStsSizeErr      Indicates an error when roiSize is negative,  or equal to zero.
   ippStsMaskSizeErr  Indicates an error condition if mask has a wrong value.
   ippStsDataTypeErr  Indicates an error when srcDataType or dstDataType has an illegal value.
   ippStsNumChannelsErr Indicates an error when numChannels has an illegal value.
}

 function ippiFilterSobelHorizBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterSobelVertBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterScharrHorizMaskBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterScharrVertMaskBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterPrewittHorizBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterPrewittVertBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterRobertsDownBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterRobertsUpBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterSobelHorizSecondBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterSobelVertSecondBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterSobelNegVertBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterLaplaceBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterHipassBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterSharpenBorderGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiFilterSobelVertBorder_8u16s_C1R
                      ippiFilterSobelHorizBorder_8u16s_C1R
                      ippiFilterScharrVertMaskBorder_8u16s_C1R
                      ippiFilterScharrHorizMaskBorder_8u16s_C1R
                      ippiFilterPrewittVertBorder_8u16s_C1R
                      ippiFilterPrewittHorizBorder_8u16s_C1R
                      ippiFilterRobertsDownBorder_8u16s_C1R
                      ippiFilterRobertsUpBorder_8u16s_C1R
                      ippiFilterSobelVertSecondBorder_8u16s_C1R
                      ippiFilterSobelHorizSecondBorder_8u16s_C1R
                      ippiFilterSobelNegVertBorder_8u16s_C1R
                      ippiFilterSobelVertBorder_16s_C1R
                      ippiFilterSobelHorizBorder_16s_C1R
                      ippiFilterScharrVertMaskBorder_16s_C1R
                      ippiFilterScharrHorizMaskBorder_16s_C1R
                      ippiFilterPrewittVertBorder_16s_C1R
                      ippiFilterPrewittHorizBorder_16s_C1R
                      ippiFilterRobertsDownBorder_16s_C1R
                      ippiFilterRobertsUpBorder_16s_C1R
                      ippiFilterSobelVertBorder_32f_C1R
                      ippiFilterSobelHorizBorder_32f_C1R
                      ippiFilterScharrVertMaskBorder_32f_C1R
                      ippiFilterScharrHorizMaskBorder_32f_C1R
                      ippiFilterPrewittVertBorder_32f_C1R
                      ippiFilterPrewittHorizBorder_32f_C1R
                      ippiFilterRobertsDownBorder_32f_C1R
                      ippiFilterRobertsUpBorder_32f_C1R
                      ippiFilterSobelVertSecondBorder_32f_C1R
                      ippiFilterSobelHorizSecondBorder_32f_C1R
                      ippiFilterSobelNegVertBorder_32f_C1R
                      ippiFilterLaplaceBorder_8u_C1R
                      ippiFilterLaplaceBorder_8u_C3R
                      ippiFilterLaplaceBorder_8u_C4R
                      ippiFilterLaplaceBorder_8u_AC4R
                      ippiFilterLaplaceBorder_16s_C1R
                      ippiFilterLaplaceBorder_16s_C3R
                      ippiFilterLaplaceBorder_16s_C4R
                      ippiFilterLaplaceBorder_16s_AC4R
                      ippiFilterLaplaceBorder_32f_C1R
                      ippiFilterLaplaceBorder_32f_C3R
                      ippiFilterLaplaceBorder_32f_C4R
                      ippiFilterLaplaceBorder_32f_AC4R
                      ippiFilterHipassBorder_8u_C1R
                      ippiFilterHipassBorder_8u_C3R
                      ippiFilterHipassBorder_8u_C4R
                      ippiFilterHipassBorder_8u_AC4R
                      ippiFilterHipassBorder_16s_C1R
                      ippiFilterHipassBorder_16s_C3R
                      ippiFilterHipassBorder_16s_C4R
                      ippiFilterHipassBorder_16s_AC4R
                      ippiFilterHipassBorder_32f_C1R
                      ippiFilterHipassBorder_32f_C3R
                      ippiFilterHipassBorder_32f_C4R
                      ippiFilterHipassBorder_32f_AC4R
                      ippiFilterSharpenBorder_8u_C1R
                      ippiFilterSharpenBorder_8u_C3R
                      ippiFilterSharpenBorder_8u_C4R
                      ippiFilterSharpenBorder_8u_AC4R
                      ippiFilterSharpenBorder_16s_C1R
                      ippiFilterSharpenBorder_16s_C3R
                      ippiFilterSharpenBorder_16s_C4R
                      ippiFilterSharpenBorder_16s_AC4R
                      ippiFilterSharpenBorder_32f_C1R
                      ippiFilterSharpenBorder_32f_C3R
                      ippiFilterSharpenBorder_32f_C4R
                      ippiFilterSharpenBorder_32f_AC4R


  Purpose:            Perform linear filtering of an image using one of
                      predefined convolution kernels.

  Parameters:
   pSrc               Pointer to the source image ROI.
   srcStep            Distance in bytes between starting points of consecutive lines in the sorce image.
   pDst               Pointer to the destination image ROI.
   dstStep            Distance in bytes between starting points of consecutive lines in the destination image.
   dstRoiSize         Size of destination ROI in pixels.
   mask               Predefined mask of IppiMaskSize type.
   borderType         Type of border.
   borderValue        Constant value to assign to pixels of the constant border. This parameter is applicable
                      only to the ippBorderConst border type.
   pBorderValue       The pointer to constant values to assign to pixels of the constant border. This parameter is applicable
                      only to the ippBorderConst border type.
   pBuffer            Pointer to the work buffer.

  Return Values:
   ippStsNoErr        Indicates no error.
   ippStsNullPtrErr   Indicates an error when pBufferSize is NULL.
   ippStsSizeErr      Indicates an error when roiSize is negative,  or equal to zero.
   ippStsNotEvenStepErr Indicated an error when one of the step values is not divisible by 4
                      for floating-point images,  or by 2 for short-integer images.
   ippStsBorderErr    Indicates an error when borderType has illegal value.
}

 function ippiFilterSobelVertBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobelHorizBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterScharrVertMaskBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterScharrHorizMaskBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterPrewittVertBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterPrewittHorizBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRobertsDownBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRobertsUpBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobelVertSecondBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobelHorizSecondBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobelNegVertBorder_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFilterSobelVertBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobelHorizBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterScharrVertMaskBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterScharrHorizMaskBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterPrewittVertBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterPrewittHorizBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRobertsDownBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRobertsUpBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobelVertSecondBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobelHorizSecondBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobelNegVertBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFilterSobelVertBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobelHorizBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterScharrVertMaskBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterScharrHorizMaskBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterPrewittVertBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterPrewittHorizBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRobertsDownBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterRobertsUpBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFilterLaplaceBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplaceBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplaceBorder_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplaceBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplaceBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplaceBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplaceBorder_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplaceBorder_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplaceBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplaceBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplaceBorder_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterLaplaceBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFilterHipassBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterHipassBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterHipassBorder_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterHipassBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterHipassBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterHipassBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterHipassBorder_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterHipassBorder_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterHipassBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterHipassBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterHipassBorder_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterHipassBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiFilterSharpenBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSharpenBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSharpenBorder_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSharpenBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pborderValue : Ipp8u_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSharpenBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSharpenBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSharpenBorder_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSharpenBorder_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp16s_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSharpenBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSharpenBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSharpenBorder_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSharpenBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mask : IppiMaskSize ; borderType : IppiBorderType ; const pBorderValue : Ipp32f_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiFilterSobelGetBufferSize

  Purpose:            Computes the size of the external buffer for sobel operator

  Parameters:
   roiSize            Size of destination ROI in pixels.
   mask               Predefined mask of IppiMaskSize type.
   normTypre          Normalization mode if IppNormTYpe type.
   srcDataType        Data type of the source image.
   dstDataType        Data type of the destination image.
   numChannels        Number of channels in the images. Possible values is 1.
   pBufferSize        Pointer to the size (in bytes) of the external work buffer.

  Return Values:
   ippStsNoErr        Indicates no error.
   ippStsNullPtrErr   Indicates an error when pBufferSize is NULL.
   ippStsSizeErr      Indicates an error when roiSize is negative,  or equal to zero.
   ippStsMaskSizeErr  Indicates an error condition if mask has a wrong value.
   ippStsBadArgErr    Indicates an error condition if normType has an illegal value.
   ippStsDataTypeErr  Indicates an error when srcDataType or dstDataType has an illegal value.
   ippStsNumChannelsErr Indicates an error when numChannels has an illegal value.
}

 function ippiFilterSobelGetBufferSize( dstRoiSize : IppiSize ; mask : IppiMaskSize ; normType : IppNormType ; srcDataType : IppDataType ; dstDataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiFilterSobel_8u16s_C1R
                      ippiFilterSobel_16s32f_C1R
                      ippiFilterSobel_16u32f_C1R
                      ippiFilterSobel_32f_C1R

  Purpose:            Perform Sobel operation of an image using pair of
                      predefined convolution kernels.

  Parameters:
   pSrc               Pointer to the source image ROI.
   srcStep            Distance in bytes between starting points of consecutive lines in the sorce image.
   pDst               Pointer to the destination image ROI.
   dstStep            Distance in bytes between starting points of consecutive lines in the destination image.
   dstRoiSize         Size of destination ROI in pixels.
   mask               Predefined mask of IppiMaskSize type.
   normType           Normalization mode of IppNoremType type
   borderType         Type of border.
   borderValue        Constant value to assign to pixels of the constant border. This parameter is applicable
                      only to the ippBorderConst border type.
   pBuffer            Pointer to the work buffer.

  Return Values:
   ippStsNoErr        Indicates no error.
   ippStsNullPtrErr   Indicates an error condition if pSrc,  pDst or pBufferSize is NULL.
   ippStsSizeErr      Indicates an error condition if dstRoiSize has a fild with zero or negative value.
   ippStsMaskSizeErr  Indicates an error condition if mask has an illegal value.
   ippStsBadArgErr    Indicates an error condition if normType has an illegal value.
   ippStsNotEvenStepErr Indicated an error when one of the step values is not divisible by 4
                      for floating-point images,  or by 2 for short-integer images.
   ippStsBorderErr    Indicates an error when borderType has illegal value.
}

 function ippiFilterSobel_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobel_16s32f_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobel_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp16u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterSobel_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Wiener Filters
{ ----------------------------------------------------------------------------


  Names:
      ippiFilterWienerGetBufferSize,
  Purpose: Computes the size of the external buffer for Wiener filter

      ippiFilterWiener_8u_C1R,  ippiFilterWiener_16s_C1R,
      ippiFilterWiener_8u_C3R,  ippiFilterWiener_16s_C3R,
      ippiFilterWiener_8u_C4R,  ippiFilterWiener_16s_C4R,
      ippiFilterWiener_8u_AC4R, ippiFilterWiener_16s_AC4R,
      ippiFilterWiener_32f_C1R,
      ippiFilterWiener_32f_C3R,
      ippiFilterWiener_32f_C4R,
      ippiFilterWiener_32f_AC4R.

  Purpose: Performs two-dimensional adaptive noise-removal
           filtering of an image using Wiener filter.

  Parameters:
      pSrc        Pointer to the source image ROI;
      srcStep     Step in bytes through the source image buffer;
      pDst        Pointer to the destination image ROI;
      dstStep     Step in bytes through the destination image buffer;
      dstRoiSize  Size of the destination ROI in pixels;
      maskSize    Size of the rectangular local pixel neighborhood (mask);
      anchor      Anchor cell specifying the mask alignment
                           with respect to the position of the input pixel;
      noise       Noise level value or array of the noise level values for
                                                       multi-channel image;
      pBuffer     Pointer to the external work buffer;
      pBufferSize Pointer to the computed value of the external buffer size;
      channels    Number of channels in the image ( 1, 3, or 4 ).

  Returns:
   ippStsNoErr           OK
   ippStsNumChannelsErr  channels is not 1,  3, or 4
   ippStsNullPtrErr      One of the pointers is NULL;
   ippStsSizeErr         dstRoiSize has a field with zero or negative value
   ippStsMaskSizeErr     maskSize has a field with zero or negative value
   ippStsNoiseRangeErr   One of the noise values is less than 0
                                                         or greater than 1.0;
}

 function ippiFilterWienerGetBufferSize( dstRoiSize : IppiSize ; maskSize : IppiSize ; channels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterWiener_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_1 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterWiener_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterWiener_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterWiener_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterWiener_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_1 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterWiener_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterWiener_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterWiener_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterWiener_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_1 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterWiener_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterWiener_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterWiener_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiSize ; anchor : IppiPoint ; var noise : Ipp32f_4 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:  ippiConvGetBufferSize

  Purpose:     Get the size (in bytes) of the buffer for ippiConv internal calculations.

  Parameters:
    src1Size    - Size, in pixels,  of the first source image.
    src2Size    - Size, in pixels,  of the second source image.
    dataType    - Data type for convolution. Possible values are ipp32f,  ipp16s, or ipp8u.
    numChannels - Number of image channels. Possible values are 1,  3, or 4.
    algType     - Bit-field mask for the algorithm type definition.
                  Possible values are the results of composition of the IppAlgType and IppiROIShape values.
                  Example: (ippiROIFull|ippAlgFFT) - full-shaped convolution will be calculated using 2D FFT.
    pBufferSize - Pointer to the calculated buffer size (in bytes).

  Return:
   ippStsNoErr          - OK.
   ippStsSizeErr        - Error when the src1Size or src2Size is negative,  or equal to zero.
   ippStsNumChannelsErr - Error when the numChannels value differs from 1,  3, or 4.
   ippStsDataTypeErr    - Error when the dataType value differs from the ipp32f,  ipp16s, or ipp8u.
   ippStsAlgTypeErr     - Error when :
                            The result of the bitwise AND operation between algType and ippAlgMask differs from the ippAlgAuto,  ippAlgDirect, or ippAlgFFT values.
                            The result of the bitwise AND operation between algType and ippiROIMask differs from the ippiROIFull or ippiROIValid values.
   ippStsNullPtrErr     - Error when the pBufferSize is NULL.
}

 function ippiConvGetBufferSize( src1Size : IppiSize ; src2Size : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; algType : IppEnum ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

   Names: ippiConv_32f_C1R, ippiConv_32f_C3R, ippiConv_32f_C4R
          ippiConv_16s_C1R, ippiConv_16s_C3R, ippiConv_16s_C4R
          ippiConv_8u_C1R,  ippiConv_8u_C3R,  ippiConv_8u_C4R
  Purpose: Performs full or valid 2-D convolution of two images.
           The result image size depends on operation shape selected in algType mask as follows:
             (Wa+Wb-1)*(Ha+Hb-1) for ippiROIFull mask
             (Wa-Wb+1)*(Ha-Hb+1) for ippiROIValid mask, 
           where Wa*Ha and Wb*Hb are the sizes of the image and template,  respectively.
          If the IppAlgMask value in algType is equal to ippAlgAuto,  the optimal algorithm is selected
          automatically. For big data size,  the function uses 2D FFT algorithm.
  Parameters:
    pSrc1, pSrc2       - Pointers to the source images ROI.
    src1Step, src2Step - Distances, in bytes,  between the starting points of consecutive lines in the source images.
    src1Size, src2Size - Size, in pixels,  of the source images.
    pDst               - Pointer to the destination image ROI.
    dstStep            - Distance, in bytes,  between the starting points of consecutive lines in the destination image.
    divisor            - The integer value by which the computed result is divided (for operations on integer data only).
    algType            - Bit-field mask for the algorithm type definition. Possible values are the results of composition of the IppAlgType and IppiROIShape values.
                          Usage example: algType=(ippiROIFull|ippAlgFFT); - full-shaped convolution will be calculated using 2D FFT.
    pBuffer            - Pointer to the buffer for internal calculations.
  Returns:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsStepErr    - Error when src1Step,  src2Step, or dstStep has a zero or negative value.
    ippStsSizeErr    - Error when src1Size or src2Size has a zero or negative value.
    ippStsDivisorErr - Error when divisor has the zero value.
    ippStsAlgTypeErr - Error when :
                         The result of the bitwise AND operation between algType and ippAlgMask differs from the ippAlgAuto,  ippAlgDirect, or ippAlgFFT values.
                         The result of the bitwise AND operation between algType and ippiROIMask differs from the ippiROIFull or ippiROIValid values.
}

 function ippiConv_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; src1Size : IppiSize ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; src2Size : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiConv_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; src1Size : IppiSize ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; src2Size : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiConv_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; src1Size : IppiSize ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; src2Size : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiConv_16s_C1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; src1Size : IppiSize ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; src2Size : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; divisor : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiConv_16s_C3R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; src1Size : IppiSize ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; src2Size : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; divisor : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiConv_16s_C4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; src1Size : IppiSize ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; src2Size : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; divisor : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiConv_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; src1Size : IppiSize ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; src2Size : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; divisor : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiConv_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; src1Size : IppiSize ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; src2Size : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; divisor : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiConv_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; src1Size : IppiSize ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; src2Size : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; divisor : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                   Image Proximity Measures
  ----------------------------------------------------------------------------

  Names:  ippiCrossCorrNormGetBufferSize

  Purpose:     Computes the size (in bytes) of the work buffer for the ippiCrossCorrNorm functions.

  Parameters:
    srcRoiSize  - Size of the source ROI in pixels.
    tplRoiSize  - Size of the template ROI in pixels.
    algType     - Bit-field mask for the algorithm type definition. Possible values are the results of composition of the IppAlgType,  IppiROIShape, and IppiNormOp values.
                  Usage example: algType=(ippiROIFull|ippAlgFFT|ippiNorm); - full-shaped cross-correlation will be calculated
                      using 2D FFT and normalization applied to result image.
    pBufferSize - Pointer to the size of the work buffer (in bytes).
  Return:
    ippStsNoErr       - OK.
    ippStsSizeErr     - Error when:
                            srcRoiSize or tplRoiSize is negative,  or equal to zero.
                            The value of srcRoiSize is less than the corresponding value of the tplRoiSize.
    ippStsAlgTypeErr  - Error when :
                            The result of the bitwise AND operation between the algType and ippAlgMask differs from the ippAlgAuto,  ippAlgDirect, or ippAlgFFT values.
                            The result of the bitwise AND operation between the algType and ippiROIMask differs from the ippiROIFull,  ippiROISame, or ippiROIValid values.
                            The result of the bitwise AND operation between the algType and ippiNormMask differs from the ippiNormNone,  ippiNorm, or ippiNormCoefficient values.
    ippStsNullPtrErr  - Error when the pBufferSize is NULL.
}

 function ippiCrossCorrNormGetBufferSize( srcRoiSize : IppiSize ; tplRoiSize : IppiSize ; algType : IppEnum ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names: ippiCrossCorrNorm_32f_C1R
         ippiCrossCorrNorm_16u32f_C1R
         ippiCrossCorrNorm_8u32f_C1R
         ippiCrossCorrNorm_8u_C1RSfs
  Purpose: Computes normalized cross-correlation between an image and a template.
           The result image size depends on operation shape selected in algType mask as follows :
             (Wa+Wb-1)*(Ha+Hb-1) for ippiROIFull mask, 
             (Wa)*(Ha)           for ippiROISame mask, 
             (Wa-Wb+1)*(Ha-Hb+1) for ippiROIValid mask, 
           where Wa*Ha and Wb*Hb are the sizes of the image and template correspondingly.
           Support of normalization operations (set in the algType mask) is set by selecting the following masks:
             ippiNormNone   - the cross-correlation without normalization.
             ippiNorm - the normalized cross-correlation.
             ippiNormCoefficient  - the normalized correlation coefficients.
           If the IppAlgMask value in algType is equal to ippAlgAuto,  the optimal algorithm is selected automatically.
           For big data size,  the function uses 2D FFT algorithm.
  Parameters:
    pSrc        - Pointer to the source image ROI.
    srcStep     - Distance, in bytes,  between the starting points of consecutive lines in the source image.
    srcRoiSize  - Size of the source ROI in pixels.
    pTpl        - Pointer to the template image.
    tplStep     - Distance, in bytes,  between the starting points of consecutive lines in the template image.
    tplRoiSize  - Size of the template ROI in pixels.
    pDst        - Pointer to the destination image ROI.
    dstStep     - Distance, in bytes,  between the starting points of consecutive lines in the destination image.
    scaleFactor - Scale factor.
    algType     - Bit-field mask for the algorithm type definition. Possible values are the results of composition of the IppAlgType,  IppiROIShape, and IppiNormOp values.
                  Usage example: algType=(ippiROIFull|ippAlgFFT|ippiNormNone); - full-shaped cross-correlation will be calculated using 2D FFT without result normalization.
    pBuffer     - Pointer to the work buffer.
  Returns:
    ippStsNoErr      OK.
    ippStsNullPtrErr Error when any of the specified pointers is NULL.
    ippStsStepErr    Error when the value of srcStep,  tplStep, or dstStep is negative,  or equal to zero.
    ippStsSizeErr    Error when :
                         srcRoiSize or tplRoiSize is negative,  or equal to zero.
                         The value of srcRoiSize is less than the corresponding value of tplRoiSize.
    ippStsAlgTypeErr Error when :
                         The result of the bitwise AND operation between the algType and ippAlgMask differs from the ippAlgAuto,  ippAlgDirect, or ippAlgFFT values.
                         The result of the bitwise AND operation between the algType and ippiROIMask differs from the ippiROIFull,  ippiROISame, or ippiROIValid values.
                         The result of the bitwise AND operation between the algType and ippiNormMask differs from the ippiNormNone,  ippiNorm, or ippiNormCoefficient values.
}

 function ippiCrossCorrNorm_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp32fPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiCrossCorrNorm_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp16uPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiCrossCorrNorm_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp8uPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiCrossCorrNorm_8u_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp8uPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; scaleFactor : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:  ippiSqrDistanceNormGetBufferSize

  Purpose:     Computes the size of the work buffer for the ippiSqrDistanceNorm functions.

  Parameters:
    srcRoiSize  - Size of the source ROI,  in pixels.
    tplRoiSize  - Size of the template ROI,  in pixels.
    algType     - Bit-field mask for the algorithm type definition. Possible values are the results of composition of the IppAlgType,  IppiROIShape, and IppiNormOp values.
                  Usage example: algType=(ippiROIFull|ippAlgFFT|ippiNorm); - result image will be calculated for full-shaped ROI
                  using 2D FFT and normalization applied.
    pBufferSize - Pointer where to store the calculated buffer size (in bytes)
  Return:
    ippStsNoErr      - Ok.
    ippStsSizeErr    - Error when :
                           srcRoiSize or tplRoiSize is negative,  or equal to zero.
                           The value of srcRoiSize is less than the corresponding value of tplRoiSize.
    ippStsAlgTypeErr - Error when :
                           The result of the bitwise AND operation between the algType and ippAlgMask differs from the ippAlgAuto,  ippAlgDirect, or ippAlgFFT values.
                           The result of the bitwise AND operation between the algType and ippiROIMask differs from the ippiROIFull,  ippiROISame, or ippiROIValid values.
                           The result of the bitwise AND operation between the algType and ippiNormMask differs from the ippiNormNone or ippiNorm values.
    ippStsNullPtrErr - Error when the pBufferSize is NULL.
}

 function ippiSqrDistanceNormGetBufferSize( srcRoiSize : IppiSize ; tplRoiSize : IppiSize ; algType : IppEnum ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names: ippiSqrDistanceNorm_32f_C1R
         ippiSqrDistanceNorm_16u32f_C1R
         ippiSqrDistanceNorm_8u32f_C1R
         ippiSqrDistanceNorm_8u_C1RSfs
  Purpose: Computes Euclidean distance between an image and a template.
           The result image size depends on operation shape selected in algType mask as follows :
             (Wa+Wb-1)*(Ha+Hb-1) for ippiROIFull mask, 
             (Wa)*(Ha)           for ippiROISame mask, 
             (Wa-Wb+1)*(Ha-Hb+1) for ippiROIValid mask, 
           where Wa*Ha and Wb*Hb are the sizes of the image and template , respectively.
           Support of normalization operations (set the algType mask) :
             ippiNormNone   - the squared Euclidean distances.
             ippiNorm - the normalized squared Euclidean distances.
           If the IppAlgMask value in algType is equal to ippAlgAuto,  the optimal algorithm is selected
           automatically. For big data size,  the function uses 2D FFT algorithm.
  Parameters:
    pSrc        - Pointer to the source image ROI.
    srcStep     - Distance, in bytes,  between the starting points of consecutive lines in the source image.
    srcRoiSize  - Size of the source ROI,  in pixels.
    pTpl        - Pointer to the template image.
    tplStep     - Distance, in bytes,  between the starting points of consecutive lines in the template image.
    tplRoiSize  - Size of the template ROI,  in pixels.
    pDst        - Pointer to the destination image ROI.
    dstStep     - Distance, in bytes,  between the starting points of consecutive lines in the destination image.
    scaleFactor - Scale factor.
    algType     - Bit-field mask for the algorithm type definition. Possible values are the results of composition of the IppAlgType,  IppiROIShape, and IppiNormOp values.
                  Usage example: algType=(ippiROIFull|ippiNormNone|ippAlgFFT); - result will be calculated for full-shaped ROI using 2D FFT without normalization.
    pBuffer     - Pointer to the buffer for internal calculation.
  Returns:
    ippStsNoErr      OK.
    ippStsNullPtrErr Error when any of the specified pointers is NULL.
    ippStsStepErr    Error when the value of srcStep,  tplStep, or dstStep is negative,  or equal to zero.
    ippStsSizeErr    Error when :
                         srcRoiSize or tplRoiSize is negative,  or equal to zero.
                         The value of srcRoiSize is less than the corresponding value of the tplRoiSize.
    ippStsAlgTypeErr Error when :
                         The result of the bitwise AND operation between the algType and ippAlgMask differs from the ippAlgAuto,  ippAlgDirect, or ippAlgFFT values.
                         The result of the bitwise AND operation between the algType and ippiROIMask differs from the ippiROIFull,  ippiROISame, or ippiROIValid values.
                         The result of the bitwise AND operation between the algType and ippiNormMask differs from the ippiNormNone or ippiNorm values.
}

 function ippiSqrDistanceNorm_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp32fPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiSqrDistanceNorm_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp16uPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiSqrDistanceNorm_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp8uPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiSqrDistanceNorm_8u_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp8uPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; scaleFactor : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                   Threshold operations
  ----------------------------------------------------------------------------

  Names:      ippiThreshold_8u_C1R
              ippiThreshold_8u_C3R
              ippiThreshold_8u_AC4R
              ippiThreshold_16s_C1R
              ippiThreshold_16s_C3R
              ippiThreshold_16s_AC4R
              ippiThreshold_32f_C1R
              ippiThreshold_32f_C3R
              ippiThreshold_32f_AC4R
              ippiThreshold_8u_C1IR
              ippiThreshold_8u_C3IR
              ippiThreshold_8u_AC4IR
              ippiThreshold_16s_C1IR
              ippiThreshold_16s_C3IR
              ippiThreshold_16s_AC4IR
              ippiThreshold_32f_C1IR
              ippiThreshold_32f_C3IR
              ippiThreshold_32f_AC4IR
              ippiThreshold_16u_C1R
              ippiThreshold_16u_C3R
              ippiThreshold_16u_AC4R
              ippiThreshold_16u_C1IR
              ippiThreshold_16u_C3IR
              ippiThreshold_16u_AC4IR

  Purpose:    Performs thresholding of an image using the specified level

  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  One of the pointers is NULL
   ippStsSizeErr     roiSize has a field with zero or negative value
   ippStsStepErr     One of the step values is zero or negative

  Parameters:
   pSrc       Pointer to the source image
   srcStep    Step through the source image
   pDst       Pointer to the destination image
   dstStep    Step through the destination image
   pSrcDst    Pointer to the source/destination image (in-place flavors)
   srcDstStep Step through the source/destination image (in-place flavors)
   roiSize    Size of the ROI
   threshold  Threshold level value (array of values for multi-channel data)
   ippCmpOp   Comparison mode,  possible values:
                ippCmpLess     - less than, 
                ippCmpGreater  - greater than
}

 function ippiThreshold_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiThreshold_GT_8u_C1R
              ippiThreshold_GT_8u_C3R
              ippiThreshold_GT_8u_AC4R
              ippiThreshold_GT_16s_C1R
              ippiThreshold_GT_16s_C3R
              ippiThreshold_GT_16s_AC4R
              ippiThreshold_GT_32f_C1R
              ippiThreshold_GT_32f_C3R
              ippiThreshold_GT_32f_AC4R
              ippiThreshold_GT_8u_C1IR
              ippiThreshold_GT_8u_C3IR
              ippiThreshold_GT_8u_AC4IR
              ippiThreshold_GT_16s_C1IR
              ippiThreshold_GT_16s_C3IR
              ippiThreshold_GT_16s_AC4IR
              ippiThreshold_GT_32f_C1IR
              ippiThreshold_GT_32f_C3IR
              ippiThreshold_GT_32f_AC4IR
              ippiThreshold_GT_16u_C1R
              ippiThreshold_GT_16u_C3R
              ippiThreshold_GT_16u_AC4R
              ippiThreshold_GT_16u_C1IR
              ippiThreshold_GT_16u_C3IR
              ippiThreshold_GT_16u_AC4IR

  Purpose:   Performs threshold operation using the comparison "greater than"
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  One of the pointers is NULL
   ippStsSizeErr     roiSize has a field with zero or negative value
   ippStsStepErr     One of the step values is zero or negative

  Parameters:
   pSrc       Pointer to the source image
   srcStep    Step through the source image
   pDst       Pointer to the destination image
   dstStep    Step through the destination image
   pSrcDst    Pointer to the source/destination image (in-place flavors)
   srcDstStep Step through the source/destination image (in-place flavors)
   roiSize    Size of the ROI
   threshold  Threshold level value (array of values for multi-channel data)
}

 function ippiThreshold_GT_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ): IppStatus; _ippapi
 function ippiThreshold_GT_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ): IppStatus; _ippapi
 function ippiThreshold_GT_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ): IppStatus; _ippapi
 function ippiThreshold_GT_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_GT_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_GT_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_GT_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_GT_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_GT_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_GT_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ): IppStatus; _ippapi
 function ippiThreshold_GT_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ): IppStatus; _ippapi
 function ippiThreshold_GT_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ): IppStatus; _ippapi
 function ippiThreshold_GT_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_GT_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_GT_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_GT_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_GT_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_GT_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_GT_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ): IppStatus; _ippapi
 function ippiThreshold_GT_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_GT_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_GT_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ): IppStatus; _ippapi
 function ippiThreshold_GT_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_GT_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiThreshold_LT_8u_C1R
              ippiThreshold_LT_8u_C3R
              ippiThreshold_LT_8u_AC4R
              ippiThreshold_LT_16s_C1R
              ippiThreshold_LT_16s_C3R
              ippiThreshold_LT_16s_AC4R
              ippiThreshold_LT_32f_C1R
              ippiThreshold_LT_32f_C3R
              ippiThreshold_LT_32f_AC4R
              ippiThreshold_LT_8u_C1IR
              ippiThreshold_LT_8u_C3IR
              ippiThreshold_LT_8u_AC4IR
              ippiThreshold_LT_16s_C1IR
              ippiThreshold_LT_16s_C3IR
              ippiThreshold_LT_16s_AC4IR
              ippiThreshold_LT_32f_C1IR
              ippiThreshold_LT_32f_C3IR
              ippiThreshold_LT_32f_AC4IR
              ippiThreshold_LT_16u_C1R
              ippiThreshold_LT_16u_C3R
              ippiThreshold_LT_16u_AC4R
              ippiThreshold_LT_16u_C1IR
              ippiThreshold_LT_16u_C3IR
              ippiThreshold_LT_16u_AC4IR

  Purpose:  Performs threshold operation using the comparison "less than"
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  One of the pointers is NULL
   ippStsSizeErr     roiSize has a field with zero or negative value
   ippStsStepErr     One of the step values is zero or negative

  Parameters:
   pSrc       Pointer to the source image
   srcStep    Step through the source image
   pDst       Pointer to the destination image
   dstStep    Step through the destination image
   pSrcDst    Pointer to the source/destination image (in-place flavors)
   srcDstStep Step through the source/destination image (in-place flavors)
   roiSize    Size of the ROI
   threshold  Threshold level value (array of values for multi-channel data)
   ippCmpOp   Comparison mode,  possible values:
                ippCmpLess     - less than
                ippCmpGreater  - greater than
}

 function ippiThreshold_LT_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ): IppStatus; _ippapi
 function ippiThreshold_LT_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ): IppStatus; _ippapi
 function ippiThreshold_LT_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ): IppStatus; _ippapi
 function ippiThreshold_LT_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LT_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LT_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_LT_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LT_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LT_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_LT_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ): IppStatus; _ippapi
 function ippiThreshold_LT_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ): IppStatus; _ippapi
 function ippiThreshold_LT_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ): IppStatus; _ippapi
 function ippiThreshold_LT_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LT_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LT_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_LT_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LT_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LT_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_LT_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ): IppStatus; _ippapi
 function ippiThreshold_LT_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_LT_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_LT_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ): IppStatus; _ippapi
 function ippiThreshold_LT_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_LT_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiThreshold_Val_8u_C1R
              ippiThreshold_Val_8u_C3R
              ippiThreshold_Val_8u_AC4R
              ippiThreshold_Val_16s_C1R
              ippiThreshold_Val_16s_C3R
              ippiThreshold_Val_16s_AC4R
              ippiThreshold_Val_32f_C1R
              ippiThreshold_Val_32f_C3R
              ippiThreshold_Val_32f_AC4R
              ippiThreshold_Val_8u_C1IR
              ippiThreshold_Val_8u_C3IR
              ippiThreshold_Val_8u_AC4IR
              ippiThreshold_Val_16s_C1IR
              ippiThreshold_Val_16s_C3IR
              ippiThreshold_Val_16s_AC4IR
              ippiThreshold_Val_32f_C1IR
              ippiThreshold_Val_32f_C3IR
              ippiThreshold_Val_32f_AC4IR
              ippiThreshold_Val_16u_C1R
              ippiThreshold_Val_16u_C3R
              ippiThreshold_Val_16u_AC4R
              ippiThreshold_Val_16u_C1IR
              ippiThreshold_Val_16u_C3IR
              ippiThreshold_Val_16u_AC4IR

  Purpose:  Performs thresholding of pixel values: pixels that satisfy
            the compare conditions are set to a specified value
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  One of the pointers is NULL
   ippStsSizeErr     roiSize has a field with zero or negative value
   ippStsStepErr     One of the step values is zero or negative

  Parameters:
   pSrc       Pointer to the source image
   srcStep    Step through the source image
   pDst       Pointer to the destination image
   dstStep    Step through the destination image
   pSrcDst    Pointer to the source/destination image (in-place flavors)
   srcDstStep Step through the source/destination image (in-place flavors)
   roiSize    Size of the ROI
   threshold  Threshold level value (array of values for multi-channel data)
   value      The output value (array or values for multi-channel data)
   ippCmpOp      comparison mode,  ippCmpLess or ippCmpGreater
}

 function ippiThreshold_Val_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ; value : Ipp8u ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ; value : Ipp16s ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ; value : Ipp32f ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ; value : Ipp8u ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ; value : Ipp16s ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ; value : Ipp32f ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ; value : Ipp16u ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ; value : Ipp16u ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiThreshold_Val_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3 ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiThreshold_GTVal_8u_C1R
              ippiThreshold_GTVal_8u_C3R
              ippiThreshold_GTVal_8u_AC4R
              ippiThreshold_GTVal_16s_C1R
              ippiThreshold_GTVal_16s_C3R
              ippiThreshold_GTVal_16s_AC4R
              ippiThreshold_GTVal_32f_C1R
              ippiThreshold_GTVal_32f_C3R
              ippiThreshold_GTVal_32f_AC4R
              ippiThreshold_GTVal_8u_C1IR
              ippiThreshold_GTVal_8u_C3IR
              ippiThreshold_GTVal_8u_AC4IR
              ippiThreshold_GTVal_16s_C1IR
              ippiThreshold_GTVal_16s_C3IR
              ippiThreshold_GTVal_16s_AC4IR
              ippiThreshold_GTVal_32f_C1IR
              ippiThreshold_GTVal_32f_C3IR
              ippiThreshold_GTVal_32f_AC4IR
              ippiThreshold_GTVal_8u_C4R
              ippiThreshold_GTVal_16s_C4R
              ippiThreshold_GTVal_32f_C4R
              ippiThreshold_GTVal_8u_C4IR
              ippiThreshold_GTVal_16s_C4IR
              ippiThreshold_GTVal_32f_C4IR
              ippiThreshold_GTVal_16u_C1R
              ippiThreshold_GTVal_16u_C3R
              ippiThreshold_GTVal_16u_AC4R
              ippiThreshold_GTVal_16u_C1IR
              ippiThreshold_GTVal_16u_C3IR
              ippiThreshold_GTVal_16u_AC4IR
              ippiThreshold_GTVal_16u_C4R
              ippiThreshold_GTVal_16u_C4IR

  Purpose:  Performs thresholding of pixel values: pixels that are
            greater than threshold,  are set to a specified value
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  One of the pointers is NULL
   ippStsSizeErr     roiSize has a field with zero or negative value
   ippStsStepErr     One of the step values is zero or negative

  Parameters:
   pSrc       Pointer to the source image
   srcStep    Step through the source image
   pDst       Pointer to the destination image
   dstStep    Step through the destination image
   pSrcDst    Pointer to the source/destination image (in-place flavors)
   srcDstStep Step through the source/destination image (in-place flavors)
   roiSize    Size of the ROI
   threshold  Threshold level value (array of values for multi-channel data)
   value      The output value (array or values for multi-channel data)
}

 function ippiThreshold_GTVal_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ; value : Ipp8u ): IppStatus; _ippapi
 function ippiThreshold_GTVal_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ; value : Ipp16s ): IppStatus; _ippapi
 function ippiThreshold_GTVal_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ; value : Ipp32f ): IppStatus; _ippapi
 function ippiThreshold_GTVal_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ; value : Ipp8u ): IppStatus; _ippapi
 function ippiThreshold_GTVal_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ; value : Ipp16s ): IppStatus; _ippapi
 function ippiThreshold_GTVal_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ; value : Ipp32f ): IppStatus; _ippapi
 function ippiThreshold_GTVal_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_4 ; const value : Ipp8u_4): IppStatus; _ippapi
 function ippiThreshold_GTVal_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_4 ; const value : Ipp16s_4): IppStatus; _ippapi
 function ippiThreshold_GTVal_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_4 ; const value : Ipp32f_4): IppStatus; _ippapi
 function ippiThreshold_GTVal_8u_C4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_4 ; const value : Ipp8u_4): IppStatus; _ippapi
 function ippiThreshold_GTVal_16s_C4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_4 ; const value : Ipp16s_4): IppStatus; _ippapi
 function ippiThreshold_GTVal_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_4 ; const value : Ipp32f_4): IppStatus; _ippapi
 function ippiThreshold_GTVal_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ; value : Ipp16u ): IppStatus; _ippapi
 function ippiThreshold_GTVal_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ; value : Ipp16u ): IppStatus; _ippapi
 function ippiThreshold_GTVal_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_GTVal_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_4 ; const value : Ipp16u_4): IppStatus; _ippapi
 function ippiThreshold_GTVal_16u_C4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_4 ; const value : Ipp16u_4): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiThreshold_LTVal_8u_C1R
              ippiThreshold_LTVal_8u_C3R
              ippiThreshold_LTVal_8u_AC4R
              ippiThreshold_LTVal_16s_C1R
              ippiThreshold_LTVal_16s_C3R
              ippiThreshold_LTVal_16s_AC4R
              ippiThreshold_LTVal_32f_C1R
              ippiThreshold_LTVal_32f_C3R
              ippiThreshold_LTVal_32f_AC4R
              ippiThreshold_LTVal_8u_C1IR
              ippiThreshold_LTVal_8u_C3IR
              ippiThreshold_LTVal_8u_AC4IR
              ippiThreshold_LTVal_16s_C1IR
              ippiThreshold_LTVal_16s_C3IR
              ippiThreshold_LTVal_16s_AC4IR
              ippiThreshold_LTVal_32f_C1IR
              ippiThreshold_LTVal_32f_C3IR
              ippiThreshold_LTVal_32f_AC4IR
              ippiThreshold_LTVal_8u_C4R
              ippiThreshold_LTVal_16s_C4R
              ippiThreshold_LTVal_32f_C4R
              ippiThreshold_LTVal_8u_C4IR
              ippiThreshold_LTVal_16s_C4IR
              ippiThreshold_LTVal_32f_C4IR
              ippiThreshold_LTVal_16u_C1R
              ippiThreshold_LTVal_16u_C3R
              ippiThreshold_LTVal_16u_AC4R
              ippiThreshold_LTVal_16u_C1IR
              ippiThreshold_LTVal_16u_C3IR
              ippiThreshold_LTVal_16u_AC4IR
              ippiThreshold_LTVal_16u_C4R
              ippiThreshold_LTVal_16u_C4IR

  Purpose:  Performs thresholding of pixel values: pixels that are
            less than threshold,  are set to a specified value
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  One of the pointers is NULL
   ippStsSizeErr     roiSize has a field with zero or negative value
   ippStsStepErr     One of the step values is zero or negative

  Parameters:
   pSrc       Pointer to the source image
   srcStep    Step through the source image
   pDst       Pointer to the destination image
   dstStep    Step through the destination image
   pSrcDst    Pointer to the source/destination image (in-place flavors)
   srcDstStep Step through the source/destination image (in-place flavors)
   roiSize    Size of the ROI
   threshold  Threshold level value (array of values for multi-channel data)
   value      The output value (array or values for multi-channel data)
}

 function ippiThreshold_LTVal_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ; value : Ipp8u ): IppStatus; _ippapi
 function ippiThreshold_LTVal_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ; value : Ipp16s ): IppStatus; _ippapi
 function ippiThreshold_LTVal_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ; value : Ipp32f ): IppStatus; _ippapi
 function ippiThreshold_LTVal_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ; value : Ipp8u ): IppStatus; _ippapi
 function ippiThreshold_LTVal_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ; value : Ipp16s ): IppStatus; _ippapi
 function ippiThreshold_LTVal_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ; value : Ipp32f ): IppStatus; _ippapi
 function ippiThreshold_LTVal_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_3 ; const value : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_3 ; const value : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_3 ; const value : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_4 ; const value : Ipp8u_4): IppStatus; _ippapi
 function ippiThreshold_LTVal_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_4 ; const value : Ipp16s_4): IppStatus; _ippapi
 function ippiThreshold_LTVal_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_4 ; const value : Ipp32f_4): IppStatus; _ippapi
 function ippiThreshold_LTVal_8u_C4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp8u_4 ; const value : Ipp8u_4): IppStatus; _ippapi
 function ippiThreshold_LTVal_16s_C4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16s_4 ; const value : Ipp16s_4): IppStatus; _ippapi
 function ippiThreshold_LTVal_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp32f_4 ; const value : Ipp32f_4): IppStatus; _ippapi
 function ippiThreshold_LTVal_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ; value : Ipp16u ): IppStatus; _ippapi
 function ippiThreshold_LTVal_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ; value : Ipp16u ): IppStatus; _ippapi
 function ippiThreshold_LTVal_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_3 ; const value : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_LTVal_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_4 ; const value : Ipp16u_4): IppStatus; _ippapi
 function ippiThreshold_LTVal_16u_C4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const threshold : Ipp16u_4 ; const value : Ipp16u_4): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippiThreshold_LTValGTVal_8u_C1R
              ippiThreshold_LTValGTVal_8u_C3R
              ippiThreshold_LTValGTVal_8u_AC4R
              ippiThreshold_LTValGTVal_16s_C1R
              ippiThreshold_LTValGTVal_16s_C3R
              ippiThreshold_LTValGTVal_16s_AC4R
              ippiThreshold_LTValGTVal_32f_C1R
              ippiThreshold_LTValGTVal_32f_C3R
              ippiThreshold_LTValGTVal_32f_AC4R
              ippiThreshold_LTValGTVal_16u_C1R
              ippiThreshold_LTValGTVal_16u_C3R
              ippiThreshold_LTValGTVal_16u_AC4R

  Purpose:    Performs double thresholding of pixel values
  Returns:
   ippStsNoErr        OK
   ippStsNullPtrErr   One of the pointers is NULL
   ippStsSizeErr      roiSize has a field with zero or negative value
   ippStsThresholdErr thresholdLT > thresholdGT
   ippStsStepErr      One of the step values is zero or negative

  Parameters:
/  Parameters:
   pSrc        Pointer to the source image
   srcStep     Step through the source image
   pDst        Pointer to the destination image
   dstStep     Step through the destination image
   pSrcDst     Pointer to the source/destination image (in-place flavors)
   srcDstStep  Step through the source/destination image (in-place flavors)
   roiSize     Size of the ROI
   thresholdLT Lower threshold value (array of values for multi-channel data)
   valueLT     Lower output value (array or values for multi-channel data)
   thresholdGT Upper threshold value (array of values for multi-channel data)
   valueGT     Upper output value (array or values for multi-channel data)
}

 function ippiThreshold_LTValGTVal_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; thresholdLT : Ipp8u ; valueLT : Ipp8u ; thresholdGT : Ipp8u ; valueGT : Ipp8u ): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; thresholdLT : Ipp16s ; valueLT : Ipp16s ; thresholdGT : Ipp16s ; valueGT : Ipp16s ): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; thresholdLT : Ipp32f ; valueLT : Ipp32f ; thresholdGT : Ipp32f ; valueGT : Ipp32f ): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp8u_3 ; const valueLT : Ipp8u_3 ; const thresholdGT : Ipp8u_3 ; const valueGT : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp16s_3 ; const valueLT : Ipp16s_3 ; const thresholdGT : Ipp16s_3 ; const valueGT : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp32f_3 ; const valueLT : Ipp32f_3 ; const thresholdGT : Ipp32f_3 ; const valueGT : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp8u_3 ; const valueLT : Ipp8u_3 ; const thresholdGT : Ipp8u_3 ; const valueGT : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp16s_3 ; const valueLT : Ipp16s_3 ; const thresholdGT : Ipp16s_3 ; const valueGT : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp32f_3 ; const valueLT : Ipp32f_3 ; const thresholdGT : Ipp32f_3 ; const valueGT : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; thresholdLT : Ipp8u ; valueLT : Ipp8u ; thresholdGT : Ipp8u ; valueGT : Ipp8u ): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; thresholdLT : Ipp16s ; valueLT : Ipp16s ; thresholdGT : Ipp16s ; valueGT : Ipp16s ): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; thresholdLT : Ipp32f ; valueLT : Ipp32f ; thresholdGT : Ipp32f ; valueGT : Ipp32f ): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp8u_3 ; const valueLT : Ipp8u_3 ; const thresholdGT : Ipp8u_3 ; const valueGT : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp16s_3 ; const valueLT : Ipp16s_3 ; const thresholdGT : Ipp16s_3 ; const valueGT : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp32f_3 ; const valueLT : Ipp32f_3 ; const thresholdGT : Ipp32f_3 ; const valueGT : Ipp32f_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp8u_3 ; const valueLT : Ipp8u_3 ; const thresholdGT : Ipp8u_3 ; const valueGT : Ipp8u_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp16s_3 ; const valueLT : Ipp16s_3 ; const thresholdGT : Ipp16s_3 ; const valueGT : Ipp16s_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp32f_3 ; const valueLT : Ipp32f_3 ; const thresholdGT : Ipp32f_3 ; const valueGT : Ipp32f_3): IppStatus; _ippapi

 function ippiThreshold_LTValGTVal_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; thresholdLT : Ipp16u ; valueLT : Ipp16u ; thresholdGT : Ipp16u ; valueGT : Ipp16u ): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp16u_3 ; const valueLT : Ipp16u_3 ; const thresholdGT : Ipp16u_3 ; const valueGT : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp16u_3 ; const valueLT : Ipp16u_3 ; const thresholdGT : Ipp16u_3 ; const valueGT : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; thresholdLT : Ipp16u ; valueLT : Ipp16u ; thresholdGT : Ipp16u ; valueGT : Ipp16u ): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp16u_3 ; const valueLT : Ipp16u_3 ; const thresholdGT : Ipp16u_3 ; const valueGT : Ipp16u_3): IppStatus; _ippapi
 function ippiThreshold_LTValGTVal_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const thresholdLT : Ipp16u_3 ; const valueLT : Ipp16u_3 ; const thresholdGT : Ipp16u_3 ; const valueGT : Ipp16u_3): IppStatus; _ippapi

{ ----------------------------------------------------------------------------
  Name: ippiComputeThreshold_Otsu_8u_C1R

  Purpose: Calculate Otsu theshold value of images
    Return:
      ippStsNoErr              Ok
      ippStsNullPtrErr         One of pointers is NULL
      ippStsSizeErr            The width or height of images is less or equal zero
      ippStsStepErr            The steps in images is less ROI
    Parameters:
      pSrc                     Pointer to image
      srcStep                  Image step
      roiSize                  Size of image ROI
      pThreshold               Returned Otsu theshold value
}

 function ippiComputeThreshold_Otsu_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pThreshold : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     Adaptive threshold functions
 ----------------------------------------------------------------------------
  Name:       ippiThresholdAdaptiveBoxGetBufferSize
              ippiThresholdAdaptiveGaussGetBufferSize
  Purpose:    to define spec and buffer sizes for adaptive threshold
  Parameters:
   roiSize       Size of the destination ROI in pixels.
   maskSize      Size of kernel for calculation of threshold level.
                 Width and height of maskSize must be equal and odd.
   dataType      Data type of the source and destination images. Possible value is ipp8u.
   numChannels   Number of channels in the images. Possible value is 1.
   pSpecSize     Pointer to the computed value of the spec size.
   pBufferSize   Pointer to the computed value of the external buffer size.
  Return:
    ippStsNoErr               OK
    ippStsNullPtrErr          any pointer is NULL
    ippStsSizeErr             size of dstRoiSize is less or equal 0
    ippStsMaskSizeErr         fields of maskSize are not equak or ones are less or equal 0
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsNumChannelsErr      Indicates an error when numChannels has an illegal value.
}

 function ippiThresholdAdaptiveBoxGetBufferSize( roiSize : IppiSize ; maskSize : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiThresholdAdaptiveGaussGetBufferSize( roiSize : IppiSize ; maskSize : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiFilterThresholdGaussAdaptiveInit
  Purpose:    initialization of Spec for adaptive threshold
  Parameters:
   roiSize       Size of the destination ROI in pixels.
   maskSize      Size of kernel for calculation of threshold level.
                 Width and height of maskSize must be equal and odd.
   dataType      Data type of the source and destination images. Possible value is ipp8u.
   numChannels   Number of channels in the images. Possible value is 1.
   sigma         value of sigma for calculation of threshold level for Gauss-method,
                 if sigma value is less or equal zero than sigma is set automatically
                 in compliance with kernel size,  in this cases
                 sigma = 0.3*(maskSize.width-1)*0.5-1)+0.8;
   pSpec         pointer to Spec
  Return:
    ippStsNoErr               OK
    ippStsNullPtrErr          pointer to Spec is NULL
    ippStsSizeErr             size of dstRoiSize is less or equal 0
    ippStsMaskSizeErr         size of kernel for calculation of threshold level.
                              Width and height of maskSize must be equal and odd.
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsNumChannelsErr      Indicates an error when numChannels has an illegal value.
}

 function ippiThresholdAdaptiveGaussInit( roiSize : IppiSize ; maskSize : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; sigma : Ipp32f ; pSpec : IppiThresholdAdaptiveSpecPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiThresholdAdaptiveBox_8u_C1R
              ippiThresholdAdaptiveThreshold_8u_C1R
  Purpose:    to executes adaptive threshold operation
  Parameters:
   pSrc          Pointer to the source image ROI.
   srcStep       Distance in bytes between starts of consecutive lines in the source image.
   pDst          Pointer to the destination image ROI.
   dstStep       Distance in bytes between starts of consecutive lines in the destination image.
   dstRoiSize    Size of the destination ROI in pixels.
   maskSize      Size of kernel for calculation of threshold level.
                 Width and height of maskSize must be equal and odd.
   delta         value for calculation of threshold (subtrahend).
   valGT         output pixel if source pixel is great then threshold.
   valLE         output pixel if source pixel is less or equal threshold.
/    borderType    Type of border.
   borderValue   Constant value to assign to pixels of the constant border. This parameter is applicable
                 only to the ippBorderConst border type.
   pSpecSize     Pointer to the computed value of the spec size.
   pBufferSize   Pointer to the computed value of the external buffer size.
  Return:
    ippStsNoErr           OK
    ippStsNullPtrErr      any pointer is NULL
    ippStsSizeErr         size of dstRoiSize is less or equal 0
    ippStsMaskSizeErr     one of the fields of maskSize has a negative or zero value or
                          if the fields of maskSize are not equal
    ippStsContextMatchErr spec is not match
    ippStsBorderErr       Indicates an error when borderType has illegal value.

     Output pixels are calculated such:
     pDst(x,y) = valGT if (pSrc(x,y) > T(x,y))
     and
     pDst(x,y) = valLE if (pSrc(x,y) <= T(x,y))

     For ippiThresholdAdaptiveBox_8u_C1R:
     T(x,y) is a mean of the kernelSize.width*kernelSize.height neighborhood of (x,y)-pixel
     minus delta.

     For ippiThresholdAdaptiveGauss_8u_C1R:
     T(x,y) is a weighted sum (cross-correlation with a Gaussian window) of
     the kernelSize.width*kernelSize.height neighborhood of (x,y)-pixel minus delta.
     Coefficients of Gaussian window is separable.
     Coefficients for row of separable Gaussian window:
     Gi = A * exp(-(i-(kernelSize.width-1)/2)^2/(0.5 * sigma^2),
     A is scale factor for
     SUM(Gi) = 1 (i = 0,...,maskSize.width-1).
}

 function ippiThresholdAdaptiveBox_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; delta : Ipp32f ; valGT : Ipp8u ; valLE : Ipp8u ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiThresholdAdaptiveGauss_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; delta : Ipp32f ; valGT : Ipp8u ; valLE : Ipp8u ; borderType : IppiBorderType ; borderValue : Ipp8u ; pSpec : IppiThresholdAdaptiveSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiThresholdAdaptiveBox_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; maskSize : IppiSize ; delta : Ipp32f ; valGT : Ipp8u ; valLE : Ipp8u ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiThresholdAdaptiveGauss_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; delta : Ipp32f ; valGT : Ipp8u ; valLE : Ipp8u ; borderType : IppiBorderType ; borderValue : Ipp8u ; pSpec : IppiThresholdAdaptiveSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                   Convert and Initialization functions
{ ----------------------------------------------------------------------------


  Name:       ippiCopyManaged

  Purpose:  copy pixel values from the source image to the destination  image


  Returns:
    ippStsNullPtrErr  One of the pointers is NULL
    ippStsSizeErr     roiSize has a field with zero or negative value
    ippStsNoErr       OK

  Parameters:
    pSrc              Pointer  to the source image buffer
    srcStep           Step in bytes through the source image buffer
    pDst              Pointer to the  destination image buffer
    dstStep           Step in bytes through the destination image buffer
    roiSize           Size of the ROI
    flags             The logic sum of tags sets type of copying.
                      (IPP_TEMPORAL_COPY,IPP_NONTEMPORAL_STORE etc.)
}

 function ippiCopyManaged_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; flags : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiCopy

  Purpose:  copy pixel values from the source image to the destination  image


  Returns:
    ippStsNullPtrErr  One of the pointers is NULL
    ippStsSizeErr     roiSize has a field with zero or negative value
    ippStsNoErr       OK

  Parameters:
    pSrc              Pointer  to the source image buffer
    srcStep           Step in bytes through the source image buffer
    pDst              Pointer to the  destination image buffer
    dstStep           Step in bytes through the destination image buffer
    roiSize           Size of the ROI
    pMask             Pointer to the mask image buffer
    maskStep          Step in bytes through the mask image buffer
}

 function ippiCopy_8u_C3C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_C1C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_C4C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_C1C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_C3CR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_C4CR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_AC4C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_C3AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_C1MR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_8u_C3MR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_8u_C4MR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_8u_AC4MR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi

 function ippiCopy_16s_C3C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_C1C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_C4C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_C1C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_C3CR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_C4CR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_AC4C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_C3AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_C1MR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_16s_C3MR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_16s_C4MR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_16s_AC4MR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi

 function ippiCopy_32f_C3C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_C1C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_C4C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_C1C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_C3CR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_C4CR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_AC4C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_C3AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_C1MR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_32f_C3MR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_32f_C4MR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_32f_AC4MR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi

 function ippiCopy_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_C4P4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_8u_P4C4R( pSrc : Ipp8u_4Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiCopy_16s_C3P3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16s_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_P3C3R( pSrc : Ipp16s_3Ptr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_C4P4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16s_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16s_P4C4R( pSrc : Ipp16s_4Ptr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiCopy_32f_C3P3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32f_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_P3C3R( pSrc : Ipp32f_3Ptr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_C4P4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32f_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32f_P4C4R( pSrc : Ipp32f_4Ptr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiCopy_32s_C3C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_C1C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_C4C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_C1C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_C3CR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_C4CR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_AC4C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_C3AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_C1MR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_32s_C3MR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_32s_C4MR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_32s_AC4MR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_32s_C3P3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32s_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_P3C3R( pSrc : Ipp32s_3Ptr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_C4P4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32s_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_32s_P4C4R( pSrc : Ipp32s_4Ptr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiCopy_16u_C3C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_C1C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_C4C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_C1C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_C3CR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_C4CR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_AC4C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_C3AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_C1MR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_16u_C3MR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_16u_C4MR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_16u_AC4MR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiCopy_16u_C3P3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_P3C3R( pSrc : Ipp16u_3Ptr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_C4P4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16u_4Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiCopy_16u_P4C4R( pSrc : Ipp16u_4Ptr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiCopyReplicateBorder

  Purpose:   Copies pixel values between two buffers and adds
             the replicated border pixels.

  Returns:
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsSizeErr       1). srcRoiSize or dstRoiSize has a field with negative or zero value
                        2). topBorderHeight or leftBorderWidth is less than zero
                        3). dstRoiSize.width < srcRoiSize.width + leftBorderWidth
                        4). dstRoiSize.height < srcRoiSize.height + topBorderHeight
    ippStsStepErr       srcStep or dstStep is less than or equal to zero
    ippStsNoErr         OK

  Parameters:
    pSrc                Pointer  to the source image buffer
    srcStep             Step in bytes through the source image
    pDst                Pointer to the  destination image buffer
    dstStep             Step in bytes through the destination image
    scrRoiSize          Size of the source ROI in pixels
    dstRoiSize          Size of the destination ROI in pixels
    topBorderHeight     Height of the top border in pixels
    leftBorderWidth     Width of the left border in pixels
}

 function ippiCopyReplicateBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32s_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi

 function ippiCopyReplicateBorder_8u_C1IR( pSrc : Ipp8uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_8u_C3IR( pSrc : Ipp8uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_8u_AC4IR( pSrc : Ipp8uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_8u_C4IR( pSrc : Ipp8uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

 function ippiCopyReplicateBorder_16s_C1IR( pSrc : Ipp16sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16s_C3IR( pSrc : Ipp16sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16s_AC4IR( pSrc : Ipp16sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16s_C4IR( pSrc : Ipp16sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

 function ippiCopyReplicateBorder_32s_C1IR( pSrc : Ipp32sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32s_C3IR( pSrc : Ipp32sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32s_AC4IR( pSrc : Ipp32sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32s_C4IR( pSrc : Ipp32sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

 function ippiCopyReplicateBorder_16u_C1IR( pSrc : Ipp16uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16u_C3IR( pSrc : Ipp16uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16u_AC4IR( pSrc : Ipp16uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16u_C4IR( pSrc : Ipp16uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

 function ippiCopyReplicateBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi

 function ippiCopyReplicateBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi

 function ippiCopyReplicateBorder_32f_C1IR( pSrc : Ipp32fPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32f_C3IR( pSrc : Ipp32fPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32f_AC4IR( pSrc : Ipp32fPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyReplicateBorder_32f_C4IR( pSrc : Ipp32fPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiCopyConstBorder

  Purpose:    Copies pixel values between two buffers and adds
              the border pixels with constant value.

  Returns:
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      1). srcRoiSize or dstRoiSize has a field with negative or zero value
                       2). topBorderHeight or leftBorderWidth is less than zero
                       3). dstRoiSize.width < srcRoiSize.width + leftBorderWidth
                       4). dstRoiSize.height < srcRoiSize.height + topBorderHeight
    ippStsStepErr      srcStep or dstStep is less than or equal to zero
    ippStsNoErr        OK

  Parameters:
    pSrc               Pointer  to the source image buffer
    srcStep            Step in bytes through the source image
    pDst               Pointer to the  destination image buffer
    dstStep            Step in bytes through the destination image
    srcRoiSize         Size of the source ROI in pixels
    dstRoiSize         Size of the destination ROI in pixels
    topBorderHeight    Height of the top border in pixels
    leftBorderWidth    Width of the left border in pixels
    value              Constant value to assign to the border pixels
}

 function ippiCopyConstBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; value : Ipp8u ): IppStatus; _ippapi
 function ippiCopyConstBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp8u_3 ): IppStatus; _ippapi
 function ippiCopyConstBorder_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp8u_3 ): IppStatus; _ippapi
 function ippiCopyConstBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp8u_4 ): IppStatus; _ippapi
 function ippiCopyConstBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; value : Ipp16s ): IppStatus; _ippapi
 function ippiCopyConstBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp16s_3 ): IppStatus; _ippapi
 function ippiCopyConstBorder_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp16s_3 ): IppStatus; _ippapi
 function ippiCopyConstBorder_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp16s_4 ): IppStatus; _ippapi
 function ippiCopyConstBorder_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; value : Ipp32s ): IppStatus; _ippapi
 function ippiCopyConstBorder_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp32s_3 ): IppStatus; _ippapi
 function ippiCopyConstBorder_32s_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp32s_3 ): IppStatus; _ippapi
 function ippiCopyConstBorder_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp32s_4 ): IppStatus; _ippapi

 function ippiCopyConstBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; value : Ipp16u ): IppStatus; _ippapi
 function ippiCopyConstBorder_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp16u_3 ): IppStatus; _ippapi
 function ippiCopyConstBorder_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp16u_3 ): IppStatus; _ippapi
 function ippiCopyConstBorder_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp16u_4 ): IppStatus; _ippapi

 function ippiCopyConstBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; value : Ipp32f ): IppStatus; _ippapi
 function ippiCopyConstBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp32f_3 ): IppStatus; _ippapi
 function ippiCopyConstBorder_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp32f_3 ): IppStatus; _ippapi
 function ippiCopyConstBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ; const value : Ipp32f_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiCopyMirrorBorder

  Purpose:   Copies pixel values between two buffers and adds
             the mirror border pixels.

  Returns:
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsSizeErr       1). srcRoiSize or dstRoiSize has a field with negative or zero value
                        2). topBorderHeight or leftBorderWidth is less than zero
                        3). dstRoiSize.width < srcRoiSize.width + leftBorderWidth
                        4). dstRoiSize.height < srcRoiSize.height + topBorderHeight
    ippStsStepErr       srcStep or dstStep is less than or equal to zero
    ippStsNoErr         OK

  Parameters:
    pSrc                Pointer  to the source image buffer
    srcStep             Step in bytes through the source image
    pDst                Pointer to the  destination image buffer
    dstStep             Step in bytes through the destination image
    scrRoiSize          Size of the source ROI in pixels
    dstRoiSize          Size of the destination ROI in pixels
    topBorderHeight     Height of the top border in pixels
    leftBorderWidth     Width of the left border in pixels
}

 function ippiCopyMirrorBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi

 function ippiCopyMirrorBorder_8u_C1IR( pSrc : Ipp8uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_8u_C3IR( pSrc : Ipp8uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_8u_C4IR( pSrc : Ipp8uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

 function ippiCopyMirrorBorder_16s_C1IR( pSrc : Ipp16sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_16s_C3IR( pSrc : Ipp16sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_16s_C4IR( pSrc : Ipp16sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

 function ippiCopyMirrorBorder_32s_C1IR( pSrc : Ipp32sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_32s_C3IR( pSrc : Ipp32sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_32s_C4IR( pSrc : Ipp32sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

 function ippiCopyMirrorBorder_16u_C1IR( pSrc : Ipp16uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_16u_C3IR( pSrc : Ipp16uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_16u_C4IR( pSrc : Ipp16uPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

 function ippiCopyMirrorBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi

 function ippiCopyMirrorBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi

 function ippiCopyMirrorBorder_32f_C1IR( pSrc : Ipp32fPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_32f_C3IR( pSrc : Ipp32fPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi
 function ippiCopyMirrorBorder_32f_C4IR( pSrc : Ipp32fPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiCopyWrapBorder

  Purpose:    Copies pixel values between two buffers and adds the border pixels.

  Returns:
    ippStsNullPtrErr    One of the pointers is NULL
    ippStsSizeErr       1). srcRoiSize or dstRoiSize has a field with negative or zero value
                        2). topBorderHeight or leftBorderWidth is less than zero
                        3). dstRoiSize.width < srcRoiSize.width + leftBorderWidth
                        4). dstRoiSize.height < srcRoiSize.height + topBorderHeight
    ippStsStepErr       srcStep or dstStep is less than or equal to zero
    ippStsNoErr         OK

  Parameters:
    pSrc                Pointer  to the source image buffer
    srcStep             Step in bytes through the source image
    pDst                Pointer to the  destination image buffer
    dstStep             Step in bytes through the destination image
    scrRoiSize          Size of the source ROI in pixels
    dstRoiSize          Size of the destination ROI in pixels
    topBorderHeight     Height of the top border in pixels
    leftBorderWidth     Width of the left border in pixels
}

 function ippiCopyWrapBorder_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyWrapBorder_32s_C1IR( pSrc : Ipp32sPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

 function ippiCopyWrapBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftBorderWidth : Int32 ): IppStatus; _ippapi
 function ippiCopyWrapBorder_32f_C1IR( pSrc : Ipp32fPtr ; srcDstStep : Int32 ; srcRoiSize : IppiSize ; dstRoiSize : IppiSize ; topBorderHeight : Int32 ; leftborderwidth : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiDup

  Purpose:  Duplication pixel values from the source image
            to the correspondent pixels in all channels
            of the destination  image.

  Returns:
    ippStsNullPtrErr  One of the pointers is NULL
    ippStsSizeErr     roiSize has a field with zero or negative value
    ippStsNoErr       OK

  Parameters:
    pSrc              Pointer  to the source image buffer
    srcStep           Step in bytes through the source image buffer
    pDst              Pointer to the  destination image buffer
    dstStep           Step in bytes through the destination image buffer
    roiSize           Size of the ROI
}

 function ippiDup_8u_C1C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiDup_8u_C1C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiSet

  Purpose:    Sets pixels in the image buffer to a constant value

  Returns:
    ippStsNullPtrErr  One of pointers is NULL
    ippStsSizeErr     roiSize has a field with negative or zero value
    ippStsNoErr       OK

  Parameters:
    value      Constant value assigned to each pixel in the image buffer
    pDst       Pointer to the destination image buffer
    dstStep    Step in bytes through the destination image buffer
    roiSize    Size of the ROI
    pMask      Pointer to the mask image buffer
    maskStep   Step in bytes through the mask image buffer
}

 function ippiSet_8u_C1R( value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_8u_C3CR( value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_8u_C4CR( value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_8u_C3R( const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_8u_C4R( const value : Ipp8u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_8u_AC4R( const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_8u_C1MR( value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_8u_C3MR( const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi

 function ippiSet_8u_C4MR( const value : Ipp8u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_8u_AC4MR( const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_16s_C1R( value : Ipp16s ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16s_C3CR( value : Ipp16s ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16s_C4CR( value : Ipp16s ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16s_C3R( const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16s_C4R( const value : Ipp16s_4 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16s_AC4R( const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16s_C1MR( value : Ipp16s ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_16s_C3MR( const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_16s_C4MR( const value : Ipp16s_4 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_16s_AC4MR( const value : Ipp16s_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_32f_C1R( value : Ipp32f ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiSet_32f_C3CR( value : Ipp32f ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_32f_C4CR( value : Ipp32f ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_32f_C3R( const value : Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_32f_C4R( const value : Ipp32f_4 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_32f_AC4R( const value : Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_32f_C1MR( value : Ipp32f ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_32f_C3MR( const value : Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_32f_C4MR( const value : Ipp32f_4 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_32f_AC4MR( const value : Ipp32f_3 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_32s_C1R( value : Ipp32s ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiSet_32s_C3CR( value : Ipp32s ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_32s_C4CR( value : Ipp32s ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_32s_C3R( const value : Ipp32s_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_32s_C4R( const value : Ipp32s_4 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_32s_AC4R( const value : Ipp32s_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_32s_C1MR( value : Ipp32s ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_32s_C3MR( const value : Ipp32s_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_32s_C4MR( const value : Ipp32s_4 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_32s_AC4MR( const value : Ipp32s_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi

 function ippiSet_16u_C1R( value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16u_C3CR( value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16u_C4CR( value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16u_C3R( const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16u_C4R( const value : Ipp16u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16u_AC4R( const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiSet_16u_C1MR( value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_16u_C3MR( const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_16u_C4MR( const value : Ipp16u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi
 function ippiSet_16u_AC4MR( const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pMask : Ipp8uPtr ; maskStep : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippiAddRandUniform_8u_C1IR,  ippiAddRandUniform_8u_C3IR,
         ippiAddRandUniform_8u_C4IR,  ippiAddRandUniform_8u_AC4IR,
         ippiAddRandUniform_16s_C1IR, ippiAddRandUniform_16s_C3IR,
         ippiAddRandUniform_16s_C4IR, ippiAddRandUniform_16s_AC4IR,
         ippiAddRandUniform_32f_C1IR, ippiAddRandUniform_32f_C3IR,
         ippiAddRandUniform_32f_C4IR, ippiAddRandUniform_32f_AC4IR
         ippiAddRandUniform_16u_C1IR, ippiAddRandUniform_16u_C3IR,
         ippiAddRandUniform_16u_C4IR, ippiAddRandUniform_16u_AC4IR,

  Purpose:    Generates pseudo-random samples with uniform distribution and adds them
              to an image.

  Returns:
    ippStsNoErr          OK
    ippStsNullPtrErr     One of the pointers is NULL
    ippStsSizeErr        roiSize has a field with zero or negative value
    ippStsStepErr        The step in image is less than or equal to zero

  Parameters:
    pSrcDst              Pointer to the image
    srcDstStep           Step in bytes through the image
    roiSize              ROI size
    low                  The lower bounds of the uniform distributions range
    high                 The upper bounds of the uniform distributions range
    pSeed                Pointer to the seed value for the pseudo-random number
                          generator
}

 function ippiAddRandUniform_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp8u ; high : Ipp8u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp8u ; high : Ipp8u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_8u_C4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp8u ; high : Ipp8u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp8u ; high : Ipp8u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp16s ; high : Ipp16s ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp16s ; high : Ipp16s ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_16s_C4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp16s ; high : Ipp16s ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp16s ; high : Ipp16s ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp32f ; high : Ipp32f ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp32f ; high : Ipp32f ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp32f ; high : Ipp32f ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp32f ; high : Ipp32f ; pSeed : Word32Ptr ): IppStatus; _ippapi

 function ippiAddRandUniform_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp16u ; high : Ipp16u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp16u ; high : Ipp16u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_16u_C4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp16u ; high : Ipp16u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandUniform_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; low : Ipp16u ; high : Ipp16u ; pSeed : Word32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiAddRandGauss_8u_C1IR,  ippiAddRandGauss_8u_C3IR,
              ippiAddRandGauss_8u_C4IR,  ippiAddRandGauss_8u_AC4IR
              ippiAddRandGauss_16s_C1IR, ippiAddRandGauss_16s_C3IR,
              ippiAddRandGauss_16s_C4IR, ippiAddRandGauss_16s_AC4IR,
              ippiAddRandGauss_32f_C1IR, ippiAddRandGauss_32f_C3IR,
              ippiAddRandGauss_32f_C4IR, ippiAddRandGauss_32f_AC4IR
              ippiAddRandGauss_16u_C1IR, ippiAddRandGauss_16u_C3IR,
              ippiAddRandGauss_16u_C4IR, ippiAddRandGauss_16u_AC4IR,

  Purpose:    Generates pseudo-random samples with normal distribution and adds them
              to an image.

  Returns:
    ippStsNoErr           OK
    ippStsNullPtrErr      One of the pointers is NULL
    ippStsSizeErr         roiSize has a field with zero or negative value
    ippStsStepErr         The step value is less than or equal to zero

  Parameters:
    pSrcDst               Pointer to the image
    srcDstStep            Step in bytes through the image
    roiSize               ROI size
    mean                  The mean of the normal distribution
    stdev                 The standard deviation of the normal distribution
    pSeed                 Pointer to the seed value for the pseudo-random number
                             generator
}


 function ippiAddRandGauss_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp8u ; stdev : Ipp8u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp8u ; stdev : Ipp8u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_8u_C4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp8u ; stdev : Ipp8u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp8u ; stdev : Ipp8u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp16s ; stdev : Ipp16s ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp16s ; stdev : Ipp16s ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_16s_C4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp16s ; stdev : Ipp16s ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_16s_AC4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp16s ; stdev : Ipp16s ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp32f ; stdev : Ipp32f ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp32f ; stdev : Ipp32f ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp32f ; stdev : Ipp32f ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_32f_AC4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp32f ; stdev : Ipp32f ; pSeed : Word32Ptr ): IppStatus; _ippapi

 function ippiAddRandGauss_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp16u ; stdev : Ipp16u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp16u ; stdev : Ipp16u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_16u_C4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp16u ; stdev : Ipp16u ; pSeed : Word32Ptr ): IppStatus; _ippapi
 function ippiAddRandGauss_16u_AC4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; mean : Ipp16u ; stdev : Ipp16u ; pSeed : Word32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiImageJaehne
  Purpose:            Creates Jaenne`s test image
  Returns:
    ippStsNoErr       No error
    ippStsNullPtrErr  pDst pointer is NULL
    ippStsSizeErr     roiSize has a field with zero or value : negative ; or
                      srcDstStep has a zero or negative value
  Parameters:
    pDst              Pointer to the destination buffer
    DstStep           Step in bytes through the destination buffer
    roiSize           Size of the destination image ROI in pixels
  Notes:
                      Dst(x,y,) = A*Sin(0.5*IPP_PI* (x2^2 + y2^2) / roiSize.height),
                      x variables from 0 to roi.width-1,
                      y variables from 0 to roi.height-1,
                      x2 = (x-roi.width+1)/2.0 ,   y2 = (y-roi.height+1)/2.0 .
                      A is the constant value depends on the image type being created.
}

 function ippiImageJaehne_8u_C1R( pDst : Ipp8uPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_8u_C3R( pDst : Ipp8uPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_8u_C4R( pDst : Ipp8uPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_8u_AC4R( pDst : Ipp8uPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiImageJaehne_16u_C1R( pDst : Ipp16uPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_16u_C3R( pDst : Ipp16uPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_16u_C4R( pDst : Ipp16uPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_16u_AC4R( pDst : Ipp16uPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiImageJaehne_16s_C1R( pDst : Ipp16sPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_16s_C3R( pDst : Ipp16sPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_16s_C4R( pDst : Ipp16sPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_16s_AC4R( pDst : Ipp16sPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiImageJaehne_32f_C1R( pDst : Ipp32fPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_32f_C3R( pDst : Ipp32fPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_32f_C4R( pDst : Ipp32fPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiImageJaehne_32f_AC4R( pDst : Ipp32fPtr ; DstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:          ippiImageRamp
 Purpose:       Creates an ippi test image with an intensity ramp.
 Parameters:
    pDst        - Pointer to the destination buffer.
    dstStep     - Distance, in bytes,  between the starting points of consecutive lines in the destination image.
    roiSize     - Size, in pixels,  of the destination image ROI.
    offset      - Offset value.
    slope       - Slope coefficient.
    axis        - Specifies the direction of the image intensity ramp,  possible values:
                      ippAxsHorizontal   in X-direction,
                      ippAxsVertical     in Y-direction,
                      ippAxsBoth         in both X and Y-directions.
  Returns:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsStepErr    - Error when dstStep has a zero or negative value.
    ippStsSizeErr    - Error when roiSize has a field with value less than 1.

 Notes:  Dst(x,y) = offset + slope * x   (if ramp for X-direction)
         Dst(x,y) = offset + slope * y   (if ramp for Y-direction)
         Dst(x,y) = offset + slope * x*y (if ramp for X, Y-direction)
}

 function ippiImageRamp_8u_C1R( pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_8u_C3R( pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_8u_C4R( pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_8u_AC4R( pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi

 function ippiImageRamp_16u_C1R( pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_16u_C3R( pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_16u_C4R( pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_16u_AC4R( pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi

 function ippiImageRamp_16s_C1R( pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_16s_C3R( pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_16s_C4R( pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_16s_AC4R( pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi

 function ippiImageRamp_32f_C1R( pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_32f_C3R( pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_32f_C4R( pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi
 function ippiImageRamp_32f_AC4R( pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; offset : float ; slope : float ; axis : IppiAxis ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiConvert

  Purpose:    Converts pixel values of an image from one bit depth to another

  Returns:
    ippStsNullPtrErr      One of the pointers is NULL
    ippStsSizeErr         roiSize has a field with zero or negative value
    ippStsStepErr         srcStep or dstStep has zero or negative value
    ippStsNoErr           OK

  Parameters:
    pSrc                  Pointer  to the source image
    srcStep               Step through the source image
    pDst                  Pointer to the  destination image
    dstStep               Step in bytes through the destination image
    roiSize               Size of the ROI
    roundMode             Rounding mode,  ippRndZero or ippRndNear
}

 function ippiConvert_8u8s_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiConvert_8u16u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u16u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u16u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u16u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u16s_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u16s_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u16s_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_8u32s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u32s_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u32s_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u32s_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u32f_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u32f_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8u32f_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_8s8u_C1Rs( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8s16s_C1R( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8s16u_C1Rs( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8s32u_C1Rs( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp32uPtr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi

 function ippiConvert_8s32s_C1R( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8s32s_C3R( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8s32s_AC4R( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8s32s_C4R( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_8s32f_C1R( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8s32f_C3R( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8s32f_AC4R( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_8s32f_C4R( pSrc : Ipp8sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_16u8u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16u8u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16u8u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16u8u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_16u8s_C1RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiConvert_16u16s_C1RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiConvert_16u32u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32uPtr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi

 function ippiConvert_16u32s_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16u32s_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16u32s_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16u32s_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16u32f_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16u32f_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16u32f_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_16s8s_C1RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiConvert_16s8u_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16s8u_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16s8u_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16s8u_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_16s16u_C1Rs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16s32u_C1Rs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32uPtr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi

 function ippiConvert_16s32s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16s32s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16s32s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16s32s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_16s32f_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16s32f_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16s32f_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_16s32f_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_32u8u_C1RSfs( pSrc : Ipp32uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiConvert_32u8s_C1RSfs( pSrc : Ipp32uPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiConvert_32u16u_C1RSfs( pSrc : Ipp32uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiConvert_32u16s_C1RSfs( pSrc : Ipp32uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiConvert_32u32s_C1RSfs( pSrc : Ipp32uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiConvert_32u32f_C1R( pSrc : Ipp32uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi

 function ippiConvert_32s8u_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_32s8u_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_32s8u_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_32s8u_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_32s8s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_32s8s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_32s8s_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiConvert_32s8s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiConvert_32s16u_C1RSfs( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiConvert_32s16s_C1RSfs( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiConvert_32s32u_C1Rs( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32uPtr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi
 function ippiConvert_32s32f_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roi : IppiSize ): IppStatus; _ippapi

 function ippiConvert_32f8u_C1RSfs( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roi : IppiSize ; round : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiConvert_32f8u_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f8u_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f8u_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f8u_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi

 function ippiConvert_32f8s_C1RSfs( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roi : IppiSize ; round : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiConvert_32f8s_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f8s_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f8s_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f8s_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8sPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi

 function ippiConvert_32f16u_C1RSfs( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roi : IppiSize ; round : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiConvert_32f16u_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f16u_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f16u_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f16u_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi

 function ippiConvert_32f16s_C1RSfs( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roi : IppiSize ; round : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiConvert_32f16s_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f16s_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f16s_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi
 function ippiConvert_32f16s_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; roundMode : IppRoundMode ): IppStatus; _ippapi

 function ippiConvert_32f32u_C1RSfs( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32uPtr ; dstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiConvert_32f32u_C1IRSfs( pSrcDst : Ipp32uPtr ; srcDstStep : Int32 ; roi : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippiConvert_32f32s_C1RSfs( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roi : IppiSize ; round : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:       ippiBinToGray_1u(8u|16u|16s|32f)_C1R,
             ippiGrayToBin_(8u|16u|16s|32f)1u_C1R
 Purpose:    Converts a bitonal image to an 8u, 16u,16s, or 32f grayscale image and vice versa.

 Parameters:
    pSrc         - Pointer to the source image ROI.
    srcStep      - Distance, in bytes,  between the starting points of consecutive lines in the source image.
    srcBitOffset - Offset (in bits) from the first byte of the source image row.
    pDst         - Pointer to the destination image ROI.
    dstStep      - Distance, in bytes,  between the starting points of consecutive lines in the destination image.
    dstBitOffset - Offset (in bits) from the first byte of the destination image row.
    roiSize      - Size of the ROI.
    loVal        - Destination value that corresponds to the "0" value of the corresponding source element.
    hiVal        - Destination value that corresponds to the "1" value of the corresponding source element.
    threahold    - Threshold level.
 Returns:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when :
                         roiSize has a zero or negative value.
                         srcBitOffset or dstBitOffset is less than zero.
    ippStsStepErr    - Error when srcStep or dstStep has a zero or negative value.
}

 function ippiBinToGray_1u8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcBitOffset : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; loVal : Ipp8u ; hiVal : Ipp8u ): IppStatus; _ippapi
 function ippiBinToGray_1u16u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcBitOffset : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; loVal : Ipp16u ; hiVal : Ipp16u ): IppStatus; _ippapi
 function ippiBinToGray_1u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcBitOffset : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; loVal : Ipp16s ; hiVal : Ipp16s ): IppStatus; _ippapi
 function ippiBinToGray_1u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcBitOffset : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; loVal : Ipp32f ; hiVal : Ipp32f ): IppStatus; _ippapi

 function ippiGrayToBin_8u1u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; threshold : Ipp8u ): IppStatus; _ippapi
 function ippiGrayToBin_16u1u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; threshold : Ipp16u ): IppStatus; _ippapi
 function ippiGrayToBin_16s1u_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; threshold : Ipp16s ): IppStatus; _ippapi
 function ippiGrayToBin_32f1u_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstBitOffset : Int32 ; roiSize : IppiSize ; threshold : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:            ippiPolarToCart

  Purpose:     Converts an image in the polar coordinate form to Cartesian
               coordinate form
  Parameters:
   pSrcMagn            Pointer to the source image plane containing magnitudes
   pSrcPhase           Pointer to the source image plane containing phase values
   srcStep             Step through the source image
   pDst                Pointer to the destination image
   dstStep             Step through the destination image
   roiSize             Size of the ROI
  Return:
   ippStsNullPtrErr    One of the pointers is NULL
   ippStsSizeErr       height or width of the image is less than 1
   ippStsStepErr,      if srcStep <= 0 or
                          dstStep <= 0
   ippStsNoErr         No errors
}

 function ippiPolarToCart_32fc_C1R( pSrcMagn : Ipp32fPtr ; pSrcPhase : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pDst : Ipp32fcPtr ; dstStep : Int32 ): IppStatus; _ippapi
 function ippiPolarToCart_32fc_C3R( pSrcMagn : Ipp32fPtr ; pSrcPhase : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pDst : Ipp32fcPtr ; dstStep : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiSwapChannels

  Purpose:    Changes the order of channels of the image
              The function performs operation for each pixel:
                  pDst[0] = pSrc[ dstOrder[0] ]
                  pDst[1] = pSrc[ dstOrder[1] ]
                  pDst[2] = pSrc[ dstOrder[2] ]
                  pDst[3] = pSrc[ dstOrder[3] ]

  Returns:
    ippStsNullPtrErr      One of the pointers is NULL
    ippStsSizeErr         roiSize has a field with zero or negative value
    ippStsStepErr         One of the step values is less than or equal to zero
    ippStsChannelOrderErr dstOrder is out of the range, 
                           it should be: dstOrder[3] = ( 0..2, 0..2, 0..2 ) for C3R,  AC4R image
                           and dstOrder[4] = ( 0..3, 0..3, 0..3 ) for C4R image
    ippStsNoErr           OK

  Parameters:
    pSrc           Pointer  to the source image
    srcStep        Step in bytes through the source image
    pDst           Pointer to the  destination image
    dstStep        Step in bytes through the destination image
    pSrcDst        Pointer to the source/destination image (in-place flavors)
    srcDstStep     Step through the source/destination image (in-place flavors)
    roiSize        Size of the ROI
    dstOrder       The order of channels in the destination image
}

 function ippiSwapChannels_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_4 ): IppStatus; _ippapi
 function ippiSwapChannels_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_4 ): IppStatus; _ippapi
 function ippiSwapChannels_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_4 ): IppStatus; _ippapi
 function ippiSwapChannels_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_32s_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_4 ): IppStatus; _ippapi
 function ippiSwapChannels_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_4 ): IppStatus; _ippapi

 function ippiSwapChannels_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_8u_C4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiSwapChannels C3C4R, C4C3R

  Purpose:    Changes the order of channels of the image
              The function performs operation for each pixel:
  a) C3C4R.
    if(dstOrder[i] < 3) dst[i] = src[dstOrder[i]];
    if(dstOrder[i] == 3) dst[i] = val;
    if(dstOrder[i] > 3) dst[i] does not change;
    i = 0,1,2,3
  b) C4C3R.
    dst[0] = src [dstOrder[0]];
    dst[1] = src [dstOrder[1]];
    dst[2] = src [dstOrder[2]];

  Returns:
    ippStsNullPtrErr      One of the pointers is NULL
    ippStsSizeErr         roiSize has a field with zero or negative value
    ippStsChannelOrderErr dstOrder is out of the range,  it should be:
                            a) C3C4R.
                              dstOrder[i] => 0, i = 0,1,2,3.
                            b) C4C3R.
                              0 <= dstOrder[i] <= 3, i = 0,1,2.
    ippStsNoErr     OK

  Parameters:
    pSrc           Pointer  to the source image
    srcStep        Step in bytes through the source image
    pDst           Pointer to the  destination image
    dstStep        Step in bytes through the destination image
    roiSize        Size of the ROI
    dstOrder       The order of channels in the destination image
    val            Constant value for C3C4R
}

 function ippiSwapChannels_8u_C3C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_4 ; val : Ipp8u ): IppStatus; _ippapi
 function ippiSwapChannels_8u_C4C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_16s_C3C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_4 ; val : Ipp16s ): IppStatus; _ippapi
 function ippiSwapChannels_16s_C4C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_16u_C3C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_4 ; val : Ipp16u ): IppStatus; _ippapi
 function ippiSwapChannels_16u_C4C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_32s_C3C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_4 ; val : Ipp32s ): IppStatus; _ippapi
 function ippiSwapChannels_32s_C4C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi
 function ippiSwapChannels_32f_C3C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_4 ; val : Ipp32f ): IppStatus; _ippapi
 function ippiSwapChannels_32f_C4C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; const dstOrder : Int32_3 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiScale

  Purpose:   Scales pixel values of an image and converts them to another bit depth
              dst = a + b * src;
              a = type_min_dst - b * type_min_src;
              b = (type_max_dst - type_min_dst) / (type_max_src - type_min_src).

  Returns:
    ippStsNullPtrErr      One of the pointers is NULL
    ippStsSizeErr         roiSize has a field with zero or negative value
    ippStsStepErr         One of the step values is less than or equal to zero
    ippStsScaleRangeErr   Input data bounds are incorrect (vMax - vMin <= 0)
    ippStsNoErr           OK

  Parameters:
    pSrc            Pointer  to the source image
    srcStep         Step through the source image
    pDst            Pointer to the  destination image
    dstStep         Step through the destination image
    roiSize         Size of the ROI
    vMin, vMax      Minimum and maximum values of the input data (32f).
    hint            Option to select the algorithmic implementation:
                        1). hint == ippAlgHintAccurate
                                  - accuracy e-8, but slowly;
                        2). hint == ippAlgHintFast,
                                 or ippAlgHintNone
                                  - accuracy e-3, but quickly.
}

 function ippiScale_8u16u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiScale_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiScale_8u32s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiScale_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiScale_8u16u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiScale_8u16s_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiScale_8u32s_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiScale_8u32f_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiScale_8u16u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiScale_8u16s_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiScale_8u32s_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiScale_8u32f_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiScale_8u16u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiScale_8u16s_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiScale_8u32s_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiScale_8u32f_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiScale_16u8u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_16s8u_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_32s8u_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_32f8u_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiScale_16u8u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_16s8u_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_32s8u_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_32f8u_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiScale_16u8u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_16s8u_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_32s8u_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_32f8u_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi
 function ippiScale_16u8u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_16s8u_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_32s8u_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippiScale_32f8u_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; vMin : Ipp32f ; vMax : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiMin
  Purpose:        computes the minimum of image pixel values
  Returns:        IppStatus
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value
  Parameters:
    pSrc        Pointer to the source image.
    srcStep     Step through the source image
    roiSize     Size of the source image ROI.
    pMin        Pointer to the result (C1)
    min         Array containing results (C3, AC4, C4)
}

 function ippiMin_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMin : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMin_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp8u_3 ): IppStatus; _ippapi
 function ippiMin_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp8u_3 ): IppStatus; _ippapi
 function ippiMin_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp8u_4 ): IppStatus; _ippapi

 function ippiMin_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMin : Ipp16sPtr ): IppStatus; _ippapi
 function ippiMin_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16s_3 ): IppStatus; _ippapi
 function ippiMin_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16s_3 ): IppStatus; _ippapi
 function ippiMin_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16s_4 ): IppStatus; _ippapi

 function ippiMin_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMin : Ipp16uPtr ): IppStatus; _ippapi
 function ippiMin_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16u_3 ): IppStatus; _ippapi
 function ippiMin_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16u_3 ): IppStatus; _ippapi
 function ippiMin_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16u_4 ): IppStatus; _ippapi

 function ippiMin_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMin : Ipp32fPtr ): IppStatus; _ippapi
 function ippiMin_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp32f_3 ): IppStatus; _ippapi
 function ippiMin_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp32f_3 ): IppStatus; _ippapi
 function ippiMin_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp32f_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiMinIndx
  Purpose:        computes the minimum of image pixel values and retrieves
                  the x and y coordinates of pixels with this value
  Returns:        IppStatus
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value
  Parameters:
    pSrc        Pointer to the source image.
    srcStep     Step in bytes through the source image
    roiSize     Size of the source image ROI.
    pMin        Pointer to the result (C1)
    min         Array of the results (C3, AC4, C4)
    pIndexX     Pointer to the x coordinate of the pixel with min value (C1)
    pIndexY     Pointer to the y coordinate of the pixel with min value (C1)
    indexX      Array containing the x coordinates of the pixel with min value (C3, AC4, C4)
    indexY      Array containing the y coordinates of the pixel with min value (C3, AC4, C4)
}

 function ippiMinIndx_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMin : Ipp8uPtr ; pIndexX : Int32Ptr ; pIndexY : Int32Ptr ): IppStatus; _ippapi
 function ippiMinIndx_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp8u_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMinIndx_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp8u_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMinIndx_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp8u_4 ; indexX : Int32_4 ; indexY : Int32_4 ): IppStatus; _ippapi

 function ippiMinIndx_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMin : Ipp16sPtr ; pIndexX : Int32Ptr ; pIndexY : Int32Ptr ): IppStatus; _ippapi
 function ippiMinIndx_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16s_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMinIndx_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16s_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMinIndx_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16s_4 ; indexX : Int32_4 ; indexY : Int32_4 ): IppStatus; _ippapi

 function ippiMinIndx_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMin : Ipp16uPtr ; pIndexX : Int32Ptr ; pIndexY : Int32Ptr ): IppStatus; _ippapi
 function ippiMinIndx_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16u_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMinIndx_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16u_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMinIndx_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp16u_4 ; indexX : Int32_4 ; indexY : Int32_4 ): IppStatus; _ippapi

 function ippiMinIndx_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMin : Ipp32fPtr ; pIndexX : Int32Ptr ; pIndexY : Int32Ptr ): IppStatus; _ippapi
 function ippiMinIndx_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp32f_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMinIndx_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp32f_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMinIndx_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; min : Ipp32f_4 ; indexX : Int32_4 ; indexY : Int32_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiMax
  Purpose:        computes the maximum of image pixel values
  Returns:        IppStatus
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value
  Parameters:
    pSrc        Pointer to the source image.
    srcStep     Step in bytes through the source image
    roiSize     Size of the source image ROI.
    pMax        Pointer to the result (C1)
    max         Array containing the results (C3, AC4, C4)
}

 function ippiMax_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMax : Ipp8uPtr ): IppStatus; _ippapi
 function ippiMax_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp8u_3 ): IppStatus; _ippapi
 function ippiMax_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp8u_3 ): IppStatus; _ippapi
 function ippiMax_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp8u_4 ): IppStatus; _ippapi

 function ippiMax_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMax : Ipp16sPtr ): IppStatus; _ippapi
 function ippiMax_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16s_3 ): IppStatus; _ippapi
 function ippiMax_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16s_3 ): IppStatus; _ippapi
 function ippiMax_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16s_4 ): IppStatus; _ippapi

 function ippiMax_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMax : Ipp16uPtr ): IppStatus; _ippapi
 function ippiMax_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16u_3 ): IppStatus; _ippapi
 function ippiMax_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16u_3 ): IppStatus; _ippapi
 function ippiMax_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16u_4 ): IppStatus; _ippapi

 function ippiMax_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMax : Ipp32fPtr ): IppStatus; _ippapi
 function ippiMax_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp32f_3 ): IppStatus; _ippapi
 function ippiMax_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp32f_3 ): IppStatus; _ippapi
 function ippiMax_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp32f_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiMaxIndx
  Purpose:        computes the maximum of image pixel values and retrieves
                  the x and y coordinates of pixels with this value
  Returns:        IppStatus
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value
  Parameters:
    pSrc        Pointer to the source image.
    srcStep     Step in bytes through the source image
    roiSize     Size of the source image ROI.
    pMax        Pointer to the result (C1)
    max         Array of the results (C3, AC4, C4)
    pIndexX     Pointer to the x coordinate of the pixel with max value (C1)
    pIndexY     Pointer to the y coordinate of the pixel with max value (C1)
    indexX      Array containing the x coordinates of the pixel with max value (C3, AC4, C4)
    indexY      Array containing the y coordinates of the pixel with max value (C3, AC4, C4)
}

 function ippiMaxIndx_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMax : Ipp8uPtr ; pIndexX : Int32Ptr ; pIndexY : Int32Ptr ): IppStatus; _ippapi
 function ippiMaxIndx_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp8u_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMaxIndx_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp8u_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMaxIndx_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp8u_4 ; indexX : Int32_4 ; indexY : Int32_4 ): IppStatus; _ippapi

 function ippiMaxIndx_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMax : Ipp16sPtr ; pIndexX : Int32Ptr ; pIndexY : Int32Ptr ): IppStatus; _ippapi
 function ippiMaxIndx_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16s_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMaxIndx_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16s_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMaxIndx_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16s_4 ; indexX : Int32_4 ; indexY : Int32_4 ): IppStatus; _ippapi

 function ippiMaxIndx_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMax : Ipp16uPtr ; pIndexX : Int32Ptr ; pIndexY : Int32Ptr ): IppStatus; _ippapi
 function ippiMaxIndx_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16u_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMaxIndx_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16u_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMaxIndx_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp16u_4 ; indexX : Int32_4 ; indexY : Int32_4 ): IppStatus; _ippapi

 function ippiMaxIndx_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pMax : Ipp32fPtr ; pIndexX : Int32Ptr ; pIndexY : Int32Ptr ): IppStatus; _ippapi
 function ippiMaxIndx_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp32f_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMaxIndx_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp32f_3 ; indexX : Int32_3 ; indexY : Int32_3 ): IppStatus; _ippapi
 function ippiMaxIndx_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; max : Ipp32f_4 ; indexX : Int32_4 ; indexY : Int32_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippiMinMax
  Purpose:        computes the minimum and maximum of image pixel value
  Returns:        IppStatus
    ippStsNoErr        OK
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsSizeErr      roiSize has a field with zero or negative value
  Parameters:
    pSrc        Pointer to the source image
    srcStep     Step in bytes through the source image
    roiSize     Size of the source image ROI.
    pMin, pMax  Pointers to the results (C1)
    min, max    Arrays containing the results (C3, AC4, C4)
}

 function ippiMinMax_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; var pMin : Ipp8u ; var pMax : Ipp8u ): IppStatus; _ippapi
 function ippiMinMax_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp8u_3 ; var max : Ipp8u_3 ): IppStatus; _ippapi
 function ippiMinMax_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp8u_3 ; var max : Ipp8u_3 ): IppStatus; _ippapi
 function ippiMinMax_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp8u_4 ; var max : Ipp8u_4 ): IppStatus; _ippapi

 function ippiMinMax_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; var pMin : Ipp16s ; var pMax : Ipp16s ): IppStatus; _ippapi
 function ippiMinMax_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp16s_3 ; var max : Ipp16s_3 ): IppStatus; _ippapi
 function ippiMinMax_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp16s_3 ; var max : Ipp16s_3 ): IppStatus; _ippapi
 function ippiMinMax_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp16s_4 ; var max : Ipp16s_4 ): IppStatus; _ippapi

 function ippiMinMax_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; var pMin : Ipp16u ; var pMax : Ipp16u ): IppStatus; _ippapi
 function ippiMinMax_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp16u_3 ; var max : Ipp16u_3 ): IppStatus; _ippapi
 function ippiMinMax_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp16u_3 ; var max : Ipp16u_3 ): IppStatus; _ippapi
 function ippiMinMax_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp16u_4 ; var max : Ipp16u_4 ): IppStatus; _ippapi

 function ippiMinMax_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; var pMin : Ipp32f ; var pMax : Ipp32f ): IppStatus; _ippapi
 function ippiMinMax_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp32f_3 ; var max : Ipp32f_3 ): IppStatus; _ippapi
 function ippiMinMax_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp32f_3 ; var max : Ipp32f_3 ): IppStatus; _ippapi
 function ippiMinMax_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; var min : Ipp32f_4 ; var max : Ipp32f_4 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiBlockMinMax_32f_C1R, ippiBlockMinMax_16s_C1R,
              ippiBlockMinMax_16u_C1R, ippiBlockMinMax_8u_C1R .

  Purpose:    Finds minimum and maximum values for blocks of the source image.

  Parameters:
    pSrc                Pointer to the source image ROI.
    srcStep             Distance, in bytes,  between the starting points of consecutive lines in the source image.
    srcSize             Size, in pixels,  of the source image.
    pDstMin             Pointer to the destination image to store minimum values per block.
    dstMinStep          Distance, in bytes,  between the starting points of consecutive lines in the pDstMin image.
    pDstMax             Pointer to the destination image to store maximum values per block.
    dstMaxStep          Distance, in bytes,  between the starting points of consecutive lines in the pDstMax image.
    blockSize           Size, in pixels,  of the block.
    pDstGlobalMin       The destination pointer to store minimum value for the entire source image.
    pDstGlobalMax       The destination pointer to store maximum value for the entire source image.
  Returns:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsStepErr    - Error when :
                         srcStep is less than srcSize.width * sizeof( *pSrc).
                         dstMinStep, or dstMaxStep is less than dstSize.width * sizeof( *pDst).
    ippStsSizeErr    - Error when srcSize or blockSize has a zero or negative value.
}

 function ippiBlockMinMax_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcSize : IppiSize ; pDstMin : Ipp32fPtr ; dstMinStep : Int32 ; pDstMax : Ipp32fPtr ; dstMaxStep : Int32 ; blockSize : IppiSize ; pDstGlobalMin : Ipp32fPtr ; pDstGlobalMax : Ipp32fPtr ): IppStatus; _ippapi
 function ippiBlockMinMax_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcSize : IppiSize ; pDstMin : Ipp16sPtr ; dstMinStep : Int32 ; pDstMax : Ipp16sPtr ; dstMaxStep : Int32 ; blockSize : IppiSize ; pDstGlobalMin : Ipp16sPtr ; pDstGlobalMax : Ipp16sPtr ): IppStatus; _ippapi
 function ippiBlockMinMax_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcSize : IppiSize ; pDstMin : Ipp16uPtr ; dstMinStep : Int32 ; pDstMax : Ipp16uPtr ; dstMaxStep : Int32 ; blockSize : IppiSize ; pDstGlobalMin : Ipp16uPtr ; pDstGlobalMax : Ipp16uPtr ): IppStatus; _ippapi
 function ippiBlockMinMax_8u_C1R ( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcSize : IppiSize ; pDstMin : Ipp8uPtr ; dstMinStep : Int32 ; pDstMax : Ipp8uPtr ; dstMaxStep : Int32 ; blockSize : IppiSize ; pDstGlobalMin : Ipp8uPtr ; pDstGlobalMax : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:              ippiMinEvery, ippiMaxEvery
  Purpose:            calculation min/max value for every element of two images
  Parameters:
   pSrc               pointer to input image
   pSrcDst            pointer to input/output image
    srcStep           Step in bytes through the source image
    roiSize           Size of the source image ROI.
  Return:
   ippStsNullPtrErr   pointer(s) to the data is NULL
   ippStsSizeErr      roiSize has a field with zero or negative value
   ippStsNoErr        otherwise
}

 function ippiMaxEvery_8u_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_8u_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_16s_C1IR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_16s_C1IR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_16u_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_16u_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_32f_C1IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiMaxEvery_8u_C3IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_8u_C3IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_16s_C3IR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_16s_C3IR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_16u_C3IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_16u_C3IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_32f_C3IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_32f_C3IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiMaxEvery_8u_C4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_8u_C4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_16s_C4IR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_16s_C4IR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_16u_C4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_16u_C4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_32f_C4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_32f_C4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiMaxEvery_8u_AC4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_8u_AC4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_16s_AC4IR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_16s_AC4IR( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_16u_AC4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_16u_AC4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_32f_AC4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_32f_AC4IR( pSrc : Ipp32fPtr ; srcStep : Int32 ; pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMinEvery_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiMaxEvery_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                      Logical Operations and Shift Functions
---------------------------------------------------------------------------- }
{
  Names:          ippiAnd, ippiAndC, ippiOr, ippiOrC, ippiXor, ippiXorC, ippiNot,
  Purpose:        Performs corresponding bitwise logical operation between pixels of two image
                  (AndC/OrC/XorC  - between pixel of the source image and a constant)

  Names:          ippiLShiftC, ippiRShiftC
  Purpose:        Shifts bits in each pixel value to the left and right
  Parameters:
   value         1) The constant value to be ANDed/ORed/XORed with each pixel of the source, 
                     constant vector for multi-channel images;
                 2) The number of bits to shift,  constant vector for multi-channel images.
   pSrc          Pointer to the source image
   srcStep       Step through the source image
   pSrcDst       Pointer to the source/destination image (in-place flavors)
   srcDstStep    Step through the source/destination image (in-place flavors)
   pSrc1         Pointer to first source image
   src1Step      Step through first source image
   pSrc2         Pointer to second source image
   src2Step      Step through second source image
   pDst          Pointer to the destination image
   dstStep       Step in destination image
   roiSize       Size of the ROI

  Returns:
   ippStsNullPtrErr   One of the pointers is NULL
   ippStsStepErr      One of the step values is less than or equal to zero
   ippStsSizeErr      roiSize has a field with zero or negative value
   ippStsShiftErr     Shift`s value is less than zero
   ippStsNoErr        No errors
}

 function ippiAnd_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_8u_AC4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_8u_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_8u_C3IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_8u_C4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_8u_AC4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_8u_C1IR( value : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_8u_C3IR(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_8u_C4IR(const value : Ipp8u_4 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_8u_AC4IR(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_16u_AC4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_16u_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_16u_C3IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_16u_C4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_16u_AC4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_16u_C1IR( value : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_16u_C3IR(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_16u_C4IR(const value : Ipp16u_4 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_16u_AC4IR(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_32s_C1R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_32s_C3R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_32s_C4R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_32s_AC4R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_32s_C1IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_32s_C3IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_32s_C4IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAnd_32s_AC4IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; value : Ipp32s ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; const value : Ipp32s_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; const value : Ipp32s_4 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_32s_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; const value : Ipp32s_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_32s_C1IR( value : Ipp32s ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_32s_C3IR(const value : Ipp32s_3 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_32s_C4IR(const value : Ipp32s_4 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiAndC_32s_AC4IR(const value : Ipp32s_3 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiOr_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_8u_AC4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_8u_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_8u_C3IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_8u_C4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_8u_AC4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_8u_C1IR( value : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_8u_C3IR(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_8u_C4IR(const value : Ipp8u_4 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_8u_AC4IR(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_16u_AC4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_16u_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_16u_C3IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_16u_C4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_16u_AC4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_16u_C1IR( value : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_16u_C3IR(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_16u_C4IR(const value : Ipp16u_4 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_16u_AC4IR(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_32s_C1R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_32s_C3R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_32s_C4R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_32s_AC4R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_32s_C1IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_32s_C3IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_32s_C4IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOr_32s_AC4IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; value : Ipp32s ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; const value : Ipp32s_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; const value : Ipp32s_4 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_32s_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; const value : Ipp32s_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_32s_C1IR( value : Ipp32s ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_32s_C3IR(const value : Ipp32s_3 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_32s_C4IR(const value : Ipp32s_4 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiOrC_32s_AC4IR(const value : Ipp32s_3 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiXor_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_8u_AC4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_8u_C1IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_8u_C3IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_8u_C4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_8u_AC4IR( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_8u_C1IR( value : Ipp8u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_8u_C3IR(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_8u_C4IR(const value : Ipp8u_4 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_8u_AC4IR(const value : Ipp8u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_16u_AC4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_16u_C1IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_16u_C3IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_16u_C4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_16u_AC4IR( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp16u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_16u_C1IR( value : Ipp16u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_16u_C3IR(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_16u_C4IR(const value : Ipp16u_4 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_16u_AC4IR(const value : Ipp16u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_32s_C1R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_32s_C3R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_32s_C4R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_32s_AC4R( pSrc1 : Ipp32sPtr ; src1Step : Int32 ; pSrc2 : Ipp32sPtr ; src2Step : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_32s_C1IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_32s_C3IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_32s_C4IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXor_32s_AC4IR( pSrc : Ipp32sPtr ; srcStep : Int32 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; value : Ipp32s ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; const value : Ipp32s_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; const value : Ipp32s_4 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_32s_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; const value : Ipp32s_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_32s_C1IR( value : Ipp32s ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_32s_C3IR(const value : Ipp32s_3 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_32s_C4IR(const value : Ipp32s_4 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiXorC_32s_AC4IR(const value : Ipp32s_3 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiNot_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiNot_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiNot_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiNot_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiNot_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiNot_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiNot_8u_C4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiNot_8u_AC4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiLShiftC_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp32u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp32u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_8u_C1IR( value : Ipp32u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_8u_C3IR( value : Ipp32u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_8u_C4IR( value : Ipp32u_4 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_8u_AC4IR( value : Ipp32u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp32u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp32u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_16u_C1IR( value : Ipp32u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_16u_C3IR( value : Ipp32u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_16u_C4IR( value : Ipp32u_4 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_16u_AC4IR( value : Ipp32u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; value : Ipp32u ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; value : Ipp32u_4 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_32s_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_32s_C1IR( value : Ipp32u ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_32s_C3IR( value : Ipp32u_3 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_32s_C4IR( value : Ipp32u_4 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiLShiftC_32s_AC4IR( value : Ipp32u_3 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiRShiftC_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp32u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp32u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_8u_C1IR( value : Ipp32u ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_8u_C3IR( value : Ipp32u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_8u_C4IR( value : Ipp32u_4 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_8u_AC4IR( value : Ipp32u_3 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp32u ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp32u_4 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16u_C1IR( value : Ipp32u ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16u_C3IR( value : Ipp32u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16u_C4IR( value : Ipp32u_4 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16u_AC4IR( value : Ipp32u_3 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; value : Ipp32u ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; value : Ipp32u_4 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16s_C1IR( value : Ipp32u ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16s_C3IR( value : Ipp32u_3 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16s_C4IR( value : Ipp32u_4 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_16s_AC4IR( value : Ipp32u_3 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; value : Ipp32u ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; value : Ipp32u_4 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_32s_AC4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; value : Ipp32u_3 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_32s_C1IR( value : Ipp32u ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_32s_C3IR( value : Ipp32u_3 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_32s_C4IR( value : Ipp32u_4 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRShiftC_32s_AC4IR( value : Ipp32u_3 ; pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                              Compare Operations
{ ----------------------------------------------------------------------------


  Name:           ippiCompare
                  ippiCompareC
  Purpose:  Compares pixel values of two images,  or pixel values of an image to a constant
            value using the following compare conditions: <, <=, ==, >, >= ;
  Names:          ippiCompareEqualEps
                  ippiCompareEqualEpsC
  Purpose:  Compares 32f images for being equal,  or equal to a given value within given tolerance
  Context:

  Returns:        IppStatus
    ippStsNoErr        No errors
    ippStsNullPtrErr   One of the pointers is NULL
    ippStsStepErr      One of the step values is less than or equal to zero
    ippStsSizeErr      roiSize has a field with zero or negative value
    ippStsEpsValErr    eps is negative

  Parameters:
    pSrc1         Pointer to the first source image;
    src1Step      Step through the first source image;
    pSrc2         Pointer to the second source image data;
    src2Step      Step through the second source image;
    pDst          Pointer to destination image data;
    dstStep       Step in destination image;
    roiSize       Size of the ROI;
    ippCmpOp      Compare operation to be used
    value         Value (array of values for multi-channel image) to compare
                  each pixel to
    eps           The tolerance value

  Notes:
}

 function ippiCompare_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_8u_AC4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi

 function ippiCompareC_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; value : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_8u_AC4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; const value : Ipp8u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi

 function ippiCompare_16s_C1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_16s_C3R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_16s_AC4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_16s_C4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi

 function ippiCompareC_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; value : Ipp16s ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_16s_AC4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; const value : Ipp16s_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi

 function ippiCompare_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_16u_AC4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi

 function ippiCompareC_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; value : Ipp16u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_16u_AC4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; const value : Ipp16u_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi

 function ippiCompare_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_32f_AC4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompare_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi

 function ippiCompareC_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; value : Ipp32f ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi
 function ippiCompareC_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; ippCmpOp : IppCmpOp ): IppStatus; _ippapi

 function ippiCompareEqualEps_32f_C1R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; eps : Ipp32f ): IppStatus; _ippapi
 function ippiCompareEqualEps_32f_C3R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; eps : Ipp32f ): IppStatus; _ippapi
 function ippiCompareEqualEps_32f_AC4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; eps : Ipp32f ): IppStatus; _ippapi
 function ippiCompareEqualEps_32f_C4R( pSrc1 : Ipp32fPtr ; src1Step : Int32 ; pSrc2 : Ipp32fPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; eps : Ipp32f ): IppStatus; _ippapi

 function ippiCompareEqualEpsC_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; value : Ipp32f ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; eps : Ipp32f ): IppStatus; _ippapi
 function ippiCompareEqualEpsC_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; eps : Ipp32f ): IppStatus; _ippapi
 function ippiCompareEqualEpsC_32f_AC4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_3 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; eps : Ipp32f ): IppStatus; _ippapi
 function ippiCompareEqualEpsC_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; const value : Ipp32f_4 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; eps : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                 Morphological Operations
{ ----------------------------------------------------------------------------


  Name:      ippiErode3x3_8u_C1R()    ippiDilate3x3_8u_C1R()
             ippiErode3x3_8u_C3R()    ippiDilate3x3_8u_C3R()
             ippiErode3x3_8u_AC4R()   ippiDilate3x3_8u_AC4R()
             ippiErode3x3_8u_C4R()    ippiDilate3x3_8u_C4R()

             ippiErode3x3_32f_C1R()   ippiDilate3x3_32f_C1R()
             ippiErode3x3_32f_C3R()   ippiDilate3x3_32f_C3R()
             ippiErode3x3_32f_AC4R()  ippiDilate3x3_32f_AC4R()
             ippiErode3x3_32f_C4R()   ippiDilate3x3_32f_C4R()

  Purpose:   Performs not in-place erosion/dilation using a 3x3 mask

  Returns:
    ippStsNullPtrErr   pSrc == NULL or pDst == NULL
    ippStsStepErr      srcStep <= 0 or dstStep <= 0
    ippStsSizeErr      roiSize has a field with zero or negative value
    ippStsStrideErr    (2+roiSize.width)*nChannels*sizeof(item) > srcStep or
                       (2+roiSize.width)*nChannels*sizeof(item) > dstStep
    ippStsNoErr        No errors

  Parameters:
    pSrc          Pointer to the source image ROI
    srcStep       Step (bytes) through the source image
    pDst          Pointer to the destination image ROI
    dstStep       Step (bytes) through the destination image
    roiSize       Size of the ROI
}

 function ippiErode3x3_64f_C1R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiDilate3x3_64f_C1R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:
    ippiZigzagInv8x8_16s_C1
    ippiZigzagFwd8x8_16s_C1

  Purpose:
    Converts a natural order  to zigzag in an 8x8 block (forward function),
    converts a zigzag order to natural  in a 8x8 block (inverse function)

  Parameter:
    pSrc   Pointer to the source block
    pDst   Pointer to the destination block

  Returns:
    ippStsNoErr      No errors
    ippStsNullPtrErr One of the pointers is NULL
}

 function ippiZigzagInv8x8_16s_C1( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ): IppStatus; _ippapi
 function ippiZigzagFwd8x8_16s_C1( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                         Windowing functions

  Note: to obtain the window coefficients you have apply the corresponding
        function to the image with all pixel values set to 1 (this image can
        created : be ; example : for ; calling function ippiSet(1,x,n))
{ ----------------------------------------------------------------------------


 Names:         ippiWinBartlett, ippiWinBartlettSep
 Purpose:       Applies Bartlett windowing function to an image.
 Parameters:
    pSrc        - Pointer to the source image.
    srcStep     - Distances, in bytes,  between the starting points of consecutive lines in the source images.
    pDst        - Pointer to the destination image.
    dstStep     - Distance, in bytes,  between the starting points of consecutive lines in the destination image.
    pSrcDst     - Pointer to the source/destination image (in-place flavors).
    srcDstStep  - Distance, in bytes,  between the starting points of consecutive lines in the source/destination image (in-place flavors).
    roiSize     - Size, in pixels,  of the ROI.
    pBuffer     - Pointer to the buffer for internal calculations. Size of the buffer is calculated by ippiWinBartlett(Sep)GetBufferSize.
  Returns:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when roiSize has a field with value less than 3.
    ippStsStepErr    - Error when srcStep,  dstStep, or srcDstStep has a zero or negative value.
}

 function ippiWinBartlett_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinBartlett_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinBartlett_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiWinBartlett_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinBartlett_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinBartlett_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiWinBartlettSep_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinBartlettSep_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinBartlettSep_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiWinBartlettSep_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinBartlettSep_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinBartlettSep_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:      ippiWinBartlettGetSize, ippiWinBartlettSepGetSize

 Purpose:    Get the size (in bytes) of the buffer for ippiWinBartlett(Sep) internal calculations.

 Parameters:
    dataType    - Data type for windowing function. Possible values are ipp32f,  ipp16u, or ipp8u.
    roiSize     - Size, in pixels,  of the ROI.
    pSize       - Pointer to the calculated buffer size (in bytes).

 Return:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - Error when pSize pointer is NULL.
    ippStsSizeErr     - Error when roiSize has a field with value less than 3.
    ippStsDataTypeErr - Error when the dataType value differs from the ipp32f,  ipp16u, or ipp8u.
}

 function ippiWinBartlettGetBufferSize( dataType : IppDataType ; roiSize : IppiSize ; var pSize : Int32 ): IppStatus; _ippapi
 function ippiWinBartlettSepGetBufferSize( dataType : IppDataType ; roiSize : IppiSize ; var pSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:         ippiWinHamming, ippiWinHammingSep
 Purpose:       Applies Hamming window function to the image.
 Parameters:
    pSrc        - Pointer to the source image.
    srcStep     - Distances, in bytes,  between the starting points of consecutive lines in the source images.
    pDst        - Pointer to the destination image.
    dstStep     - Distance, in bytes,  between the starting points of consecutive lines in the destination image.
    pSrcDst     - Pointer to the source/destination image (in-place flavors).
    srcDstStep  - Distance, in bytes,  between the starting points of consecutive lines in the source/destination image (in-place flavors).
    roiSize     - Size, in pixels,  of the ROI.
    pBuffer     - Pointer to the buffer for internal calculations. Size of the buffer is calculated by ippiWinHamming(Sep)GetBufferSize.
  Returns:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when roiSize has a field with value less than 3.
    ippStsStepErr    - Error when srcStep,  dstStep, or srcDstStep has a zero or negative value.
}

 function ippiWinHamming_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinHamming_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinHamming_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiWinHamming_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinHamming_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinHamming_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiWinHammingSep_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinHammingSep_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinHammingSep_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiWinHammingSep_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinHammingSep_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiWinHammingSep_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:      ippiWinHammingGetBufferSize, ippiWinHammingSepGetBufferSize

 Purpose:    Get the size (in bytes) of the buffer for ippiWinHamming(Sep) internal calculations.

 Parameters:
    dataType    - Data type for windowing function. Possible values are ipp32f,  ipp16u, or ipp8u.
    roiSize     - Size, in pixels,  of the ROI.
    pSize       - Pointer to the calculated buffer size (in bytes).

 Return:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - Error when pSize pointer is NULL.
    ippStsSizeErr     - Error when roiSize has a field with value less than 3.
    ippStsDataTypeErr - Error when the dataType value differs from the ipp32f,  ipp16u, or ipp8u.
}

 function ippiWinHammingGetBufferSize( dataType : IppDataType ; roiSize : IppiSize ; var pSize : Int32 ): IppStatus; _ippapi
 function ippiWinHammingSepGetBufferSize( dataType : IppDataType ; roiSize : IppiSize ; var pSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:        ippiTranspose

  Purpose:     Transposing an image

  Parameters:
    pSrc       Pointer to the source image
    srcStep    Step through the source image
    pDst       Pointer to the destination image
    dstStep    Step through the destination image
    pSrcDst    Pointer to the source/destination image (in-place flavors)
    srcDstStep Step through the source/destination image (in-place flavors)
    roiSize    Size of the source ROI

  Returns:
    ippStsNoErr      - Ok.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when:
                         roiSize has a field with zero or negative value;
                         roiSize.width != roiSize.height (in-place flavors).

  Notes: Parameters roiSize.width and roiSize.height are defined for the source image.
}

 function ippiTranspose_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_8u_C1IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_8u_C3IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_8u_C4IR( pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiTranspose_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_16u_C1IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_16u_C3IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_16u_C4IR( pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiTranspose_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_16s_C1IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_16s_C3IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_16s_C4IR( pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiTranspose_32s_C1R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_32s_C3R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_32s_C4R( pSrc : Ipp32sPtr ; srcStep : Int32 ; pDst : Ipp32sPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_32s_C1IR( pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_32s_C3IR( pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_32s_C4IR( pSrcDst : Ipp32sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi

 function ippiTranspose_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_32f_C1IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_32f_C3IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiTranspose_32f_C4IR( pSrcDst : Ipp32fPtr ; srcDstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi


{
 Name:        ippiDeconvFFTGetSize_32f

 Purpose:     Get sizes,  in bytes,  of the IppiDeconvFFTState_32f_C(1|3)R structure.

 Parameters:
    numChannels - Number of image channels. Possible values are 1 and 3.
    kernelSize  - Size of kernel.
    FFTorder    - Order of created FFT structure.
    pSize       - Pointer to the size of IppiDeconvFFTState_32f_C(1|3)R structure (in bytes).

 Returns:
    ippStsNoErr           - Ok.
    ippStsNullPtrErr      - Error when any of the specified pointers is NULL.
    ippStsNumChannelsErr  - Error when the numChannels value differs from 1 or 3.
    ippStsSizeErr         - Error when:
                               kernelSize less or equal to zero;
                               kernelSize great than 2^FFTorder.
}

 function ippiDeconvFFTGetSize_32f( nChannels : Int32 ; kernelSize : Int32 ; FFTorder : Int32 ; var pSize : Int32 ): IppStatus; _ippapi

{
 Name:        ippiDeconvFFTInit_32f_C1R, ippiDeconvFFTInit_32f_C3R

 Purpose:     Initialize IppiDeconvFFTState structure.

 Parameters:
    pDeconvFFTState - Pointer to the created deconvolution structure.
    pKernel         - Pointer to the kernel array.
    kernelSize      - Size of kernel.
    FFTorder        - Order of created FFT structure.
    threshold       - Threshold level value (for except dividing to zero).

 Returns:
    ippStsNoErr      - Ok.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when:
                          kernelSize less or equal to zero;
                          kernelSize great than 2^FFTorder.
    ippStsBadArgErr  - Error when threshold less or equal to zero.
}

 function ippiDeconvFFTInit_32f_C1R( pDeconvFFTState : IppiDeconvFFTState_32f_C1RPtr ; pKernel : Ipp32fPtr ; kernelSize : Int32 ; FFTorder : Int32 ; threshold : Ipp32f ): IppStatus; _ippapi
 function ippiDeconvFFTInit_32f_C3R( pDeconvFFTState : IppiDeconvFFTState_32f_C3RPtr ; pKernel : Ipp32fPtr ; kernelSize : Int32 ; FFTorder : Int32 ; threshold : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:        ippiDeconvFFT_32f_C*R

  Purpose:    Perform deconvolution for source image using FFT

  Parameters:
    pSrc            - Pointer to the source image.
    srcStep         - Step in bytes in the source image.
    pDst            - Pointer to the destination image.
    dstStep         - Step in bytes in the destination image.
    roi             - Size of the image ROI in pixels.
    pDeconvFFTState - Pointer to the Deconvolution context structure.

  Returns:
    ippStsNoErr          - Ok.
    ippStsNullPtrErr     - Error when any of the specified pointers is NULL.
    ippStsSizeErr        - Error when:
                               roi.width or roi.height less or equal to zero;
                               roi.width or roi.height great than (2^FFTorder-kernelSize).
    ippStsStepErr        - Error when srcstep or dststep less than roi.width multiplied by type size.
    ippStsNotEvenStepErr - Error when one of step values for floating-point images cannot be divided by 4.
}

 function ippiDeconvFFT_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roi : IppiSize ; pDeconvFFTState : IppiDeconvFFTState_32f_C1RPtr ): IppStatus; _ippapi
 function ippiDeconvFFT_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roi : IppiSize ; pDeconvFFTState : IppiDeconvFFTState_32f_C3RPtr ): IppStatus; _ippapi

{
 Name:        ippiDeconvLRGetSize_32f

 Purpose:     Get sizes,  in bytes,  of the IppiDeconvLR_32f_C(1|3)R structure.

 Parameters:
    numChannels - Number of image channels. Possible values are 1 and 3.
    kernelSize  - Size of kernel.
    maxroi      - Maximum size of the image ROI in pixels.
    pSize       - Pointer to the size of IppiDeconvLR_32f_C(1|3)R structure (in bytes).

 Returns:
    ippStsNoErr           - Ok.
    ippStsNullPtrErr      - Error when any of the specified pointers is NULL.
    ippStsNumChannelsErr  - Error when the numChannels value differs from 1 or 3.
    ippStsSizeErr         - Error when:
                               kernelSize less or equal to zero;
                               kernelSize great than maxroi.width or maxroi.height;
                               maxroi.height or maxroi.width less or equal to zero.
}

 function ippiDeconvLRGetSize_32f( numChannels : Int32 ; kernelSize : Int32 ; maxroi : IppiSize ; var pSize : Int32 ): IppStatus; _ippapi

{
 Name:        ippiDeconvLRInit_32f_C1R, ippiDeconvLRInit_32f_C3R

 Purpose:     Initialize IppiDeconvLR_32f_C(1|3)R structure.

 Parameters:
    pDeconvLR   - Pointer to the created Lucy-Richardson Deconvolution context structure.
    pKernel     - Pointer to the kernel array.
    kernelSize  - Size of kernel.
    maxroi      - Maximum size of the image ROI in pixels.
    threshold   - Threshold level value (to exclude dividing to zero).

 Returns:
    ippStsNoErr      - Ok.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when:
                         kernelSize less or equal to zero;
                         kernelSize great than maxroi.width or maxroi.height,
                         maxroi.height or maxroi.width less or equal to zero.
    ippStsBadArgErr  - Error when threshold less or equal to zero.
}

 function ippiDeconvLRInit_32f_C1R( pDeconvLR : IppiDeconvLR_32f_C1RPtr ; pKernel : Ipp32fPtr ; kernelSize : Int32 ; maxroi : IppiSize ; threshold : Ipp32f ): IppStatus; _ippapi
 function ippiDeconvLRInit_32f_C3R( pDeconvLR : IppiDeconvLR_32f_C3RPtr ; pKernel : Ipp32fPtr ; kernelSize : Int32 ; maxroi : IppiSize ; threshold : Ipp32f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:        ippiDeconvLR_32f_C1R, ippiDeconvLR_32f_C3R

  Purpose:    Perform deconvolution for source image using Lucy-Richardson algorithm

  Parameters:
    pSrc      - Pointer to the source image.
    srcStep   - Step in bytes in the source image.
    pDst      - Pointer to the destination image.
    dstStep   - Step in bytes in the destination image.
    roi       - Size of the image ROI in pixels.
    numiter   - Number of algorithm iteration.
    pDeconvLR - Pointer to the Lucy-Richardson Deconvolution context structure.

  Returns:
    ippStsNoErr          - Ok.
    ippStsNullPtrErr     - Error when any of the specified pointers is NULL.
    ippStsSizeErr        - Error when:
                               roi.width or roi.height less or equal to zero;
                               roi.width  great than (maxroi.width-kernelSize);
                               roi.height great than (maxroi.height-kernelSize).
    ippStsStepErr        - Error when srcstep or dststep less than roi.width multiplied by type size.
    ippStsNotEvenStepErr - Error when one of step values for floating-point images cannot be divided by 4.
    ippStsBadArgErr      - Error when number of iterations less or equal to zero.
}

 function ippiDeconvLR_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roi : IppiSize ; numiter : Int32 ; pDeconvLR : IppiDeconvLR_32f_C1RPtr ): IppStatus; _ippapi
 function ippiDeconvLR_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; roi : IppiSize ; numiter : Int32 ; pDeconvLR : IppiDeconvLR_32f_C3RPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:        ippiCompColorKey_8u_C1R
                ippiCompColorKey_8u_C3R
                ippiCompColorKey_8u_C4R
                ippiCompColorKey_16s_C1R
                ippiCompColorKey_16s_C3R
                ippiCompColorKey_16s_C4R
                ippiCompColorKey_16u_C1R
                ippiCompColorKey_16u_C3R
                ippiCompColorKey_16u_C4R

  Purpose:    Perform alpha blending with transparent background.

  Returns:     IppStatus
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the pointers is NULL
     ippStsSizeErr          The roiSize has a field with negative or zero value
     ippStsStepErr          One of steps is less than or equal to zero
     ippStsAlphaTypeErr     Unsupported type of composition (for ippiAlphaCompColorKey)

  Parameters:
    pSrc1, pSrc2           Pointers to the source images
    src1Step, src2Step     Steps through the source images
    pDst                   Pointer to the destination image
    dstStep                Step through the destination image
    roiSize                Size of the image ROI
    colorKey               Color value (array of values for multi-channel data)
    alphaType              The type of composition to perform (for ippiAlphaCompColorKey)
}

 function ippiCompColorKey_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; colorKey : Ipp8u ): IppStatus; _ippapi
 function ippiCompColorKey_8u_C3R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; colorKey : Ipp8u_3 ): IppStatus; _ippapi
 function ippiCompColorKey_8u_C4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; colorKey : Ipp8u_4 ): IppStatus; _ippapi
 function ippiCompColorKey_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; colorKey : Ipp16u ): IppStatus; _ippapi
 function ippiCompColorKey_16u_C3R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; colorKey : Ipp16u_3 ): IppStatus; _ippapi
 function ippiCompColorKey_16u_C4R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; colorKey : Ipp16u_4 ): IppStatus; _ippapi
 function ippiCompColorKey_16s_C1R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; colorKey : Ipp16s ): IppStatus; _ippapi
 function ippiCompColorKey_16s_C3R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; colorKey : Ipp16s_3 ): IppStatus; _ippapi
 function ippiCompColorKey_16s_C4R( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; colorkey : Ipp16s_4 ): IppStatus; _ippapi

 function ippiAlphaCompColorKey_8u_AC4R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; alpha1 : Ipp8u ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; alpha2 : Ipp8u ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; colorKey : Ipp8u_4 ; alphaType : IppiAlphaType ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     Median filter function
 ----------------------------------------------------------------------------
 Name:
   ippiMedian_8u_P3C1R

 Purpose:
   Median of three images.

   For each pixel (x, y) in the ROI:
   pDst[x + y*dstStep] = MEDIAN(pSrc[0][x + y*srcStep],
                                pSrc[1][x + y*srcStep],
                                pSrc[2][x + y*srcStep]);

 Parameters:
   pSrc       Pointer to three source images.
   srcStep    Step in bytes through source images.
   pDst       Pointer to the destination image.
   dstStep    Step in bytes through the destination image buffer.
   size       Size of the ROI in pixels.

 Returns:
   ippStsNoErr        Indicates no error. Any other value indicates an error or a warning.
   ippStsNullPtrErr   Indicates an error if one of the specified pointers is NULL.
   ippStsSizeErr      Indicates an error condition if size has a field with zero or negative value.
}

 function ippiMedian_8u_P3C1R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; size : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     De-interlacing filter function
  ----------------------------------------------------------------------------

  Name:               ippiDeinterlaceFilterCAVT_8u_C1R
  Purpose:            Performs de-interlacing of two-field image
                      using content adaptive vertical temporal (CAVT) filtering
  Parameters:
    pSrc              pointer to the source image (frame)
    srcStep           step of the source pointer in bytes
    pDst              pointer to the destination image (frame)
    dstStep           step of the destination pointer in bytes
    threshold         threshold level value
    roiSize           size of the source and destination ROI
  Returns:
    ippStsNoErr       no errors
    ippStsNullPtrErr  pSrc == NULL or pDst == NULL
    ippStsSizeErr     width of roi is less or equal zero or
                      height of roi is less 8 or odd
}

 function ippiDeinterlaceFilterCAVT_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; threshold : Ipp16u ; roiSize : IppiSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     Bilateral filter function
}

{ ----------------------------------------------------------------------------

                     Bilateral filter functions with Border
 ----------------------------------------------------------------------------
  Name:       ippiFilterBilateralBorderGetBufferSize
  Purpose:    to define buffer size for bilateral filter
  Parameters:
   filter        Type of bilateral filter. Possible value is ippiFilterBilateralGauss.
   dstRoiSize    Roi size (in pixels) of destination image what will be applied
                 for processing.
   radius        Radius of circular neighborhood what defines pixels for calculation.
   dataType      Data type of the source and desination images. Possible values
                 are and : Ipp8u ipp32f.
   numChannels   Number of channels in the images. Possible values are 1 and 3.
   distMethod    The type of method for definition of distance between pixel intensity.
                 Possible value is ippDistNormL1.
   pSpecSize     Pointer to the size (in bytes) of the spec.
   pBufferSize   Pointer to the size (in bytes) of the external work buffer.
  Return:
    ippStsNoErr               OK
    ippStsNullPtrErr          any pointer is NULL
    ippStsSizeErr             size of dstRoiSize is less or equal 0
    ippStsMaskSizeErr         radius is less or equal 0
    ippStsNotSupportedModeErr filter or distMethod is not supported
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsNumChannelsErr      Indicates an error when numChannels has an illegal value.
}

 function ippiFilterBilateralBorderGetBufferSize( filter : IppiFilterBilateralType ; dstRoiSize : IppiSize ; radius : Int32 ; dataType : IppDataType ; numChannels : Int32 ; distMethodType : IppiDistanceMethodType ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiFilterBilateralBorderInit
  Purpose:    initialization of Spec for bilateral filter with border
  Parameters:
   filter           Type of bilateral filter. Possible value is ippiFilterBilateralGauss.
   dstRoiSize       Roi size (in pixels) of destination image what will be applied
                    for processing.
   radius           Radius of circular neighborhood what defines pixels for calculation.
   dataType      Data type of the source and desination images. Possible values
                 are and : Ipp8u ipp32f.
   numChannels   Number of channels in the images. Possible values are 1 and 3.
   distMethodType   The type of method for definition of distance beetween pixel intensity.
                    Possible value is ippDistNormL1.
   valSquareSigma   square of Sigma for factor function for pixel intensity
   posSquareSigma   square of Sigma for factor function for pixel position
    pSpec           pointer to Spec
  Return:
    ippStsNoErr               OK
    ippStsNullPtrErr          pointer ro Spec is NULL
    ippStsSizeErr             size of dstRoiSize is less or equal 0
    ippStsMaskSizeErr         radius is less or equal 0
    ippStsNotSupportedModeErr filter or distMethod is not supported
    ippStsDataTypeErr         Indicates an error when dataType has an illegal value.
    ippStsNumChannelsErr      Indicates an error when numChannels has an illegal value.
    ippStsBadArgErr           valSquareSigma or posSquareSigma is less or equal 0
}

 function ippiFilterBilateralBorderInit( filter : IppiFilterBilateralType ; dstRoiSize : IppiSize ; radius : Int32 ; dataType : IppDataType ; numChannels : Int32 ; distMethod : IppiDistanceMethodType ; valSquareSigma : Ipp32f ; posSquareSigma : Ipp32f ; pSpec : IppiFilterBilateralSpecPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiFilterBilateralBorder_8u_C1R
              ippiFilterBilateralBorder_8u_C3R
              ippiFilterBilateralBorder_32f_C1R
              ippiFilterBilateralBorder_32f_C3R
  Purpose:    bilateral filter
  Parameters:
    pSrc         Pointer to the source image
    srcStep      Step through the source image
    pDst         Pointer to the destination image
    dstStep      Step through the destination image
    dstRoiSize   Size of the destination ROI
    borderType   Type of border.
    borderValue  Pointer to constant value to assign to pixels of the constant border. This parameter is applicable
                 only to the ippBorderConst border type. If this pointer is NULL than the constant value is equal 0.
    pSpec        Pointer to filter spec
    pBuffer      Pointer ro work buffer
  Return:
    ippStsNoErr           OK
    ippStsNullPtrErr      pointer to Src,  Dst, Spec or Buffer is NULL
    ippStsSizeErr         size of dstRoiSize is less or equal 0
    ippStsContextMatchErr filter Spec is not match
    ippStsNotEvenStepErr  Indicated an error when one of the step values is not divisible by 4
                          for floating-point images.
    ippStsBorderErr       Indicates an error when borderType has illegal value.
}

 function ippiFilterBilateralBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; borderType : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiFilterBilateralSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBilateralBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; borderType : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiFilterBilateralSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBilateralBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; borderType : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiFilterBilateralSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBilateralBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; borderType : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiFilterBilateralSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:      ippiFilterGetBufSize_64f_C1R
  Purpose:   Get size of temporal buffer
  Parameters:
      kernelSize      Size of the rectangular kernel in pixels.
      roiWidth        Width of ROI
      pSize           Pointer to the size of work buffer
  Returns:
   ippStsNoErr        Ok
   ippStsNullPtrErr   pSize is NULL
   ippStsSizeErr      Some size of kernelSize or roiWidth less or equal zero
  Remark:             Function may return zero size of buffer.
}

 function ippiFilterGetBufSize_64f_C1R( kernelSize : IppiSize ; roiWidth : Int32 ; var pSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippiFilter_64f_C1R
  Purpose:    Filters an image using a general float rectangular kernel
  Parameters:
      pSrc            Pointer to the source buffer
      srcStep         Step in bytes through the source image buffer
      pDst            Pointer to the destination buffer
      dstStep         Step in bytes through the destination image buffer
      dstRoiSize      Size of the source and destination ROI in pixels
      pKernel         Pointer to the kernel values ( 64f kernel )
      kernelSize      Size of the rectangular kernel in pixels.
      anchor          Anchor cell specifying the rectangular kernel alignment
                      with respect to the position of the input pixel
      pBuffer         Pointer to work buffer
  Returns:
   ippStsNoErr        Ok
   ippStsNullPtrErr   Some of pointers to pSrc,  pDst or pKernel are NULL or
                      pBuffer is null but GetBufSize returned non zero size
   ippStsSizeErr      Some size of dstRoiSize or kernalSize less or equal zero
   ippStsStepErr      srcStep is less than (roiWidth + kernelWidth - 1) * sizeof(Ipp64f) or
                      dstStep is less than  roiWidth * sizeof(Ipp64f)
}

 function ippiFilter_64f_C1R( pSrc : Ipp64fPtr ; srcStep : Int32 ; pDst : Ipp64fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; pKernel : Ipp64fPtr ; kernelSize : IppiSize ; anchor : IppiPoint ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi


{
  Purpose:    Divides pixel values of an image by pixel values of
              another image with three rounding modes (ippRndZero,ippRndNear,ippRndFinancial)
              and places the scaled results in a destination
              image.
  Name:       ippiDiv_Round_16s_C1RSfs, ippiDiv_Round_8u_C1RSfs, ippiDiv_Round_16u_C1RSfs,
              ippiDiv_Round_16s_C3RSfs, ippiDiv_Round_8u_C3RSfs, ippiDiv_Round_16u_C3RSfs,
              ippiDiv_Round_16s_C4RSfs, ippiDiv_Round_8u_C4RSfs, ippiDiv_Round_16u_C4RSfs,
              ippiDiv_Round_16s_AC4RSfs, ippiDiv_Round_8u_AC4RSfs, ippiDiv_Round_16u_AC4RSfs,
  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field with zero or negative value
    ippStsStepErr            At least one step value is less than or equal to zero
    ippStsDivByZero          A warning that a divisor value is zero,  the function
                             execution is continued.
                    If a dividend is equal to zero,  then the result is zero;
                    if it is greater than zero,  then the result is IPP_MAX_16S,  or IPP_MAX_8U,  or IPP_MAX_16U
                    if it is less than zero (for 16s), then the result is IPP_MIN_16S
   ippStsRoundModeNotSupportedErr Unsupported round mode


  Parameters:
    pSrc1                    Pointer to the divisor source image
    src1Step                 Step through the divisor source image
    pSrc2                    Pointer to the dividend source image
    src2Step                 Step through the dividend source image
    pDst                     Pointer to the destination image
    dstStep                  Step through the destination image
    roiSize                  Size of the ROI
    rndMode           Rounding mode (ippRndZero, ippRndNear or ippRndFinancial)
    scaleFactor              Scale factor
}

 function ippiDiv_Round_16s_C1RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16s_C3RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16s_C4RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16s_AC4RSfs( pSrc1 : Ipp16sPtr ; src1Step : Int32 ; pSrc2 : Ipp16sPtr ; src2Step : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_8u_C1RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_8u_C3RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_8u_C4RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_8u_AC4RSfs( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16u_C1RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16u_C3RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16u_C4RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16u_AC4RSfs( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi
{
  Purpose:    Divides pixel values of an image by pixel values of
              another image with three rounding modes (ippRndZero,ippRndNear,ippRndFinancial)
              and places the scaled results in a destination
              image.
  Name:       ippiDiv_Round_16s_C1IRSfs, ippiDiv_Round_8u_C1IRSfs, ippiDiv_Round_16u_C1IRSfs,
              ippiDiv_Round_16s_C3IRSfs, ippiDiv_Round_8u_C3IRSfs, ippiDiv_Round_16u_C3IRSfs,
              ippiDiv_Round_16s_C4IRSfs, ippiDiv_Round_8u_C4IRSfs, ippiDiv_Round_16u_C4IRSfs,
              ippiDiv_Round_16s_AC4IRSfs, ippiDiv_Round_8u_AC4IRSfs, ippiDiv_Round_16u_AC4IRSfs,
  Parameters:
    pSrc                     Pointer to the divisor source image
    srcStep                  Step through the divisor source image
    pSrcDst                  Pointer to the dividend source/destination image
    srcDstStep               Step through the dividend source/destination image
    roiSize                  Size of the ROI
    rndMode           Rounding mode (ippRndZero, ippRndNear or ippRndFinancial)
    scaleFactor              Scale factor
  Returns:
    ippStsNoErr              OK
    ippStsNullPtrErr         One of the pointers is NULL
    ippStsSizeErr            roiSize has a field with zero or negative value
    ippStsStepErr            At least one step value is less than or equal to zero
    ippStsDivByZero          A warning that a divisor value is zero,  the function
                             execution is continued.
                    If a dividend is equal to zero,  then the result is zero;
                    if it is greater than zero,  then the result is IPP_MAX_16S,  or IPP_MAX_8U,  or IPP_MAX_16U
                    if it is less than zero (for 16s), then the result is IPP_MIN_16S
   ippStsRoundModeNotSupportedErr Unsupported round mode
}

 function ippiDiv_Round_16s_C1IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16s_C3IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16s_C4IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16s_AC4IRSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; pSrcDst : Ipp16sPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_8u_C1IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_8u_C3IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_8u_C4IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_8u_AC4IRSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; pSrcDst : Ipp8uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16u_C1IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16u_C3IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16u_C4IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi
 function ippiDiv_Round_16u_AC4IRSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; pSrcDst : Ipp16uPtr ; srcDstStep : Int32 ; roiSize : IppiSize ; rndMode : IppRoundMode ; ScaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                      Resize Transform Functions
------------------------------------------------------------------------------

  Name:               ippiResizeGetSize
  Purpose:            Computes the size of Spec structure and temporal buffer for Resize transform

  Parameters:
    srcSize           Size of the input image (in pixels)
    dstSize           Size of the output image (in pixels)
    interpolation     Interpolation method
    antialiasing      Supported values: 1- resizing with antialiasing,  0 - resizing without antialiasing
    pSpecSize         Pointer to the size (in bytes) of the Spec structure
    pInitBufSize      Pointer to the size (in bytes) of the temporal buffer

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of any image is zero
    ippStsSizeErr             Indicates an error in the following cases:
                              -  if the source image size is less than a filter size of the chosen
                                 interpolation method (except ippSuper),
                              -  if one of the specified dimensions of the source image is less than
                                 the corresponding dimension of the destination image (for ippSuper method only),
                              -  if width or height of the source or destination image is negative, 
                              -  if one of the calculated sizes exceeds maximum 32 bit signed integer
                                 positive value (the size of the one of the processed images is too large).
                              -  if width or height of the source or destination image is negative.
    ippStsInterpolationErr    Indicates an error if interpolation has an illegal value
    ippStsNoAntialiasing      Indicates a warning if specified interpolation does not support antialiasing
    ippStsNotSupportedModeErr Indicates an error if requested mode is currently not supported

  Notes:
    1. Supported interpolation methods are ippNearest,  ippLinear, ippCubic, ippLanczos and ippSuper.
    2. If antialiasing value is equal to 1,  use the ippResizeAntialiasing<Filter>Init functions,  otherwise, use ippResize<Filter>Init
    3. The implemented interpolation algorithms have the following filter sizes: Nearest Neighbor 1x1, 
       Linear 2x2,  Cubic 4x4,  2-lobed Lanczos 4x4.
}

 function ippiResizeGetSize_8u( srcSize : IppiSize ; dstSize : IppiSize ; interpolation : IppiInterpolationType ; antialiasing : Ipp32u ; var pSpecSize : Int32 ; var pInitBufSize : Int32 ): IppStatus; _ippapi
 function ippiResizeGetSize_16u( srcSize : IppiSize ; dstSize : IppiSize ; interpolation : IppiInterpolationType ; antialiasing : Ipp32u ; var pSpecSize : Int32 ; var pInitBufSize : Int32 ): IppStatus; _ippapi
 function ippiResizeGetSize_16s( srcSize : IppiSize ; dstSize : IppiSize ; interpolation : IppiInterpolationType ; antialiasing : Ipp32u ; var pSpecSize : Int32 ; pInitBufSize : Ipp32sPtr ): IppStatus; _ippapi
 function ippiResizeGetSize_32f( srcSize : IppiSize ; dstSize : IppiSize ; interpolation : IppiInterpolationType ; antialiasing : Ipp32u ; var pSpecSize : Int32 ; var pInitBufSize : Int32 ): IppStatus; _ippapi
 function ippiResizeGetSize_64f( srcSize : IppiSize ; dstSize : IppiSize ; interpolation : IppiInterpolationType ; antialiasing : Ipp32u ; var pSpecSize : Int32 ; var pInitBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeGetBufferSize
  Purpose:            Computes the size of external buffer for Resize transform

  Parameters:
    pSpec             Pointer to the Spec structure for resize filter
    dstSize           Size of the output image (in pixels)
    numChannels       Number of channels,  possible values are 1 or 3 or 4
    pBufSize          Pointer to the size (in bytes) of the external buffer

  Return Values:
    ippStsNoErr           Indicates no error
    ippStsNullPtrErr      Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation     Indicates a warning if width or height of output image is zero
    ippStsContextMatchErr Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsNumChannelErr   Indicates an error if numChannels has illegal value
    ippStsSizeErr         Indicates an error condition in the following cases:
                          - if width or height of the source image is negative, 
                          - if the calculated buffer size exceeds maximum 32 bit signed integer
                            positive value (the processed image ROIs are too large ).
    ippStsSizeWrn         Indicates a warning if the destination image size is more than
                          the destination image origin size
}

 function ippiResizeGetBufferSize_8u( pSpec : IppiResizeSpec_32fPtr ; dstSize : IppiSize ; numChannels : Ipp32u ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiResizeGetBufferSize_16u( pSpec : IppiResizeSpec_32fPtr ; dstSize : IppiSize ; numChannels : Ipp32u ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiResizeGetBufferSize_16s( pSpec : IppiResizeSpec_32fPtr ; dstSize : IppiSize ; numChannels : Ipp32u ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiResizeGetBufferSize_32f( pSpec : IppiResizeSpec_32fPtr ; dstSize : IppiSize ; numChannels : Ipp32u ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippiResizeGetBufferSize_64f( pSpec : IppiResizeSpec_64fPtr ; dstSize : IppiSize ; numChannels : Ipp32u ; var pBufSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeGetBorderSize
  Purpose:            Computes the size of possible borders for Resize transform

  Parameters:
    pSpec             Pointer to the Spec structure for resize filter
    borderSize        Size of necessary borders (for memory allocation)

  Return Values:
    ippStsNoErr           Indicates no error
    ippStsNullPtrErr      Indicates an error if one of the specified pointers is NULL
    ippStsContextMatchErr Indicates an error if pointer to an invalid pSpec structure is passed
}

 function ippiResizeGetBorderSize_8u( pSpec : IppiResizeSpec_32fPtr ; var borderSize : IppiBorderSize ): IppStatus; _ippapi
 function ippiResizeGetBorderSize_16u( pSpec : IppiResizeSpec_32fPtr ; var borderSize : IppiBorderSize ): IppStatus; _ippapi
 function ippiResizeGetBorderSize_16s( pSpec : IppiResizeSpec_32fPtr ; var borderSize : IppiBorderSize ): IppStatus; _ippapi
 function ippiResizeGetBorderSize_32f( pSpec : IppiResizeSpec_32fPtr ; var borderSize : IppiBorderSize ): IppStatus; _ippapi
 function ippiResizeGetBorderSize_64f( pSpec : IppiResizeSpec_64fPtr ; var borderSize : IppiBorderSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeGetSrcOffset
  Purpose:            Computes the offset of input image for Resize transform by tile processing

  Parameters:
    pSpec             Pointer to the Spec structure for resize filter
    dstOffset         Offset of the tiled destination image respective
                      to the destination image origin
    srcOffset         Pointer to the offset of input image

  Return Values:
    ippStsNoErr           Indicates no error
    ippStsNullPtrErr      Indicates an error if one of the specified pointers is NULL
    ippStsContextMatchErr Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsOutOfRangeErr   Indicates an error if the destination image offset point is outside the
                          destination image origin
}

 function ippiResizeGetSrcOffset_8u( pSpec : IppiResizeSpec_32fPtr ; dstOffset : IppiPoint ; srcOffset : IppiPointPtr ): IppStatus; _ippapi
 function ippiResizeGetSrcOffset_16u( pSpec : IppiResizeSpec_32fPtr ; dstOffset : IppiPoint ; srcOffset : IppiPointPtr ): IppStatus; _ippapi
 function ippiResizeGetSrcOffset_16s( pSpec : IppiResizeSpec_32fPtr ; dstOffset : IppiPoint ; srcOffset : IppiPointPtr ): IppStatus; _ippapi
 function ippiResizeGetSrcOffset_32f( pSpec : IppiResizeSpec_32fPtr ; dstOffset : IppiPoint ; srcOffset : IppiPointPtr ): IppStatus; _ippapi
 function ippiResizeGetSrcOffset_64f( pSpec : IppiResizeSpec_64fPtr ; dstOffset : IppiPoint ; srcOffset : IppiPointPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeGetSrcRoi
  Purpose:            Computes the ROI of input image
                      for Resize transform by tile processing

  Parameters:
    pSpec             Pointer to the Spec structure for resize filter
    dstRoiOffset      Offset of the destination image ROI
    dstRoiSize        Size of the ROI of destination image
    srcRoiOffset      Pointer to the offset of source image ROI
    srcRoiSize        Pointer to the ROI size of source image

  Return Values:
    ippStsNoErr           Indicates no error
    ippStsNullPtrErr      Indicates an error if one of the specified pointers is NULL
    ippStsContextMatchErr Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsOutOfRangeErr   Indicates an error if the destination image offset point is outside
                          the destination image origin
    IppStsSizeWrn         Indicates a warning if the destination ROI exceeds with
                          the destination image origin
}

 function ippiResizeGetSrcRoi_8u( pSpec : IppiResizeSpec_32fPtr ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; srcRoiOffset : IppiPointPtr ; srcRoiSize : IppiSizePtr ): IppStatus; _ippapi
 function ippiResizeGetSrcRoi_16u( pSpec : IppiResizeSpec_32fPtr ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; srcRoiOffset : IppiPointPtr ; srcRoiSize : IppiSizePtr ): IppStatus; _ippapi
 function ippiResizeGetSrcRoi_16s( pSpec : IppiResizeSpec_32fPtr ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; srcRoiOffset : IppiPointPtr ; srcRoiSize : IppiSizePtr ): IppStatus; _ippapi
 function ippiResizeGetSrcRoi_32f( pSpec : IppiResizeSpec_32fPtr ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; srcRoiOffset : IppiPointPtr ; srcRoiSize : IppiSizePtr ): IppStatus; _ippapi
 function ippiResizeGetSrcRoi_64f( pSpec : IppiResizeSpec_64fPtr ; dstRoiOffset : IppiPoint ; dstRoiSize : IppiSize ; srcRoiOffset : IppiPointPtr ; srcRoiSize : IppiSizePtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeNearestInit
                      ippiResizeLinearInit
                      ippiResizeCubicInit
                      ippiResizeLanczosInit
                      ippiResizeSuperInit

  Purpose:            Initializes the Spec structure for the Resize transform
                      by different interpolation methods

  Parameters:
    srcSize           Size of the input image (in pixels)
    dstSize           Size of the output image (in pixels)
    valueB            The first parameter (B) for specifying Cubic filters
    valueC            The second parameter (C) for specifying Cubic filters
    numLobes          The parameter for specifying Lanczos (2 or 3) or Hahn (3 or 4) filters
    pInitBuf          Pointer to the temporal buffer for several filter initialization
    pSpec             Pointer to the Spec structure for resize filter

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of any image is zero
    ippStsSizeErr             Indicates an error in the following cases:
                              -  if width or height of the source or destination image is negative, 
                              -  if the source image size is less than a filter size of the chosen
                                 interpolation method (except ippiResizeSuperInit).
                              -  if one of the specified dimensions of the source image is less than
                                 the corresponding dimension of the destination image
                                 (for ippiResizeSuperInit only).
    ippStsNotSupportedModeErr Indicates an error if the requested mode is not supported.

  Notes/References:
    1. The equation shows the family of cubic filters:
           ((12-9B-6C)*|x|^3 + (-18+12B+6C)*|x|^2                  + (6-2B)  ) / 6   for |x| < 1
    K(x) = ((   -B-6C)*|x|^3 + (    6B+30C)*|x|^2 + (-12B-48C)*|x| + (8B+24C)) / 6   for 1 <= |x| < 2
           0   elsewhere
    Some values of (B,C) correspond to known cubic splines: Catmull-Rom (B=0,C=0.5), B-Spline (B=1,C=0) and other.
      Mitchell, Don P.; Netravali, Arun N. (Aug. 1988). "Reconstruction filters in computer graphics"
      http://www.mentallandscape.com/Papers_siggraph88.pdf

    2. Hahn filter does not supported now.
    3. The implemented interpolation algorithms have the following filter sizes: Nearest Neighbor 1x1, 
       Linear 2x2,  Cubic 4x4,  2-lobed Lanczos 4x4,  3-lobed Lanczos 6x6.
}

 function ippiResizeNearestInit_8u( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi
 function ippiResizeNearestInit_16u( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi
 function ippiResizeNearestInit_16s( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi
 function ippiResizeNearestInit_32f( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi
 function ippiResizeLinearInit_8u( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi
 function ippiResizeLinearInit_16u( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi
 function ippiResizeLinearInit_16s( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi
 function ippiResizeLinearInit_32f( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi
 function ippiResizeLinearInit_64f( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_64fPtr ): IppStatus; _ippapi
 function ippiResizeCubicInit_8u( srcSize : IppiSize ; dstSize : IppiSize ; valueB : Ipp32f ; valueC : Ipp32f ; pSpec : IppiResizeSpec_32fPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubicInit_16u( srcSize : IppiSize ; dstSize : IppiSize ; valueB : Ipp32f ; valueC : Ipp32f ; pSpec : IppiResizeSpec_32fPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubicInit_16s( srcSize : IppiSize ; dstSize : IppiSize ; valueB : Ipp32f ; valueC : Ipp32f ; pSpec : IppiResizeSpec_32fPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubicInit_32f( srcSize : IppiSize ; dstSize : IppiSize ; valueB : Ipp32f ; valueC : Ipp32f ; pSpec : IppiResizeSpec_32fPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczosInit_8u( srcSize : IppiSize ; dstSize : IppiSize ; numLobes : Ipp32u ; pSpec : IppiResizeSpec_32fPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczosInit_16u( srcSize : IppiSize ; dstSize : IppiSize ; numLobes : Ipp32u ; pSpec : IppiResizeSpec_32fPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczosInit_16s( srcSize : IppiSize ; dstSize : IppiSize ; numLobes : Ipp32u ; pSpec : IppiResizeSpec_32fPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczosInit_32f( srcSize : IppiSize ; dstSize : IppiSize ; numLobes : Ipp32u ; pSpec : IppiResizeSpec_32fPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuperInit_8u( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi
 function ippiResizeSuperInit_16u( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi
 function ippiResizeSuperInit_16s( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi
 function ippiResizeSuperInit_32f( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeNearest
                      ippiResizeLinear
                      ippiResizeCubic
                      ippiResizeLanczos
                      ippiResizeSuper

  Purpose:            Changes an image size by different interpolation methods

  Parameters:
    pSrc              Pointer to the source image
    srcStep           Distance (in bytes) between of consecutive lines in the source image
    pDst              Pointer to the destination image
    dstStep           Distance (in bytes) between of consecutive lines in the destination image
    dstOffset         Offset of tiled image respectively destination image origin
    dstSize           Size of the destination image (in pixels)
    border            Type of the border
    borderValue       Pointer to the constant value(s) if border type equals ippBorderConstant
    pSpec             Pointer to the Spec structure for resize filter
    pBuffer           Pointer to the work buffer

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of output image is zero
    ippStsBorderErr           Indicates an error if border type has an illegal value
    ippStsContextMatchErr     Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsNotSupportedModeErr Indicates an error if requested mode is currently not supported
    ippStsSizeErr             Indicates an error if width or height of the destination image
                              is negative
    ippStsStepErr             Indicates an error if the step value is not data type multiple
    ippStsOutOfRangeErr       Indicates an error if the destination image offset point is outside the
                              destination image origin
    ippStsSizeWrn             Indicates a warning if the destination image size is more than
                              the destination image origin size

  Notes:
    1. Supported border types are ippBorderInMemory and ippBorderReplicate
       (except Nearest Neighbor and Super Sampling methods).
    2. Hahn filter does not supported now.
}

 function ippiResizeNearest_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeNearest_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeNearest_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeNearest_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeNearest_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeNearest_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeNearest_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeNearest_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeNearest_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeNearest_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeNearest_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeNearest_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_32f_C3R( pSrc : Ipp32fPtr ; const srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_64f_C1R( pSrc : Ipp64fPtr ; srcStep : Ipp32s ; pDst : Ipp64fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp64fPtr ; pSpec : IppiResizeSpec_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_64f_C3R( pSrc : Ipp64fPtr ; srcStep : Ipp32s ; pDst : Ipp64fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp64fPtr ; pSpec : IppiResizeSpec_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLinear_64f_C4R( pSrc : Ipp64fPtr ; srcStep : Ipp32s ; pDst : Ipp64fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp64fPtr ; pSpec : IppiResizeSpec_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeCubic_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeLanczos_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeSuper_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeLinearAntialiasingInit

  Purpose:            Initializes the Spec structure for the Resize transform
                      by different interpolation methods

  Parameters:
    srcSize           Size of the input image (in pixels)
    dstSize           Size of the output image (in pixels)
    valueB            The first parameter (B) for specifying Cubic filters
    valueC            The second parameter (C) for specifying Cubic filters
    numLobes          The parameter for specifying Lanczos (2 or 3) or Hahn (3 or 4) filters
    pInitBuf          Pointer to the temporal buffer for several filter initialization
    pSpec             Pointer to the Spec structure for resize filter

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of any image is zero
    ippStsSizeErr             Indicates an error in the following cases:
                              -  if width or height of the source or destination image is negative, 
                              -  if the source image size is less than a filter size of the chosen
                                 interpolation method (except ippiResizeSuperInit).
                              -  if one of the specified dimensions of the source image is less than
                                 the corresponding dimension of the destination image
                                 (for ippiResizeSuperInit only).
    ippStsNotSupportedModeErr Indicates an error if the requested mode is not supported.

  Notes/References:
    1. The equation shows the family of cubic filters:
           ((12-9B-6C)*|x|^3 + (-18+12B+6C)*|x|^2                  + (6-2B)  ) / 6   for |x| < 1
    K(x) = ((   -B-6C)*|x|^3 + (    6B+30C)*|x|^2 + (-12B-48C)*|x| + (8B+24C)) / 6   for 1 <= |x| < 2
           0   elsewhere
    Some values of (B,C) correspond to known cubic splines: Catmull-Rom (B=0,C=0.5), B-Spline (B=1,C=0) and other.
      Mitchell, Don P.; Netravali, Arun N. (Aug. 1988). "Reconstruction filters in computer graphics"
      http://www.mentallandscape.com/Papers_siggraph88.pdf

    2. Hahn filter does not supported now.
    3. The implemented interpolation algorithms have the following filter sizes: Nearest Neighbor 1x1, 
       Linear 2x2,  Cubic 4x4,  2-lobed Lanczos 4x4,  3-lobed Lanczos 6x6.
}

 function ippiResizeAntialiasingLinearInit( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeSpec_32fPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeAntialiasingCubicInit( srcSize : IppiSize ; dstSize : IppiSize ; valueB : Ipp32f ; valueC : Ipp32f ; pSpec : IppiResizeSpec_32fPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeAntialiasingLanczosInit( srcSize : IppiSize ; dstSize : IppiSize ; numLobes : Ipp32u ; pSpec : IppiResizeSpec_32fPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeAntialiasing

  Purpose:            Changes an image size by different interpolation methods with antialiasing technique

  Parameters:
    pSrc              Pointer to the source image
    srcStep           Distance (in bytes) between of consecutive lines in the source image
    pDst              Pointer to the destination image
    dstStep           Distance (in bytes) between of consecutive lines in the destination image
    dstOffset         Offset of tiled image respectively destination image origin
    dstSize           Size of the destination image (in pixels)
    border            Type of the border
    borderValue       Pointer to the constant value(s) if border type equals ippBorderConstant
    pSpec             Pointer to the Spec structure for resize filter
    pBuffer           Pointer to the work buffer

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of output image is zero
    ippStsBorderErr           Indicates an error if border type has an illegal value
    ippStsContextMatchErr     Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsNotSupportedModeErr Indicates an error if requested mode is currently not supported
    ippStsSizeErr             Indicates an error if width or height of the destination image
                              is negative
    ippStsStepErr             Indicates an error if the step value is not data type multiple
    ippStsOutOfRangeErr       Indicates an error if the destination image offset point is outside the
                              destination image origin
    ippStsSizeWrn             Indicates a warning if the destination image size is more than
                              the destination image origin size

  Notes:
    1. Supported border types are ippBorderInMemory and ippBorderReplicate
    2. Hahn filter does not supported now.
}

 function ippiResizeAntialiasing_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeAntialiasing_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeAntialiasing_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiResizeAntialiasing_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeAntialiasing_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeAntialiasing_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Ipp32s ; pDst : Ipp16uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiResizeAntialiasing_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeAntialiasing_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeAntialiasing_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Ipp32s ; pDst : Ipp16sPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16sPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiResizeAntialiasing_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeAntialiasing_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeAntialiasing_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Ipp32s ; pDst : Ipp32fPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiResizeSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                      Resize Transform Functions. YUY2 pixel format
------------------------------------------------------------------------------

  Name:               ippiResizeYUV422GetSize
  Purpose:            Computes the size of Spec structure and temporal buffer for Resize transform

  Parameters:
    srcSize           Size of the source image (in pixels)
    dstSize           Size of the destination image (in pixels)
    interpolation     Interpolation method
    antialiasing      Antialiasing method
    pSpecSize         Pointer to the size (in bytes) of the Spec structure
    pInitBufSize      Pointer to the size (in bytes) of the temporal buffer

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of any image is zero
    ippStsSizeErr             Indicates an error in the following cases:
                              - if the source image size is less than the filter size
                                for the chosen interpolation method, 
                              - if one of the calculated sizes exceeds maximum 32 bit signed integer
                                positive value (the size of one of the processed images is too large).
    ippStsSizeWrn             Indicates a warning if width of the image is odd
    ippStsInterpolationErr    Indicates an error if interpolation has an illegal value
    ippStsNoAntialiasing      if the specified interpolation method does not support antialiasing.
    ippStsNotSupportedModeErr Indicates an error if requested mode is currently not supported

  Notes:
    1. Supported interpolation methods are ippNearest,  ippLinear.
    2. Antialiasing feature does not supported now. The antialiasing value should be equal zero.
    3. The implemented interpolation algorithms have the following filter sizes: Nearest Neighbor 2x1, 
       Linear 4x2.
}

 function ippiResizeYUV422GetSize( srcSize : IppiSize ; dstSize : IppiSize ; interpolation : IppiInterpolationType ; antialiasing : Ipp32u ; pSpecSize : Ipp32sPtr ; pInitBufSize : Ipp32sPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeYUV422GetBufSize
  Purpose:            Computes the size of external buffer for Resize transform

  Parameters:
    pSpec             Pointer to the Spec structure for resize filter
    dstSize           Size of the output image (in pixels)
    pBufSize          Pointer to the size (in bytes) of the external buffer

  Return Values:
    ippStsNoErr           Indicates no error
    ippStsNullPtrErr      Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation     Indicates a warning if width or height of the destination image is
                          equal to zero.
    ippStsContextMatchErr Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsSizeWrn         Indicates a warning in the following cases:
                          - if width of the image is odd, 
                          - if the destination image size is more than the destination image origin size
    ippStsSizeErr         Indicates an error in the following cases:
                          - if width of the image is equal to 1, 
                          - if width or height of the source or destination image is negative, 
                          - if the calculated buffer size exceeds maximum 32 bit signed integer positive
                          value (the processed image size is too large)
}

 function ippiResizeYUV422GetBufSize( pSpec : IppiResizeYUV422SpecPtr ; dstSize : IppiSize ; pBufSize : Ipp32sPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeYUV422GetBorderSize
  Purpose:            Computes the size of possible borders for Resize transform

  Parameters:
    pSpec             Pointer to the Spec structure for resize filter
    borderSize        Size of necessary borders

  Return Values:
    ippStsNoErr           Indicates no error
    ippStsNullPtrErr      Indicates an error if one of the specified pointers is NULL
    ippStsContextMatchErr Indicates an error if pointer to an invalid pSpec structure is passed
}

 function ippiResizeYUV422GetBorderSize( pSpec : IppiResizeYUV422SpecPtr ; var borderSize : IppiBorderSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeYUV422GetSrcOffset
  Purpose:            Computes the offset of input image for Resize transform by tile processing

  Parameters:
    pSpec             Pointer to the Spec structure for resize filter
    dstOffset         Offset of the tiled destination image respective to the destination image origin
    srcOffset         Pointer to the offset of source image

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsMisalignedOffsetErr Indicates an error if the x field of the dstOffset parameter is odd.
    ippStsContextMatchErr     Indicates an error if pointer to the spec structure is invalid.
}

 function ippiResizeYUV422GetSrcOffset( pSpec : IppiResizeYUV422SpecPtr ; dstOffset : IppiPoint ; srcOffset : IppiPointPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeYUV422NearestInit
                      ippiResizeYUV422LinearInit

  Purpose:            Initializes the Spec structure for the Resize transform
                      by different interpolation methods
  Parameters:
    srcSize           Size of the source image (in pixels)
    dstSize           Size of the destination image (in pixels)
    pSpec             Pointer to the Spec structure for resize filter

  Return Values:
    ippStsNoErr           Indicates no error
    ippStsNullPtrErr      Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation     Indicates a warning if width or height of any image is zero
    ippStsSizeWrn         Indicates a warning if width of any image is odd
    ippStsSizeErr         Indicates an error in the following cases:
                          - if width of the image is equal to 1, 
                          - if width or height of the source or destination image is negative, 
                          - if the source image size is less than the chosen
                            interpolation method filter size
  Notes:
    1.The implemented interpolation algorithms have the following filter sizes: Nearest Neighbor 2x1, 
      Linear 4x2.
}

 function ippiResizeYUV422NearestInit( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeYUV422SpecPtr ): IppStatus; _ippapi
 function ippiResizeYUV422LinearInit( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeYUV422SpecPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeYUV422Nearest_8u_C2R
                      ippiResizeYUV422Linear_8u_C2R

  Purpose:            Changes an image size by different interpolation methods

  Parameters:
    pSrc              Pointer to the source image
    srcStep           Distance (in bytes) between of consecutive lines in the source image
    pDst              Pointer to the destination image
    dstStep           Distance (in bytes) between of consecutive lines in the destination image
    dstOffset         Offset of tiled image respectively output origin image
    dstSize           Size of the destination image (in pixels)
    border            Type of the border
    borderValue       Pointer to the constant value(s) if border type equals ippBorderConstant
    pSpec             Pointer to the Spec structure for resize filter
    pBuffer           Pointer to the work buffer

  Return Values:
    ippStsNoErr                Indicates no error
    ippStsNullPtrErr           Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation          Indicates a warning if width or height of output image is zero
    ippStsContextMatchErr      Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsSizeWrn              Indicates a warning in the following cases:
/                                - if width of the image is odd, 
                               - if the destination image size is more than the destination image origin size.
    ippStsMisalignedOffsetErr  Indicates an error if the x field of the dstOffset parameter is odd
    ippStsSizeErr              Indicates an error if width of the destination image is equal to 1, 
                               or if width or height of the source or destination image is negative
    ippStsOutOfRangeErr        Indicates an error if the destination image offset point is outside
                               the destination image origin
    ippStsStepErr              Indicates an error if the step value is not data type multiple

  Notes:
    1. YUY2 pixel format (Y0U0Y1V0,Y2U1Y3V1,.. or Y0Cb0Y1Cr0, Y2Cb1Y3Cr1,..).
    2. Supported border types are ippBorderInMemory and ippBorderReplicate for Linear method.
}

 function ippiResizeYUV422Nearest_8u_C2R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeYUV422SpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeYUV422Linear_8u_C2R( pSrc : Ipp8uPtr ; srcStep : Ipp32s ; pDst : Ipp8uPtr ; dstStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeYUV422SpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                      Resize Transform Functions. NV12 planar format
------------------------------------------------------------------------------

  Name:               ippiResizeYUV420GetSize
  Purpose:            Computes the size of Spec structure and temporal buffer for Resize transform

  Parameters:
    srcSize           Size of the input image (in pixels)
    dstSize           Size of the output image (in pixels)
    interpolation     Interpolation method
    antialiasing      Antialiasing method
    pSpecSize         Pointer to the size (in bytes) of the Spec structure
    pInitBufSize      Pointer to the size (in bytes) of the temporal buffer

  Return Values:
    ippStsNoErr               Indicates no error
    ippStsNullPtrErr          Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation         Indicates a warning if width or height of any image is zero
    ippStsSizeErr             Indicates an error in the following cases:
                              - if width or height of the image is equal to 1, 
                              - if the source image size is less than a filter size of
                                the chosen interpolation method (except ippSuper),
                              - if one of the specified dimensions of the source image is less than
                                the corresponding dimension of the destination image
                                (for ippSuper method only),
                              - if width or height of the source or destination image is negative, 
                              - if one of the calculated sizes exceeds maximum 32 bit signed integer
                                positive value (the size of the one of the processed images is too large).
    ippStsSizeWrn             Indicates a warning if width or height of any image is odd
    ippStsInterpolationErr    Indicates an error if interpolation has an illegal value
    ippStsNoAntialiasing      Indicates a warning if the specified interpolation method does not
                              support antialiasing
    ippStsNotSupportedModeErr Indicates an error if requested mode is currently not supported

  Notes:
    1. Supported interpolation methods are ippLanczos and ippSuper.
    2. Antialiasing feature does not supported now. The antialiasing value should be equal zero.
    3. The implemented interpolation algorithms have the following filter sizes: 2-lobed Lanczos 4x4
}

 function ippiResizeYUV420GetSize( srcSize : IppiSize ; dstSize : IppiSize ; interpolation : IppiInterpolationType ; antialiasing : Ipp32u ; pSpecSize : Ipp32sPtr ; pInitBufSize : Ipp32sPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeYUV420GetBufferSize
  Purpose:            Computes the size of external buffer for Resize transform

  Parameters:
    pSpec             Pointer to the Spec structure for resize filter
    dstSize           Size of the output image (in pixels)
    pBufSize          Pointer to the size (in bytes) of the external buffer

  Return Values:
    ippStsNoErr           Indicates no error
    ippStsNullPtrErr      Indicates an error if one of the specified pointers is NULL
    ippStsContextMatchErr Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsNoOperation     Indicates a warning if width or height of destination image is zero
    ippStsSizeWrn         Indicates a warning in the following cases:
                          - if width or height of the image is odd, 
                          - if the destination image size is more than the destination
/                             image origin size
    ippStsSizeErr         Indicates an error in the following cases
                          - if width or height of the image is equal to 1, 
                          - if width or height of the destination image is negative, 
                          - if the calculated buffer size exceeds maximum 32 bit signed integer
                            positive value (the processed image size is too large)
}

 function ippiResizeYUV420GetBufferSize( pSpec : IppiResizeYUV420SpecPtr ; dstSize : IppiSize ; pBufSize : Ipp32sPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeYUV420GetBorderSize
  Purpose:            Computes the size of possible borders for Resize transform

  Parameters:
    pSpec             Pointer to the Spec structure for resize filter
    borderSize        Size of necessary borders

  Return Values:
    ippStsNoErr           Indicates no error
    ippStsNullPtrErr      Indicates an error if one of the specified pointers is NULL
    ippStsContextMatchErr Indicates an error if pointer to an invalid pSpec structure is passed
}

 function ippiResizeYUV420GetBorderSize( pSpec : IppiResizeYUV420SpecPtr ; var borderSize : IppiBorderSize ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeYUV420GetSrcOffset
  Purpose:            Computes the offset of input image for Resize transform by tile processing

  Parameters:
    pSpec             Pointer to the Spec structure for resize filter
    dstOffset         Point of offset of tiled output image
    srcOffset         Pointer to the offset of input image

  Return Values:
    ippStsNoErr                Indicates no error
    ippStsNullPtrErr           Indicates an error if one of the specified pointers is NULL
    ippStsSizeErr              Indicates an error if width or height of the destination image is negative
    ippStsContextMatchErr      Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsOutOfRangeErr        Indicates an error if the destination image offset
                               point is outside the destination image origin
    ippStsMisalignedOffsetErr  Indicates an error if one of the fields of the dstOffset parameter is odd.
}

 function ippiResizeYUV420GetSrcOffset( pSpec : IppiResizeYUV420SpecPtr ; dstOffset : IppiPoint ; srcOffset : IppiPointPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeYUV420LanczosInit
                      ippiResizeYUV420SuperInit

  Purpose:            Initializes the Spec structure for the Resize transform
                      by different interpolation methods

  Parameters:
    srcSize           Size of the input image (in pixels)
    dstSize           Size of the output image (in pixels)
    pSpec             Pointer to the Spec structure for resize filter

  Return Values:
    ippStsNoErr                Indicates no error
    ippStsNullPtrErr           Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation          Indicates a warning if width or height of any image is zero
    ippStsSizeWrn              Indicates a warning if width or height of any image is odd
    ippStsSizeErr              Indicates an error in the following cases:
                                - if width or height of the source or destination image is equal to 1, 
                                - if width or height of the source or destination image is negative, 
                                - if the source image size is less than the chosen interpolation
                                  filter size (excepting ippSuper)
                                - if one of the specified dimensions of the source image is less than
                                  the corresponding dimension of the destination image (only for ippSuper)
    ippStsNotSupportedModeErr  Indicates an error if the requested mode is not supported

    Note.
    The implemented interpolation algorithms have the following filter sizes:
      2-lobed Lanczos 8x8,  3-lobed Lanczos 12x12.
}

 function ippiResizeYUV420LanczosInit( srcSize : IppiSize ; dstSize : IppiSize ; numLobes : Ipp32u ; pSpec : IppiResizeYUV420SpecPtr ; pInitBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeYUV420SuperInit( srcSize : IppiSize ; dstSize : IppiSize ; pSpec : IppiResizeYUV420SpecPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiResizeYUV420Lanczos_8u_P2R
                      ippiResizeYUV420Super_8u_P2R

  Purpose:            Changes an image size by different interpolation methods

  Parameters:
    pSrcY             Pointer to the source image Y plane
    srcYStep          Distance (in bytes) between of consecutive lines in the source image Y plane
    pSrcUV            Pointer to the source image UV plane
    srcUVStep         Distance (in bytes) between of consecutive lines in the source image UV plane
    pDstY             Pointer to the destination image Y plane
    dstYStep          Distance (in bytes) between of consecutive lines in the destination image Y plane
    pDstUV            Pointer to the destination image UV plane
    dstUVStep         Distance (in bytes) between of consecutive lines in the destination image UV plane
    dstOffset         Offset of tiled image respectively output origin image
    dstSize           Size of the output image (in pixels)
    border            Type of the border
    borderValue       Pointer to the constant value(s) if border type equals ippBorderConstant
    pSpec             Pointer to the Spec structure for resize filter
    pBuffer           Pointer to the work buffer

  Return Values:
    ippStsNoErr                Indicates no error
    ippStsNullPtrErr           Indicates an error if one of the specified pointers is NULL
    ippStsNoOperation          Indicates a warning if width or height of destination image is zero
    ippStsSizeWrn              Indicates a warning in the following cases:
                               - if width of the image is odd, 
                               - if the destination image exceeds the destination image origin
    ippStsSizeErr              Indicates an error if width of the destination image is equal to 1, 
                               or if width or height of the source or destination image is negative
    ippStsBorderErr            Indicates an error if border type has an illegal value
    ippStsContextMatchErr      Indicates an error if pointer to an invalid pSpec structure is passed
    ippStsMisalignedOffsetErr  Indicates an error if one of the fields of the dstOffset parameter is odd
    ippStsNotSupportedModeErr  Indicates an error if the requested mode is not supported

  Notes:
    1. Source 4:2:0 two-plane image format (NV12):
      All Y samples (pSrcY) are found first in memory as an array of unsigned char with an even number of lines memory alignment, 
      followed immediately by an array (pSrcUV) of unsigned char containing interleaved U and V samples.
    2. Supported border types are ippBorderInMemory and ippBorderReplicate for Lanczos methods.
}

 function ippiResizeYUV420Lanczos_8u_P2R( pSrcY : Ipp8uPtr ; srcYStep : Ipp32s ; pSrcUV : Ipp8uPtr ; srcUVStep : Ipp32s ; pDstY : Ipp8uPtr ; dstYStep : Ipp32s ; pDstUV : Ipp8uPtr ; dstUVStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiResizeYUV420SpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiResizeYUV420Super_8u_P2R( pSrcY : Ipp8uPtr ; srcYStep : Ipp32s ; pSrcUV : Ipp8uPtr ; srcUVStep : Ipp32s ; pDstY : Ipp8uPtr ; dstYStep : Ipp32s ; pDstUV : Ipp8uPtr ; dstUVStep : Ipp32s ; dstOffset : IppiPoint ; dstSize : IppiSize ; pSpec : IppiResizeYUV420SpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ -----------------------------------------------------------------------------------------------------
  Name:       ippiFilterBorderGetSize, ippiFilterBorderInit, ippiFilterBorder
  Purpose:    Filters an image using a general integer rectangular kernel
  Returns:
   ippStsNoErr       OK
   ippStsNullPtrErr  One of the pointers is NULL
   ippStsSizeErr     dstRoiSize or kernelSize has a field with zero or negative value
   ippStsDivisorErr  Divisor value is zero,  function execution is interrupted

  Parameters:
      pSrc        Distance, in bytes,  between the starting points of consecutive lines in the source image
      srcStep     Step in bytes through the source image buffer
      pDst        Pointer to the destination buffer
      dstStep     Distance, in bytes,  between the starting points of consecutive lines in the destination image
      dstRoiSize  Size of the source and destination ROI in pixels
      pKernel     Pointer to the kernel values
      kernelSize  Size of the rectangular kernel in pixels.
      divisor     The integer value by which the computed result is divided.
      kernelType  Kernel type (ipp16s|Ipp32f)
      dataType    Data type (ipp8u|ipp16u|Ipp32f)
      numChannels Number of channels,  possible values are 1,  3 or 4
      roundMode   Rounding mode (ippRndZero, ippRndNear or ippRndFinancial)
      pSpecSize   Pointer to the size (in bytes) of the spec structure
      pBufSize    Pointer to the size (in bytes) of the external buffer
      pSpec       Pointer to pointer to the allocated and initialized context structure
      borderType  Type of the border
      borderValue Pointer to the constant value(s) if border type equals ippBorderConstant
      pBuffer     Pointer to the work buffer. It can be equal to NULL if optimization algorithm doesn`t demand a work buffer
}

 function ippiFilterBorderGetSize( kernelSize : IppiSize ; dstRoiSize : IppiSize ; dataType : IppDataType ; kernelType : IppDataType ; numChannels : Int32 ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippiFilterBorderInit_16s( pKernel : Ipp16sPtr ; kernelSize : IppiSize ; divisor : Int32 ; dataType : IppDataType ; numChannels : Int32 ; roundMode : IppRoundMode ; pSpec : IppiFilterBorderSpecPtr ): IppStatus; _ippapi
 function ippiFilterBorderInit_32f( pKernel : Ipp32fPtr ; kernelSize : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; roundMode : IppRoundMode ; pSpec : IppiFilterBorderSpecPtr ): IppStatus; _ippapi
 function ippiFilterBorder_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp8uPtr ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBorder_8u_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp8u_3 ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBorder_8u_C4R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp8u_4 ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBorder_16u_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp16uPtr ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBorder_16u_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp16u_3 ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBorder_16u_C4R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp16u_4 ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBorder_16s_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; borderValue : Ipp16sPtr ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBorder_16s_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp16s_3 ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBorder_16s_C4R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp16s_4 ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBorder_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; pBorderValue : Ipp32fPtr ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBorder_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp32f_3 ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiFilterBorder_32f_C4R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; border : IppiBorderType ; const borderValue : Ipp32f_4 ; pSpec : IppiFilterBorderSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{
  Name:       ippiFilterBorderSetMode
  Purpose:    Set offset value for Ipp8u and Ipp16u and roundMode (Fast or Accurate)
                               
  Parameters:
    hint        ippAlgHintNone, ippAlgHintFast, ippAlgHintAccurate.  Default, fast or accurate rounding.
                             ippAlgHintNone and ippAlgHintFast - default modes,  mean that the most common rounding is performed with 
                             roundMode passed to Init function,  but function performance takes precedence over accuracy and some output
                             pixels can differ on +-1 from exact result
                             ippAlgHintAccurate means that all output pixels are exact and accuracy takes precedence over performance
    offset             offset value. It is just a constant that is added to the final signed result before converting it to unsigned for Ipp8u and Ipp16u data types
    pSpec            Pointer to the initialized ippiFilter Spec

  Returns:
    ippStsNoErr       no errors
    ippStsNullPtrErr  one of the pointers is NULL
    ippStsNotSupportedModeErr     the offset value is not supported,  for Ipp16s and Ipp32f data types.
    ippStsAccurateModeNotSupported the accurate mode not supported for some data types. The result of rounding can be inexact.
}

 function ippiFilterBorderSetMode( hint : IppHintAlgorithm ; offset : Int32 ; pSpec : IppiFilterBorderSpecPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------------------------------
  Name:       ippiLBPImageMode
  Purpose:    Calculates the LBP of the image.
  Parameters:
    pSrc        Pointer to the source image ROI.
    srcStep     Distance in bytes between starting points of consecutive lines in the source image.
    pDst        Pointer to the destination image ROI.
    dstStep     Distance in bytes between starting points of consecutive lines in the destination image.
    dstRoiSize  Size of the destination ROI in pixels.
    mode        Specify how LBP is created.
    borderType  Type of border.
                Possible values are:
                     ippBorderRepl Border is replicated from the edge pixels.
                     ippBorderInMem Border is obtained from the source image pixels in memory.
                     Mixed borders are also supported.
                     They can be obtained by the bitwise operation OR between ippBorderRepl and ippBorderInMemTop,  ippBorderInMemBottom, ippBorderInMemLeft, ippBorderInMemRight.
    borderValue Constant value to assign to pixels of the constant border. This parameter is applicable only to the ippBorderConst border type.
  Returns:
    ippStsNoErr      Indicates no error.
    ippStsNullPtrErr Indicates an error when one of the specified pointers is NULL.
    ippStsSizeErr    Indicates an error if dstRoiSize has a field with zero or negative value.
    ippStsBadArgErr  Indicates an error when border has an illegal value.
}

 function ippiLBPImageMode3x3_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mode : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp8uPtr ): IppStatus; _ippapi
 function ippiLBPImageMode5x5_8u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mode : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp8uPtr): IppStatus; _ippapi
 function ippiLBPImageMode5x5_8u16u_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mode : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp8uPtr): IppStatus; _ippapi
 function ippiLBPImageMode3x3_32f8u_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mode : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp32fPtr ): IppStatus; _ippapi
 function ippiLBPImageMode5x5_32f8u_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mode : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp32fPtr ): IppStatus; _ippapi
 function ippiLBPImageMode5x5_32f16u_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; mode : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp32fPtr ): IppStatus; _ippapi



{ ----------------------------------------------------------------------------------------------------
  Name:       ippiLBPImageHorizCorr_...
  Purpose:    Calculates a correlation between two LBPs.
  Parameters:
    pSrc1, pSrc2       Pointers to the source images ROI.
    srcStep1, srcStep2 Distance in bytes between starting points of consecutive lines in the source image.
    pDst               Pointer to the destination image ROI.
    dstStep            Distance in bytes between starting points of consecutive lines in the destination image.
    dstRoiSize         Size of the destination ROI in pixels.
    horShift           Horizontal shift of the pSrc2 image.
    borderType         Type of border. Possible values are:
                           ippBorderRepl      Border is replicated from the edge pixels.
                           ippBorderInMem     Border is obtained from the source image pixels in memory.
                           Mixed borders are also supported.
                           They can be obtained by the bitwise operation OR between ippBorderRepl and ippBorderInMemTop,  ippBorderInMemBottom, ippBorderInMemLeft, ippBorderInMemRight.
    borderValue         Constant value to assign to pixels of the constant border. This parameter is applicable only to the ippBorderConst border type.
  Returns:
    ippStsNoErr      Indicates no error.
    ippStsNullPtrErr Indicates an error when one of the specified pointers is NULL.
    ippStsSizeErr    Indicates an error if dstRoiSize has a field with zero or negative value.
    ippStsBadArgErr  Indicates an error when border has an illegal value.
}

 function ippiLBPImageHorizCorr_8u_C1R( pSrc1 : Ipp8uPtr ; src1Step : Int32 ; pSrc2 : Ipp8uPtr ; src2Step : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; horShift : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp8uPtr): IppStatus; _ippapi
 function ippiLBPImageHorizCorr_16u_C1R( pSrc1 : Ipp16uPtr ; src1Step : Int32 ; pSrc2 : Ipp16uPtr ; src2Step : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstRoiSize : IppiSize ; horShift : Int32 ; borderType : IppiBorderType ; pBorderValue : Ipp16uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name: ippiSADGetBufferSize

 Purpose: Compute size of the work buffer for the ippiSAD

 Parameters:
    srcRoiSize  size of the source ROI in pixels
    tplRoiSize  size of the template ROI in pixels
    dataType    input data specifier
    numChannels Number of channels in the images
    shape       enumeration, defined shape result of the following SAD operation
    pBufferSize pointer to the computed value of the external buffer size

  Return:
   ippStsNoErr        no errors
   ippStsNullPtrErr   pBufferSize==NULL
   ippStsSizeErr      0>=srcRoiSize.width || 0>=srcRoiSize.height
                      0>=tplRoiSize.width || 0>=tplRoiSize.height
   ippStsDataTypeErr  dataType!=8u or dataType!=16u or dataType!=16s or dataType!=32f
   ippStsNotSupportedModeErr  shape != ippiROIValid
                              numChannels != 1
                              dataType has an illegal value
}

 function ippiSADGetBufferSize( srcRoiSize : IppiSize ; tplRoiSize : IppiSize ; dataType : IppDataType ; numChannels : Int32 ; shape : IppiROIShape ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name: ippiSAD_...

 Purpose: Sum of Absolute Differences of given image and template

 Parameters:
    pSrc        pointer to source ROI
    srcStep     step through the source image
    srcRoiSize  size of sourse ROI (pixels)
    pTpl        pointer to template (source) ROI
    tplStep     step through the template image
    tplRoiSize  size of template ROI (pixels)
    pDst        pointer to destination ROI
    dstStep     step through the destination image
    shape       defined shape result of the SAD operation
    scaleFactor scale factor
    pBuffer     pointer to the buffer for internal computation (is currentry used)

 Return status:
    ippStsNoErr                no errors
    ippStsNullPtrErr           pSrc==NULL or pTpl==NULL or pDst==NULL
    ippStsStepErr              srcStep/dstStep has a zero or negative value
                               srcStep/dstStep value is not multiple to image data size
    ippStsSizeErr              ROI has any field with zero or negative value
    ippStsNotSupportedModeErr  intersection of source and destination ROI is detected
                               shape!=ippiROIValid
    ippStsBadArgErr            illegal scaleFactor value,  i.e. !(0<=scalefactor<log(W*H)
*}

 function ippiSAD_8u32s_C1RSfs( pSrc : Ipp8uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp8uPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; shape : IppiROIShape ; scaleFactor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiSAD_16u32s_C1RSfs( pSrc : Ipp16uPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp16uPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; shape : IppiROIShape ; scaleFactor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiSAD_16s32s_C1RSfs( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp16sPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp32sPtr ; dstStep : Int32 ; shape : IppiROIShape ; scaleFactor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiSAD_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; srcRoiSize : IppiSize ; pTpl : Ipp32fPtr ; tplStep : Int32 ; tplRoiSize : IppiSize ; pDst : Ipp32fPtr ; dstStep : Int32 ; shape : IppiROIShape ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippiGradientVectorGetBufferSize

  Purpose:            Computes the size of the external buffer for
                      Gradient() calls

  Parameters:
    roiSize           Size of destination ROI in pixels
    mask              Predefined mask of IppiMaskSize type. Possible values are ippMask3x3 or ippMask5x5
    dataType          Input data type specifier
    numChannels       Number of channels of the input image
    pBufferSize       Pointer to the size (in bytes) of the external work buffer.

  Return Values:
    ippStsNoErr        Indicates no error
    ippStsNullPtrErr   Indicates an error when pBufferSize is NULL
    ippStsDataTypeErr  dataType!=8u or dataType!=16u or dataType!=16s or dataType!=32f
    ippStsSizeErr      Indicates an error when roiSize is negative,  or equal to zero.
    ippStsMaskSizeErr  Indicates an error condition if mask has a wrong value
}

 function ippiGradientVectorGetBufferSize( roiSize : IppiSize ; mask : IppiMaskSize ; dataType : IppDataType ; numChannels : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name: ippiGradientVectorSobel_8u16s_C1R
       ippiGradientVectorSobel_16u32f_C1R
       ippiGradientVectorSobel_16s32f_C1R
       ippiGradientVectorSobel_32f_C1R

       ippiGradientVectorScharr_8u16s_C1R
       ippiGradientVectorScharr_16u32f_C1R
       ippiGradientVectorScharr_16s32f_C1R
       ippiGradientVectorScharr_32f_C1R

       ippiGradientVectorPrewitt_8u16s_C1R
       ippiGradientVectorPrewitt_16u32f_C1R
       ippiGradientVectorPrewitt_16s32f_C1R
       ippiGradientVectorPrewitt_32f_C1R

       ippiGradientVectorSobel_8u16s_C3C1R
       ippiGradientVectorSobel_16u32f_C3C1R
       ippiGradientVectorSobel_16s32f_C3C1R
       ippiGradientVectorSobel_32f_C3C1R

       ippiGradientVectorScharr_8u16s_C3C1R
       ippiGradientVectorScharr_16u32f_C3C1R
       ippiGradientVectorScharr_16s32f_C3C1R
       ippiGradientVectorScharr_32f_C3C1R

       ippiGradientVectorPrewitt_8u16s_C3C1R
       ippiGradientVectorPrewitt_16u32f_C3C1R
       ippiGradientVectorPrewitt_16s32f_C3C1R
       ippiGradientVectorPrewitt_32f_C3C1R

 Purpose: Computes gradient vectors over an image using Sobel,  Scharr or Prewitt operator

 Parameters:
    pSrc        pointer to source ROI
    srcStep     step through the source image
    pGx         pointer to the X-component of computed gradient
    gxStep      step through the X-component image
    pGy         pointer to the Y-component of computed gradient
    gyStep      step through the Y-component image
    pMag        pointer to the magnitude of computed gradient
    magStep     step through the magnitude image
    pAngle      pointer to the angle of computed gradient
    angleStep   step through the magnitude image
    dstRoiSize  size of destination
    mask        operator size specfier
    normType    normalization type (L1 or L2) specfier
    borderType  kind of border specfier
    borderValue constant border value
    pBuffer     pointer to the buffer for internal computation  (is currently used)

 Return status:
    ippStsNoErr          no error
    ippStsNullPtrErr     pSrc==NULL
    ippStsStepErr        srcStep has a zero or negative value
                         applicable gxStep or gyStep or magStep or angleStep has a zero or negative value
                         or is not multiple to image data size (4 for floating-point images or by 2 for short-integer images)
    ippStsSizeErr        ROI has any field with zero or negative value
    ippStsMaskSizeErr    illegal maskSize specfier value
    ippStsBadArgErr      illegal normType specfier value
    ippStsBorderErr      illegal borderType specfier value
}

 function ippiGradientVectorSobel_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pGx : Ipp16sPtr ; gxStep : Int32 ; pGy : Ipp16sPtr ; gyStep : Int32 ; pMag : Ipp16sPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorSobel_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp16u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorSobel_16s32f_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorSobel_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiGradientVectorScharr_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pGx : Ipp16sPtr ; gxStep : Int32 ; pGy : Ipp16sPtr ; gyStep : Int32 ; pMag : Ipp16sPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorScharr_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp16u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorScharr_16s32f_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorScharr_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiGradientVectorPrewitt_8u16s_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pGx : Ipp16sPtr ; gxStep : Int32 ; pGy : Ipp16sPtr ; gyStep : Int32 ; pMag : Ipp16sPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorPrewitt_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp16u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorPrewitt_16s32f_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorPrewitt_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiGradientVectorSobel_8u16s_C3C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pGx : Ipp16sPtr ; gxStep : Int32 ; pGy : Ipp16sPtr ; gyStep : Int32 ; pMag : Ipp16sPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorSobel_16u32f_C3C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorSobel_16s32f_C3C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorSobel_32f_C3C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiGradientVectorScharr_8u16s_C3C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pGx : Ipp16sPtr ; gxStep : Int32 ; pGy : Ipp16sPtr ; gyStep : Int32 ; pMag : Ipp16sPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorScharr_16u32f_C3C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorScharr_16s32f_C3C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorScharr_32f_C3C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiGradientVectorPrewitt_8u16s_C3C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pGx : Ipp16sPtr ; gxStep : Int32 ; pGy : Ipp16sPtr ; gyStep : Int32 ; pMag : Ipp16sPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorPrewitt_16u32f_C3C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorPrewitt_16s32f_C3C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiGradientVectorPrewitt_32f_C3C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; pGx : Ipp32fPtr ; gxStep : Int32 ; pGy : Ipp32fPtr ; gyStep : Int32 ; pMag : Ipp32fPtr ; magStep : Int32 ; pAngle : Ipp32fPtr ; angleStep : Int32 ; dstRoiSize : IppiSize ; maskSize : IppiMaskSize ; normType : IppNormType ; borderType : IppiBorderType ; const borderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippiHOGGetSize

 Purpose:             Computes size of HOG spec

 Parameters:
    pConfig           pointer to HOG configure
    pSpecSize         pointer to the size of HOG spec

 Return status:
    ippStsNoErr          Indicates no error
    ippStsNullPtrErr     Indicates an error when pConfig or pSpecSize is NULL
    ippStsSizeErr        Indicates an error in HOG configure:
                         size of detection window has any field with zero or negative value
    ippStsNotSupportedModeErr Indicates an error in HOG configure:
                         - 2>cellSize or cellSize>IPP_HOG_MAX_CELL
                         - cellSize>blockSize or blockSize>IPP_HOG_MAX_BLOCK
                         - blockSize is not multiple cellSize
                         - block has not 2x2 cell geomentry
                         - blockStride is not multiple cellSize
                         - detection window size is not multiple blockSize
                         - 2>nbins or nbins>IPP_HOG_MAX_BINS
                         - sigma or l2thresh is not positive value
}

 function ippiHOGGetSize( pConfig : IppiHOGConfigPtr ; pHOGSpecSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippiHOGInit

 Purpose:             Initialize the HOG spec for future use

 Parameters:
    pConfig           pointer to HOG configure
    pHOGSpec          pointer to the HOG spec

 Return status:
    ippStsNoErr          Indicates no error
    ippStsNullPtrErr     Indicates an error when pConfig or pHOGSpec is NULL

    ippStsSizeErr        Indicates an error when size of detection window
                         defined in pConfig is not match to other
                         (blockSize and blockStride) geometric parameters
    ippStsNotSupportedModeErr Indicates an error in HOG configure:
                         - 2>cellSize or cellSize>IPP_HOG_MAX_CELL
                         - cellSize>blockSize or blockSize>IPP_HOG_MAX_BLOCK
                         - blockSize is not multiple cellSize
                         - block has not 2x2 cell geomentry
                         - blockStride is not multiple cellSize
                         - 2>nbins or nbins>IPP_HOG_MAX_BINS
                         - sigma or l2thresh is not positive value
}

 function ippiHOGInit( pConfig : IppiHOGConfigPtr ; pHOGSpec : IppiHOGSpecPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippiHOGGetBufferSize

 Purpose:             Computes size of work buffer

 Parameters:
    pHOGSpec          pointer to the HOG spec
    roiSize           max size of input ROI (pixels)
    pBufferSize       pointer to the size of work buffer (in bytes)

 Return status:
    ippStsNoErr          Indicates no error
    ippStsNullPtrErr     Indicates an error when pHOGSpec or pBufferSizeis is NULL
    ippStsContextMatchErr Indicates an error when undefined pHOGSpec
    ippStsSizeErr        Indicates an error if roiSize has any field is less then pConfig->winSize
}

 function ippiHOGGetBufferSize( pHOGSpec : IppiHOGSpecPtr ; roiSize : IppiSize ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippiHOGGetDescriptorSize

 Purpose:             Computes size of HOG descriptor

 Parameters:
    pHOGSpec             pointer to the HOG spec
    pWinDescriptorSize   pointer to the size of HOG descriptor (in bytes)
                         per each detection window

 Return status:
    ippStsNoErr          Indicates no error
    ippStsNullPtrErr     Indicates an error when pHOGSpec or pDescriptorSize is NULL
    ippStsContextMatchErr Indicates an error when undefined pHOGSpec
}

 function ippiHOGGetDescriptorSize( pHOGSpec : IppiHOGSpecPtr ; pWinDescriptorSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippiHOG

 Purpose:             Computes HOG descriptor

 Parameters:
    pSrc              pointer to the input detection window
    roiSize           size of detection window
    srcStep           input image step
    pLocation         array of locations of interest (LOI) (detection window position)
    nLocations        number of LOI
    pDst              pointer to the HOG descriptor
    pHOGSpec          pointer to the HOG spec
    borderID          border type specifier
    borderValue       border constant value
    pBuffer           pointer to the work buffer

 Return status:
    ippStsNoErr          Indicates no error
    ippStsNullPtrErr     Indicates an error when pHOGSpec,  pSrc, or pDst is NULL
    ippStsContextMatchErr Indicates an error when undefined pHOGSpec
    ippStsStepErr        Indicates an error is input image step isn`t positive
    ippStsNotEvenStepErr Indicates an error when srcStep is not multiple input data type
    ippStsSizeErr        Indicates an error if roiSize isn`t matchs to HOG context
    ippStsBorderErr      Indicates an error when borderID is not
                         ippBorderInMem, ippBorderRepl or ippBorderConst
                         (or derivative from)
}

 function ippiHOG_8u32f_C1R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pLocation : IppiPointPtr ; nLocations : Int32 ; pDst : Ipp32fPtr ; pHOGSpec : IppiHOGSpecPtr ; borderID : IppiBorderType ; borderValue : Ipp8u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHOG_16u32f_C1R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pLocation : IppiPointPtr ; nLocations : Int32 ; pDst : Ipp32fPtr ; pHOGSpec : IppiHOGSpecPtr ; borderID : IppiBorderType ; borderValue : Ipp16u ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHOG_16s32f_C1R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pLocation : IppiPointPtr ; nLocations : Int32 ; pDst : Ipp32fPtr ; pHOGSpec : IppiHOGSpecPtr ; borderID : IppiBorderType ; borderValue : Ipp16s ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHOG_32f_C1R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pLocation : IppiPointPtr ; nLocations : Int32 ; pDst : Ipp32fPtr ; pHOGSpec : IppiHOGSpecPtr ; borderID : IppiBorderType ; borderValue : Ipp32f ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippiHOG_8u32f_C3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pLocation : IppiPointPtr ; nLocations : Int32 ; pDst : Ipp32fPtr ; pHOGCtx : IppiHOGSpecPtr ; borderID : IppiBorderType ; borderValue : Ipp8u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHOG_16u32f_C3R( pSrc : Ipp16uPtr ; srcStep : Int32 ; roiSize : IppiSize ; pLocation : IppiPointPtr ; nLocations : Int32 ; pDst : Ipp32fPtr ; pHOGCtx : IppiHOGSpecPtr ; borderID : IppiBorderType ; borderValue : Ipp16u_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHOG_16s32f_C3R( pSrc : Ipp16sPtr ; srcStep : Int32 ; roiSize : IppiSize ; pLocation : IppiPointPtr ; nLocations : Int32 ; pDst : Ipp32fPtr ; pHOGCtx : IppiHOGSpecPtr ; borderID : IppiBorderType ; borderValue : Ipp16s_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippiHOG_32f_C3R( pSrc : Ipp32fPtr ; srcStep : Int32 ; roiSize : IppiSize ; pLocation : IppiPointPtr ; nLocations : Int32 ; pDst : Ipp32fPtr ; pHOGCtx : IppiHOGSpecPtr ; borderID : IppiBorderType ; borderValue : Ipp32f_3 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

           3D Geometric Transform Functions
---------------------------------------------------------------------------- }

{
  Name:               ipprResizeGetBufSize
  Purpose:            Computes the size of an external work buffer (in bytes)
  Parameters:
    srcVOI            region of interest of source volume
    dstVOI            region of interest of destination volume
    nChannel          number of channels
    interpolation     type of interpolation to perform for resizing the input volume:
                        IPPI_INTER_NN      nearest neighbor interpolation
                        IPPI_INTER_LINEAR  trilinear interpolation
                        IPPI_INTER_CUBIC   tricubic polynomial interpolation
                      including two-parameter cubic filters:
                        IPPI_INTER_CUBIC2P_BSPLINE      B-spline filter (1, 0)
                        IPPI_INTER_CUBIC2P_CATMULLROM   Catmull-Rom filter (0, 1/2)
                        IPPI_INTER_CUBIC2P_B05C03       special filter with parameters (1/2, 3/10)
    pSize             pointer to the external buffer`s size
  Returns:
    ippStsNoErr             no errors
    ippStsNullPtrErr        pSize == NULL
    ippStsSizeErr           width or height or depth of volumes is less or equal zero
    ippStsNumChannelsErr    number of channels is not one
    ippStsInterpolationErr  (interpolation != IPPI_INTER_NN) &&
                            (interpolation != IPPI_INTER_LINEAR) &&
                            (interpolation != IPPI_INTER_CUBIC) &&
                            (interpolation != IPPI_INTER_CUBIC2P_BSPLINE) &&
                            (interpolation != IPPI_INTER_CUBIC2P_CATMULLROM) &&
                            (interpolation != IPPI_INTER_CUBIC2P_B05C03)
}

 function ipprResizeGetBufSize( srcVOI : IpprCuboid ; dstVOI : IpprCuboid ; nChannel : Int32 ; interpolation : Int32 ; var pSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ipprGetResizeCuboid
  Purpose:            Computes coordinates of the destination volume
  Parameters:
    srcVOI            volume of interest of source volume
    pDstCuboid        resultant cuboid
    xFactor           they specify fraction of resizing in X direction
    yFactor           they specify fraction of resizing in Y direction
    zFactor           they specify fraction of resizing in Z direction
    xShift            they specify shifts of resizing in X direction
    yShift            they specify shifts of resizing in Y direction
    zShift            they specify shifts of resizing in Z direction
    interpolation     type of interpolation
  Returns:
    ippStsNoErr             no errors
    ippStsSizeErr           width or height or depth of srcVOI is less or equal zero
    ippStsResizeFactorErr   xFactor or yFactor or zFactor is less or equal zero
    ippStsInterpolationErr  interpolation has an illegal value
    ippStsNullPtrErr        pDstCuboid == NULL
}

 function ipprGetResizeCuboid( srcVOI : IpprCuboid ; pDstCuboid : IpprCuboidPtr ; xFactor : double ; yFactor : double ; zFactor : double ; xShift : double ; yShift : double ; zShift : double ; interpolation : Int32 ): IppStatus; _ippapi

{
  Name:               ipprResize_<mode>
  Purpose:            Performs RESIZE transform of the source volume
                      by xFactor,  yFactor, zFactor and xShift,  yShift, zShift
                            |X'|   |xFactor    0       0   |   |X|   |xShift|
                            |Y'| = |        yFactor    0   | * |Y| + |yShift|
                            |Z'|   |   0       0    zFactor|   |Z|   |zShift|
  Parameters:
    pSrc              pointer to source volume data (8u_C1V, 16u_C1V, 32f_C1V modes)
                      or array of pointers to planes in source volume data
    srcVolume         size of source volume
    srcStep           step in every plane of source volume
    srcPlaneStep      step between planes of source volume (8u_C1V, 16u_C1V, 32f_C1V modes)
    srcVOI            volume of interest of source volume
    pDst              pointer to destination volume data (8u_C1V and 16u_C1V modes)
                      or array of pointers to planes in destination volume data
    dstStep           step in every plane of destination volume
    dstPlaneStep      step between planes of destination volume (8u_C1V, 16u_C1V, 32f_C1V modes)
    dstVOI            volume of interest of destination volume
    xFactor           they specify fraction of resizing in X direction
    yFactor           they specify fraction of resizing in Y direction
    zFactor           they specify fraction of resizing in Z direction
    xShift            they specify shifts of resizing in X direction
    yShift            they specify shifts of resizing in Y direction
    zShift            they specify shifts of resizing in Z direction
    interpolation     type of interpolation to perform for resizing the input volume:
                        IPPI_INTER_NN      nearest neighbor interpolation
                        IPPI_INTER_LINEAR  trilinear interpolation
                        IPPI_INTER_CUBIC   tricubic polynomial interpolation
                      including two-parameter cubic filters:
                        IPPI_INTER_CUBIC2P_BSPLINE      B-spline filter (1, 0)
                        IPPI_INTER_CUBIC2P_CATMULLROM   Catmull-Rom filter (0, 1/2)
                        IPPI_INTER_CUBIC2P_B05C03       special filter with parameters (1/2, 3/10)
    pBuffer           pointer to work buffer
  Returns:
    ippStsNoErr             no errors
    ippStsNullPtrErr        pSrc == NULL or pDst == NULL or pBuffer == NULL
    ippStsSizeErr           width or height or depth of volumes is less or equal zero
    ippStsWrongIntersectVOI VOI hasn`t an intersection with the source or destination volume
    ippStsResizeFactorErr   xFactor or yFactor or zFactor is less or equal zero
    ippStsInterpolationErr  (interpolation != IPPI_INTER_NN) &&
                            (interpolation != IPPI_INTER_LINEAR) &&
                            (interpolation != IPPI_INTER_CUBIC) &&
                            (interpolation != IPPI_INTER_CUBIC2P_BSPLINE) &&
                            (interpolation != IPPI_INTER_CUBIC2P_CATMULLROM) &&
                            (interpolation != IPPI_INTER_CUBIC2P_B05C03)
  Notes:
    <mode> are 8u_C1V or 16u_C1V or 32f_C1V or 8u_C1PV or 16u_C1PV or 32f_C1PV
}

 function ipprResize_8u_C1V( pSrc : Ipp8uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcPlaneStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstPlaneStep : Int32 ; dstVOI : IpprCuboid ; xFactor : double ; yFactor : double ; zFactor : double ; xShift : double ; yShift : double ; zShift : double ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ipprResize_16u_C1V( pSrc : Ipp16uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcPlaneStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstPlaneStep : Int32 ; dstVOI : IpprCuboid ; xFactor : double ; yFactor : double ; zFactor : double ; xShift : double ; yShift : double ; zShift : double ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ipprResize_32f_C1V( pSrc : Ipp32fPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcPlaneStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstPlaneStep : Int32 ; dstVOI : IpprCuboid ; xFactor : double ; yFactor : double ; zFactor : double ; xShift : double ; yShift : double ; zShift : double ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ipprResize_8u_C1PV( pSrc : Ipp8uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstVOI : IpprCuboid ; xFactor : double ; yFactor : double ; zFactor : double ; xShift : double ; yShift : double ; zShift : double ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ipprResize_16u_C1PV( pSrc : Ipp16uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstVOI : IpprCuboid ; xFactor : double ; yFactor : double ; zFactor : double ; xShift : double ; yShift : double ; zShift : double ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ipprResize_32f_C1PV( pSrc : Ipp32fPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstVOI : IpprCuboid ; xFactor : double ; yFactor : double ; zFactor : double ; xShift : double ; yShift : double ; zShift : double ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi


{
  Name:               ipprWarpAffineGetBufSize
  Purpose:            Computes the size of an external work buffer (bytes : in )
  Parameters:
    srcVolume         size of source volume
    srcVOI            region of interest of source volume
    dstVOI            region of interest of destination volume
    coeffs            affine transform matrix
    nChannel          number of channels
    interpolation     type of interpolation to perform for resizing the input volume:
                        IPPI_INTER_NN      nearest neighbor interpolation
                        IPPI_INTER_LINEAR  trilinear interpolation
                        IPPI_INTER_CUBIC   tricubic polynomial interpolation
                      including two-parameter cubic filters:
                        IPPI_INTER_CUBIC2P_BSPLINE      B-spline filter (1, 0)
                        IPPI_INTER_CUBIC2P_CATMULLROM   Catmull-Rom filter (0, 1/2)
                        IPPI_INTER_CUBIC2P_B05C03       special filter with parameters (1/2, 3/10)
    pSize             pointer to the external buffer`s size
  Returns:
    ippStsNoErr             no errors
    ippStsNullPtrErr        pSize == NULL or coeffs == NULL
    ippStsSizeErr           size of source or destination volumes is less or equal zero
    ippStsNumChannelsErr    number of channels is not one
    ippStsInterpolationErr  (interpolation != IPPI_INTER_NN) &&
                            (interpolation != IPPI_INTER_LINEAR) &&
                            (interpolation != IPPI_INTER_CUBIC) &&
                            (interpolation != IPPI_INTER_CUBIC2P_BSPLINE) &&
                            (interpolation != IPPI_INTER_CUBIC2P_CATMULLROM) &&
                            (interpolation != IPPI_INTER_CUBIC2P_B05C03)
}

 function ipprWarpAffineGetBufSize( srcVolume : IpprVolume ; srcVOI : IpprCuboid ; dstVOI : IpprCuboid ; const coeffs : double_3_4 ; nChannel : Int32 ; interpolation : Int32 ; var pSize : Int32 ): IppStatus; _ippapi

{
  Names:              ipprWarpAffine_<mode>
  Purpose:            Performs AFFINE transform of the source volume by matrix a[3][4]
                            |X'|   |a00 a01 a02|   |X|   |a03|
                            |Y'| = |a10 a11 a12| * |Y| + |a13|
                            |Z'|   |a20 a21 a22|   |Z|   |a23|
  Parameters:
    pSrc              array of pointers to planes in source volume data
    srcVolume         size of source volume
    srcStep           step in every plane of source volume
    srcVOI            volume of interest of source volume
    pDst              array of pointers to planes in destination volume data
    dstStep           step in every plane of destination volume
    dstVOI            volume of interest of destination volume
    coeffs            affine transform matrix
    interpolation     type of interpolation to perform for affine transform the input volume:
                        IPPI_INTER_NN      nearest neighbor interpolation
                        IPPI_INTER_LINEAR  trilinear interpolation
                        IPPI_INTER_CUBIC   tricubic polynomial interpolation
                      including two-parameter cubic filters:
                        IPPI_INTER_CUBIC2P_BSPLINE      B-spline filter (1, 0)
                        IPPI_INTER_CUBIC2P_CATMULLROM   Catmull-Rom filter (0, 1/2)
                        IPPI_INTER_CUBIC2P_B05C03       special filter with parameters (1/2, 3/10)
    pBuffer           pointer to work buffer
  Returns:
    ippStsNoErr             no errors
    ippStsNullPtrErr        pSrc == NULL or pDst == NULL or pBuffer == NULL or coeffs == NULL
    ippStsSizeErr           width or height or depth of source volume is less or equal zero
    ippStsWrongIntersectVOI VOI hasn`t an intersection with the source or destination volume
    ippStsCoeffErr          determinant of the transform matrix Aij is equal to zero
    ippStsInterpolationErr  interpolation has an illegal value
  Notes:
    <mode> are 8u_C1PV or 16u_C1PV or 32f_C1PV
}

 function ipprWarpAffine_8u_C1PV( pSrc : Ipp8uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstVOI : IpprCuboid ; const coeffs : double_3_4 ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ipprWarpAffine_16u_C1PV( pSrc : Ipp16uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstVOI : IpprCuboid ; const coeffs : double_3_4 ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ipprWarpAffine_32f_C1PV( pSrc : Ipp32fPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstVOI : IpprCuboid ; const coeffs : double_3_4 ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{
  Names:              ipprWarpAffine_<mode>
  Purpose:            Performs AFFINE transform of the source volume by matrix a[3][4]
                            |X'|   |a00 a01 a02|   |X|   |a03|
                            |Y'| = |a10 a11 a12| * |Y| + |a13|
                            |Z'|   |a20 a21 a22|   |Z|   |a23|
  Parameters:
    pSrc              array of pointers to planes in source volume data
    srcVolume         size of source volume
    srcStep           step in every plane of source volume
    srcPlaneStep      step between planes of source volume (8u_C1V, 16u_C1V, 32f_C1V modes)
    srcVOI            volume of interest of source volume
    pDst              array of pointers to planes in destination volume data
    dstStep           step in every plane of destination volume
    dstPlaneStep      step between planes of destination volume (8u_C1V, 16u_C1V, 32f_C1V modes)
    dstVOI            volume of interest of destination volume
    coeffs            affine transform matrix
    interpolation     type of interpolation to perform for affine transform the input volume:
                        IPPI_INTER_NN      nearest neighbor interpolation
                        IPPI_INTER_LINEAR  trilinear interpolation
                        IPPI_INTER_CUBIC   tricubic polynomial interpolation
                      including two-parameter cubic filters:
                        IPPI_INTER_CUBIC2P_BSPLINE      B-spline filter (1, 0)
                        IPPI_INTER_CUBIC2P_CATMULLROM   Catmull-Rom filter (0, 1/2)
                        IPPI_INTER_CUBIC2P_B05C03       special filter with parameters (1/2, 3/10)
    pBuffer           pointer to work buffer
  Returns:
    ippStsNoErr             no errors
    ippStsNullPtrErr        pSrc == NULL or pDst == NULL or pBuffer == NULL or coeffs == NULL
    ippStsSizeErr           width or height or depth of source volume is less or equal zero
    ippStsWrongIntersectVOI VOI hasn't an intersection with the source or destination volume
    ippStsCoeffErr          determinant of the transform matrix Aij is equal to zero
    ippStsInterpolationErr  interpolation has an illegal value
  Notes:
    <mode> are 8u_C1V or 16u_C1V or 32f_C1V
}

 function ipprWarpAffine_8u_C1V( pSrc : Ipp8uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcPlaneStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstPlaneStep : Int32 ; dstVOI : IpprCuboid ; const coeffs : double_3_4 ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ipprWarpAffine_16u_C1V( pSrc : Ipp16uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcPlaneStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstPlaneStep : Int32 ; dstVOI : IpprCuboid ; const coeffs : double_3_4 ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ipprWarpAffine_32f_C1V( pSrc : Ipp32fPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcPlaneStep : Int32 ; srcVOI : IpprCuboid ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstPlaneStep : Int32 ; dstVOI : IpprCuboid ; const coeffs : double_3_4 ; interpolation : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{
  Names:              ipprRemap_<mode>
  Purpose:            Performs REMAP TRANSFORM of the source volume by remapping
                        dst[i,j,k] = src[xMap[i,j,k], yMap[i,j,k], zMap[i,j,k]]
  Parameters:
    pSrc              array of pointers to planes in source volume data
    srcVolume         size of source volume
    srcStep           step in every plane of source volume
    srcVOI            volume of interest of source volume
    pxMap             array of pointers to images with X coordinates of map
    pyMap             array of pointers to images with Y coordinates of map
    pzMap             array of pointers to images with Z coordinates of map
    mapStep           step in every plane of each map volumes
    pDst              array of pointers to planes in destination volume data
    dstStep           step in every plane of destination volume
    dstVolume         size of destination volume
    interpolation     type of interpolation to perform for resizing the input volume:
                        IPPI_INTER_NN      nearest neighbor interpolation
                        IPPI_INTER_LINEAR  trilinear interpolation
                        IPPI_INTER_CUBIC   tricubic polynomial interpolation
                      including two-parameter cubic filters:
                        IPPI_INTER_CUBIC2P_BSPLINE    B-spline filter (1, 0)
                        IPPI_INTER_CUBIC2P_CATMULLROM Catmull-Rom filter (0, 1/2)
                        IPPI_INTER_CUBIC2P_B05C03     special filter with parameters (1/2, 3/10)
  Returns:
    ippStsNoErr             no errors
    ippStsNullPtrErr        pSrc == NULL or pDst == NULL or
                            pxMap == NULL or pyMap == NULL or pzMap == NULL
    ippStsSizeErr           width or height or depth of volumes is less or equal zero
    ippStsInterpolationErr  interpolation has an illegal value
    ippStsWrongIntersectVOI srcVOI hasn`t intersection with the srcStep : Int32,  no operation
  Notes:
    <mode> are 8u_C1PV or 16u_C1PV or 32f_C1PV
}

 function ipprRemap_8u_C1PV( pSrc : Ipp8uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcVOI : IpprCuboid ; pxMap : Ipp32fPtr ; pyMap : Ipp32fPtr ; pzMap : Ipp32fPtr ; mapStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstVolume : IpprVolume ; interpolation : Int32 ): IppStatus; _ippapi
 function ipprRemap_16u_C1PV( pSrc : Ipp16uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcVOI : IpprCuboid ; pxMap : Ipp32fPtr ; pyMap : Ipp32fPtr ; pzMap : Ipp32fPtr ; mapStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstVolume : IpprVolume ; interpolation : Int32 ): IppStatus; _ippapi
 function ipprRemap_32f_C1PV( pSrc : Ipp32fPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcVOI : IpprCuboid ; pxMap : Ipp32fPtr ; pyMap : Ipp32fPtr ; pzMap : Ipp32fPtr ; mapStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstVolume : IpprVolume ; interpolation : Int32 ): IppStatus; _ippapi

{
  Names:              ipprRemap_<mode>
  Purpose:            Performs REMAP TRANSFORM of the source volume by remapping
                        dst[i,j,k] = src[xMap[i,j,k], yMap[i,j,k], zMap[i,j,k]]
  Parameters:
    pSrc              array of pointers to planes in source volume data
    srcVolume         size of source volume
    srcStep           step in every plane of source volume
    srcPlaneStep      step between planes of source volume (8u_C1V, 16u_C1V, 32f_C1V modes)
    srcVOI            volume of interest of source volume
    pxMap             array of pointers to images with X coordinates of map
    pyMap             array of pointers to images with Y coordinates of map
    pzMap             array of pointers to images with Z coordinates of map
    mapStep           step in every plane of each map volumes
    pDst              array of pointers to planes in destination volume data
    dstStep           step in every plane of destination volume
    dstPlaneStep      step between planes of destination volume (8u_C1V, 16u_C1V, 32f_C1V modes)
    dstVolume         size of destination volume
    interpolation     type of interpolation to perform for resizing the input volume:
                        IPPI_INTER_NN      nearest neighbor interpolation
                        IPPI_INTER_LINEAR  trilinear interpolation
                        IPPI_INTER_CUBIC   tricubic polynomial interpolation
                      including two-parameter cubic filters:
                        IPPI_INTER_CUBIC2P_BSPLINE    B-spline filter (1, 0)
                        IPPI_INTER_CUBIC2P_CATMULLROM Catmull-Rom filter (0, 1/2)
                        IPPI_INTER_CUBIC2P_B05C03     special filter with parameters (1/2, 3/10)
  Returns:
    ippStsNoErr             no errors
    ippStsNullPtrErr        pSrc == NULL or pDst == NULL or
                            pxMap == NULL or pyMap == NULL or pzMap == NULL
    ippStsSizeErr           width or height or depth of volumes is less or equal zero
    ippStsInterpolationErr  interpolation has an illegal value
    ippStsWrongIntersectVOI srcVOI hasn`t intersection with the source volume,  no operation
  Notes:
    <mode> are 8u_C1V or 16u_C1V or 32f_C1V
}

 function ipprRemap_8u_C1V( pSrc : Ipp8uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcPlaneStep : Int32 ; srcVOI : IpprCuboid ; pxMap : Ipp32fPtr ; pyMap : Ipp32fPtr ; pzMap : Ipp32fPtr ; mapStep : Int32 ; mapPlaneStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; dstPlaneStep : Int32 ; dstVolume : IpprVolume ; interpolation : Int32 ): IppStatus; _ippapi
 function ipprRemap_16u_C1V( pSrc : Ipp16uPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcPlaneStep : Int32 ; srcVOI : IpprCuboid ; pxMap : Ipp32fPtr ; pyMap : Ipp32fPtr ; pzMap : Ipp32fPtr ; mapStep : Int32 ; mapPlaneStep : Int32 ; pDst : Ipp16uPtr ; dstStep : Int32 ; dstPlaneStep : Int32 ; dstVolume : IpprVolume ; interpolation : Int32 ): IppStatus; _ippapi
 function ipprRemap_32f_C1V( pSrc : Ipp32fPtr ; srcVolume : IpprVolume ; srcStep : Int32 ; srcPlaneStep : Int32 ; srcVOI : IpprCuboid ; pxMap : Ipp32fPtr ; pyMap : Ipp32fPtr ; pzMap : Ipp32fPtr ; mapStep : Int32 ; mapPlaneStep : Int32 ; pDst : Ipp32fPtr ; dstStep : Int32 ; dstPlaneStep : Int32 ; dstVolume : IpprVolume ; interpolation : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

           3D General Linear Filters
---------------------------------------------------------------------------- }

{
  Name:               ipprFilterGetBufSize
  Purpose:            Computes the size of an external work buffer (in bytes)
  Parameters:
    dstVolume         size of the volume
    kernelVolume      size of the kernel volume
    nChannel          number of channels
    pSize             pointer to the external buffer`s size
  Returns:
    ippStsNoErr           no errors
    ippStsNullPtrErr      pSize == NULL
    ippStsSizeErr         width or height or depth of volumes is less or equal zero
    ippStsNumChannelsErr  number of channels is not one
}

 function ipprFilterGetBufSize( dstVolume : IpprVolume ; kernelVolume : IpprVolume ; nChannel : Int32 ; var pSize : Int32 ): IppStatus; _ippapi

{
  Name:               ipprFilter_16s_C1PV
  Purpose:            Filters a volume using a general integer cuboidal kernel
  Parameters:
    pSrc              array of pointers to planes in source volume data
    srcStep           step in every plane of source volume
    pDst              array of pointers to planes in destination volume data
    dstStep           step in every plane of destination volume
    dstVolume         size of the processed volume
    pKernel           pointer to the kernel values
    kernelVolume      size of the kernel volume
    anchor            anchor 3d-cell specifying the cuboidal kernel alignment
                      with respect to the position of the input voxel
    divisor           the integer value by which the computed result is divided
    pBuffer           pointer to the external buffer`s size
  Returns:
    ippStsNoErr       no errors
    ippStsNullPtrErr  one of the pointers is NULL
    ippStsSizeErr     width or height or depth of volumes is less or equal zero
    ippStsDivisorErr  divisor value is zero,  function execution is interrupted
}

 function ipprFilter_16s_C1PV( pSrc : Ipp16sPtr ; srcStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstVolume : IpprVolume ; pKernel : Ipp32sPtr ; kernelVolume : IpprVolume ; anchor : IpprPoint ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{
  Name:               ipprFilter_16s_C1V
  Purpose:            Filters a volume using a general integer cuboidal kernel
  Parameters:
    pSrc              array of pointers to planes in source volume data
    srcStep           step in every plane of source volume
    srcPlaneStep      step between planes of source volume (8u_C1V, 16u_C1V, 32f_C1V modes)
    pDst              array of pointers to planes in destination volume data
    dstStep           step in every plane of destination volume
    dstPlaneStep      step between planes of destination volume (8u_C1V, 16u_C1V, 32f_C1V modes)
    dstVolume         size of the processed volume
    pKernel           pointer to the kernel values
    kernelVolume      size of the kernel volume
    anchor            anchor 3d-cell specifying the cuboidal kernel alignment
                      with respect to the position of the input voxel
    divisor           the integer value by which the computed result is divided
    pBuffer           pointer to the external buffer`s size
  Returns:
    ippStsNoErr       no errors
    ippStsNullPtrErr  one of the pointers is NULL
    ippStsSizeErr     width or height or depth of volumes is less or equal zero
    ippStsDivisorErr  divisor value is zero,  function execution is interrupted
}

 function ipprFilter_16s_C1V( pSrc : Ipp16sPtr ; srcStep : Int32 ; srcPlaneStep : Int32 ; pDst : Ipp16sPtr ; dstStep : Int32 ; dstPlaneStep : Int32 ; dstVolume : IpprVolume ; pKernel : Ipp32sPtr ; kernelVolume : IpprVolume ; anchor : IpprPoint ; divisor : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi


{
              Intel(R) Integrated Performance Primitives
              Signal Processing (ippSP)
}

{ ----------------------------------------------------------------------------

  Name:       ippsGetLibVersion
  Purpose:    get the library version
  Parameters:
  Returns:    pointer to structure describing version of the ipps library

  Notes:      don`t free the pointer
}

 function ippsGetLibVersion: IppLibraryVersionPtr; _ippapi

{ ----------------------------------------------------------------------------

                   Functions to allocate and free memory
------------------------------------------------------------------------------

  Name:       ippsMalloc
  Purpose:    32-byte aligned memory allocation
  Parameter:
    len       number of elements (according to their type)
  Returns:    pointer to allocated memory

  Notes:      the memory allocated by ippsMalloc has to be free by ippsFree
              function only.
}

 function ippsMalloc_8u(len : Int32 ):Ipp8uPtr; _ippapi
 function ippsMalloc_16u(len : Int32 ):Ipp16uPtr; _ippapi
 function ippsMalloc_32u(len : Int32 ):Ipp32uPtr; _ippapi
 function ippsMalloc_8s(len : Int32 ):Ipp8sPtr; _ippapi
 function ippsMalloc_16s(len : Int32 ):Ipp16sPtr; _ippapi
 function ippsMalloc_32s(len : Int32 ):Ipp32sPtr; _ippapi
 function ippsMalloc_64s(len : Int32 ):Ipp64sPtr; _ippapi

 function ippsMalloc_32f(len : Int32 ):Ipp32fPtr; _ippapi
 function ippsMalloc_64f(len : Int32 ):Ipp64fPtr; _ippapi

 function ippsMalloc_8sc(len : Int32 ):Ipp8scPtr; _ippapi
 function ippsMalloc_16sc(len : Int32 ): Ipp16scPtr; _ippapi
 function ippsMalloc_32sc(len : Int32 ): Ipp32scPtr; _ippapi
 function ippsMalloc_64sc(len : Int32 ): Ipp64scPtr; _ippapi
 function ippsMalloc_32fc(len : Int32 ): Ipp32fcPtr; _ippapi
 function ippsMalloc_64fc(len : Int32 ): Ipp64fcPtr; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsFree
  Purpose:    free memory allocated by the ippsMalloc functions
  Parameter:
    ptr       pointer to the memory allocated by the ippsMalloc functions

  Notes:      use the function to free memory allocated by ippsMalloc_*
}

procedure ippsFree(ptr : Pointer ); _ippapi

{ ----------------------------------------------------------------------------

                   Vector Initialization functions
------------------------------------------------------------------------------

  Name:       ippsCopy
  Purpose:    copy data from source to destination vector
  Parameters:
    pSrc        pointer to the input vector
    pDst        pointer to the output vector
    len         length of the vectors,  number of items
  Return:
    ippStsNullPtrErr        pointer(s) to the data is NULL
    ippStsSizeErr           length of the vectors is less or equal zero
    ippStsNoErr             otherwise
}

 function ippsCopy_8u( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCopy_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCopy_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCopy_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCopy_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCopy_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCopy_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCopy_32s( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCopy_32sc( pSrc : Ipp32scPtr ; pDst : Ipp32scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCopy_64s( pSrc : Ipp64sPtr ; pDst : Ipp64sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCopy_64sc( pSrc : Ipp64scPtr ; pDst : Ipp64scPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsCopyLE_1u
              ippsCopyBE_1u
  Purpose:    copy bit`s data from source to destination vector
  Parameters:
    pSrc          pointer to the input vector
    srcBitOffset  offset in the first byte of the source vector
    pDst          pointer to the output vector
    dstBitOffset  offset in the first byte of the destination vector
    len           length of the vectors,  number of bits
  Return:
    ippStsNullPtrErr        pointer(s) to the data is NULL
    ippStsSizeErr           length of the vectors is less or equal zero
    ippStsNoErr             otherwise
}

 function ippsCopyLE_1u( pSrc : Ipp8uPtr ; srcBitOffset : Int32 ; pDst : Ipp8uPtr ; dstBitOffset : Int32 ; len : Int32 ): IppStatus; _ippapi
 function ippsCopyBE_1u( pSrc : Ipp8uPtr ; srcBitOffset : Int32 ; pDst : Ipp8uPtr ; dstBitOffset : Int32 ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsMove
  Purpose:    The ippsMove function copies "len" elements from src to dst.
              If some regions of the source area and the destination overlap, 
              ippsMove ensures that the original source bytes in the overlapping
              region are copied before being overwritten.

  Parameters:
    pSrc        pointer to the input vector
    pDst        pointer to the output vector
    len         length of the vectors,  number of items
  Return:
    ippStsNullPtrErr        pointer(s) to the data is NULL
    ippStsSizeErr           length of the vectors is less or equal zero
    ippStsNoErr             otherwise
}

 function ippsMove_8u( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMove_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMove_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMove_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMove_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMove_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMove_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMove_32s( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMove_32sc( pSrc : Ipp32scPtr ; pDst : Ipp32scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMove_64s( pSrc : Ipp64sPtr ; pDst : Ipp64sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMove_64sc( pSrc : Ipp64scPtr ; pDst : Ipp64scPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsZero
  Purpose:    set elements of the vector to zero of corresponding type
  Parameters:
    pDst       pointer to the destination vector
    len        length of the vectors
  Return:
    ippStsNullPtrErr        pointer to the vector is NULL
    ippStsSizeErr           length of the vectors is less or equal zero
    ippStsNoErr             otherwise
}

 function ippsZero_8u( pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsZero_16s( pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsZero_16sc( pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsZero_32f( pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsZero_32fc( pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsZero_64f( pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsZero_64fc( pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsZero_32s( pDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsZero_32sc( pDst : Ipp32scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsZero_64s( pDst : Ipp64sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsZero_64sc( pDst : Ipp64scPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsSet
  Purpose:    set elements of the destination vector to the value
  Parameters:
    val        value to set the elements of the vector
    pDst       pointer to the destination vector
    len        length of the vectors
  Return:
    ippStsNullPtrErr        pointer to the vector is NULL
    ippStsSizeErr           length of the vector is less or equal zero
    ippStsNoErr             otherwise
}

 function ippsSet_8u( val : Ipp8u ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSet_16s( val : Ipp16s ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSet_16sc( val : Ipp16sc ; pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSet_32s( val : Ipp32s ; pDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSet_32sc( val : Ipp32sc ; pDst : Ipp32scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSet_32f( val : Ipp32f ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSet_32fc( val : Ipp32fc ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSet_64s( val : Ipp64s ; pDst : Ipp64sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSet_64sc( val : Ipp64sc ; pDst : Ipp64scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSet_64f( val : Ipp64f ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSet_64fc( val : Ipp64fc ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                     ippsRandUniform
 Purpose:                  Makes pseudo-random samples with a uniform distribution
                           and places them in the vector.
 Parameters:
    pDst                   The pointer to vector
    len                    Vector`s length
    pRandUniState          A pointer to the structure containing parameters for the
                           generator of noise
 Returns:
    ippStsNullPtrErr       pRandUniState==NULL
    ippStsContextMatchErr  pState->idCtx != idCtxRandUni
    ippStsNoErr            No errors
}

 function ippsRandUniform_8u( pDst : Ipp8uPtr ; len : Int32 ; pRandUniState : IppsRandUniState_8uPtr ): IppStatus; _ippapi
 function ippsRandUniform_16s( pDst : Ipp16sPtr ; len : Int32 ; pRandUniState : IppsRandUniState_16sPtr ): IppStatus; _ippapi
 function ippsRandUniform_32f( pDst : Ipp32fPtr ; len : Int32 ; pRandUniState : IppsRandUniState_32fPtr ): IppStatus; _ippapi
 function ippsRandUniform_64f( pDst : Ipp64fPtr ; len : Int32 ; pRandUniState : IppsRandUniState_64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                     ippsRandGauss
 Purpose:                  Makes pseudo-random samples with a normal distribution
                           and places them in the vector.
 Parameters:
    pDst                   The pointer to vector
    len                    Vector`s length
    pRandUniState          A pointer to the structure containing parameters
                           for the generator of noise
    ippStsContextMatchErr  pState->idCtx != idCtxRandGauss
 Returns:
    ippStsNullPtrErr       pRandGaussState==NULL
    ippStsNoErr            No errors
}

 function ippsRandGauss_8u( pDst : Ipp8uPtr ; len : Int32 ; pRandGaussState : IppsRandGaussState_8uPtr ): IppStatus; _ippapi
 function ippsRandGauss_16s( pDst : Ipp16sPtr ; len : Int32 ; pRandGaussState : IppsRandGaussState_16sPtr ): IppStatus; _ippapi
 function ippsRandGauss_32f( pDst : Ipp32fPtr ; len : Int32 ; pRandGaussState : IppsRandGaussState_32fPtr ): IppStatus; _ippapi
 function ippsRandGauss_64f( pDst : Ipp64fPtr ; len : Int32 ; pRandGaussState : IppsRandGaussState_64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsRandGaussGetSize

  Purpose:    Gaussian sequence generator state variable size -
              computes the size, in bytes, 
              of the state variable structure ippsRandGaussState_16s.
  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         pRandGaussStateSize==NULL
  Arguments:
    pRandGaussStateSize      pointer to the computed values of the size
                             of the structure ippsRandGaussState_8u/16s/32f.
}

 function ippsRandGaussGetSize_8u(pRandGaussStateSize : Int32Ptr ): IppStatus; _ippapi
 function ippsRandGaussGetSize_16s(pRandGaussStateSize : Int32Ptr ): IppStatus; _ippapi
 function ippsRandGaussGetSize_32f(pRandGaussStateSize : Int32Ptr ): IppStatus; _ippapi
 function ippsRandGaussGetSize_64f(pRandGaussStateSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippsRandGaussInit
 Purpose:             Initializes the Gaussian sequence generator state structure with
                      given parameters (mean, variance, seed).
 Parameters:
    pRandGaussState   A pointer to the structure containing parameters for the
                      generator of noise.
    mean              Mean of the normal distribution.
    stdDev            Standard deviation of the normal distribution.
    seed              Seed value used by the pseudo-random number generator

 Returns:
    ippStsNullPtrErr  pRandGaussState==NULL
    ippMemAllocErr    Can not allocate normal random state
    ippStsNoErr       No errors
}

 function ippsRandGaussInit_8u( pRandGaussState : IppsRandGaussState_8uPtr ; mean : Ipp8u ; stdDev : Ipp8u ; seed : Word32 ): IppStatus; _ippapi
 function ippsRandGaussInit_16s( pRandGaussState : IppsRandGaussState_16sPtr ; mean : Ipp16s ; stdDev : Ipp16s ; seed : Word32 ): IppStatus; _ippapi
 function ippsRandGaussInit_32f( pRandGaussState : IppsRandGaussState_32fPtr ; mean : Ipp32f ; stdDev : Ipp32f ; seed : Word32 ): IppStatus; _ippapi
 function ippsRandGaussInit_64f( pRandGaussState : IppsRandGaussState_64fPtr ; mean : Ipp64f ; stdDev : Ipp64f ; seed : Word32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsRandUniformGetSize

  Purpose:    Uniform sequence generator state variable size -
              computes the size, in bytes, 
              of the state variable structure ippsRandIniState_16s.

  Return:
    ippStsNoErr              Ok
    ippStsNullPtrErr         pRandUniformStateSize==NULL
  Arguments:
    pRandGaussStateSize      pointer to the computed value of the size
                             of the structure ippsRandUniState_8u/16s/32f.
}

 function ippsRandUniformGetSize_8u( pRandUniformStateSize : Int32Ptr ): IppStatus; _ippapi
 function ippsRandUniformGetSize_16s( pRandUniformStateSize : Int32Ptr ): IppStatus; _ippapi
 function ippsRandUniformGetSize_32f( pRandUniformStateSize : Int32Ptr ): IppStatus; _ippapi
 function ippsRandUniformGetSize_64f( pRandUniformStateSize : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:                ippsRandUniformInit
 Purpose:             Initializes the uniform sequence generator state structure with
                      given parameters (boundaries, seed)
 Parameters:
    pRandUniState     Pointer to the structure containing parameters for the
                      generator of noise.
    low               Lower bound of the uniform distribution`s range.
    high              Upper bounds of the uniform distribution`s range.
    seed              Seed value used by the pseudo-random number generation
                      algorithm.
}

 function ippsRandUniformInit_8u( pRandUniState : IppsRandUniState_8uPtr ; low : Ipp8u ; high : Ipp8u ; seed : Word32 ): IppStatus; _ippapi
 function ippsRandUniformInit_16s( pRandUniState : IppsRandUniState_16sPtr ; low : Ipp16s ; high : Ipp16s ; seed : Word32 ): IppStatus; _ippapi
 function ippsRandUniformInit_32f( pRandUniState : IppsRandUniState_32fPtr ; low : Ipp32f ; high : Ipp32f ; seed : Word32 ): IppStatus; _ippapi
 function ippsRandUniformInit_64f( pRandUniState : IppsRandUniState_64fPtr ; low : Ipp64f ; high : Ipp64f ; seed : Word32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:               ippsVectorJaehne
  Purpose:            creates Jaehne vector

  Parameters:
    pDst              the pointer to the destination vector
    len               length of the vector
    magn              magnitude of the signal

  Return:
    ippStsNoErr       indicates no error
    ippStsNullPtrErr  indicates an error when the pDst pointer is NULL
    ippStsBadSizeErr  indicates an error when len is less or equal zero
    ippStsJaehneErr   indicates an error when magnitude value is negative

  Notes:              pDst[n] = magn*sin(0.5*pi*n^2/len), n=0,1,2,..len-1.
}

 function ippsVectorJaehne_8u( pDst : Ipp8uPtr ; len : Int32 ; magn : Ipp8u ): IppStatus; _ippapi
 function ippsVectorJaehne_16u( pDst : Ipp16uPtr ; len : Int32 ; magn : Ipp16u ): IppStatus; _ippapi
 function ippsVectorJaehne_16s( pDst : Ipp16sPtr ; len : Int32 ; magn : Ipp16s ): IppStatus; _ippapi
 function ippsVectorJaehne_32s( pDst : Ipp32sPtr ; len : Int32 ; magn : Ipp32s ): IppStatus; _ippapi
 function ippsVectorJaehne_32f( pDst : Ipp32fPtr ; len : Int32 ; magn : Ipp32f ): IppStatus; _ippapi
 function ippsVectorJaehne_64f( pDst : Ipp64fPtr ; len : Int32 ; magn : Ipp64f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippsTone
  Purpose:        Generates a tone with a given frequency,  phase, and magnitude.
  Parameters:
    pDst        - Pointer to the destination vector.
    len         - Length of the vector.
    magn        - Magnitude of the tone; that is,  the maximum value attained by the wave.
    rFreq       - Frequency of the tone relative to the sampling frequency.
                  It must be in range [0.0, 0.5) for real,  and [0.0, 1.0) for complex tone.
    pPhase      - Phase of the tone relative to a cosinewave. It must be in range [0.0, 2*PI).
    hint        - Suggests using specific code.
  Notes:
    for real:  pDst[i] = magn * cos(IPP_2PI * rfreq * i + phase);
    for cplx:  pDst[i].re = magn * cos(IPP_2PI * rfreq * i + phase);
               pDst[i].im = magn * sin(IPP_2PI * rfreq * i + phase);
  Returns:
    ippStsNoErr        - OK.
    ippStsNullPtrErr   - Error when any of the specified pointers is NULL.
    ippStsSizeErr      - Error when length of the vector is less or equal zero.
    ippStsToneMagnErr  - Error when the magn value is less than or equal to zero.
    ippStsToneFreqErr  - Error when the rFreq value is less than 0 or greater than or equal to 0.5 for real tone and 1.0 for complex tone.
    ippStsTonePhaseErr - Error when the phase value is less 0 or greater or equal 2*PI.
}

 function ippsTone_32f( pDst : Ipp32fPtr ; len : Int32 ; magn : Ipp32f ; rFreq : Ipp32f ; pPhase : Ipp32fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsTone_32fc( pDst : Ipp32fcPtr ; len : Int32 ; magn : Ipp32f ; rFreq : Ipp32f ; pPhase : Ipp32fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsTone_64f( pDst : Ipp64fPtr ; len : Int32 ; magn : Ipp64f ; rFreq : Ipp64f ; pPhase : Ipp64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsTone_64fc( pDst : Ipp64fcPtr ; len : Int32 ; magn : Ipp64f ; rFreq : Ipp64f ; pPhase : Ipp64fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsTone_16s( pDst : Ipp16sPtr ; len : Int32 ; magn : Ipp16s ; rFreq : Ipp32f ; pPhase : Ipp32fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsTone_16sc( pDst : Ipp16scPtr ; len : Int32 ; magn : Ipp16s ; rFreq : Ipp32f ; pPhase : Ipp32fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippsTriangle
  Purpose:        Generates a triangle with a given frequency,  phase, and magnitude.
  Parameters:
    pDst        - Pointer to destination vector.
    len         - Length of the vector.
    magn        - Magnitude of the Triangle,  that is,  the maximum value attained by the wave.
    rFreq       - Frequency of the Triangle relative to the sampling frequency. It must be in range [0.0, 0.5).
    pPhase      - Pointer to the phase of the Triangle relative to acosinewave. It must be in range [0.0, 2*PI).
                  The returned value may be used to compute the next continuous data block.
    asym        - Asymmetry of a triangle. It must be in range [-PI,PI).
  Returns:
    ippStsNoErr         - OK.
    ippStsNullPtrErr    - Error when any of the specified pointers is NULL.
    ippStsSizeErr       - Error when length of the vector is less or equal zero.
    ippStsTrnglMagnErr  - Error when the magn value is less or equal to zero.
    ippStsTrnglFreqErr  - Error when the rFreq value is less 0 or greater or equal 0.5.
    ippStsTrnglPhaseErr - Error when the phase value is less 0 or greater or equal 2*PI.
    ippStsTrnglAsymErr  - Error when the asym value is less -PI or greater or equal PI.
}

 function ippsTriangle_64f( pDst : Ipp64fPtr ; len : Int32 ; magn : Ipp64f ; rFreq : Ipp64f ; asym : Ipp64f ; pPhase : Ipp64fPtr ): IppStatus; _ippapi
 function ippsTriangle_64fc( pDst : Ipp64fcPtr ; len : Int32 ; magn : Ipp64f ; rFreq : Ipp64f ; asym : Ipp64f ; pPhase : Ipp64fPtr ): IppStatus; _ippapi
 function ippsTriangle_32f( pDst : Ipp32fPtr ; len : Int32 ; magn : Ipp32f ; rFreq : Ipp32f ; asym : Ipp32f ; pPhase : Ipp32fPtr ): IppStatus; _ippapi
 function ippsTriangle_32fc( pDst : Ipp32fcPtr ; len : Int32 ; magn : Ipp32f ; rFreq : Ipp32f ; asym : Ipp32f ; pPhase : Ipp32fPtr ): IppStatus; _ippapi
 function ippsTriangle_16s( pDst : Ipp16sPtr ; len : Int32 ; magn : Ipp16s ; rFreq : Ipp32f ; asym : Ipp32f ; pPhase : Ipp32fPtr ): IppStatus; _ippapi
 function ippsTriangle_16sc( pDst : Ipp16scPtr ; len : Int32 ; magn : Ipp16s ; rFreq : Ipp32f ; asym : Ipp32f ; pPhase : Ipp32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                   Convert functions
------------------------------------------------------------------------------

  Name:       ippsReal
  Purpose:    form vector with real part of the input complex vector
  Parameters:
    pSrc       pointer to the input complex vector
    pDstRe     pointer to the output vector to store the real part
    len        length of the vectors,  number of items
  Return:
    ippStsNullPtrErr       pointer(s) to the data is NULL
    ippStsSizeErr          length of the vectors is less or equal zero
    ippStsNoErr            otherwise
}

 function ippsReal_64fc( pSrc : Ipp64fcPtr ; pDstRe : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsReal_32fc( pSrc : Ipp32fcPtr ; pDstRe : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsReal_16sc( pSrc : Ipp16scPtr ; pDstRe : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsImag
  Purpose:    form vector with imaginary part of the input complex vector
  Parameters:
    pSrc       pointer to the input complex vector
    pDstRe     pointer to the output vector to store the real part
    len        length of the vectors,  number of items
  Return:
    ippStsNullPtrErr       pointer(s) to the data is NULL
    ippStsSizeErr          length of the vectors is less or equal zero
    ippStsNoErr            otherwise
}

 function ippsImag_64fc( pSrc : Ipp64fcPtr ; pDstIm : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsImag_32fc( pSrc : Ipp32fcPtr ; pDstIm : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsImag_16sc( pSrc : Ipp16scPtr ; pDstIm : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsCplxToReal
  Purpose:    form the real and imaginary parts of the input complex vector
  Parameters:
    pSrc       pointer to the input complex vector
    pDstRe     pointer to output vector to store the real part
    pDstIm     pointer to output vector to store the imaginary part
    len        length of the vectors,  number of items
  Return:
    ippStsNullPtrErr        pointer(s) to the data is NULL
    ippStsSizeErr           length of the vectors is less or equal zero
    ippStsNoErr             otherwise
}

 function ippsCplxToReal_64fc( pSrc : Ipp64fcPtr ; pDstRe : Ipp64fPtr ; pDstIm : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCplxToReal_32fc( pSrc : Ipp32fcPtr ; pDstRe : Ipp32fPtr ; pDstIm : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCplxToReal_16sc( pSrc : Ipp16scPtr ; pDstRe : Ipp16sPtr ; pDstIm : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsRealToCplx
  Purpose:    form complex vector from the real and imaginary components
  Parameters:
    pSrcRe     pointer to the input vector with real part,  may be NULL
    pSrcIm     pointer to the input vector with imaginary part,  may be NULL
    pDst       pointer to the output complex vector
    len        length of the vectors
  Return:
    ippStsNullPtrErr        pointer to the destination data is NULL
    ippStsSizeErr           length of the vectors is less or equal zero
    ippStsNoErr             otherwise

  Notes:      one of the two input pointers may be NULL. In this case
              the corresponding values of the output complex elements is 0
}

 function ippsRealToCplx_64f( pSrcRe : Ipp64fPtr ; pSrcIm : Ipp64fPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsRealToCplx_32f( pSrcRe : Ipp32fPtr ; pSrcIm : Ipp32fPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsRealToCplx_16s( pSrcRe : Ipp16sPtr ; pSrcIm : Ipp16sPtr ; pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:       ippsConj, ippsConjFlip
  Purpose:     complex conjugate data vector
  Parameters:
    pSrc               pointer to the input vector
    pDst               pointer to the output vector
    len                length of the vectors
  Return:
    ippStsNullPtrErr      pointer(s) to the data is NULL
    ippStsSizeErr         length of the vectors is less or equal zero
    ippStsNoErr           otherwise
  Notes:
    the ConjFlip version conjugates and stores result in reverse order
}

 function ippsConj_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConj_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConj_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConj_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConj_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConj_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConjFlip_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConjFlip_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConjFlip_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConjCcs_64fc_I( pSrcDst : Ipp64fcPtr ; lenDst : Int32 ): IppStatus; _ippapi
 function ippsConjCcs_32fc_I( pSrcDst : Ipp32fcPtr ; lenDst : Int32 ): IppStatus; _ippapi
 function ippsConjCcs_64fc( pSrc : Ipp64fPtr ; pDst : Ipp64fcPtr ; lenDst : Int32 ): IppStatus; _ippapi
 function ippsConjCcs_32fc( pSrc : Ipp32fPtr ; pDst : Ipp32fcPtr ; lenDst : Int32 ): IppStatus; _ippapi
 function ippsConjPack_64fc_I( pSrcDst : Ipp64fcPtr ; lenDst : Int32 ): IppStatus; _ippapi
 function ippsConjPack_32fc_I( pSrcDst : Ipp32fcPtr ; lenDst : Int32 ): IppStatus; _ippapi
 function ippsConjPack_64fc( pSrc : Ipp64fPtr ; pDst : Ipp64fcPtr ; lenDst : Int32 ): IppStatus; _ippapi
 function ippsConjPack_32fc( pSrc : Ipp32fPtr ; pDst : Ipp32fcPtr ; lenDst : Int32 ): IppStatus; _ippapi
 function ippsConjPerm_64fc_I( pSrcDst : Ipp64fcPtr ; lenDst : Int32 ): IppStatus; _ippapi
 function ippsConjPerm_32fc_I( pSrcDst : Ipp32fcPtr ; lenDst : Int32 ): IppStatus; _ippapi
 function ippsConjPerm_64fc( pSrc : Ipp64fPtr ; pDst : Ipp64fcPtr ; lenDst : Int32 ): IppStatus; _ippapi
 function ippsConjPerm_32fc( pSrc : Ipp32fPtr ; pDst : Ipp32fcPtr ; lenDst : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsConvert
  Purpose:    Converts integer data to floating point data
  Parameters:
    pSrc        pointer to integer data to be converted
    pDst        pointer to the destination vector
    len         length of the vectors
  Return:
    ippStsNullPtrErr    pointer(s) to the data is NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
}

 function ippsConvert_8s16s( pSrc : Ipp8sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_16s32s( pSrc : Ipp16sPtr ; pDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_32s16s( pSrc : Ipp32sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_8s32f( pSrc : Ipp8sPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_8u32f( pSrc : Ipp8uPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_16s32f( pSrc : Ipp16sPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_16u32f( pSrc : Ipp16uPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_32s64f( pSrc : Ipp32sPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_32s32f( pSrc : Ipp32sPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_64s64f( pSrc : Ipp64sPtr ; pDst : Ipp64fPtr ; len : Ipp32u ): IppStatus; _ippapi
 function ippsConvert_16s8s_Sfs( pSrc : Ipp16sPtr ; pDst : Ipp8sPtr ; len : Ipp32u ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

{----------------------------------------------------------------------------
  Name:       ippsConvert
  Purpose:    convert floating point data to integer data
  Parameters:
    pSrc         pointer to the input floating point data to be converted
    pDst         pointer to destination vector
    len          length of the vectors
    rndMode      Rounding mode which can be ippRndZero or ippRndNear
    scaleFactor  scale factor value
  Return:
    ippStsNullPtrErr    pointer(s) to the data NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
  Note:
    an out-of-range result will be saturated
}

 function ippsConvert_32f8s_Sfs( pSrc : Ipp32fPtr ; pDst : Ipp8sPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_32f8u_Sfs( pSrc : Ipp32fPtr ; pDst : Ipp8uPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_32f16s_Sfs( pSrc : Ipp32fPtr ; pDst : Ipp16sPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_32f16u_Sfs( pSrc : Ipp32fPtr ; pDst : Ipp16uPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_64f32s_Sfs( pSrc : Ipp64fPtr ; pDst : Ipp32sPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_32f32s_Sfs( pSrc : Ipp32fPtr ; pDst : Ipp32sPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_64f16s_Sfs( pSrc : Ipp64fPtr ; pDst : Ipp16sPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_64f64s_Sfs( pSrc : Ipp64fPtr ; pDst : Ipp64sPtr ; len : Ipp32u ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsConvert_32f64f
  Purpose:    Converts floating point data Ipp32f
              to floating point data Ipp64f
  Parameters:
    pSrc          pointer to the input vector
    pDst          pointer to the output vector
    len           length of the vectors
  Return:
    ippStsNullPtrErr    pointer(s) to the data is NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
}

 function ippsConvert_32f64f( pSrc : Ipp32fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsConvert_64f32f
  Purpose:    Converts floating point data Ipp64f
              to floating point data Ipp32f
  Parameters:
    pSrc          pointer to the input vector
    pDst          pointer to the output vector
    len           length of the vectors
  Return:
    ippStsNullPtrErr    pointer(s) to the data is NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
  Note:
    an out-of-range result will be saturated
}

 function ippsConvert_64f32f( pSrc : Ipp64fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsConvert
  Purpose:    Converts integer data to floating point data
  Parameters:
    pSrc          pointer to integer data to be converted
    pDst          pointer to the destination vector
    len           length of the vectors
    scaleFactor   scale factor value
  Return:
    ippStsNullPtrErr    pointer(s) to the data is NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
}

 function ippsConvert_16s32f_Sfs( pSrc : Ipp16sPtr ; pDst : Ipp32fPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_16s64f_Sfs( pSrc : Ipp16sPtr ; pDst : Ipp64fPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_32s32f_Sfs( pSrc : Ipp32sPtr ; pDst : Ipp32fPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_32s64f_Sfs( pSrc : Ipp32sPtr ; pDst : Ipp64fPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_32s16s_Sfs( pSrc : Ipp32sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsConvert
  Purpose:    Converts 24u data to 32u or 32f data.
              Converts 32u or 32f data to 24u data.
              Converts 24s data to 32s or 32f data.
              Converts 32s or 32f data to 24s data.
  Parameters:
    pSrc          pointer to the input vector
    pDst          pointer to the output vector
    len           length of the vectors
    scaleFactor   scale factor value
  Return:
    ippStsNullPtrErr    pointer(s) to the data is NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
}

 function ippsConvert_24u32u( pSrc : Ipp8uPtr ; pDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_32u24u_Sfs( pSrc : Ipp32uPtr ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_24u32f( pSrc : Ipp8uPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_32f24u_Sfs( pSrc : Ipp32fPtr ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_24s32s( pSrc : Ipp8uPtr ; pDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_32s24s_Sfs( pSrc : Ipp32sPtr ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsConvert_24s32f( pSrc : Ipp8uPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsConvert_32f24s_Sfs( pSrc : Ipp32fPtr ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsConvert_16s16f
  Purpose:    Converts integer data to floating point data
  Parameters:
    pSrc        pointer to integer data to be converted
    pDst        pointer to the destination vector
    len         length of the vectors
    rndMode      Rounding mode which can be ippRndZero or ippRndNear
  Return:
    ippStsNullPtrErr    pointer(s) to the data is NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
}

 function ippsConvert_16s16f( pSrc : Ipp16sPtr ; pDst : Ipp16fPtr ; len : Int32 ; rndMode : IppRoundMode ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsConvert_16f16s_Sfs
  Purpose:    convert floating point data to integer data
  Parameters:
    pSrc         pointer to the input floating point data to be converted
    pDst         pointer to destination vector
    len          length of the vectors
    rndMode      Rounding mode which can be ippRndZero or ippRndNear
    scaleFactor  scale factor value
  Return:
    ippStsNullPtrErr    pointer(s) to the data NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
  Note:
    an out-of-range result will be saturated
}

 function ippsConvert_16f16s_Sfs( pSrc : Ipp16fPtr ; pDst : Ipp16sPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsConvert_32f16f
  Purpose:    Converts floating point data Ipp32f
              to floating point data Ipp16f
  Parameters:
    pSrc          pointer to the input vector
    pDst          pointer to the output vector
    len           length of the vectors
    rndMode       Rounding mode which can be ippRndZero or ippRndNear
  Return:
    ippStsNullPtrErr    pointer(s) to the data is NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
}

 function ippsConvert_32f16f( pSrc : Ipp32fPtr ; pDst : Ipp16fPtr ; len : Int32 ; rndMode : IppRoundMode ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsConvert_16f32f
  Purpose:    Converts floating point data Ipp16f
              to floating point data Ipp32f
  Parameters:
    pSrc          pointer to the input vector
    pDst          pointer to the output vector
    len           length of the vectors
Return:
    ippStsNullPtrErr    pointer(s) to the data is NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
}

 function ippsConvert_16f32f( pSrc : Ipp16fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsConvert
  Purpose:    convert integer data to integer data
  Parameters:
    pSrc         pointer to the input integer data to be converted
    pDst         pointer to destination vector
    len          length of the vectors
    rndMode      Rounding mode which can be ippRndZero or ippRndNear
    scaleFactor  scale factor value
  Return:
    ippStsNullPtrErr    pointer(s) to the data NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
  Note:
    an out-of-range result will be saturated
}

 function ippsConvert_64s32s_Sfs( pSrc : Ipp64sPtr ; pDst : Ipp32sPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsThreshold
  Purpose:    execute threshold operation on every element of the vector
  Parameters:
    level      level of the threshold operation
    pSrcDst    pointer to the vector for in-place operation
    pSrc       pointer to the input vector
    pDst       pointer to the output vector
    len        length of the vectors
    relOp      comparison mode,  cmpLess or cmpGreater
  Return:
    ippStsNullPtrErr          pointer(s) to the data is NULL
    ippStsSizeErr             length of the vectors is less or equal zero
    ippStsThreshNegLevelErr   negative level value in complex operation
    ippStsBadArgErr           relOp is no cmpLess and no cmpGreater
    ippStsNoErr               otherwise
  Notes:
  real data
    cmpLess    : pDst[n] = pSrc[n] < level ? level : pSrc[n];
    cmpGreater : pDst[n] = pSrc[n] > level ? level : pSrc[n];
  complex data
    cmpLess    : pDst[n] = abs(pSrc[n]) < level ? pSrc[n]*k : pSrc[n];
    cmpGreater : pDst[n] = abs(pSrc[n]) > level ? pSrc[n]*k : pSrc[n];
    where k = level / abs(pSrc[n]);
}

 function ippsThreshold_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ; relOp : IppCmpOp ): IppStatus; _ippapi
 function ippsThreshold_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ; relOp : IppCmpOp ): IppStatus; _ippapi
 function ippsThreshold_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ; relOp : IppCmpOp ): IppStatus; _ippapi
 function ippsThreshold_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ; relOp : IppCmpOp ): IppStatus; _ippapi
 function ippsThreshold_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ; relOp : IppCmpOp ): IppStatus; _ippapi
 function ippsThreshold_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ; level : Ipp16s ; relOp : IppCmpOp ): IppStatus; _ippapi

 function ippsThreshold_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ; relOp : IppCmpOp ): IppStatus; _ippapi
 function ippsThreshold_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ; relOp : IppCmpOp ): IppStatus; _ippapi
 function ippsThreshold_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ; relOp : IppCmpOp ): IppStatus; _ippapi
 function ippsThreshold_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ; relOp : IppCmpOp ): IppStatus; _ippapi
 function ippsThreshold_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ; relOp : IppCmpOp ): IppStatus; _ippapi
 function ippsThreshold_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; level : Ipp16s ; relOp : IppCmpOp ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsThresholdLT
              ippsThresholdGT
  Purpose:    execute threshold operation on every element of the vector, 
              "less than" for ippsThresoldLT
              "greater than for ippsThresholdGT
  Parameters:
    pSrcDst    pointer to the vector for in-place operation
    pSrc       pointer to the input vector
    pDst       pointer to the output vector
    len         length of the vectors
    level      level of the threshold operation
  Return:
    ippStsNullPtrErr          pointer(s) to the data is NULL
    ippStsSizeErr             length of the vectors is less or equal zero
    ippStsThreshNegLevelErr   negative level value in complex operation
    ippStsNoErr               otherwise
}

 function ippsThreshold_LT_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LT_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LT_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LT_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LT_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_LT_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_LT_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LT_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LT_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LT_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LT_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_LT_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi

 function ippsThreshold_LT_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ; level : Ipp32s ): IppStatus; _ippapi
 function ippsThreshold_LT_32s( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; level : Ipp32s ): IppStatus; _ippapi

 function ippsThreshold_GT_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_GT_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_GT_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_GT_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_GT_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_GT_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_GT_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_GT_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_GT_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_GT_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_GT_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_GT_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsThreshold_LTAbs
              ippsThreshold_GTAbs
  Purpose:    execute threshold by abolute value operation on every element
              of the vector
              "less than" for ippsThresold_LTAbs
              "greater than for ippsThreshold_GTAbs
  Parameters:
    pSrcDst    pointer to the vector for in-place operation
    pSrc       pointer to the input vector
    pDst       pointer to the output vector
    len         length of the vectors
    level      level of the threshold operation
  Return:
    ippStsNullPtrErr          pointer(s) to the data is NULL
    ippStsSizeErr             length of the vectors is less or equal zero
    ippStsThreshNegLevelErr   negative level value in complex operation
    ippStsNoErr               otherwise
}

 function ippsThreshold_LTAbs_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTAbs_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LTAbs_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_LTAbs_32s( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; level : Ipp32s ): IppStatus; _ippapi
 function ippsThreshold_LTAbs_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTAbs_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LTAbs_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_LTAbs_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ; level : Ipp32s ): IppStatus; _ippapi
 function ippsThreshold_GTAbs_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_GTAbs_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_GTAbs_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_GTAbs_32s( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; level : Ipp32s ): IppStatus; _ippapi
 function ippsThreshold_GTAbs_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_GTAbs_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_GTAbs_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_GTAbs_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ; level : Ipp32s ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsThresholdLTValue
              ippsThresholdGTValue
  Purpose:    execute threshold operation on every element of the vector with
              replace on value, 
              "less than" for ippsThresoldLTValue
              "greater than for ippsThresholdGTValue
  Parameters:
    pSrcDst    pointer to the vector for in-place operation
    pSrc       pointer to the input vector
    pDst       pointer to the output vector
    len         length of the vectors
    level      level of the threshold operation
    value      value of replace
  Return:
    ippStsNullPtrErr          pointer(s) to the data is NULL
    ippStsSizeErr             length of the vectors is less or equal zero
    ippStsThreshNegLevelErr   negative level value in complex operation
    ippStsNoErr               otherwise
}

 function ippsThreshold_LTVal_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ; value : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTVal_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ; value : Ipp32fc ): IppStatus; _ippapi
 function ippsThreshold_LTVal_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ; value : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LTVal_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ; value : Ipp64fc ): IppStatus; _ippapi
 function ippsThreshold_LTVal_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ; value : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_LTVal_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ; level : Ipp16s ; value : Ipp16sc ): IppStatus; _ippapi
 function ippsThreshold_LTVal_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ; value : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTVal_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ; value : Ipp32fc ): IppStatus; _ippapi
 function ippsThreshold_LTVal_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ; value : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LTVal_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ; value : Ipp64fc ): IppStatus; _ippapi
 function ippsThreshold_LTVal_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ; value : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_LTVal_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; level : Ipp16s ; value : Ipp16sc ): IppStatus; _ippapi
 function ippsThreshold_GTVal_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ; value : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_GTVal_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ; value : Ipp32fc ): IppStatus; _ippapi
 function ippsThreshold_GTVal_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ; value : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_GTVal_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ; value : Ipp64fc ): IppStatus; _ippapi
 function ippsThreshold_GTVal_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ; value : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_GTVal_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ; level : Ipp16s ; value : Ipp16sc ): IppStatus; _ippapi
 function ippsThreshold_GTVal_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ; value : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_GTVal_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ; value : Ipp32fc ): IppStatus; _ippapi
 function ippsThreshold_GTVal_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ; value : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_GTVal_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ; value : Ipp64fc ): IppStatus; _ippapi
 function ippsThreshold_GTVal_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ; value : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_GTVal_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; level : Ipp16s ; value : Ipp16sc ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsThreshold_LTAbsVal
  Purpose:    substitute each element of input vector that is less by absolute
              value than specified level by specified constant value:
              if( ABS(x[i]) < level ) y[i] = value;
              else y[i] = x[i];
  Parameters:
    pSrcDst    pointer to the vector for in-place operation
    pSrc       pointer to the input vector
    pDst       pointer to the output vector
    len        length of the vectors
    level      level of the threshold operation
    value      substitution value
  Return:
    ippStsNullPtrErr          pointer(s) to the data is NULL
    ippStsSizeErr             length of the vectors is less or equal zero
    ippStsThreshNegLevelErr   negative level is not supported
    ippStsNoErr               otherwise
}

 function ippsThreshold_LTAbsVal_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ; value : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTAbsVal_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ; value : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LTAbsVal_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ; value : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_LTAbsVal_32s( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; level : Ipp32s ; value : Ipp32s ): IppStatus; _ippapi
 function ippsThreshold_LTAbsVal_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ; value : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTAbsVal_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ; value : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LTAbsVal_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; level : Ipp16s ; value : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_LTAbsVal_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ; level : Ipp32s ; value : Ipp32s ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsThresholdLTInv

  Purpose:    replace elements of vector values by their inversion after
              threshold operation
  Parameters:
    level      level of threshold operation
    pSrcDst    pointer to the vector in in-place operation
    pSrc       pointer to the source vector
    pDst       pointer to the destination vector
    len        length of the vectors
  Return:
    ippStsNullPtrErr              pointer(s) to the data is NULL
    ippStsSizeErr                 length of the vector is less or equal zero
    ippStsThreshNegLevelErr       negative level value
    ippStsInvZero                 level value and source element value are zero
    ippStsNoErr                   otherwise
}

 function ippsThreshold_LTInv_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTInv_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTInv_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LTInv_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi

 function ippsThreshold_LTInv_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTInv_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ; level : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTInv_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LTInv_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ; level : Ipp64f ): IppStatus; _ippapi

{ ---------------------------------------------------------------------------- }

 function ippsThreshold_LTValGTVal_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; levelLT : Ipp32f ; valueLT : Ipp32f ; levelGT : Ipp32f ; valueGT : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTValGTVal_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; levelLT : Ipp64f ; valueLT : Ipp64f ; levelGT : Ipp64f ; valueGT : Ipp64f ): IppStatus; _ippapi
 function ippsThreshold_LTValGTVal_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; levelLT : Ipp32f ; valueLT : Ipp32f ; levelGT : Ipp32f ; valueGT : Ipp32f ): IppStatus; _ippapi
 function ippsThreshold_LTValGTVal_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; levelLT : Ipp64f ; valueLT : Ipp64f ; levelGT : Ipp64f ; valueGT : Ipp64f ): IppStatus; _ippapi

 function ippsThreshold_LTValGTVal_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; levelLT : Ipp16s ; valueLT : Ipp16s ; levelGT : Ipp16s ; valueGT : Ipp16s ): IppStatus; _ippapi
 function ippsThreshold_LTValGTVal_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; levelLT : Ipp16s ; valueLT : Ipp16s ; levelGT : Ipp16s ; valueGT : Ipp16s ): IppStatus; _ippapi

 function ippsThreshold_GT_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ; level : Ipp32s ): IppStatus; _ippapi
 function ippsThreshold_GT_32s( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; level : Ipp32s ): IppStatus; _ippapi

 function ippsThreshold_LTValGTVal_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ; levelLT : Ipp32s ; valueLT : Ipp32s ; levelGT : Ipp32s ; valueGT : Ipp32s ): IppStatus; _ippapi
 function ippsThreshold_LTValGTVal_32s( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; levelLT : Ipp32s ; valueLT : Ipp32s ; levelGT : Ipp32s ; valueGT : Ipp32s ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsCartToPolar

  Purpose:    Convert cartesian coordinate to polar. Input data are formed as
              a complex vector.

  Parameters:
   pSrc          an input complex vector
   pDstMagn      an output vector to store the magnitude components
   pDstPhase     an output vector to store the phase components (in radians)
   len           a length of the array
  Return:
   ippStsNoErr           Ok
   ippStsNullPtrErr      Some of pointers to input or output data are NULL
   ippStsSizeErr         The length of the arrays is less or equal zero
}

 function ippsCartToPolar_32fc( pSrc : Ipp32fcPtr ; pDstMagn : Ipp32fPtr ; pDstPhase : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCartToPolar_64fc( pSrc : Ipp64fcPtr ; pDstMagn : Ipp64fPtr ; pDstPhase : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsCartToPolar

  Purpose:    Convert cartesian coordinate to polar. Input data are formed as
              two real vectors.

  Parameters:
   pSrcRe       an input vector containing the coordinates X
   pSrcIm       an input vector containing the coordinates Y
   pDstMagn     an output vector to store the magnitude components
   pDstPhase    an output vector to store the phase components (in radians)
   len          a length of the array
  Return:
   ippStsNoErr           Ok
   ippStsNullPtrErr      Some of pointers to input or output data are NULL
   ippStsSizeErr         The length of the arrays is less or equal zero
}

 function ippsCartToPolar_32f( pSrcRe : Ipp32fPtr ; pSrcIm : Ipp32fPtr ; pDstMagn : Ipp32fPtr ; pDstPhase : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsCartToPolar_64f( pSrcRe : Ipp64fPtr ; pSrcIm : Ipp64fPtr ; pDstMagn : Ipp64fPtr ; pDstPhase : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsPolarToCart

  Purpose:    Convert polar coordinate to cartesian. Output data are formed as
              a complex vector.

  Parameters:
   pDstMagn      an input vector containing the magnitude components
   pDstPhase     an input vector containing the phase components(in radians)
   pDst          an output complex vector to store the cartesian coordinates
   len           a length of the arrays
  Return:
   ippStsNoErr           Ok
   ippStsNullPtrErr      Some of pointers to input or output data are NULL
   ippStsSizeErr         The length of the arrays is less or equal zero
}

 function ippsPolarToCart_32fc( pSrcMagn : Ipp32fPtr ; pSrcPhase : Ipp32fPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsPolarToCart_64fc( pSrcMagn : Ipp64fPtr ; pSrcPhase : Ipp64fPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsPolarToCart

  Purpose:    Convert polar coordinate to cartesian. Output data are formed as
              two real vectors.

  Parameters:
   pDstMagn     an input vector containing the magnitude components
   pDstPhase    an input vector containing the phase components(in radians)
   pSrcRe       an output complex vector to store the coordinates X
   pSrcIm       an output complex vector to store the coordinates Y
   len          a length of the arrays
  Return:
   ippStsNoErr           Ok
   ippStsNullPtrErr      Some of pointers to input or output data are NULL
   ippStsSizeErr         The length of the arrays is less or equal zero
}

 function ippsPolarToCart_32f( pSrcMagn : Ipp32fPtr ; pSrcPhase : Ipp32fPtr ; pDstRe : Ipp32fPtr ; pDstIm : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsPolarToCart_64f( pSrcMagn : Ipp64fPtr ; pSrcPhase : Ipp64fPtr ; pDstRe : Ipp64fPtr ; pDstIm : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsCartToPolar

  Purpose:    Convert cartesian coordinate to polar. Input data are formed as
              a complex vector.

  Parameters:
   pSrc              an input complex vector
   pDstMagn          an output vector to store the magnitude components
   pDstPhase         an output vector to store the phase components (in radians)
   len               a length of the array
   magnScaleFactor   scale factor of the magnitude companents
   phaseScaleFactor  scale factor of the phase companents
  Return:
   ippStsNoErr           Ok
   ippStsNullPtrErr      Some of pointers to input or output data are NULL
   ippStsSizeErr         The length of the arrays is less or equal zero
}

 function ippsCartToPolar_16sc_Sfs( pSrc : Ipp16scPtr ; pDstMagn : Ipp16sPtr ; pDstPhase : Ipp16sPtr ; len : Int32 ; magnScaleFactor : Int32 ; phaseScaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsPolarToCart

  Purpose:    Convert polar coordinate to cartesian. Output data are formed as
              a complex vector.

  Parameters:
   pDstMagn          an input vector containing the magnitude components
   pDstPhase         an input vector containing the phase components(in radians)
   pDst              an output complex vector to store the cartesian coordinates
   len               a length of the arrays
   magnScaleFactor   scale factor of the magnitude companents
   phaseScaleFactor  scale factor of the phase companents
  Return:
   ippStsNoErr           Ok
   ippStsNullPtrErr      Some of pointers to input or output data are NULL
   ippStsSizeErr         The length of the arrays is less or equal zero
}

 function ippsPolarToCart_16sc_Sfs( pSrcMagn : Ipp16sPtr ; pSrcPhase : Ipp16sPtr ; pDst : Ipp16scPtr ; len : Int32 ; magnScaleFactor : Int32 ; phaseScaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                          Companding functions
  ----------------------------------------------------------------------------

  Name:       ippsFlip
  Purpose:    dst[i] = src[len-i-1], i=0..len-1
  Parameters:
    pSrc      pointer to the input vector
    pDst      pointer to the output vector
    len       length of the vectors,  number of items
  Return:
    ippStsNullPtrErr        pointer(s) to the data is NULL
    ippStsSizeErr           length of the vectors is less or equal zero
    ippStsNoErr             otherwise
}

 function ippsFlip_8u( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsFlip_8u_I( pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsFlip_16u( pSrc : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsFlip_16u_I( pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsFlip_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsFlip_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsFlip_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsFlip_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsFlip_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsFlip_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsFlip_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsFlip_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsSwapBytes
  Purpose:    switches from a "big endian" order to the "little endian" order and vice-versa
  Parameters:
    pSrc                 pointer to the source vector
    pSrcDst              pointer to the source/destination vector
    pDst                 pointer to the destination vector
    len                  length of the vectors
  Return:
    ippStsNullPtrErr     pointer to the vector is NULL
    ippStsSizeErr        length of the vectors is less or equal zero
    ippStsNoErr          otherwise
}

 function ippsSwapBytes_16u_I( pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSwapBytes_24u_I( pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSwapBytes_32u_I( pSrcDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSwapBytes_64u_I( pSrcDst : Ipp64uPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsSwapBytes_16u( pSrc : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSwapBytes_24u( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSwapBytes_32u( pSrc : Ipp32uPtr ; pDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSwapBytes_64u( pSrc : Ipp64uPtr ; pDst : Ipp64uPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Arithmetic functions
------------------------------------------------------------------------------

  Names:       ippsAdd, ippsSub, ippsMul

  Purpose:    add, subtract and multiply operations upon every element of
              the source vector
  Arguments:
    pSrc                 pointer to the source vector
    pSrcDst              pointer to the source/destination vector
    pSrc1                pointer to the first source vector
    pSrc2                pointer to the second source vector
    pDst                 pointer to the destination vector
    len                  length of the vectors
    scaleFactor          scale factor value
  Return:
    ippStsNullPtrErr     pointer(s) to the data is NULL
    ippStsSizeErr        length of the vectors is less or equal zero
    ippStsNoErr          otherwise
  Note:
    AddC(X,v,Y)    :  Y[n] = X[n] + v
    MulC(X,v,Y)    :  Y[n] = X[n] * v
    SubC(X,v,Y)    :  Y[n] = X[n] - v
    SubCRev(X,v,Y) :  Y[n] = v - X[n]
    Sub(X,Y)       :  Y[n] = Y[n] - X[n]
    Sub(X,Y,Z)     :  Z[n] = Y[n] - X[n]
}

 function ippsAddC_16s_I( val : Ipp16s ; pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsSubC_16s_I( val : Ipp16s ; pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsMulC_16s_I( val : Ipp16s ; pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAddC_32f_I( val : Ipp32f ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAddC_32fc_I( val : Ipp32fc ; pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubC_32f_I( val : Ipp32f ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubC_32fc_I( val : Ipp32fc ; pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_32f_I( val : Ipp32f ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_32fc_I( val : Ipp32fc ; pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulC_32f_I( val : Ipp32f ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulC_32fc_I( val : Ipp32fc ; pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAddC_64f_I( val : Ipp64f ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAddC_64fc_I( val : Ipp64fc ; pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubC_64f_I( val : Ipp64f ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubC_64fc_I( val : Ipp64fc ; pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_64f_I( val : Ipp64f ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_64fc_I( val : Ipp64fc ; pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulC_64f_I( val : Ipp64f ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulC_64fc_I( val : Ipp64fc ; pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulC_32f16s_Sfs( pSrc : Ipp32fPtr ; val : Ipp32f ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_Low_32f16s( pSrc : Ipp32fPtr ; val : Ipp32f ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi


 function ippsAddC_8u_ISfs( val : Ipp8u ; pSrcDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubC_8u_ISfs( val : Ipp8u ; pSrcDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_8u_ISfs( val : Ipp8u ; pSrcDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_8u_ISfs( val : Ipp8u ; pSrcDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddC_16s_ISfs( val : Ipp16s ; pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubC_16s_ISfs( val : Ipp16s ; pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_16s_ISfs( val : Ipp16s ; pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddC_16sc_ISfs( val : Ipp16sc ; pSrcDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubC_16sc_ISfs( val : Ipp16sc ; pSrcDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_16sc_ISfs( val : Ipp16sc ; pSrcDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_16s_ISfs( val : Ipp16s ; pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_16sc_ISfs( val : Ipp16sc ; pSrcDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddC_32s_ISfs( val : Ipp32s ; pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddC_32sc_ISfs( val : Ipp32sc ; pSrcDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubC_32s_ISfs( val : Ipp32s ; pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubC_32sc_ISfs( val : Ipp32sc ; pSrcDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_32s_ISfs( val : Ipp32s ; pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_32sc_ISfs( val : Ipp32sc ; pSrcDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_32s_ISfs( val : Ipp32s ; pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_32sc_ISfs( val : Ipp32sc ; pSrcDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsAddC_32f( pSrc : Ipp32fPtr ; val : Ipp32f ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAddC_32fc( pSrc : Ipp32fcPtr ; val : Ipp32fc ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubC_32f( pSrc : Ipp32fPtr ; val : Ipp32f ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubC_32fc( pSrc : Ipp32fcPtr ; val : Ipp32fc ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_32f( pSrc : Ipp32fPtr ; val : Ipp32f ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_32fc( pSrc : Ipp32fcPtr ; val : Ipp32fc ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulC_32f( pSrc : Ipp32fPtr ; val : Ipp32f ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulC_32fc( pSrc : Ipp32fcPtr ; val : Ipp32fc ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAddC_64f( pSrc : Ipp64fPtr ; val : Ipp64f ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAddC_64fc( pSrc : Ipp64fcPtr ; val : Ipp64fc ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubC_64f( pSrc : Ipp64fPtr ; val : Ipp64f ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubC_64fc( pSrc : Ipp64fcPtr ; val : Ipp64fc ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_64f( pSrc : Ipp64fPtr ; val : Ipp64f ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_64fc( pSrc : Ipp64fcPtr ; val : Ipp64fc ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulC_64f( pSrc : Ipp64fPtr ; val : Ipp64f ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulC_64fc( pSrc : Ipp64fcPtr ; val : Ipp64fc ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsAddC_8u_Sfs( pSrc : Ipp8uPtr ; val : Ipp8u ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubC_8u_Sfs( pSrc : Ipp8uPtr ; val : Ipp8u ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_8u_Sfs( pSrc : Ipp8uPtr ; val : Ipp8u ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_8u_Sfs( pSrc : Ipp8uPtr ; val : Ipp8u ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddC_16s_Sfs( pSrc : Ipp16sPtr ; val : Ipp16s ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddC_16sc_Sfs( pSrc : Ipp16scPtr ; val : Ipp16sc ; pDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubC_16s_Sfs( pSrc : Ipp16sPtr ; val : Ipp16s ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubC_16sc_Sfs( pSrc : Ipp16scPtr ; val : Ipp16sc ; pDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_16s_Sfs( pSrc : Ipp16sPtr ; val : Ipp16s ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_16sc_Sfs( pSrc : Ipp16scPtr ; val : Ipp16sc ; pDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_16s_Sfs( pSrc : Ipp16sPtr ; val : Ipp16s ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_16sc_Sfs( pSrc : Ipp16scPtr ; val : Ipp16sc ; pDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddC_32s_Sfs( pSrc : Ipp32sPtr ; val : Ipp32s ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddC_32sc_Sfs( pSrc : Ipp32scPtr ; val : Ipp32sc ; pDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubC_32s_Sfs( pSrc : Ipp32sPtr ; val : Ipp32s ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubC_32sc_Sfs( pSrc : Ipp32scPtr ; val : Ipp32sc ; pDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_32s_Sfs( pSrc : Ipp32sPtr ; val : Ipp32s ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_32sc_Sfs( pSrc : Ipp32scPtr ; val : Ipp32sc ; pDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_32s_Sfs( pSrc : Ipp32sPtr ; val : Ipp32s ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_32sc_Sfs( pSrc : Ipp32scPtr ; val : Ipp32sc ; pDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsAdd_16s_I( pSrc : Ipp16sPtr ; pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSub_16s_I( pSrc : Ipp16sPtr ; pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_16s_I( pSrc : Ipp16sPtr ; pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_32f_I( pSrc : Ipp32fPtr ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_32fc_I( pSrc : Ipp32fcPtr ; pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSub_32f_I( pSrc : Ipp32fPtr ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSub_32fc_I( pSrc : Ipp32fcPtr ; pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_32f_I( pSrc : Ipp32fPtr ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_32fc_I( pSrc : Ipp32fcPtr ; pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_64f_I( pSrc : Ipp64fPtr ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_64fc_I( pSrc : Ipp64fcPtr ; pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSub_64f_I( pSrc : Ipp64fPtr ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSub_64fc_I( pSrc : Ipp64fcPtr ; pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_64f_I( pSrc : Ipp64fPtr ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_64fc_I( pSrc : Ipp64fcPtr ; pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAddC_64u_Sfs( pSrc : Ipp64uPtr ; val : Ipp64u ; pDst : Ipp64uPtr ; len : Ipp32u ; scaleFactor : Int32 ; rndMode : IppRoundMode ): IppStatus; _ippapi
 function ippsAddC_64s_Sfs( pSrc : Ipp64sPtr ; val : Ipp64s ; pDst : Ipp64sPtr ; len : Ipp32u ; scaleFactor : Int32 ; rndMode : IppRoundMode ): IppStatus; _ippapi

 function ippsAdd_8u_ISfs( pSrc : Ipp8uPtr ; pSrcDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_8u_ISfs( pSrc : Ipp8uPtr ; pSrcDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_8u_ISfs( pSrc : Ipp8uPtr ; pSrcDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_16s_ISfs( pSrc : Ipp16sPtr ; pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_16sc_ISfs( pSrc : Ipp16scPtr ; pSrcDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_16s_ISfs( pSrc : Ipp16sPtr ; pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_16sc_ISfs( pSrc : Ipp16scPtr ; pSrcDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_16s_ISfs( pSrc : Ipp16sPtr ; pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_16sc_ISfs( pSrc : Ipp16scPtr ; pSrcDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_32s_ISfs( pSrc : Ipp32sPtr ; pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_32sc_ISfs( pSrc : Ipp32scPtr ; pSrcDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_32s_ISfs( pSrc : Ipp32sPtr ; pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_32sc_ISfs( pSrc : Ipp32scPtr ; pSrcDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_32s_ISfs( pSrc : Ipp32sPtr ; pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_32sc_ISfs( pSrc : Ipp32scPtr ; pSrcDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_8u16u( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_8u16u( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_16s( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSub_16s( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_16s( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_16u( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_32u( pSrc1 : Ipp32uPtr ; pSrc2 : Ipp32uPtr ; pDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_16s32f( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSub_16s32f( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_16s32f( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_32fc( pSrc1 : Ipp32fcPtr ; pSrc2 : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSub_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSub_32fc( pSrc1 : Ipp32fcPtr ; pSrc2 : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_32fc( pSrc1 : Ipp32fcPtr ; pSrc2 : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAdd_64fc( pSrc1 : Ipp64fcPtr ; pSrc2 : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSub_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSub_64fc( pSrc1 : Ipp64fcPtr ; pSrc2 : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_64fc( pSrc1 : Ipp64fcPtr ; pSrc2 : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsAdd_8u_Sfs( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_8u_Sfs( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_8u_Sfs( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_16s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_16sc_Sfs( pSrc1 : Ipp16scPtr ; pSrc2 : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_16s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_16sc_Sfs( pSrc1 : Ipp16scPtr ; pSrc2 : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_16s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_16sc_Sfs( pSrc1 : Ipp16scPtr ; pSrc2 : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_16s32s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_32s_Sfs( pSrc1 : Ipp32sPtr ; pSrc2 : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_64s_Sfs( pSrc1 : Ipp64sPtr ; pSrc2 : Ipp64sPtr ; pDst : Ipp64sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_32sc_Sfs( pSrc1 : Ipp32scPtr ; pSrc2 : Ipp32scPtr ; pDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_32s_Sfs( pSrc1 : Ipp32sPtr ; pSrc2 : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_32sc_Sfs( pSrc1 : Ipp32scPtr ; pSrc2 : Ipp32scPtr ; pDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_32s_Sfs( pSrc1 : Ipp32sPtr ; pSrc2 : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_32sc_Sfs( pSrc1 : Ipp32scPtr ; pSrc2 : Ipp32scPtr ; pDst : Ipp32scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_16u16s_Sfs( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsMul_32f32fc_I( pSrc : Ipp32fPtr ; pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMul_32f32fc( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsAdd_16s32s_I( pSrc : Ipp16sPtr ; pSrcDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsAddC_16u_ISfs( val : Ipp16u ; pSrcDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddC_16u_Sfs( pSrc : Ipp16uPtr ; val : Ipp16u ; pDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_16u_ISfs( pSrc : Ipp16uPtr ; pSrcDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAdd_16u_Sfs( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsSubC_16u_ISfs( val : Ipp16u ; pSrcDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubC_16u_Sfs( pSrc : Ipp16uPtr ; val : Ipp16u ; pDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_16u_ISfs( val : Ipp16u ; pSrcDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSubCRev_16u_Sfs( pSrc : Ipp16uPtr ; val : Ipp16u ; pDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_16u_ISfs( pSrc : Ipp16uPtr ; pSrcDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSub_16u_Sfs( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsMulC_16u_ISfs( val : Ipp16u ; pSrcDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMulC_16u_Sfs( pSrc : Ipp16uPtr ; val : Ipp16u ; pDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_16u_ISfs( pSrc : Ipp16uPtr ; pSrcDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMul_16u_Sfs( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsMulC_64s_ISfs( val : Ipp64s ; pSrcDst : Ipp64sPtr ; len : Ipp32u ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsMulC_64f64s_ISfs( val : Ipp64f ; pSrcDst : Ipp64sPtr ; len : Ipp32u ; scaleFactor : Int32 ): IppStatus; _ippapi

{----------------------------------------------------------------------------
  Name:       ippsAddProduct
  Purpose:    multiplies elements of two source vectors and adds product to
              the accumulator vector
  Parameters:
    pSrc1                pointer to the first source vector
    pSrc2                pointer to the second source vector
    pSrcDst              pointer to the source/destination (accumulator) vector
    len                  length of the vectors
    scaleFactor          scale factor value
  Return:
    ippStsNullPtrErr     pointer to the vector is NULL
    ippStsSizeErr        length of the vectors is less or equal zero
    ippStsNoErr          otherwise

  Notes:                 pSrcDst[n] = pSrcDst[n] + pSrc1[n] Ptr pSrc2[n], n=0,1,2,..len-1.
}

 function ippsAddProduct_16s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddProduct_16s32s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddProduct_32s_Sfs( pSrc1 : Ipp32sPtr ; pSrc2 : Ipp32sPtr ; pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsAddProduct_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAddProduct_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsAddProduct_32fc( pSrc1 : Ipp32fcPtr ; pSrc2 : Ipp32fcPtr ; pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAddProduct_64fc( pSrc1 : Ipp64fcPtr ; pSrc2 : Ipp64fcPtr ; pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsSqr
  Purpose:    compute square value for every element of the source vector
  Parameters:
    pSrcDst          pointer to the source/destination vector
    pSrc             pointer to the input vector
    pDst             pointer to the output vector
    len              length of the vectors
   scaleFactor       scale factor value
  Return:
    ippStsNullPtrErr    pointer(s) the source data NULL
    ippStsSizeErr       length of the vectors is less or equal zero
    ippStsNoErr         otherwise
}

 function ippsSqr_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqr_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqr_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqr_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsSqr_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqr_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqr_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqr_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsSqr_16s_ISfs( pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSqr_16sc_ISfs( pSrcDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsSqr_16s_Sfs( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSqr_16sc_Sfs( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSqr_8u_ISfs( pSrcDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSqr_8u_Sfs( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSqr_16u_ISfs( pSrcDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSqr_16u_Sfs( pSrc : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsDiv

  Purpose:    divide every element of the source vector by the scalar value
              or by corresponding element of the second source vector
  Arguments:
    val               the divisor value
    pSrc              pointer to the divisor source vector
    pSrc1             pointer to the divisor source vector
    pSrc2             pointer to the dividend source vector
    pDst              pointer to the destination vector
    pSrcDst           pointer to the source/destination vector
    len               vector's length,  number of items
    scaleFactor       scale factor parameter value
  Return:
    ippStsNullPtrErr     pointer(s) to the data vector is NULL
    ippStsSizeErr        length of the vector is less or equal zero
    ippStsDivByZeroErr   the scalar divisor value is zero
    ippStsDivByZero      Warning status if an element of divisor vector is
                      zero. If the dividend is zero than result is
                      NaN, if the dividend is not zero than result
                      is Infinity with correspondent sign. The
                      execution is not aborted. For the integer operation
                      zero instead of NaN and the corresponding bound
                      values instead of Infinity
    ippStsNoErr          otherwise
  Note:
    DivC(v,X,Y)  :    Y[n] = X[n] / v
    DivC(v,X)    :    X[n] = X[n] / v
    Div(X,Y)     :    Y[n] = Y[n] / X[n]
    Div(X,Y,Z)   :    Z[n] = Y[n] / X[n]
}

 function ippsDiv_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDiv_32fc( pSrc1 : Ipp32fcPtr ; pSrc2 : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDiv_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDiv_64fc( pSrc1 : Ipp64fcPtr ; pSrc2 : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsDiv_16s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDiv_8u_Sfs( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDiv_16sc_Sfs( pSrc1 : Ipp16scPtr ; pSrc2 : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsDivC_32f( pSrc : Ipp32fPtr ; val : Ipp32f ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDivC_32fc( pSrc : Ipp32fcPtr ; val : Ipp32fc ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDivC_64f( pSrc : Ipp64fPtr ; val : Ipp64f ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDivC_64fc( pSrc : Ipp64fcPtr ; val : Ipp64fc ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsDivC_16s_Sfs( pSrc : Ipp16sPtr ; val : Ipp16s ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDivC_8u_Sfs( pSrc : Ipp8uPtr ; val : Ipp8u ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDivC_16sc_Sfs( pSrc : Ipp16scPtr ; val : Ipp16sc ; pDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsDiv_32f_I( pSrc : Ipp32fPtr ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDiv_32fc_I( pSrc : Ipp32fcPtr ; pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDiv_64f_I( pSrc : Ipp64fPtr ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDiv_64fc_I( pSrc : Ipp64fcPtr ; pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsDiv_16s_ISfs( pSrc : Ipp16sPtr ; pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDiv_8u_ISfs( pSrc : Ipp8uPtr ; pSrcDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDiv_16sc_ISfs( pSrc : Ipp16scPtr ; pSrcDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsDiv_32s_Sfs( pSrc1 : Ipp32sPtr ; pSrc2 : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsDiv_32s_ISfs( pSrc : Ipp32sPtr ; pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsDiv_32s16s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp32sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsDivC_32f_I( val : Ipp32f ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDivC_32fc_I( val : Ipp32fc ; pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDivC_64f_I( val : Ipp64f ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDivC_64fc_I( val : Ipp64fc ; pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsDivC_16s_ISfs( val : Ipp16s ; pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDivC_8u_ISfs( val : Ipp8u ; pSrcDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDivC_16sc_ISfs( val : Ipp16sc ; pSrcDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsDivCRev_16u( pSrc : Ipp16uPtr ; val : Ipp16u ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDivCRev_32f( pSrc : Ipp32fPtr ; val : Ipp32f ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDivCRev_16u_I( val : Ipp16u ; pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsDivCRev_32f_I( val : Ipp32f ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsDivC_16u_ISfs( val : Ipp16u ; pSrcDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDivC_16u_Sfs( pSrc : Ipp16uPtr ; val : Ipp16u ; pDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDiv_16u_ISfs( pSrc : Ipp16uPtr ; pSrcDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDiv_16u_Sfs( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsDivC_64s_ISfs( val : Ipp64s ; pSrcDst : Ipp64sPtr ; len : Ipp32u ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsSqrt
  Purpose:    compute square root value for every element of the source vector
   pSrc                 pointer to the source vector
   pDst                 pointer to the destination vector
   pSrcDst              pointer to the source/destination vector
   len                  length of the vector(s), number of items
   scaleFactor          scale factor value
  Return:
   ippStsNullPtrErr        pointer to vector is NULL
   ippStsSizeErr           length of the vector is less or equal zero
   ippStsSqrtNegArg        negative value in real sequence
   ippStsNoErr             otherwise
}

 function ippsSqrt_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqrt_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqrt_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqrt_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsSqrt_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqrt_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqrt_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSqrt_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsSqrt_16s_ISfs( pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSqrt_16sc_ISfs( pSrcDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsSqrt_16s_Sfs( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSqrt_16sc_Sfs( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsSqrt_8u_ISfs( pSrcDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSqrt_8u_Sfs( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSqrt_16u_ISfs( pSrcDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSqrt_16u_Sfs( pSrc : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsSqrt_32s16s_Sfs( pSrc : Ipp32sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsCubrt
  Purpose:    Compute cube root of every elements of the source vector
  Parameters:
   pSrc                 pointer to the source vector
   pDst                 pointer to the destination vector
   len                  length of the vector(s)
   scaleFactor          scale factor value
  Return:
   ippStsNullPtrErr        pointer(s) to the data vector is NULL
   ippStsSizeErr           length of the vector(s) is less or equal 0
   ippStsNoErr             otherwise
}

 function ippsCubrt_32s16s_Sfs( pSrc : Ipp32sPtr ; pDst : Ipp16sPtr ; Len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsCubrt_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsAbs
  Purpose:    compute absolute value of each element of the source vector
  Parameters:
   pSrcDst            pointer to the source/destination vector
   pSrc               pointer to the source vector
   pDst               pointer to the destination vector
   len                length of the vector(s), number of items
  Return:
   ippStsNullPtrErr      pointer(s) to data vector is NULL
   ippStsSizeErr         length of a vector is less or equal 0
   ippStsNoErr           otherwise
}

 function ippsAbs_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAbs_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAbs_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsAbs_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAbs_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAbs_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsAbs_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAbs_32s( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsMagnitude
  Purpose:    compute magnitude of every complex element of the source
  Parameters:
   pSrcDst            pointer to the source/destination vector
   pSrc               pointer to the source vector
   pDst               pointer to the destination vector
   len                length of the vector(s), number of items
   scaleFactor        scale factor value
  Return:
   ippStsNullPtrErr      pointer(s) to data vector is NULL
   ippStsSizeErr         length of a vector is less or equal 0
   ippStsNoErr           otherwise
  Notes:
         dst = sqrt( src.re^2 + src.im^2 )
}

 function ippsMagnitude_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMagnitude_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMagnitude_16sc32f( pSrc : Ipp16scPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMagnitude_16sc_Sfs( pSrc : Ipp16scPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMagnitude_32f( pSrcRe : Ipp32fPtr ; pSrcIm : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMagnitude_64f( pSrcRe : Ipp64fPtr ; pSrcIm : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMagnitude_16s_Sfs( pSrcRe : Ipp16sPtr ; pSrcIm : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMagnitude_32sc_Sfs( pSrc : Ipp32scPtr ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsMagnitude_16s32f( pSrcRe : Ipp16sPtr ; pSrcIm : Ipp16sPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsExp
  Purpose:    compute exponent value for all elements of the source vector
  Parameters:
   pSrcDst            pointer to the source/destination vector
   pSrc               pointer to the source vector
   pDst               pointer to the destination vector
   len                length of the vector(s)
   scaleFactor        scale factor value
  Return:
   ippStsNullPtrErr      pointer(s) to the data vector is NULL
   ippStsSizeErr         length of the vector(s) is less or equal 0
   ippStsNoErr           otherwise
}

 function ippsExp_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsExp_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsExp_16s_ISfs( pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsExp_32s_ISfs( pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsExp_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsExp_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsExp_16s_Sfs( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsExp_32s_Sfs( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsLn
  Purpose:    compute natural logarithm of every elements of the source vector
  Parameters:
   pSrcDst              pointer to the source/destination vector
   pSrc                 pointer to the source vector
   pDst                 pointer to the destination vector
   len                  length of the vector(s)
   ScaleFactor          scale factor value
  Return:
   ippStsNullPtrErr        pointer(s) to the data vector is NULL
   ippStsSizeErr           length of the vector(s) is less or equal 0
   ippStsLnZeroArg         zero value in the source vector
   ippStsLnNegArg          negative value in the source vector
   ippStsNoErr             otherwise
  Notes:
                Ln( x<0 ) = NaN
                Ln( 0 ) = -Inf
}

 function ippsLn_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsLn_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsLn_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsLn_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsLn_16s_ISfs( pSrcDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsLn_16s_Sfs( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsLn_32s_ISfs( pSrcDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsLn_32s_Sfs( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsSumLn
  Purpose:    computes sum of natural logarithm every elements of the source vector
  Parameters:
   pSrc                 pointer to the source vector
   pSum                 pointer to the result
   len                  length of the vector
  Return:
   ippStsNullPtrErr     pointer(s) to the data vector is NULL
   ippStsSizeErr        length of the vector(s) is less or equal 0
   ippStsLnZeroArg      zero value in the source vector
   ippStsLnNegArg       negative value in the source vector
   ippStsNoErr          otherwise
}


 function ippsSumLn_32f( pSrc : Ipp32fPtr ; len : Int32 ; pSum : Ipp32fPtr ): IppStatus; _ippapi
 function ippsSumLn_64f( pSrc : Ipp64fPtr ; len : Int32 ; pSum : Ipp64fPtr ): IppStatus; _ippapi
 function ippsSumLn_32f64f( pSrc : Ipp32fPtr ; len : Int32 ; pSum : Ipp64fPtr ): IppStatus; _ippapi
 function ippsSumLn_16s32f( pSrc : Ipp16sPtr ; len : Int32 ; pSum : Ipp32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsSortAscend, ippsSortDescend

  Purpose:    Execute sorting of all elemens of the vector.
              ippsSortAscend  is sorted in increasing order.
              ippsSortDescend is sorted in decreasing order.
  Arguments:
    pSrcDst              pointer to the source/destination vector
    len                  length of the vector
  Return:
    ippStsNullPtrErr     pointer to the data is NULL
    ippStsSizeErr        length of the vector is less or equal zero
    ippStsNoErr          otherwise
}

 function ippsSortAscend_8u_I( pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortAscend_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortAscend_16u_I( pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortAscend_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortAscend_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortAscend_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsSortDescend_8u_I( pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortDescend_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortDescend_16u_I( pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortDescend_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortDescend_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortDescend_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsSortIndexAscend_8u_I( pSrcDst : Ipp8uPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortIndexAscend_16s_I( pSrcDst : Ipp16sPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortIndexAscend_16u_I( pSrcDst : Ipp16uPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortIndexAscend_32s_I( pSrcDst : Ipp32sPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortIndexAscend_32f_I( pSrcDst : Ipp32fPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortIndexAscend_64f_I( pSrcDst : Ipp64fPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi

 function ippsSortIndexDescend_8u_I( pSrcDst : Ipp8uPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortIndexDescend_16s_I( pSrcDst : Ipp16sPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortIndexDescend_16u_I( pSrcDst : Ipp16uPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortIndexDescend_32s_I( pSrcDst : Ipp32sPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortIndexDescend_32f_I( pSrcDst : Ipp32fPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi
 function ippsSortIndexDescend_64f_I( pSrcDst : Ipp64fPtr ; pDstIdx : Int32Ptr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsSortRadixGetBufferSize, ippsSortRadixIndexGetBufferSize
  Purpose:     : Get the size (in bytes) of the buffer for ippsSortRadix internal calculations.
  Arguments:
    len           length of the vectors
    dataType      data type of the vector.
    pBufferSize   pointer to the calculated buffer size (in bytes).
  Return:
   ippStsNoErr        OK
   ippStsNullPtrErr   pBufferSize is NULL
   ippStsSizeErr      vector`s length is not positive
   ippStsDataTypeErr  unsupported data type
}

 function ippsSortRadixGetBufferSize( len : Int32 ; dataType : IppDataType ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsSortRadixIndexGetBufferSize( len : Int32 ; dataType : IppDataType ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsSortRadixAscend, ippsSortRadixDescend

  Purpose:    Rearrange elements of input vector using radix sort algorithm.
              ippsSortRadixAscend  - sorts input array in increasing order
              ippsSortRadixDescend - sorts input array in decreasing order

  Arguments:
    pSrcDst   pointer to the source/destination vector
    len       length of the vectors
    pBuffer   pointer to the work buffer
  Return:
    ippStsNoErr       OK
    ippStsNullPtrErr  pointer to the data or work buffer is NULL
    ippStsSizeErr     length of the vector is less or equal zero
}

 function ippsSortRadixAscend_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixAscend_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixAscend_32u_I( pSrcDst : Ipp32uPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixAscend_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixAscend_16u_I( pSrcDst : Ipp16uPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixAscend_8u_I( PtrpSrcDst : Ipp8u ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixAscend_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsSortRadixDescend_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixDescend_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixDescend_32u_I( pSrcDst : Ipp32uPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixDescend_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixDescend_16u_I( pSrcDst : Ipp16uPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixDescend_8u_I( PtrpSrcDst : Ipp8u ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixDescend_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsSortRadixIndexAscend, ippsSortRadixIndexDescend

  Purpose:    Indirectly sorts possibly sparse input vector,  using indexes.
              For a dense input array the following will be true:

              ippsSortRadixIndexAscend  - pSrc[pDstIndx[i-1]] <= pSrc[pDstIndx[i]];
              ippsSortRadixIndexDescend - pSrc[pDstIndx[i]] <= pSrc[pDstIndx[i-1]];

  Arguments:
    pSrc              pointer to the first element of a sparse input vector;
    srcStrideBytes    step between two consecutive elements of input vector in bytes;
    pDstIndx          pointer to the output indexes vector;
    len               length of the vectors
    pBuffer           pointer to the work buffer
  Return:
    ippStsNoErr       OK
    ippStsNullPtrErr  pointers to the vectors or poiter to work buffer is NULL
    ippStsSizeErr     length of the vector is less or equal zero
}

 function ippsSortRadixIndexAscend_32f( pSrc : Ipp32fPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixIndexAscend_32s( pSrc : Ipp32sPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixIndexAscend_32u( pSrc : Ipp32uPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixIndexAscend_16s( pSrc : Ipp16sPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixIndexAscend_16u( pSrc : Ipp16uPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixIndexAscend_8u( pSrc : Ipp8uPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixIndexDescend_32f( pSrc : Ipp32fPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixIndexDescend_32s( pSrc : Ipp32sPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixIndexDescend_32u( pSrc : Ipp32uPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixIndexDescend_16s( pSrc : Ipp16sPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixIndexDescend_16u( pSrc : Ipp16uPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsSortRadixIndexDescend_8u( pSrc : Ipp8uPtr ; srcStrideBytes : Ipp32s ; pDstIndx : Ipp32sPtr ; len : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Vector Measures Functions
------------------------------------------------------------------------------

  Names:      ippsSum
  Purpose:    sum all elements of the source vector
  Parameters:
   pSrc                pointer to the source vector
   pSum                pointer to the result
   len                 length of the vector
   scaleFactor         scale factor value
  Return:
   ippStsNullPtrErr       pointer to the vector or result is NULL
   ippStsSizeErr          length of the vector is less or equal 0
   ippStsNoErr            otherwise
}

 function ippsSum_16s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pSum : Ipp16sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSum_16sc_Sfs( pSrc : Ipp16scPtr ; len : Int32 ; pSum : Ipp16scPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSum_16s32s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pSum : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSum_16sc32sc_Sfs( pSrc : Ipp16scPtr ; len : Int32 ; pSum : Ipp32scPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSum_32s_Sfs( pSrc : Ipp32sPtr ; len : Int32 ; pSum : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsSum_32f( pSrc : Ipp32fPtr ; len : Int32 ; pSum : Ipp32fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsSum_32fc( pSrc : Ipp32fcPtr ; len : Int32 ; pSum : Ipp32fcPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsSum_64f( pSrc : Ipp64fPtr ; len : Int32 ; pSum : Ipp64fPtr ): IppStatus; _ippapi
 function ippsSum_64fc( pSrc : Ipp64fcPtr ; len : Int32 ; pSum : Ipp64fcPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsMean
  Purpose:    compute average value of all elements of the source vector
  Parameters:
   pSrc                pointer to the source vector
   pMean               pointer to the result
   len                 length of the source vector
   scaleFactor         scale factor value
  Return:
   ippStsNullPtrErr       pointer(s) to the vector or the result is NULL
   ippStsSizeErr          length of the vector is less or equal 0
   ippStsNoErr            otherwise
}

 function ippsMean_16s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pMean : Ipp16sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMean_16sc_Sfs( pSrc : Ipp16scPtr ; len : Int32 ; pMean : Ipp16scPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMean_32s_Sfs( pSrc : Ipp32sPtr ; len : Int32 ; pMean : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMean_32f( pSrc : Ipp32fPtr ; len : Int32 ; pMean : Ipp32fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsMean_32fc( pSrc : Ipp32fcPtr ; len : Int32 ; pMean : Ipp32fcPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsMean_64f( pSrc : Ipp64fPtr ; len : Int32 ; pMean : Ipp64fPtr ): IppStatus; _ippapi
 function ippsMean_64fc( pSrc : Ipp64fcPtr ; len : Int32 ; pMean : Ipp64fcPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsStdDev
  Purpose:    compute standard deviation value of all elements of the vector
  Parameters:
   pSrc               pointer to the vector
   len                length of the vector
   pStdDev            pointer to the result
   scaleFactor        scale factor value
  Return:
   ippStsNoErr           Ok
   ippStsNullPtrErr      pointer to the vector or the result is NULL
   ippStsSizeErr         length of the vector is less than 2
  Functionality:
         std = sqrt( sum( (x[n] - mean(x))^2, n=0..len-1 ) / (len-1))
}

 function ippsStdDev_16s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pStdDev : Ipp16sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsStdDev_16s32s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pStdDev : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsStdDev_32f( pSrc : Ipp32fPtr ; len : Int32 ; pStdDev : Ipp32fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsStdDev_64f( pSrc : Ipp64fPtr ; len : Int32 ; pStdDev : Ipp64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsMeanStdDev
  Purpose:    compute standard deviation value and mean value
              of all elements of the vector
  Parameters:
   pSrc               pointer to the vector
   len                length of the vector
   pStdDev            pointer to the result
   pMean              pointer to the result
   scaleFactor        scale factor value
  Return:
   ippStsNoErr           Ok
   ippStsNullPtrErr      pointer to the vector or the result is NULL
   ippStsSizeErr         length of the vector is less than 2
  Functionality:
         std = sqrt( sum( (x[n] - mean(x))^2, n=0..len-1 ) / (len-1))
}

 function ippsMeanStdDev_16s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pMean : Ipp16sPtr ; pStdDev : Ipp16sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMeanStdDev_16s32s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pMean : Ipp32sPtr ; pStdDev : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsMeanStdDev_32f( pSrc : Ipp32fPtr ; len : Int32 ; pMean : Ipp32fPtr ; pStdDev : Ipp32fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsMeanStdDev_64f( pSrc : Ipp64fPtr ; len : Int32 ; pMean : Ipp64fPtr ; pStdDev : Ipp64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:      ippsMin, ippsMax, ippsMinMax
 Purpose:    Find minimum/maximum value among all elements of the source vector
 Parameters:
    pSrc     - Pointer to the source vector.
    len      - Length of the vector.
    pMax     - Pointer to the result.
    pMin     - Pointer to the result.
 Returns:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - Error when any of the specified pointers is NULL.
    ippStsSizeErr     - Error when length of the vector is less or equal 0.
}

 function ippsMin_16s( pSrc : Ipp16sPtr ; len : Int32 ; pMin : Ipp16sPtr ): IppStatus; _ippapi
 function ippsMin_32s( pSrc : Ipp32sPtr ; len : Int32 ; pMin : Ipp32sPtr ): IppStatus; _ippapi
 function ippsMin_32f( pSrc : Ipp32fPtr ; len : Int32 ; pMin : Ipp32fPtr ): IppStatus; _ippapi
 function ippsMin_64f( pSrc : Ipp64fPtr ; len : Int32 ; pMin : Ipp64fPtr ): IppStatus; _ippapi

 function ippsMax_16s( pSrc : Ipp16sPtr ; len : Int32 ; pMax : Ipp16sPtr ): IppStatus; _ippapi
 function ippsMax_32s( pSrc : Ipp32sPtr ; len : Int32 ; pMax : Ipp32sPtr ): IppStatus; _ippapi
 function ippsMax_32f( pSrc : Ipp32fPtr ; len : Int32 ; pMax : Ipp32fPtr ): IppStatus; _ippapi
 function ippsMax_64f( pSrc : Ipp64fPtr ; len : Int32 ; pMax : Ipp64fPtr ): IppStatus; _ippapi

 function ippsMinMax_8u( pSrc : Ipp8uPtr ; len : Int32 ; pMin : Ipp8uPtr ; pMax : Ipp8uPtr ): IppStatus; _ippapi
 function ippsMinMax_16u( pSrc : Ipp16uPtr ; len : Int32 ; pMin : Ipp16uPtr ; pMax : Ipp16uPtr ): IppStatus; _ippapi
 function ippsMinMax_16s( pSrc : Ipp16sPtr ; len : Int32 ; pMin : Ipp16sPtr ; pMax : Ipp16sPtr ): IppStatus; _ippapi
 function ippsMinMax_32u( pSrc : Ipp32uPtr ; len : Int32 ; pMin : Ipp32uPtr ; pMax : Ipp32uPtr ): IppStatus; _ippapi
 function ippsMinMax_32s( pSrc : Ipp32sPtr ; len : Int32 ; pMin : Ipp32sPtr ; pMax : Ipp32sPtr ): IppStatus; _ippapi
 function ippsMinMax_32f( pSrc : Ipp32fPtr ; len : Int32 ; pMin : Ipp32fPtr ; pMax : Ipp32fPtr ): IppStatus; _ippapi
 function ippsMinMax_64f( pSrc : Ipp64fPtr ; len : Int32 ; pMin : Ipp64fPtr ; pMax : Ipp64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:      ippsMinAbs, ippsMaxAbs
 Purpose:    Returns the minimum/maximum absolute value of a vector.
 Parameters:
    pSrc     - Pointer to the source vector.
    len      - Length of the vector.
    pMinAbs  - Pointer to the result.
    pMaxAbs  - Pointer to the result.
 Returns:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - Error when any of the specified pointers is NULL.
    ippStsSizeErr     - Error when length of the vector is less or equal 0.
}

 function ippsMinAbs_16s( pSrc : Ipp16sPtr ; len : Int32 ; pMinAbs : Ipp16sPtr ): IppStatus; _ippapi
 function ippsMinAbs_32s( pSrc : Ipp32sPtr ; len : Int32 ; pMinAbs : Ipp32sPtr ): IppStatus; _ippapi
 function ippsMinAbs_32f( pSrc : Ipp32fPtr ; len : Int32 ; pMinAbs : Ipp32fPtr ): IppStatus; _ippapi
 function ippsMinAbs_64f( pSrc : Ipp64fPtr ; len : Int32 ; pMinAbs : Ipp64fPtr ): IppStatus; _ippapi

 function ippsMaxAbs_16s( pSrc : Ipp16sPtr ; len : Int32 ; pMaxAbs : Ipp16sPtr ): IppStatus; _ippapi
 function ippsMaxAbs_32s( pSrc : Ipp32sPtr ; len : Int32 ; pMaxAbs : Ipp32sPtr ): IppStatus; _ippapi
 function ippsMaxAbs_32f( pSrc : Ipp32fPtr ; len : Int32 ; pMaxAbs : Ipp32fPtr ): IppStatus; _ippapi
 function ippsMaxAbs_64f( pSrc : Ipp64fPtr ; len : Int32 ; pMaxAbs : Ipp64fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:      ippsMinIndx, ippsMaxIndx
 Purpose:    Find element with min/max value and return the value and the index.
 Parameters:
    pSrc     - Pointer to the input vector.
    len      - Length of the vector.
    pMin     - Pointer to min value found.
    pMax     - Pointer to max value found.
    pIndx    - Pointer to index of the first min/max value,  may be NULL.
    pMinIndx - Pointer to index of the first minimum value.
    pMaxIndx - Pointer to index of the first maximum value.
 Returns:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - Error when any of the specified pointers is NULL.
    ippStsSizeErr     - Error when length of the vector is less or equal 0.
}

 function ippsMinIndx_16s( pSrc : Ipp16sPtr ; len : Int32 ; pMin : Ipp16sPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMinIndx_32s( pSrc : Ipp32sPtr ; len : Int32 ; pMin : Ipp32sPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMinIndx_32f( pSrc : Ipp32fPtr ; len : Int32 ; pMin : Ipp32fPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMinIndx_64f( pSrc : Ipp64fPtr ; len : Int32 ; pMin : Ipp64fPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi

 function ippsMaxIndx_16s( pSrc : Ipp16sPtr ; len : Int32 ; pMax : Ipp16sPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMaxIndx_32s( pSrc : Ipp32sPtr ; len : Int32 ; pMax : Ipp32sPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMaxIndx_32f( pSrc : Ipp32fPtr ; len : Int32 ; pMax : Ipp32fPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMaxIndx_64f( pSrc : Ipp64fPtr ; len : Int32 ; pMax : Ipp64fPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi

 function ippsMinMaxIndx_8u( pSrc : Ipp8uPtr ; len : Int32 ; pMin : Ipp8uPtr ; pMinIndx : Int32Ptr ; pMax : Ipp8uPtr ; pMaxIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMinMaxIndx_16u( pSrc : Ipp16uPtr ; len : Int32 ; pMin : Ipp16uPtr ; pMinIndx : Int32Ptr ; pMax : Ipp16uPtr ; pMaxIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMinMaxIndx_16s( pSrc : Ipp16sPtr ; len : Int32 ; pMin : Ipp16sPtr ; pMinIndx : Int32Ptr ; pMax : Ipp16sPtr ; pMaxIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMinMaxIndx_32u( pSrc : Ipp32uPtr ; len : Int32 ; pMin : Ipp32uPtr ; pMinIndx : Int32Ptr ; pMax : Ipp32uPtr ; pMaxIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMinMaxIndx_32s( pSrc : Ipp32sPtr ; len : Int32 ; pMin : Ipp32sPtr ; pMinIndx : Int32Ptr ; pMax : Ipp32sPtr ; pMaxIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMinMaxIndx_32f( pSrc : Ipp32fPtr ; len : Int32 ; pMin : Ipp32fPtr ; pMinIndx : Int32Ptr ; pMax : Ipp32fPtr ; pMaxIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMinMaxIndx_64f( pSrc : Ipp64fPtr ; len : Int32 ; pMin : Ipp64fPtr ; pMinIndx : Int32Ptr ; pMax : Ipp64fPtr ; pMaxIndx : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:      ippsMinAbsIndx, ippsMaxAbsIndx
 Purpose:    Returns the min/max absolute value of a vector and the index of the corresponding element.
 Parameters:
    pSrc     - Pointer to the input vector.
    len      - Length of the vector.
    pMinAbs  - Pointer to the min absolute value found.
    pMaxAbs  - Pointer to the max absolute value found.
    pMinIndx - Pointer to index of the first minimum absolute value.
    pMaxIndx - Pointer to index of the first maximum absolute value.
 Returns:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - Error when any of the specified pointers is NULL.
    ippStsSizeErr     - Error when length of the vector is less or equal 0.
}

 function ippsMinAbsIndx_16s( pSrc : Ipp16sPtr ; len : Int32 ; pMinAbs : Ipp16sPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMinAbsIndx_32s( pSrc : Ipp32sPtr ; len : Int32 ; pMinAbs : Ipp32sPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi

 function ippsMaxAbsIndx_16s( pSrc : Ipp16sPtr ; len : Int32 ; pMaxAbs : Ipp16sPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi
 function ippsMaxAbsIndx_32s( pSrc : Ipp32sPtr ; len : Int32 ; pMaxAbs : Ipp32sPtr ; pIndx : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Names:      ippsMinEvery, ippsMaxEvery
 Purpose:    Calculation min/max value for every element of two vectors.
 Parameters:
    pSrc     - Pointer to the first input vector.
    pSrcDst  - Pointer to the second input vector which stores the result.
    pSrc1    - Pointer to the first input vector.
    pSrc2    - Pointer to the second input vector.
    pDst     - Pointer to the destination vector.
    len      - Length of the vector.
 Returns:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - Error when any of the specified pointers is NULL.
    ippStsSizeErr     - Error when length of the vector is less or equal 0.
}

 function ippsMinEvery_8u_I( pSrc : Ipp8uPtr ; pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMinEvery_16u_I( pSrc : Ipp16uPtr ; pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMinEvery_16s_I( pSrc : Ipp16sPtr ; pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMinEvery_32s_I( pSrc : Ipp32sPtr ; pSrcDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMinEvery_32f_I( pSrc : Ipp32fPtr ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMinEvery_64f_I( pSrc : Ipp64fPtr ; pSrcDst : Ipp64fPtr ; len : Ipp32u ): IppStatus; _ippapi

 function ippsMinEvery_8u( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Ipp32u ): IppStatus; _ippapi
 function ippsMinEvery_16u( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Ipp32u ): IppStatus; _ippapi
 function ippsMinEvery_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Ipp32u ): IppStatus; _ippapi
 function ippsMinEvery_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Ipp32u ): IppStatus; _ippapi

 function ippsMaxEvery_8u_I( pSrc : Ipp8uPtr ; pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMaxEvery_16u_I( pSrc : Ipp16uPtr ; pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMaxEvery_16s_I( pSrc : Ipp16sPtr ; pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMaxEvery_32s_I( pSrc : Ipp32sPtr ; pSrcDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMaxEvery_32f_I( pSrc : Ipp32fPtr ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMaxEvery_64f_I( pSrc : Ipp64fPtr ; pSrcDst : Ipp64fPtr ; len : Ipp32u ): IppStatus; _ippapi

 function ippsMaxEvery_8u( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Ipp32u ): IppStatus; _ippapi
 function ippsMaxEvery_16u( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Ipp32u ): IppStatus; _ippapi
 function ippsMaxEvery_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Ipp32u ): IppStatus; _ippapi
 function ippsMaxEvery_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Ipp32u ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:
    ippsPhase_64fc
    ippsPhase_32fc
    ippsPhase_16sc_Sfs
    ippsPhase_16sc32f
  Purpose:
    Compute the phase (in radians) of complex vector elements.
  Parameters:
    pSrcRe    - an input complex vector
    pDst      - an output vector to store the phase components;
    len       - a length of the arrays.
    scaleFactor   - a scale factor of output results (only for integer data)
  Return:
    ippStsNoErr               Ok
    ippStsNullPtrErr          Some of pointers to input or output data are NULL
    ippStsBadSizeErr          The length of the arrays is less or equal zero
}

 function ippsPhase_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsPhase_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsPhase_16sc32f( pSrc : Ipp16scPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsPhase_16sc_Sfs( pSrc : Ipp16scPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:
    ippsPhase_64f
    ippsPhase_32f
    ippsPhase_16s_Sfs
    ippsPhase_16s32f
  Purpose:
    Compute the phase of complex data formed as two real vectors.
  Parameters:
    pSrcRe    - an input vector containing a real part of complex data
    pSrcIm    - an input vector containing an imaginary part of complex data
    pDst      - an output vector to store the phase components
    len       - a length of the arrays.
    scaleFactor   - a scale factor of output results (only for integer data)
  Return:
    ippStsNoErr               Ok
    ippStsNullPtrErr          Some of pointers to input or output data are NULL
    ippStsBadSizeErr          The length of the arrays is less or equal zero
}

 function ippsPhase_64f( pSrcRe : Ipp64fPtr ; pSrcIm : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsPhase_32f( pSrcRe : Ipp32fPtr ; pSrcIm : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsPhase_16s_Sfs( pSrcRe : Ipp16sPtr ; pSrcIm : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsPhase_16s32f( pSrcRe : Ipp16sPtr ; pSrcIm : Ipp16sPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:
      ippsMaxOrder_64f
      ippsMaxOrder_32f
      ippsMaxOrder_32s
      ippsMaxOrder_16s
  Purpose:
     Determines the maximal number of binary digits for data representation.
  Parameters:
    pSrc     The pointer on input signal vector.
    pOrder   Pointer to result value.
    len      The  length of  the input vector.
  Return:
    ippStsNoErr         Ok
    ippStsNullPtrErr    Some of pointers to input or output data are NULL
    ippStsSizeErr       The length of the arrays is less or equal zero
    ippStsNanArg        If not a number is met in a input value
}

 function ippsMaxOrder_64f( pSrc : Ipp64fPtr ; len : Int32 ; pOrder : Int32Ptr ): IppStatus; _ippapi
 function ippsMaxOrder_32f( pSrc : Ipp32fPtr ; len : Int32 ; pOrder : Int32Ptr ): IppStatus; _ippapi
 function ippsMaxOrder_32s( pSrc : Ipp32sPtr ; len : Int32 ; pOrder : Int32Ptr ): IppStatus; _ippapi
 function ippsMaxOrder_16s( pSrc : Ipp16sPtr ; len : Int32 ; pOrder : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsArctan

  Purpose: compute arctangent value for all elements of the source vector

  Return:
   stsNoErr           Ok
   stsNullPtrErr      Some of pointers to input or output data are NULL
   stsBadSizeErr      The length of the arrays is less or equal zero

  Parameters:
   pSrcDst            pointer to the source/destination vector
   pSrc               pointer to the source vector
   pDst               pointer to the destination vector
   len                a length of the array
}

 function ippsArctan_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsArctan_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsArctan_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsArctan_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippsFindNearestOne
  Purpose:        Searches the table for an element closest to the reference value
                  and returns its value and index
  Context:
  Returns:        IppStatus
    ippStsNoErr        Ok
    ippStsNullPtrErr   At least one of the specified pointers is NULL
    ippStsSizeErr      The length of the table is less than or equal to zero
  Parameters:
    inpVal        reference Value
    pOutVal       pointer to the found value
    pOutIndx      pointer to the found index
    pTable        table for search
    tblLen        length of the table
  Notes:
                  The table should contain monotonically increasing values
}

 function ippsFindNearestOne_16u( inpVal : Ipp16u ; pOutVal : Ipp16uPtr ; pOutIndex : Int32Ptr ; pTable : Ipp16uPtr ; tblLen : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippsFindNearest
  Purpose:        Searches the table for elements closest to the reference values
                  and the their indexes
  Context:
  Returns:        IppStatus
    ippStsNoErr        Ok
    ippStsNullPtrErr   At least one of the specified pointers is NULL
    ippStsSizeErr      The length of table or pVals is less than or equal to zero
  Parameters:
    pVals         pointer to the reference values vector
    pOutVals      pointer to the vector with the found values
    pOutIndexes   pointer to the array with indexes of the found elements
    len           length of the input vector
    pTable        table for search
    tblLen        length of the table
  Notes:
                  The table should contain monotonically increasing values
}


 function ippsFindNearest_16u( pVals : Ipp16uPtr ; pOutVals : Ipp16uPtr ; pOutIndexes : Int32Ptr ; len : Int32 ; pTable : Ipp16uPtr ; tblLen : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                      Vector logical functions
------------------------------------------------------------------------------

  Names:              ippsAnd, ippsOr, ippsXor, ippsNot, ippsLShiftC, ippsRShiftC
  Purpose:            logical operations and vector shifts
  Parameters:
   val                1) value to be ANDed/ORed/XORed with each element of the vector (And, Or, Xor);
                      2) position`s number which vector elements to be SHIFTed on (ShiftC)
   pSrc               pointer to input vector
   pSrcDst            pointer to input/output vector
   pSrc1              pointer to first input vector
   pSrc2              pointer to second input vector
   pDst               pointer to output vector
   len                vector`s length
  Return:
   ippStsNullPtrErr      pointer(s) to the data is NULL
   ippStsSizeErr         vector`s length is less or equal zero
   ippStsShiftErr        shift`s value is less zero
   ippStsNoErr           otherwise
}

 function ippsAndC_8u_I( val : Ipp8u ; pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAndC_8u( pSrc : Ipp8uPtr ; val : Ipp8u ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAndC_16u_I( val : Ipp16u ; pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAndC_16u( pSrc : Ipp16uPtr ; val : Ipp16u ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAndC_32u_I( val : Ipp32u ; pSrcDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAndC_32u( pSrc : Ipp32uPtr ; val : Ipp32u ; pDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAnd_8u_I( pSrc : Ipp8uPtr ; pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAnd_8u( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAnd_16u_I( pSrc : Ipp16uPtr ; pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAnd_16u( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAnd_32u_I( pSrc : Ipp32uPtr ; pSrcDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsAnd_32u( pSrc1 : Ipp32uPtr ; pSrc2 : Ipp32uPtr ; pDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsOrC_8u_I( val : Ipp8u ; pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsOrC_8u( pSrc : Ipp8uPtr ; val : Ipp8u ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsOrC_16u_I( val : Ipp16u ; pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsOrC_16u( pSrc : Ipp16uPtr ; val : Ipp16u ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsOrC_32u_I( val : Ipp32u ; pSrcDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsOrC_32u( pSrc : Ipp32uPtr ; val : Ipp32u ; pDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsOr_8u_I( pSrc : Ipp8uPtr ; pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsOr_8u( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsOr_16u_I( pSrc : Ipp16uPtr ; pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsOr_16u( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsOr_32u_I( pSrc : Ipp32uPtr ; pSrcDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsOr_32u( pSrc1 : Ipp32uPtr ; pSrc2 : Ipp32uPtr ; pDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsXorC_8u_I( val : Ipp8u ; pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsXorC_8u( pSrc : Ipp8uPtr ; val : Ipp8u ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsXorC_16u_I( val : Ipp16u ; pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsXorC_16u( pSrc : Ipp16uPtr ; val : Ipp16u ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsXorC_32u_I( val : Ipp32u ; pSrcDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsXorC_32u( pSrc : Ipp32uPtr ; val : Ipp32u ; pDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsXor_8u_I( pSrc : Ipp8uPtr ; pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsXor_8u( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsXor_16u_I( pSrc : Ipp16uPtr ; pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsXor_16u( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsXor_32u_I( pSrc : Ipp32uPtr ; pSrcDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsXor_32u( pSrc1 : Ipp32uPtr ; pSrc2 : Ipp32uPtr ; pDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsNot_8u_I( pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsNot_8u( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsNot_16u_I( pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsNot_16u( pSrc : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsNot_32u_I( pSrcDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsNot_32u( pSrc : Ipp32uPtr ; pDst : Ipp32uPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsLShiftC_8u_I( val : Int32 ; pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsLShiftC_8u( pSrc : Ipp8uPtr ; val : Int32 ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsLShiftC_16u_I( val : Int32 ; pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsLShiftC_16u( pSrc : Ipp16uPtr ; val : Int32 ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsLShiftC_16s_I( val : Int32 ; pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsLShiftC_16s( pSrc : Ipp16sPtr ; val : Int32 ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsLShiftC_32s_I( val : Int32 ; pSrcDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsLShiftC_32s( pSrc : Ipp32sPtr ; val : Int32 ; pDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsRShiftC_8u_I( val : Int32 ; pSrcDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsRShiftC_8u( pSrc : Ipp8uPtr ; val : Int32 ; pDst : Ipp8uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsRShiftC_16u_I( val : Int32 ; pSrcDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsRShiftC_16u( pSrc : Ipp16uPtr ; val : Int32 ; pDst : Ipp16uPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsRShiftC_16s_I( val : Int32 ; pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsRShiftC_16s( pSrc : Ipp16sPtr ; val : Int32 ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsRShiftC_32s_I( val : Int32 ; pSrcDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsRShiftC_32s( pSrc : Ipp32sPtr ; val : Int32 ; pDst : Ipp32sPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Dot Product Functions
------------------------------------------------------------------------------

  Name:       ippsDotProd
  Purpose:    compute Dot Product value
  Arguments:
     pSrc1               pointer to the source vector
     pSrc2               pointer to the another source vector
     len                 vector`s length,  number of items
     pDp                 pointer to the result
     scaleFactor         scale factor value
  Return:
     ippStsNullPtrErr       pointer(s) pSrc pDst is NULL
     ippStsSizeErr          length of the vectors is less or equal 0
     ippStsNoErr            otherwise
  Notes:
     the functions don`t conjugate one of the source vectors
}
 function ippsDotProd_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; len : Int32 ; pDp : Ipp32fPtr ): IppStatus; _ippapi
 function ippsDotProd_32fc( pSrc1 : Ipp32fcPtr ; pSrc2 : Ipp32fcPtr ; len : Int32 ; pDp : Ipp32fcPtr ): IppStatus; _ippapi
 function ippsDotProd_32f32fc( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fcPtr ; len : Int32 ; pDp : Ipp32fcPtr ): IppStatus; _ippapi

 function ippsDotProd_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; len : Int32 ; pDp : Ipp64fPtr ): IppStatus; _ippapi
 function ippsDotProd_64fc( pSrc1 : Ipp64fcPtr ; pSrc2 : Ipp64fcPtr ; len : Int32 ; pDp : Ipp64fcPtr ): IppStatus; _ippapi
 function ippsDotProd_64f64fc( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fcPtr ; len : Int32 ; pDp : Ipp64fcPtr ): IppStatus; _ippapi

 function ippsDotProd_16s64s( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; len : Int32 ; pDp : Ipp64sPtr ): IppStatus; _ippapi
 function ippsDotProd_16sc64sc( pSrc1 : Ipp16scPtr ; pSrc2 : Ipp16scPtr ; len : Int32 ; pDp : Ipp64scPtr ): IppStatus; _ippapi
 function ippsDotProd_16s16sc64sc( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16scPtr ; len : Int32 ; pDp : Ipp64scPtr ): IppStatus; _ippapi

 function ippsDotProd_16s32f( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; len : Int32 ; pDp : Ipp32fPtr ): IppStatus; _ippapi

 function ippsDotProd_32f64f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; len : Int32 ; pDp : Ipp64fPtr ): IppStatus; _ippapi
 function ippsDotProd_32fc64fc( pSrc1 : Ipp32fcPtr ; pSrc2 : Ipp32fcPtr ; len : Int32 ; pDp : Ipp64fcPtr ): IppStatus; _ippapi
 function ippsDotProd_32f32fc64fc( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fcPtr ; len : Int32 ; pDp : Ipp64fcPtr ): IppStatus; _ippapi

 function ippsDotProd_16s32s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; len : Int32 ; pDp : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDotProd_32s_Sfs( pSrc1 : Ipp32sPtr ; pSrc2 : Ipp32sPtr ; len : Int32 ; pDp : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDotProd_16s32s32s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp32sPtr ; len : Int32 ; pDp : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:
          ippsPowerSpectr_64fc
          ippsPowerSpectr_32fc
          ippsPowerSpectr_16sc_Sfs
          ippsPowerSpectr_16sc32f
  Purpose:
    Compute the power spectrum of complex vector
  Parameters:
    pSrcRe    - pointer to the real part of input vector.
    pSrcIm    - pointer to the image part of input vector.
    pDst      - pointer to the result.
    len       - vector length.
    scaleFactor   - scale factor for rezult (only for integer data).
  Return:
   ippStsNullPtrErr  indicates that one or more pointers to the data is NULL.
   ippStsSizeErr     indicates that vector length is less or equal zero.
   ippStsNoErr       otherwise.
}



 function ippsPowerSpectr_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsPowerSpectr_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsPowerSpectr_16sc_Sfs( pSrc : Ipp16scPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsPowerSpectr_16sc32f( pSrc : Ipp16scPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:
          ippsPowerSpectr_64f
          ippsPowerSpectr_32f
          ippsPowerSpectr_16s_Sfs
          ippsPowerSpectr_16s32f
  Purpose:
    Compute the power spectrum of complex data formed as two real vectors
  Parameters:
    pSrcRe    - pointer to the real part of input vector.
    pSrcIm    - pointer to the image part of input vector.
    pDst      - pointer to the result.
    len       - vector length.
    scaleFactor   - scale factor for rezult (only for integer data).
  Return:
   ippStsNullPtrErr  indicates that one or more pointers to the data is NULL.
   ippStsSizeErr     indicates that vector length is less or equal zero.
   ippStsNoErr       otherwise.
}

 function ippsPowerSpectr_64f( pSrcRe : Ipp64fPtr ; pSrcIm : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsPowerSpectr_32f( pSrcRe : Ipp32fPtr ; pSrcIm : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsPowerSpectr_16s_Sfs( pSrcRe : Ipp16sPtr ; pSrcIm : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsPowerSpectr_16s32f( pSrcRe : Ipp16sPtr ; pSrcIm : Ipp16sPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Linear Transform
------------------------------------------------------------------------------

  Names:
    ippsNormalize_64fc_I
    ippsNormalize_32fc_I
    ippsNormalize_16sc_ISfs
    ippsNormalize_64fc
    ippsNormalize_32fc
    ippsNormalize_16sc_Sfs
  Purpose:
    Complex vector normalization using offset and division method.
  Parameters:
    pSrcDst   - a complex vector for in-place operation
    pSrc      - an input complex vector
    pDst      - an output complex vector
    len       - a length of the arrays.
    vsub      - complex a subtrahend
    vdiv      - denominator
    scaleFactor   - a scale factor of output results (only for integer data)
  Return:
    ippStsNoErr            Ok
    ippStsNullPtrErr       Some of pointers to input or output data are NULL
    ippStsSizeErr          The length of the arrays is less or equal zero
    ippStsDivByZeroErr     denominator equal zero or less than float
                           format minimum
}
 function ippsNormalize_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ; vsub : Ipp64fc ; vdiv : Ipp64f ): IppStatus; _ippapi
 function ippsNormalize_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ; vsub : Ipp32fc ; vdiv : Ipp32f ): IppStatus; _ippapi
 function ippsNormalize_16sc_ISfs( pSrcDst : Ipp16scPtr ; len : Int32 ; vsub : Ipp16sc ; vdiv : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsNormalize_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ; vsub : Ipp64fc ; vdiv : Ipp64f ): IppStatus; _ippapi
 function ippsNormalize_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ; vsub : Ipp32fc ; vdiv : Ipp32f ): IppStatus; _ippapi
 function ippsNormalize_16sc_Sfs( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; vsub : Ipp16sc ; vdiv : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:
    ippsNormalize_64f_I
    ippsNormalize_32f_I
    ippsNormalize_16s_ISfs
    ippsNormalize_64f
    ippsNormalize_32f
    ippsNormalize_16s_Sfs
  Purpose:
    Normalize elements of real vector with the help of offset and division.
  Parameters:
    pSrcDst   - a vector of real data for in-place operation
    pSrc      - an input vector of real data
    pDst      - an output vector of real data
    len       - a length of the arrays.
    vSub      - subtrahend
    vDiv      - denominator
    scaleFactor   - a scale factor of output results (only for integer data)
  Return:
    ippStsNoErr               Ok
    ippStsNullPtrErr          Some of pointers to input or output data are NULL
    ippStsSizeErr             The length of the arrays is less or equal zero
    ippStsDivByZeroErr        denominator equal zero or less than float
                           format minimum
}

 function ippsNormalize_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; vSub : Ipp64f ; vDiv : Ipp64f ): IppStatus; _ippapi
 function ippsNormalize_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; vSub : Ipp32f ; vDiv : Ipp32f ): IppStatus; _ippapi
 function ippsNormalize_16s_ISfs( pSrcDst : Ipp16sPtr ; len : Int32 ; vSub : Ipp16s ; vDiv : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsNormalize_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; vSub : Ipp64f ; vDiv : Ipp64f ): IppStatus; _ippapi
 function ippsNormalize_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; vSub : Ipp32f ; vDiv : Ipp32f ): IppStatus; _ippapi
 function ippsNormalize_16s_Sfs( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; vSub : Ipp16s ; vDiv : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Definitions for FFT Functions
----------------------------------------------------------------------------

                  FFT Get Size Functions
------------------------------------------------------------------------------

  Name:       ippsFFTGetSize_C, ippsFFTGetSize_R
  Purpose:    Computes the size of the FFT context structure and the size
                of the required work buffer (in bytes)
  Arguments:
     order      Base-2 logarithm of the number of samples in FFT
     flag       Flag to choose the results normalization factors
     hint       Option to select the algorithmic implementation of the transform
                function
     pSizeSpec  Pointer to the size value of FFT specification structure
     pSizeInit  Pointer to the size value of the buffer for FFT initialization function
     pSizeBuf   Pointer to the size value of the FFT external work buffer
  Return:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
     ippStsFftOrderErr      FFT order value is illegal
     ippStsFFTFlagErr       Incorrect normalization flag value
}

 function ippsFFTGetSize_C_32fc( order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpecSize : Int32Ptr ; pSpecBufferSize : Int32Ptr ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsFFTGetSize_C_32f( order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpecSize : Int32Ptr ; pSpecBufferSize : Int32Ptr ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsFFTGetSize_R_32f( order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpecSize : Int32Ptr ; pSpecBufferSize : Int32Ptr ; var pBufferSize : Int32 ): IppStatus; _ippapi

 function ippsFFTGetSize_C_64fc( order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpecSize : Int32Ptr ; pSpecBufferSize : Int32Ptr ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsFFTGetSize_C_64f( order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpecSize : Int32Ptr ; pSpecBufferSize : Int32Ptr ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsFFTGetSize_R_64f( order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpecSize : Int32Ptr ; pSpecBufferSize : Int32Ptr ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  FFT Context Functions
------------------------------------------------------------------------------

  Name:       ippsFFTInit_C, ippsFFTInit_R
  Purpose:    Initializes the FFT context structure
  Arguments:
     order        Base-2 logarithm of the number of samples in FFT
     flag         Flag to choose the results normalization factors
     hint         Option to select the algorithmic implementation of the transform
                  function
     ppFFTSpec    Double pointer to the FFT specification structure to be created
     pSpec        Pointer to the FFT specification structure
     pSpecBuffer  Pointer to the temporary work buffer
  Return:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
     ippStsFftOrderErr      FFT order value is illegal
     ippStsFFTFlagErr       Incorrect normalization flag value
}

 function ippsFFTInit_C_32fc( ppFFTSpec : IppsFFTSpec_C_32fcPtrPtr ; order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpec : Ipp8uPtr ; pSpecBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInit_C_32f( ppFFTSpec : IppsFFTSpec_C_32fPtrPtr ; order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpec : Ipp8uPtr ; pSpecBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInit_R_32f( ppFFTSpec : IppsFFTSpec_R_32fPtrPtr ; order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpec : Ipp8uPtr ; pSpecBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsFFTInit_C_64fc( ppFFTSpec : IppsFFTSpec_C_64fcPtrPtr ; order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpec : Ipp8uPtr ; pSpecBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInit_C_64f( ppFFTSpec : IppsFFTSpec_C_64fPtrPtr ; order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpec : Ipp8uPtr ; pSpecBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInit_R_64f( ppFFTSpec : IppsFFTSpec_R_64fPtrPtr ; order : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSpec : Ipp8uPtr ; pSpecBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  FFT Complex Transforms
------------------------------------------------------------------------------

  Name:       ippsFFTFwd_CToC, ippsFFTInv_CToC
  Purpose:    Computes forward and inverse FFT of a complex signal
  Arguments:
     pFFTSpec     Pointer to the FFT context
     pSrc         Pointer to the source complex signal
     pDst         Pointer to the destination complex signal
     pSrcRe       Pointer to the real      part of source signal
     pSrcIm       Pointer to the imaginary part of source signal
     pDstRe       Pointer to the real      part of destination signal
     pDstIm       Pointer to the imaginary part of destination signal
     pSrcDst      Pointer to the complex signal
     pSrcDstRe    Pointer to the real      part of signal
     pSrcDstIm    Pointer to the imaginary part of signal
     pBuffer      Pointer to the work buffer
     scaleFactor  Scale factor for output result
  Return:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers with the exception of
                              pBuffer is NULL
     ippStsContextMatchErr  Invalid context structure
     ippStsMemAllocErr      Memory allocation fails
}

 function ippsFFTFwd_CToC_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; pFFTSpec : IppsFFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CToC_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; pFFTSpec : IppsFFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_CToC_32f( pSrcRe : Ipp32fPtr ; pSrcIm : Ipp32fPtr ; pDstRe : Ipp32fPtr ; pDstIm : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_C_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CToC_32f( pSrcRe : Ipp32fPtr ; pSrcIm : Ipp32fPtr ; pDstRe : Ipp32fPtr ; pDstIm : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_C_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsFFTFwd_CToC_32fc_I( pSrcDst : Ipp32fcPtr ; pFFTSpec : IppsFFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CToC_32fc_I( pSrcDst : Ipp32fcPtr ; pFFTSpec : IppsFFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_CToC_32f_I( pSrcDstRe : Ipp32fPtr ; pSrcDstIm : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_C_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CToC_32f_I( pSrcDstRe : Ipp32fPtr ; pSrcDstIm : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_C_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsFFTFwd_CToC_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; pFFTSpec : IppsFFTSpec_C_64fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CToC_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; pFFTSpec : IppsFFTSpec_C_64fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_CToC_64f( pSrcRe : Ipp64fPtr ; pSrcIm : Ipp64fPtr ; pDstRe : Ipp64fPtr ; pDstIm : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_C_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CToC_64f( pSrcRe : Ipp64fPtr ; pSrcIm : Ipp64fPtr ; pDstRe : Ipp64fPtr ; pDstIm : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_C_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsFFTFwd_CToC_64fc_I( pSrcDst : Ipp64fcPtr ; pFFTSpec : IppsFFTSpec_C_64fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CToC_64fc_I( pSrcDst : Ipp64fcPtr ; pFFTSpec : IppsFFTSpec_C_64fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_CToC_64f_I( pSrcDstRe : Ipp64fPtr ; pSrcDstIm : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_C_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CToC_64f_I( pSrcDstRe : Ipp64fPtr ; pSrcDstIm : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_C_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  FFT Real Packed Transforms
------------------------------------------------------------------------------

  Name:       ippsFFTFwd_RToPerm, ippsFFTFwd_RToPack, ippsFFTFwd_RToCCS
              ippsFFTInv_PermToR, ippsFFTInv_PackToR, ippsFFTInv_CCSToR
  Purpose:    Computes forward and inverse FFT of a real signal
              Perm : using ; Pack or Ccs packed format
  Arguments:
     pFFTSpec       Pointer to the FFT context
     pSrc           Pointer to the source signal
     pDst           Pointer to thedestination signal
     pSrcDst        Pointer to the source/destination signal (in-place)
     pBuffer        Pointer to the work buffer
     scaleFactor    Scale factor for output result
  Return:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers with the exception of
                              pBuffer is NULL
     ippStsContextMatchErr  Invalid context structure
     ippStsMemAllocErr      Memory allocation fails
}

 function ippsFFTFwd_RToPerm_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_RToPack_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_RToCCS_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_PermToR_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_PackToR_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CCSToR_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsFFTFwd_RToPerm_32f_I( pSrcDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_RToPack_32f_I( pSrcDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_RToCCS_32f_I( pSrcDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_PermToR_32f_I( pSrcDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_PackToR_32f_I( pSrcDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CCSToR_32f_I( pSrcDst : Ipp32fPtr ; pFFTSpec : IppsFFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsFFTFwd_RToPerm_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_RToPack_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_RToCCS_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_PermToR_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_PackToR_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CCSToR_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsFFTFwd_RToPerm_64f_I( pSrcDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_RToPack_64f_I( pSrcDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTFwd_RToCCS_64f_I( pSrcDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_PermToR_64f_I( pSrcDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_PackToR_64f_I( pSrcDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFFTInv_CCSToR_64f_I( pSrcDst : Ipp64fPtr ; pFFTSpec : IppsFFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Definitions for DFT Functions
----------------------------------------------------------------------------

                  DFT Context Functions
------------------------------------------------------------------------------

  Name:       ippsDFTGetSize_C, ippsDFTGetSize_R
  Purpose:    Computes the size of the DFT context structure and the size
                of the required work buffer (in bytes)
  Arguments:
     length     Length of the DFT transform
     flag       Flag to choose the results normalization factors
     hint       Option to select the algorithmic implementation of the transform
                function
     pSizeSpec  Pointer to the size value of DFT specification structure
     pSizeInit  Pointer to the size value of the buffer for DFT initialization function
     pSizeBuf   Pointer to the size value of the DFT external work buffer
  Return:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
     ippStsOrderErr         Invalid length value
     ippStsFFTFlagErr       Incorrect normalization flag value
     ippStsSizeErr          Indicates an error when length is less than or equal to 0
}

 function ippsDFTGetSize_C_32fc( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSizeSpec : Int32Ptr ; pSizeInit : Int32Ptr ; pSizeBuf : Int32Ptr ): IppStatus; _ippapi
 function ippsDFTGetSize_C_32f( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSizeSpec : Int32Ptr ; pSizeInit : Int32Ptr ; pSizeBuf : Int32Ptr ): IppStatus; _ippapi
 function ippsDFTGetSize_R_32f( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSizeSpec : Int32Ptr ; pSizeInit : Int32Ptr ; pSizeBuf : Int32Ptr ): IppStatus; _ippapi

 function ippsDFTGetSize_C_64fc( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSizeSpec : Int32Ptr ; pSizeInit : Int32Ptr ; pSizeBuf : Int32Ptr ): IppStatus; _ippapi
 function ippsDFTGetSize_C_64f( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSizeSpec : Int32Ptr ; pSizeInit : Int32Ptr ; pSizeBuf : Int32Ptr ): IppStatus; _ippapi
 function ippsDFTGetSize_R_64f( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pSizeSpec : Int32Ptr ; pSizeInit : Int32Ptr ; pSizeBuf : Int32Ptr ): IppStatus; _ippapi
{ ----------------------------------------------------------------------------

                  DFT Init Functions
------------------------------------------------------------------------------

  Name:       ippsDFTInit_C, ippsDFTInit_R
  Purpose:    initialize of DFT context
  Arguments:
     length     Length of the DFT transform
     flag       Flag to choose the results normalization factors
     hint       Option to select the algorithmic implementation of the transform
                function
     pDFTSpec   Double pointer to the DFT context structure
     pMemInit   Pointer to initialization buffer
  Return:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers is NULL
     ippStsOrderErr         Invalid length value
     ippStsFFTFlagErr       Incorrect normalization flag value
     ippStsSizeErr          Indicates an error when length is less than or equal to 0
}

 function ippsDFTInit_C_32fc( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pDFTSpec : IppsDFTSpec_C_32fcPtr ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInit_C_32f( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pDFTSpec : IppsDFTSpec_C_32fPtr ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInit_R_32f( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pDFTSpec : IppsDFTSpec_R_32fPtr ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi

 function ippsDFTInit_C_64fc( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pDFTSpec : IppsDFTSpec_C_64fcPtr ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInit_C_64f( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pDFTSpec : IppsDFTSpec_C_64fPtr ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInit_R_64f( length : Int32 ; flag : Int32 ; hint : IppHintAlgorithm ; pDFTSpec : IppsDFTSpec_R_64fPtr ; pMemInit : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  DFT Complex Transforms
------------------------------------------------------------------------------

  Name:       ippsDFTFwd_CToC, ippsDFTInv_CToC
  Purpose:    Computes forward and inverse DFT of a complex signal
  Arguments:
     pDFTSpec     Pointer to the DFT context
     pSrc         Pointer to the source complex signal
     pDst         Pointer to the destination complex signal
     pSrcRe       Pointer to the real      part of source signal
     pSrcIm       Pointer to the imaginary part of source signal
     pDstRe       Pointer to the real      part of destination signal
     pDstIm       Pointer to the imaginary part of destination signal
     pBuffer      Pointer to the work buffer
     scaleFactor  Scale factor for output result
  Return:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers with the exception of
                              pBuffer is NULL
     ippStsContextMatchErr  Invalid context structure
     ippStsMemAllocErr      Memory allocation fails
}

 function ippsDFTFwd_CToC_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; pDFTSpec : IppsDFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInv_CToC_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; pDFTSpec : IppsDFTSpec_C_32fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTFwd_CToC_32f( pSrcRe : Ipp32fPtr ; pSrcIm : Ipp32fPtr ; pDstRe : Ipp32fPtr ; pDstIm : Ipp32fPtr ; pDFTSpec : IppsDFTSpec_C_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInv_CToC_32f( pSrcRe : Ipp32fPtr ; pSrcIm : Ipp32fPtr ; pDstRe : Ipp32fPtr ; pDstIm : Ipp32fPtr ; pDFTSpec : IppsDFTSpec_C_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsDFTFwd_CToC_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; pDFTSpec : IppsDFTSpec_C_64fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInv_CToC_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; pDFTSpec : IppsDFTSpec_C_64fcPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTFwd_CToC_64f( pSrcRe : Ipp64fPtr ; pSrcIm : Ipp64fPtr ; pDstRe : Ipp64fPtr ; pDstIm : Ipp64fPtr ; pDFTSpec : IppsDFTSpec_C_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInv_CToC_64f( pSrcRe : Ipp64fPtr ; pSrcIm : Ipp64fPtr ; pDstRe : Ipp64fPtr ; pDstIm : Ipp64fPtr ; pDFTSpec : IppsDFTSpec_C_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  DFT Real Packed Transforms
{ ----------------------------------------------------------------------------


  Name:       ippsDFTFwd_RToPerm, ippsDFTFwd_RToPack, ippsDFTFwd_RToCCS
              ippsDFTInv_PermToR, ippsDFTInv_PackToR, ippsDFTInv_CCSToR
  Purpose:    Compute forward and inverse DFT of a real signal
              using Perm,  Pack or Ccs packed format
  Arguments:
     pFFTSpec       Pointer to the DFT context
     pSrc           Pointer to the source signal
     pDst           Pointer to the destination signal
     pSrcDst        Pointer to the source/destination signal (in-place)
     pBuffer        Pointer to the work buffer
     scaleFactor    Scale factor for output result
  Return:
     ippStsNoErr            No errors
     ippStsNullPtrErr       One of the specified pointers with the exception of
                              pBuffer is NULL
     ippStsContextMatchErr  Invalid context structure
     ippStsMemAllocErr      Memory allocation fails
}

 function ippsDFTFwd_RToPerm_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pDFTSpec : IppsDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTFwd_RToPack_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pDFTSpec : IppsDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTFwd_RToCCS_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pDFTSpec : IppsDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInv_PermToR_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pDFTSpec : IppsDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInv_PackToR_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pDFTSpec : IppsDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInv_CCSToR_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pDFTSpec : IppsDFTSpec_R_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsDFTFwd_RToPerm_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pDFTSpec : IppsDFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTFwd_RToPack_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pDFTSpec : IppsDFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTFwd_RToCCS_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pDFTSpec : IppsDFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInv_PermToR_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pDFTSpec : IppsDFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInv_PackToR_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pDFTSpec : IppsDFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDFTInv_CCSToR_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pDFTSpec : IppsDFTSpec_R_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

              Vector multiplication in RCPack and in RCPerm formats
{ ----------------------------------------------------------------------------


  Names:              ippsMulPack, ippsMulPerm
  Purpose:            multiply two vectors stored in RCPack and RCPerm formats
  Parameters:
   pSrc               pointer to input vector (in-place case)
   pSrcDst            pointer to output vector (in-place case)
   pSrc1              pointer to first input vector
   pSrc2              pointer to second input vector
   pDst               pointer to output vector
   len                vector`s length
   scaleFactor        scale factor
  Return:
   ippStsNullPtrErr      pointer(s) to the data is NULL
   ippStsSizeErr         vector`s length is less or equal zero
   ippStsNoErr           otherwise
}

 function ippsMulPack_32f_I( pSrc : Ipp32fPtr ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulPerm_32f_I( pSrc : Ipp32fPtr ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulPack_64f_I( pSrc : Ipp64fPtr ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulPerm_64f_I( pSrc : Ipp64fPtr ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulPack_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulPerm_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulPack_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulPerm_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:              ippsMulPackConj
  Purpose:            multiply on a complex conjugate vector and store in RCPack format
  Parameters:
   pSrc               pointer to input vector (in-place case)
   pSrcDst            pointer to output vector (in-place case)
   len                vector`s length
  Return:
   ippStsNullPtrErr      pointer(s) to the data is NULL
   ippStsSizeErr         vector`s length is less or equal zero
   ippStsNoErr           otherwise
}

 function ippsMulPackConj_32f_I( pSrc : Ipp32fPtr ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsMulPackConj_64f_I( pSrc : Ipp64fPtr ; pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:        ippsGoertz
  Purpose:      compute DFT for single frequency (Goertzel algorithm)
  Parameters:
    freq                 single relative frequency value [0, 1.0)
    pSrc                 pointer to the input vector
    len                  length of the vector
    pVal                 pointer to the DFT result value computed
    scaleFactor          scale factor value
  Return:
    ippStsNullPtrErr        pointer to the data is NULL
    ippStsSizeErr           length of the vector is less or equal zero
    ippStsRelFreqErr        frequency value out of range
    ippStsNoErr             otherwise
}

 function ippsGoertz_32fc( pSrc : Ipp32fcPtr ; len : Int32 ; pVal : Ipp32fcPtr ; rFreq : Ipp32f ): IppStatus; _ippapi
 function ippsGoertz_64fc( pSrc : Ipp64fcPtr ; len : Int32 ; pVal : Ipp64fcPtr ; rFreq : Ipp64f ): IppStatus; _ippapi

 function ippsGoertz_16sc_Sfs( pSrc : Ipp16scPtr ; len : Int32 ; pVal : Ipp16scPtr ; rFreq : Ipp32f ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsGoertz_32f( pSrc : Ipp32fPtr ; len : Int32 ; pVal : Ipp32fcPtr ; rFreq : Ipp32f ): IppStatus; _ippapi
 function ippsGoertz_16s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pVal : Ipp16scPtr ; rFreq : Ipp32f ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsGoertz_64f( pSrc : Ipp64fPtr ; len : Int32 ; pVal : Ipp64fcPtr ; rFreq : Ipp64f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Definitions for DCT Functions
----------------------------------------------------------------------------

                  DCT Get Size Functions
{ ----------------------------------------------------------------------------


  Name:       ippsDCTFwdGetSize, ippsDCTInvGetSize
  Purpose:    get sizes of the DCTSpec and buffers (in bytes)
  Arguments:
     len             - number of samples in DCT
     hint            - code specific use hints
     pSpecSize       - where write size of DCTSpec
     pSpecBufferSize - where write size of buffer for DCTInit functions
     pBufferSize     - where write size of buffer for DCT calculation
  Return:
     ippStsNoErr            no errors
     ippStsNullPtrErr       pSpecSize == NULL or pSpecBufferSize == NULL or
                            pBufferSize == NULL
     ippStsSizeErr          bad the len value
}

 function ippsDCTFwdGetSize_32f( len : Int32 ; hint : IppHintAlgorithm ; pSpecSize : Int32Ptr ; pSpecBufferSize : Int32Ptr ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsDCTInvGetSize_32f( len : Int32 ; hint : IppHintAlgorithm ; pSpecSize : Int32Ptr ; pSpecBufferSize : Int32Ptr ; var pBufferSize : Int32 ): IppStatus; _ippapi

 function ippsDCTFwdGetSize_64f( len : Int32 ; hint : IppHintAlgorithm ; pSpecSize : Int32Ptr ; pSpecBufferSize : Int32Ptr ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsDCTInvGetSize_64f( len : Int32 ; hint : IppHintAlgorithm ; pSpecSize : Int32Ptr ; pSpecBufferSize : Int32Ptr ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  DCT Context Functions
{ ----------------------------------------------------------------------------


  Name:       ippsDCTFwdInit, ippsDCTInvInit
  Purpose:    initialize of DCT context
  Arguments:
     len         - number of samples in DCT
     hint        - code specific use hints
     ppDCTSpec   - where write pointer to new context
     pSpec       - pointer to area for DCTSpec
     pSpecBuffer - pointer to work buffer
  Return:
     ippStsNoErr            no errors
     ippStsNullPtrErr       ppDCTSpec == NULL or
                            pSpec == NULL or pMemInit == NULL
     ippStsSizeErr          bad the len value
}

 function ippsDCTFwdInit_32f( ppDCTSpec : IppsDCTFwdSpec_32fPtrPtr ; len : Int32 ; hint : IppHintAlgorithm ; pSpec : Ipp8uPtr ; pSpecBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDCTInvInit_32f( ppDCTSpec : IppsDCTInvSpec_32fPtrPtr ; len : Int32 ; hint : IppHintAlgorithm ; pSpec : Ipp8uPtr ; pSpecBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsDCTFwdInit_64f( ppDCTSpec : IppsDCTFwdSpec_64fPtrPtr ; len : Int32 ; hint : IppHintAlgorithm ; pSpec : Ipp8uPtr ; pSpecBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDCTInvInit_64f( ppDCTSpec : IppsDCTInvSpec_64fPtrPtr ; len : Int32 ; hint : IppHintAlgorithm ; pSpec : Ipp8uPtr ; pSpecBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  DCT Transforms
{ ----------------------------------------------------------------------------


  Name:       ippsDCTFwd, ippsDCTInv
  Purpose:    compute forward and inverse DCT of signal
  Arguments:
     pDCTSpec - pointer to DCT context
     pSrc     - pointer to source signal
     pDst     - pointer to destination signal
     pSrcDst  - pointer to signal
     pBuffer  - pointer to work buffer
     scaleFactorPtr
              - scale factor for output result
  Return:
     ippStsNoErr            no errors
     ippStsNullPtrErr       pDCTSpec == NULL or
                            pSrc == NULL or pDst == NULL or pSrcDst == NULL
     ippStsContextMatchErr  bad context identifier
     ippStsMemAllocErr      memory allocation error
}

 function ippsDCTFwd_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pDCTSpec : IppsDCTFwdSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDCTInv_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; pDCTSpec : IppsDCTInvSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsDCTFwd_32f_I( pSrcDst : Ipp32fPtr ; pDCTSpec : IppsDCTFwdSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDCTInv_32f_I( pSrcDst : Ipp32fPtr ; pDCTSpec : IppsDCTInvSpec_32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsDCTFwd_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pDCTSpec : IppsDCTFwdSpec_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDCTInv_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; pDCTSpec : IppsDCTInvSpec_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsDCTFwd_64f_I( pSrcDst : Ipp64fPtr ; pDCTSpec : IppsDCTFwdSpec_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsDCTInv_64f_I( pSrcDst : Ipp64fPtr ; pDCTSpec : IppsDCTInvSpec_64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

          Wavelet Transform Functions for Fixed Filter Banks
---------------------------------------------------------------------------- }
{
 Name:       ippsWTHaar
 Purpose:    one level Haar Wavelet Transform
 Arguments:
   pSrc        - source vector;
   len         - length of source vector;
   pDstLow     - coarse "low frequency" component destination;
   pDstHigh    - detail "high frequency" component destination;
   pSrcLow     - coarse "low frequency" component source;
   pSrcHigh    - detail "high frequency" component source;
   pDst        - destination vector;
   scaleFactor - scale factor value
  Return:
   ippStsNullPtrErr    pointer(s) to the data vector is NULL
   ippStsSizeErr       the length is less or equal zero
   ippStsNoErr         otherwise
}

 function ippsWTHaarFwd_32f( pSrc : Ipp32fPtr ; len : Int32 ; pDstLow : Ipp32fPtr ; pDstHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTHaarFwd_64f( pSrc : Ipp64fPtr ; len : Int32 ; pDstLow : Ipp64fPtr ; pDstHigh : Ipp64fPtr ): IppStatus; _ippapi

 function ippsWTHaarFwd_16s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pDstLow : Ipp16sPtr ; pDstHigh : Ipp16sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsWTHaarInv_32f( pSrcLow : Ipp32fPtr ; pSrcHigh : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWTHaarInv_64f( pSrcLow : Ipp64fPtr ; pSrcHigh : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsWTHaarInv_16s_Sfs( pSrcLow : Ipp16sPtr ; pSrcHigh : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

          Wavelet Transform Fucntions for User Filter Banks
---------------------------------------------------------------------------- }

{
 Name:        ippsWTFwdGetSize

 Purpose:      Get sizes,  in bytes,  of the ippsWTFwd state structure.

 Parameters:
   srcType   - Data type of the source vector.
   lenLow    - Length of lowpass filter.
   offsLow   - Input delay of lowpass filter.
   lenHigh   - Length of highpass filter.
   offsHigh  - Input delay of highpass filter.
   pStateSize- Pointer to the size of the ippsWTFwd state structure (in bytes).

 Returns:
   ippStsNoErr        - Ok.
   ippStsNullPtrErr   - Error when any of the specified pointers is NULL.
   ippStsSizeErr      - Error when filters length is negative,  or equal to zero.
   ippStsWtOffsetErr  - Error when filter delay is less than (-1).
}

 function ippsWTFwdGetSize( srcType : IppDataType ; lenLow : Int32 ; offsLow : Int32 ; lenHigh : Int32 ; offsHigh : Int32 ; pStateSize : Int32Ptr ): IppStatus; _ippapi

{
 Name:        ippsWTFwdInit

 Purpose:     Initialize forward wavelet transform state structure.

 Parameters:
   pState    - Pointer to allocated ippsWTFwd state structure.
   pTapsLow  - Pointer to lowpass filter taps.
   lenLow    - Length of lowpass filter.
   offsLow   - Input delay of lowpass filter.
   pTapsHigh - Pointer to highpass filter taps.
   lenHigh   - Length of highpass filter.
   offsHigh  - Input delay of highpass filter.

 Returns:
   ippStsNoErr        - Ok.
   ippStsNullPtrErr   - Error when any of the specified pointers is NULL.
   ippStsSizeErr      - Error when filters length negative : is ; or equal to zero.
   ippStsWtOffsetErr  - Error when filter delay is less than (-1).
}

 function ippsWTFwdInit_8u32f( pState : IppsWTFwdState_8u32fPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; offsLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; offsHigh : Int32 ): IppStatus; _ippapi
 function ippsWTFwdInit_16u32f( pState : IppsWTFwdState_16u32fPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; offsLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; offsHigh : Int32 ): IppStatus; _ippapi
 function ippsWTFwdInit_16s32f( pState : IppsWTFwdState_16s32fPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; offsLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; offsHigh : Int32 ): IppStatus; _ippapi
 function ippsWTFwdInit_32f( pState : IppsWTFwdState_32fPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; offsLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; offsHigh : Int32 ): IppStatus; _ippapi

{
 Name:        ippsWTFwdSetDlyLine_32f, ippsWTFwdSetDlyLine_8s32f,
              ippsWTFwdSetDlyLine_8u32f, ippsWTFwdSetDlyLine_16s32f,
              ippsWTFwdSetDlyLine_16u32f

 Purpose:     The function copies the pointed vectors to internal delay lines.

 Parameters:
   pState   - pointer to pState structure;
   pDlyLow  - pointer to delay line for lowpass filtering;
   pDlyHigh - pointer to delay line for highpass filtering.

 Returns:
   ippStsNoErr            - Ok;
   ippStsNullPtrErr       - some of pointers pDlyLow
                              or pDlyHigh vectors are NULL;
   ippStspStateMatchErr   - mismatch pState structure.

 Notes: lengths of delay lines:
          len(pDlyLow)  = lenLow  + offsLow  - 1;
          len(pDlyHigh) = lenHigh + offsHigh - 1;
  lenLow, offsLow, lenHigh, offsHigh - parameters
    for ippsWTFwdInitAlloc function.
}

 function ippsWTFwdSetDlyLine_32f( pState : IppsWTFwdState_32fPtr ; pDlyLow : Ipp32fPtr ; const pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTFwdSetDlyLine_8u32f( pState : IppsWTFwdState_8u32fPtr ; pDlyLow : Ipp32fPtr ; const pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTFwdSetDlyLine_16s32f( pState : IppsWTFwdState_16s32fPtr ; pDlyLow : Ipp32fPtr ; const pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTFwdSetDlyLine_16u32f( pState : IppsWTFwdState_16u32fPtr ; pDlyLow : Ipp32fPtr ; const pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi


{
 Name:        ippsWTFwdGetDlyLine_32f, ippsWTFwdGetDlyLine_8s32f,
              ippsWTFwdGetDlyLine_8u32f, ippsWTFwdGetDlyLine_16s32f,
              ippsWTFwdGetDlyLine_16u32f

 Purpose:     The function copies data from interanl delay lines
                to the pointed vectors.
 Parameters:
   pState   - pointer to pState structure;
   pDlyLow  - pointer to delay line for lowpass filtering;
   pDlyHigh - pointer to delay line for highpass filtering.

 Returns:
   ippStsNoErr            - Ok;
   ippStsNullPtrErr       - some of pointers pDlyLow
                              or pDlyHigh vectors are NULL;
   ippStspStateMatchErr   - mismatch pState structure.

 Notes: lengths of delay lines:
          len(pDlyLow)  = lenLow  + offsLow  - 1;
          len(pDlyHigh) = lenHigh + offsHigh - 1;
  lenLow, offsLow, lenHigh, offsHigh - parameters
    for ippsWTFwdInitAlloc function.
}

 function ippsWTFwdGetDlyLine_32f( pState : IppsWTFwdState_32fPtr ; pDlyLow : Ipp32fPtr ; pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTFwdGetDlyLine_8u32f( pState : IppsWTFwdState_8u32fPtr ; pDlyLow : Ipp32fPtr ; pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTFwdGetDlyLine_16s32f( pState : IppsWTFwdState_16s32fPtr ; pDlyLow : Ipp32fPtr ; pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTFwdGetDlyLine_16u32f( pState : IppsWTFwdState_16u32fPtr ; pDlyLow : Ipp32fPtr ; pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi


{
 Name:        ippsWTFwd_32f, ippsWTFwd_16s32f, ippsWTFwd_16u32f,
              ippsWTFwd_8s32f, ippsWTFwd_8u32f

 Purpose:     Forward wavelet transform.

 Parameters:
   pSrc     - pointer to source block of data;
   pDstLow  - pointer to destination block of
                "low-frequency" component;
   pDstHigh - pointer to destination block of
                "high-frequency" component;
   dstLen   - length of destination;
   pState    - pointer to pState structure.

  Returns:
   ippStsNoErr            - Ok;
   ippStsNullPtrErr       - some of pointers to pSrc,  pDstLow
                              or pDstHigh vectors are NULL;
   ippStsSizeErr          - the length is less or equal zero;
   ippStspStateMatchErr    - mismatch pState structure.

 Notes:      source block length must be 2 * dstLen.
}

 function ippsWTFwd_32f( pSrc : Ipp32fPtr ; pDstLow : Ipp32fPtr ; pDstHigh : Ipp32fPtr ; dstLen : Int32 ; pState : IppsWTFwdState_32fPtr ): IppStatus; _ippapi
 function ippsWTFwd_8u32f( pSrc : Ipp8uPtr ; pDstLow : Ipp32fPtr ; pDstHigh : Ipp32fPtr ; dstLen : Int32 ; pState : IppsWTFwdState_8u32fPtr ): IppStatus; _ippapi
 function ippsWTFwd_16s32f( pSrc : Ipp16sPtr ; pDstLow : Ipp32fPtr ; pDstHigh : Ipp32fPtr ; dstLen : Int32 ; pState : IppsWTFwdState_16s32fPtr ): IppStatus; _ippapi
 function ippsWTFwd_16u32f( pSrc : Ipp16uPtr ; pDstLow : Ipp32fPtr ; pDstHigh : Ipp32fPtr ; dstLen : Int32 ; pState : IppsWTFwdState_16u32fPtr ): IppStatus; _ippapi

{
 Name:        ippsWTInvGetSize

 Purpose:      Get sizes,  in bytes,  of the ippsWTInv state structure.

 Parameters:
   dstType   - Data type of the destination vector.
   lenLow    - Length of lowpass filter.
   offsLow   - Input delay of lowpass filter.
   lenHigh   - Length of highpass filter.
   offsHigh  - Input delay of highpass filter.
   pStateSize- Pointer to the size of the ippsWTInv state structure (in bytes).

 Returns:
   ippStsNoErr        - Ok.
   ippStsNullPtrErr   - Error when any of the specified pointers is NULL.
   ippStsSizeErr      - Error when filters length is negative,  or equal to zero.
   ippStsWtOffsetErr  - Error when filter delay is less than (-1).
}

 function ippsWTInvGetSize( dstType : IppDataType ; lenLow : Int32 ; offsLow : Int32 ; lenHigh : Int32 ; offsHigh : Int32 ; pStateSize : Int32Ptr ): IppStatus; _ippapi


{
 Name:        ippsWTInvInit

 Purpose:     Initialize inverse wavelet transform state structure.

 Parameters:
   pState    - Pointer to allocated ippsWTInv state structure.
   pTapsLow  - Pointer to lowpass filter taps.
   lenLow    - Length of lowpass filter.
   offsLow   - Input delay of lowpass filter.
   pTapsHigh - Pointer to highpass filter taps.
   lenHigh   - Length of highpass filter.
   offsHigh  - Input delay of highpass filter.

 Returns:
   ippStsNoErr        - Ok.
   ippStsNullPtrErr   - Error when any of the specified pointers is NULL.
   ippStsSizeErr      - Error when filters length is negative,  or equal to zero.
   ippStsWtOffsetErr  - Error when filter delay is less than (-1).
}

 function ippsWTInvInit_32f8u( pState : IppsWTInvState_32f8uPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; offsLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; offsHigh : Int32 ): IppStatus; _ippapi
 function ippsWTInvInit_32f16u( pState : IppsWTInvState_32f16uPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; offsLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; offsHigh : Int32 ): IppStatus; _ippapi
 function ippsWTInvInit_32f16s( pState : IppsWTInvState_32f16sPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; offsLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; offsHigh : Int32 ): IppStatus; _ippapi
 function ippsWTInvInit_32f( pState : IppsWTInvState_32fPtr ; pTapsLow : Ipp32fPtr ; lenLow : Int32 ; offsLow : Int32 ; pTapsHigh : Ipp32fPtr ; lenHigh : Int32 ; offsHigh : Int32 ): IppStatus; _ippapi



{
 Name:        ippsWTInvSetDlyLine_32f, ippsWTInvSetDlyLine_32f8s,
              ippsWTInvSetDlyLine_32f8u, ippsWTInvSetDlyLine_32f16s,
              ippsWTInvSetDlyLine_32f16u

 Purpose:     The function copies the pointed vectors to internal delay lines.

 Parameters:
   pState   - pointer to pState structure;
   pDlyLow  - pointer to delay line for lowpass filtering;
   pDlyHigh - pointer to delay line for highpass filtering.

 Returns:
   ippStsNoErr            - Ok;
   ippStsNullPtrErr       - some of pointers pDlyLow
                              or pDlyHigh vectors are NULL;
   ippStspStateMatchErr   - mismatch pState structure.

 Notes: lengths of delay lines (as "C" expression):
          len(pDlyLow)  = (lenLow   + offsLow  - 1) / 2;
          len(pDlyHigh) = (lenHigh  + offsHigh - 1) / 2;
  lenLow, offsLow, lenHigh, offsHigh - parameters
    for ippsWTInvInitAlloc function.
}

 function ippsWTInvSetDlyLine_32f( pState : IppsWTInvState_32fPtr ; pDlyLow : Ipp32fPtr ; const pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTInvSetDlyLine_32f8u( pState : IppsWTInvState_32f8uPtr ; pDlyLow : Ipp32fPtr ; const pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTInvSetDlyLine_32f16s( pState : IppsWTInvState_32f16sPtr ; pDlyLow : Ipp32fPtr ; const pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTInvSetDlyLine_32f16u( pState : IppsWTInvState_32f16uPtr ; pDlyLow : Ipp32fPtr ; const pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi

{
 Name:        ippsWTInvGetDlyLine_32f, ippsWTInvGetDlyLine_32f8s,
              ippsWTInvGetDlyLine_32f8u, ippsWTInvGetDlyLine_32f16s,
              ippsWTInvGetDlyLine_32f16u

 Purpose:     The function copies data from interanl delay lines
                to the pointed vectors.
 Parameters:
   pState   - pointer to pState structure;
   pDlyLow  - pointer to delay line for lowpass filtering;
   pDlyHigh - pointer to delay line for highpass filtering.

 Returns:
   ippStsNoErr            - Ok;
   ippStsNullPtrErr       - some of pointers pDlyLow
                              or pDlyHigh vectors are NULL;
   ippStspStateMatchErr    - mismatch pState structure.

 Notes: lengths of delay lines (as "C" expression):
          len(pDlyLow)  = (lenLow   + offsLow  - 1) / 2;
          len(pDlyHigh) = (lenHigh  + offsHigh - 1) / 2;
  lenLow, offsLow, lenHigh, offsHigh - parameters
    for ippsWTInvInitAlloc function.
}

 function ippsWTInvGetDlyLine_32f( pState : IppsWTInvState_32fPtr ; pDlyLow : Ipp32fPtr ; pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTInvGetDlyLine_32f8u( pState : IppsWTInvState_32f8uPtr ; pDlyLow : Ipp32fPtr ; pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTInvGetDlyLine_32f16s( pState : IppsWTInvState_32f16sPtr ; pDlyLow : Ipp32fPtr ; pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi
 function ippsWTInvGetDlyLine_32f16u( pState : IppsWTInvState_32f16uPtr ; pDlyLow : Ipp32fPtr ; pDlyHigh : Ipp32fPtr ): IppStatus; _ippapi

{
 Name:        ippsWTInv_32f, ippsWTInv_32f16s, ippsWTInv_32f16u,
              ippsWTInv_32f8u

 Purpose:     Inverse wavelet transform.

 Parameters:
   srcLow  - pointer to source block of "low-frequency" component;
   srcHigh - pointer to source block of "high-frequency" component;
   dstLen  - length of components.
   dst     - pointer to destination block of reconstructed data;
   pState  - pointer to pState structure;

  Returns:
   ippStsNoErr            - Ok;
   ippStsNullPtrErr       - some of pointers to pDst pSrcLow or pSrcHigh vectors are NULL;
   ippStsSizeErr          - the length is less or equal zero;
   ippStspStateMatchErr   - mismatch pState structure.

 Notes:      destination block length must be 2 * srcLen.
}

 function ippsWTInv_32f( pSrcLow : Ipp32fPtr ; pSrcHigh : Ipp32fPtr ; srcLen : Int32 ; pDst : Ipp32fPtr ; pState : IppsWTInvState_32fPtr ): IppStatus; _ippapi
 function ippsWTInv_32f8u( pSrcLow : Ipp32fPtr ; pSrcHigh : Ipp32fPtr ; srcLen : Int32 ; pDst : Ipp8uPtr ; pState : IppsWTInvState_32f8uPtr ): IppStatus; _ippapi
 function ippsWTInv_32f16s( pSrcLow : Ipp32fPtr ; pSrcHigh : Ipp32fPtr ; srcLen : Int32 ; pDst : Ipp16sPtr ; pState : IppsWTInvState_32f16sPtr ): IppStatus; _ippapi
 function ippsWTInv_32f16u( pSrcLow : Ipp32fPtr ; pSrcHigh : Ipp32fPtr ; srcLen : Int32 ; pDst : Ipp16uPtr ; pState : IppsWTInvState_32f16uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Filtering
----------------------------------------------------------------------------

                  Convolution functions
----------------------------------------------------------------------------

  Names:  ippsConvolveGetBufferSize

  Purpose:     Get the size (in bytes) of the buffer for ippsConvolve`s internal calculations.

  Parameters:
    src1Len     - Length of the first source vector.
    src2Len     - Length of the second source vector.
    dataType    - Data type for convolution (Ipp32f|Ipp64f).
    algType     - Selector for the algorithm type. Contains IppAlgType values.
    pBufferSize - Pointer to the calculated buffer size (in bytes).
  Return:
   ippStsNoErr       - OK
   ippStsNullPtrErr  - pBufferSize is NULL.
   ippStsSizeErr     - Vector`s length is not positive.
   ippStsDataTypeErr - Unsupported data type.
   ippStsAlgTypeErr - Unsupported algorithm type.
}

 function ippsConvolveGetBufferSize( src1Len : Int32 ; src2Len : Int32 ; dataType : IppDataType ; algType : IppEnum ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:       ippsConvolve_32f, ippsConvolve_64f
 Purpose:    Perform a linear convolution of 1D signals.
 Parameters:
    pSrc1   - Pointer to the first source vector.
    src1Len - Length of the first source vector.
    pSrc2   - Pointer to the second source vector.
    src2Len - Length of the second source vector.
    pDst    - Pointer to the destination vector.
    algType - Selector for the algorithm type. Contains IppAlgType values.
    pBuffer - Pointer to the buffer for internal calculations.
 Returns:    IppStatus
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - One of the pointers is NULL.
    ippStsSizeErr     - Vector`s length is not positive.
    ippStsAlgTypeErr  - Unsupported algorithm type.
  Notes:
          Length of the destination data vector is src1Len+src2Len-1.
          The input signals are exchangeable because of the commutative
          property of convolution.
          Some other values may be returned the by FFT transform functions.
}

 function ippsConvolve_32f( pSrc1 : Ipp32fPtr ; src1Len : Int32 ; pSrc2 : Ipp32fPtr ; src2Len : Int32 ; pDst : Ipp32fPtr ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsConvolve_64f( pSrc1 : Ipp64fPtr ; src1Len : Int32 ; pSrc2 : Ipp64fPtr ; src2Len : Int32 ; pDst : Ipp64fPtr ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsConvBiased_32f
  Purpose:    Linear Convolution of 1D signals whith a bias.
  Parameters:
      pSrc1               pointer to the first source vector
      pSrc2               pointer to the second source vector
      src1Len             length of the first source vector
      src2Len             length of the second source vector
      pDst                pointer to the destination vector
      dstLen              length of the destination vector
      bias
  Returns:    IppStatus
      ippStsNullPtrErr        pointer(s) to the data is NULL
      ippStsSizeErr           length of the vectors is less or equal zero
      ippStsNoErr             otherwise
}

 function ippsConvBiased_32f( pSrc1 : Ipp32fPtr ; src1Len : Int32 ; pSrc2 : Ipp32fPtr ; src2Len : Int32 ; pDst : Ipp32fPtr ; dstLen : Int32 ; bias : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     IIR filters (float and double taps versions)
---------------------------------------------------------------------------- }


{ ----------------------------------------------------------------------------

  Work with Delay Line
{ ----------------------------------------------------------------------------


  Names:      ippsIIRGetDlyLine, ippsIIRSetDlyLine
  Purpose:    set and get delay line
  Parameters:
      pState              - pointer to IIR filter context
      pDelay              - pointer to delay line to be set
  Return:
      ippStsContextMatchErr  - wrong context identifier
      ippStsNullPtrErr       - pointer(s) pState or pDelay is NULL
      ippStsNoErr            - otherwise
}

 function ippsIIRGetDlyLine_32f( pState : IppsIIRState_32fPtr ; pDlyLine : Ipp32fPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine_32f( pState : IppsIIRState_32fPtr ; const pDlyLine : Ipp32fPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine_32fc( pState : IppsIIRState_32fcPtr ; pDlyLine : Ipp32fcPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine_32fc( pState : IppsIIRState_32fcPtr ; const pDlyLine : Ipp32fcPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine32f_16s( pState : IppsIIRState32f_16sPtr ; pDlyLine : Ipp32fPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine32f_16s( pState : IppsIIRState32f_16sPtr ; const pDlyLine : Ipp32fPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine32fc_16sc( pState : IppsIIRState32fc_16scPtr ; pDlyLine : Ipp32fcPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine32fc_16sc( pState : IppsIIRState32fc_16scPtr ; const pDlyLine : Ipp32fcPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine_64f( pState : IppsIIRState_64fPtr ; pDlyLine : Ipp64fPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine_64f( pState : IppsIIRState_64fPtr ; const pDlyLine : Ipp64fPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine_64fc( pState : IppsIIRState_64fcPtr ; pDlyLine : Ipp64fcPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine_64fc( pState : IppsIIRState_64fcPtr ; const pDlyLine : Ipp64fcPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine64f_32f( pState : IppsIIRState64f_32fPtr ; pDlyLine : Ipp64fPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine64f_32f( pState : IppsIIRState64f_32fPtr ; const pDlyLine : Ipp64fPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine64fc_32fc( pState : IppsIIRState64fc_32fcPtr ; pDlyLine : Ipp64fcPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine64fc_32fc( pState : IppsIIRState64fc_32fcPtr ; const pDlyLine : Ipp64fcPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine64f_32s( pState : IppsIIRState64f_32sPtr ; pDlyLine : Ipp64fPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine64f_32s( pState : IppsIIRState64f_32sPtr ; const pDlyLine : Ipp64fPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine64fc_32sc( pState : IppsIIRState64fc_32scPtr ; pDlyLine : Ipp64fcPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine64fc_32sc( pState : IppsIIRState64fc_32scPtr ; const pDlyLine : Ipp64fcPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine64f_16s( pState : IppsIIRState64f_16sPtr ; pDlyLine : Ipp64fPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine64f_16s( pState : IppsIIRState64f_16sPtr ; const pDlyLine : Ipp64fPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine64fc_16sc( pState : IppsIIRState64fc_16scPtr ; pDlyLine : Ipp64fcPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine64fc_16sc( pState : IppsIIRState64fc_16scPtr ; const pDlyLine : Ipp64fcPtr ): IppStatus; _ippapi

 function ippsIIRGetDlyLine64f_DF1_32s( pState : IppsIIRState64f_32sPtr ; pDlyLine : Ipp32sPtr ): IppStatus; _ippapi
 function ippsIIRSetDlyLine64f_DF1_32s( pState : IppsIIRState64f_32sPtr ; const pDlyLine : Ipp32sPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

            Filtering
  ----------------------------------------------------------------------------

  Names:         ippsIIR
  Purpose:       IIR filter with float or double taps. Vector filtering
  Parameters:
      pState              - pointer to filter context
      pSrcDst             - pointer to input/output vector in in-place ops
      pSrc                - pointer to input vector
      pDst                - pointer to output vector
      len                 - length of the vectors
      scaleFactor         - scale factor value
  Return:
      ippStsContextMatchErr  - wrong context identifier
      ippStsNullPtrErr       - pointer(s) to the data is NULL
      ippStsSizeErr          - length of the vectors <= 0
      ippStsNoErr            - otherwise

  Note: Don`t modify scaleFactor value unless context is changed
}

 function ippsIIR_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; pState : IppsIIRState_32fPtr ): IppStatus; _ippapi
 function ippsIIR_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; pState : IppsIIRState_32fPtr ): IppStatus; _ippapi
 function ippsIIR_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ; pState : IppsIIRState_32fcPtr ): IppStatus; _ippapi
 function ippsIIR_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ; pState : IppsIIRState_32fcPtr ): IppStatus; _ippapi

 function ippsIIR32f_16s_Sfs( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; pState : IppsIIRState32f_16sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsIIR32f_16s_ISfs( pSrcDst : Ipp16sPtr ; len : Int32 ; pState : IppsIIRState32f_16sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsIIR32fc_16sc_Sfs( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; pState : IppsIIRState32fc_16scPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsIIR32fc_16sc_ISfs( pSrcDst : Ipp16scPtr ; len : Int32 ; pState : IppsIIRState32fc_16scPtr ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsIIR_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; pState : IppsIIRState_64fPtr ): IppStatus; _ippapi
 function ippsIIR_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; pState : IppsIIRState_64fPtr ): IppStatus; _ippapi
 function ippsIIR_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ; pState : IppsIIRState_64fcPtr ): IppStatus; _ippapi
 function ippsIIR_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ; pState : IppsIIRState_64fcPtr ): IppStatus; _ippapi

 function ippsIIR64f_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; pState : IppsIIRState64f_32fPtr ): IppStatus; _ippapi
 function ippsIIR64f_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; pState : IppsIIRState64f_32fPtr ): IppStatus; _ippapi
 function ippsIIR64fc_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ; pState : IppsIIRState64fc_32fcPtr ): IppStatus; _ippapi
 function ippsIIR64fc_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ; pState : IppsIIRState64fc_32fcPtr ): IppStatus; _ippapi

 function ippsIIR64f_32s_Sfs( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; pState : IppsIIRState64f_32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsIIR64f_32s_ISfs( pSrcDst : Ipp32sPtr ; len : Int32 ; pState : IppsIIRState64f_32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsIIR64fc_32sc_Sfs( pSrc : Ipp32scPtr ; pDst : Ipp32scPtr ; len : Int32 ; pState : IppsIIRState64fc_32scPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsIIR64fc_32sc_ISfs( pSrcDst : Ipp32scPtr ; len : Int32 ; pState : IppsIIRState64fc_32scPtr ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsIIR64f_16s_Sfs( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; pState : IppsIIRState64f_16sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsIIR64f_16s_ISfs( pSrcDst : Ipp16sPtr ; len : Int32 ; pState : IppsIIRState64f_16sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsIIR64fc_16sc_Sfs( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; pState : IppsIIRState64fc_16scPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsIIR64fc_16sc_ISfs( pSrcDst : Ipp16scPtr ; len : Int32 ; pState : IppsIIRState64fc_16scPtr ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:         ippsIIR_32f_P, ippsIIR64f_32s_P
  Purpose:       IIR filter for multi-channel data. Vector filtering.
  Parameters:
      ppSrc               - pointer to array of pointers to source vectors
      ppDst               - pointer to array of pointers to destination vectors
      ppSrcDst            - pointer to array of source/destination vectors in in-place ops
      len                 - length of the vectors
      nChannels           - number of processing channels
      ppState             - pointer to array of filter contexts
  Return:
      ippStsContextMatchErr  - wrong context identifier
      ippStsNullPtrErr       - pointer(s) to the data is NULL
      ippStsSizeErr          - length of the vectors <= 0
      ippStsChannelErr       - number of processing channels <= 0
      ippStsNoErr            - otherwise
}

 function ippsIIR_32f_P( ppSrc : Ipp32fPtrPtr ; ppDst : Ipp32fPtrPtr ; len : Int32 ; nChannels : Int32 ; ppState : IppsIIRState_32fPtrPtr ): IppStatus; _ippapi
 function ippsIIR_32f_IP( ppSrcDst : Ipp32fPtrPtr ; len : Int32 ; nChannels : Int32 ; ppState : IppsIIRState_32fPtrPtr ): IppStatus; _ippapi
 function ippsIIR64f_32s_PSfs( ppSrc : Ipp32sPtrPtr ; ppDst : Ipp32sPtrPtr ; len : Int32 ; nChannels : Int32 ; ppState : IppsIIRState64f_32sPtrPtr ; pScaleFactor : Int32Ptr ): IppStatus; _ippapi
 function ippsIIR64f_32s_IPSfs( ppSrcDst : Ipp32sPtrPtr ; len : Int32 ; nChannels : Int32 ; ppState : IppsIIRState64f_32sPtrPtr ; pScaleFactor : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     IIR filters (integer taps version)
  ----------------------------------------------------------------------------

          Initialize IIR state with external memory buffer
  ----------------------------------------------------------------------------


  Name:         ippsIIRGetStateSize, ippsIIRGetStateSize_BiQuad,
                ippsIIRGetStateSize_BiQuad_DF1_32f,
                ippsIIRInit, ippsIIRInit_BiQuad,
                ippsIIRInit_BiQuad_DF1_32f

  Purpose:      ippsIIRGetStateSize - calculates the size of the IIR State
                                                                   structure;
                ippsIIRInit - initialize IIR state - set taps and delay line
                using external memory buffer;
  Parameters:
      pTaps       - pointer to the filter coefficients;
      order       - order of the filter;
      numBq       - order of the filter;
      pDlyLine    - pointer to the delay line values,  can be NULL;
      ppState     - double pointer to the IIR state created or NULL;
      tapsFactor  - scaleFactor for taps (integer version);
      pBufferSize - pointer where to store the calculated IIR State structure
                                                             size (in bytes);
   Return:
      status      - status value returned,  its value are
         ippStsNullPtrErr       - pointer(s) to the data is NULL
         ippStsIIROrderErr      - order <= 0 or numBq < 1
         ippStsNoErr            - otherwise
}

{ ---------------------------------- 32f ---------------------------------- }

 function ippsIIRGetStateSize_32f( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize_32fc( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize_BiQuad_32f( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize_BiQuad_DF1_32f( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize_BiQuad_32fc( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRInit_32f( ppState : IppsIIRState_32fPtrPtr ; pTaps : Ipp32fPtr ; order : Int32 ; pDlyLine : Ipp32fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit_32fc( ppState : IppsIIRState_32fcPtrPtr ; pTaps : Ipp32fcPtr ; order : Int32 ; pDlyLine : Ipp32fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit_BiQuad_32f( ppState : IppsIIRState_32fPtrPtr ; pTaps : Ipp32fPtr ; numBq : Int32 ; pDlyLine : Ipp32fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit_BiQuad_DF1_32f( pState : IppsIIRState_32fPtrPtr ; pTaps : Ipp32fPtr ; numBq : Int32 ; pDlyLine : Ipp32fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit_BiQuad_32fc( ppState : IppsIIRState_32fcPtrPtr ; pTaps : Ipp32fcPtr ; numBq : Int32 ; pDlyLine : Ipp32fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

{-------------------------------- 32f_16s -------------------------------- }

 function ippsIIRGetStateSize32f_16s( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize32fc_16sc( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize32f_BiQuad_16s( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize32fc_BiQuad_16sc( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRInit32f_16s( ppState : IppsIIRState32f_16sPtrPtr ; pTaps : Ipp32fPtr ; order : Int32 ; pDlyLine : Ipp32fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit32fc_16sc( ppState : IppsIIRState32fc_16scPtrPtr ; pTaps : Ipp32fcPtr ; order : Int32 ; pDlyLine : Ipp32fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit32f_BiQuad_16s( ppState : IppsIIRState32f_16sPtrPtr ; pTaps : Ipp32fPtr ; numBq : Int32 ; pDlyLine : Ipp32fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit32fc_BiQuad_16sc( ppState : IppsIIRState32fc_16scPtrPtr ; pTaps : Ipp32fcPtr ; numBq : Int32 ; pDlyLine : Ipp32fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

{---------------------------------- 64f ---------------------------------- }

 function ippsIIRGetStateSize_64f( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize_64fc( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize_BiQuad_64f( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize_BiQuad_64fc( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRInit_64f( ppState : IppsIIRState_64fPtrPtr ; pTaps : Ipp64fPtr ; order : Int32 ; pDlyLine : Ipp64fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit_64fc( ppState : IppsIIRState_64fcPtrPtr ; pTaps : Ipp64fcPtr ; order : Int32 ; pDlyLine : Ipp64fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit_BiQuad_64f( ppState : IppsIIRState_64fPtrPtr ; pTaps : Ipp64fPtr ; numBq : Int32 ; pDlyLine : Ipp64fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit_BiQuad_64fc( ppState : IppsIIRState_64fcPtrPtr ; pTaps : Ipp64fcPtr ; numBq : Int32 ; pDlyLine : Ipp64fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

{-------------------------------- 64f_16s -------------------------------- }

 function ippsIIRGetStateSize64f_16s( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize64fc_16sc( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize64f_BiQuad_16s( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize64fc_BiQuad_16sc( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRInit64f_16s( ppState : IppsIIRState64f_16sPtrPtr ; pTaps : Ipp64fPtr ; order : Int32 ; pDlyLine : Ipp64fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit64fc_16sc( ppState : IppsIIRState64fc_16scPtrPtr ; pTaps : Ipp64fcPtr ; order : Int32 ; pDlyLine : Ipp64fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit64f_BiQuad_16s( ppState : IppsIIRState64f_16sPtrPtr ; pTaps : Ipp64fPtr ; numBq : Int32 ; pDlyLine : Ipp64fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit64fc_BiQuad_16sc( ppState : IppsIIRState64fc_16scPtrPtr ; pTaps : Ipp64fcPtr ; numBq : Int32 ; pDlyLine : Ipp64fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

{-------------------------------- 64f_32s -------------------------------- }

 function ippsIIRGetStateSize64f_32s( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize64fc_32sc( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize64f_BiQuad_32s( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize64f_BiQuad_DF1_32s( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize64fc_BiQuad_32sc( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRInit64f_32s( ppState : IppsIIRState64f_32sPtrPtr ; pTaps : Ipp64fPtr ; order : Int32 ; pDlyLine : Ipp64fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit64fc_32sc( ppState : IppsIIRState64fc_32scPtrPtr ; pTaps : Ipp64fcPtr ; order : Int32 ; pDlyLine : Ipp64fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit64f_BiQuad_32s( ppState : IppsIIRState64f_32sPtrPtr ; pTaps : Ipp64fPtr ; numBq : Int32 ; pDlyLine : Ipp64fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit64f_BiQuad_DF1_32s( ppState : IppsIIRState64f_32sPtrPtr ; pTaps : Ipp64fPtr ; numBq : Int32 ; pDlyLine : Ipp32sPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit64fc_BiQuad_32sc( ppState : IppsIIRState64fc_32scPtrPtr ; pTaps : Ipp64fcPtr ; numBq : Int32 ; pDlyLine : Ipp64fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

{-------------------------------- 64f_32f -------------------------------- }

 function ippsIIRGetStateSize64f_32f( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize64fc_32fc( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize64f_BiQuad_32f( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRGetStateSize64fc_BiQuad_32fc( numBq : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRInit64f_32f( ppState : IppsIIRState64f_32fPtrPtr ; pTaps : Ipp64fPtr ; order : Int32 ; pDlyLine : Ipp64fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit64fc_32fc( ppState : IppsIIRState64fc_32fcPtrPtr ; pTaps : Ipp64fcPtr ; order : Int32 ; pDlyLine : Ipp64fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit64f_BiQuad_32f( ppState : IppsIIRState64f_32fPtrPtr ; pTaps : Ipp64fPtr ; numBq : Int32 ; pDlyLine : Ipp64fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRInit64fc_BiQuad_32fc( ppState : IppsIIRState64fc_32fcPtrPtr ; pTaps : Ipp64fcPtr ; numBq : Int32 ; pDlyLine : Ipp64fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsIIRGenLowpass_64f, ippsIIRGenHighpass_64f

  Purpose:    This function computes the highpass and lowpass IIR filter coefficients

  Parameters:
    rFreq       - Cut off frequency (0 < rFreq < 0.5).
    ripple      - Possible ripple in pass band for ippChebyshev1 type of filter.
    order       - The order of future filter (1 <= order <= 12).
    pTaps       - Pointer to the array which specifies the filter coefficients.
    filterType  - Type of required filter (ippButterworth or ippChebyshev1).
    pBuffer     - Pointer to the buffer for internal calculations. The size calculates by ippsIIRGenGetBufferSize.

  Returns:
    ippStsNoErr                - OK.
    ippStsNullPtrErr           - Error when any of the specified pointers is NULL.
    ippStsIIRPassbandRippleErr - Error when the ripple in passband for Chebyshev1 design is less zero,  equal to zero or greater than 29.
    ippStsFilterFrequencyErr   - Error when the cut of frequency of filter is less zero,  equal to zero or greater than 0.5.
    ippStsIIRGenOrderErr       - Error when the order of an IIR filter for design them is less than one or greater than 12.
}

 function ippsIIRGenLowpass_64f( rFreq : Ipp64f ; ripple : Ipp64f ; order : Int32 ; pTaps : Ipp64fPtr ; filterType : IppsIIRFilterType ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsIIRGenHighpass_64f( rFreq : Ipp64f ; ripple : Ipp64f ; order : Int32 ; pTaps : Ipp64fPtr ; filterType : IppsIIRFilterType ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsIIRGenGetBufferSize

  Purpose:    Gets the size (in bytes) of the buffer for ippsIIRGen internal calculations.

  Parameters:
    order       - The order of future filter (1 <= order <= 12).
    pBufferSize - Pointer to the calculated buffer size (in bytes).

  Returns:
    ippStsNoErr                - OK.
    ippStsNullPtrErr           - Error when any of the specified pointers is NULL.
    ippStsIIRGenOrderErr       - Error when the order of an IIR filter for design them is less than one or greater than 12.
}

 function ippsIIRGenGetBufferSize( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                     FIR filters (float and double taps versions)
  ----------------------------------------------------------------------------

                  FIR LMS filters
  ----------------------------------------------------------------------------

  Name:         ippsFIRLMSGetStateSize, ippsFIRLMSInit
  Purpose:      ippsFIRLMSGetStateSize - calculates the size of the FIR State
                                                                   structure;
                ippsFIRLMSInit - initialize FIR state - set taps and delay line
                using external memory buffer;
  Parameters:
      pTaps       - pointer to the filter coefficients;
      tapsLen     - number of coefficients;
      dlyIndex      current index value for the delay line
      pDlyLine    - pointer to the delay line values,  can be NULL;
      ppState     - pointer to the FIR state created or NULL;
      pStateSize  - pointer where to store the calculated FIR State structure
   Return:
      status      - status value returned,  its value are
         ippStsNullPtrErr       - pointer(s) to the data is NULL
         ippStsFIRLenErr        - tapsLen <= 0
         ippStsNoErr            - otherwise
}

 function ippsFIRLMSGetStateSize_32f( tapsLen : Int32 ; dlyIndex : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsFIRLMSGetStateSize32f_16s( tapsLen : Int32 ; dlyIndex : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

 function ippsFIRLMSInit_32f( ppState : IppsFIRLMSState_32fPtrPtr ; pTaps : Ipp32fPtr ; tapsLen : Int32 ; pDlyLine : Ipp32fPtr ; dlyIndex : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRLMSInit32f_16s( ppState : IppsFIRLMSState32f_16sPtrPtr ; pTaps : Ipp32fPtr ; tapsLen : Int32 ; pDlyLine : Ipp16sPtr ; dlyIndex : Int32 ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

   Names:      ippsFIRLMS
   Purpose:    LMS filtering with context use
   Parameters:
      pState    pointer to the state
      pSrc      pointer to the source signal
      pRef      pointer to the desired signal
      pDst      pointer to the output signal
      len       length of the signals
      mu        adaptation step
   Return:
      ippStsNullPtrErr       pointer to the data is null
      ippStsSizeErr          the length of signals is equal or less zero
      ippStsContextMatchErr    wrong state identifier
      ippStsNoErr            otherwise
}

 function ippsFIRLMS_32f( pSrc : Ipp32fPtr ; pRef : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; mu : float ; pState : IppsFIRLMSState_32fPtr ): IppStatus; _ippapi
 function ippsFIRLMS32f_16s( pSrc : Ipp16sPtr ; pRef : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; mu : float ; pState : IppsFIRLMSState32f_16sPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

   Names:        ippsFIRLMSGetTaps
   Purpose:      get taps values
   Parameters:
      pstate          pointer to the state
      pTaps           pointer to the array to store the taps values
   Return:
      ippStsNullPtrErr   pointer to the data is null
      ippStsNoErr        otherwise
}

 function ippsFIRLMSGetTaps_32f( pState : IppsFIRLMSState_32fPtr ; pOutTaps : Ipp32fPtr ): IppStatus; _ippapi
 function ippsFIRLMSGetTaps32f_16s( pState : IppsFIRLMSState32f_16sPtr ; pOutTaps : Ipp32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

   Names:       ippsFIRLMSGetDlyl, ippsFIRLMSSetDlyl
   Purpose:     set or get delay line
   Parameters:
      pState         pointer to the state structure
      pDlyLine       pointer to the delay line of the single size = tapsLen
      pDlyLineIndex  pointer to get the current delay line index
   Return:
      ippStsNullPtrErr       pointer to the data is null
      ippStsContextMatchErr    wrong state identifier
      ippStsNoErr            otherwise
}

 function ippsFIRLMSGetDlyLine_32f( pState : IppsFIRLMSState_32fPtr ; pDlyLine : Ipp32fPtr ; pDlyLineIndex : Int32Ptr ): IppStatus; _ippapi
 function ippsFIRLMSGetDlyLine32f_16s( pState : IppsFIRLMSState32f_16sPtr ; pDlyLine : Ipp16sPtr ; pDlyLineIndex : Int32Ptr ): IppStatus; _ippapi

 function ippsFIRLMSSetDlyLine_32f( pState : IppsFIRLMSState_32fPtr ; pDlyLine : Ipp32fPtr ; dlyLineIndex : Int32 ): IppStatus; _ippapi
 function ippsFIRLMSSetDlyLine32f_16s( pState : IppsFIRLMSState32f_16sPtr ; pDlyLine : Ipp16sPtr ; dlyLineIndex : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  FIR LMS MR filters
  ----------------------------------------------------------------------------

  Names:     ippsFIRGen
  Purpose:   This function computes the lowpass FIR filter coefficients
              by windowing of ideal (infinite) filter coefficients segment.

 Parameters:
    rFreq    - Cut off frequency (0 < rfreq < 0.5).
    pTaps    - Pointer to the array which specifies the filter coefficients.
    tapsLen  - The number of taps in pTaps[] array (tapsLen>=5).
    winType  - The ippWindowType switch variable,  which specifies the smoothing window type.
    doNormal - If doNormal=0 the functions calculates non-normalized sequence of filter coefficients, 
               in other cases the sequence of coefficients will be normalized.
    pBuffer  - Pointer to the buffer for internal calculations. The size calculates by ippsFIRGenGetBufferSize.
 Returns:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when the length of coefficient`s array is less than 5.
    ippStsSizeErr    - Error when the low or high frequency isn`t satisfy the condition 0 < rLowFreq < 0.5.
}

 function ippsFIRGenLowpass_64f( rFreq : Ipp64f ; pTaps : Ipp64fPtr ; tapsLen : Int32 ; winType : IppWinType ; doNormal : IppBool ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRGenHighpass_64f( rFreq : Ipp64f ; pTaps : Ipp64fPtr ; tapsLen : Int32 ; winType : IppWinType ; doNormal : IppBool ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

 function ippsFIRGenBandpass_64f( rLowFreq : Ipp64f ; rHighFreq : Ipp64f ; pTaps : Ipp64fPtr ; tapsLen : Int32 ; winType : IppWinType ; doNormal : IppBool ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRGenBandstop_64f( rLowFreq : Ipp64f ; rHighFreq : Ipp64f ; pTaps : Ipp64fPtr ; tapsLen : Int32 ; winType : IppWinType ; doNormal : IppBool ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsFIRGenGetBufferSize

  Purpose:    Gets the size (in bytes) of the buffer for ippsFIRGen internal calculations.

  Parameters:
    tapsLen     - The number of taps.
    pBufferSize - Pointer to the calculated buffer size (in bytes).

  Returns:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - Error when any of the specified pointers is NULL.
    ippStsSizeErr    - Error when the length of coefficient`s array is less than 5.
}

 function ippsFIRGenGetBufferSize( tapsLen : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Windowing functions
  Note: to create the window coefficients you have to make two calls
        Set(1,x,n) and Win(x,n)
{ ----------------------------------------------------------------------------


  Names:            ippsWinBartlett
  Parameters:
   pSrcDst          pointer to the vector
   len              length of the vector,  window size
  Return:
   ippStsNullPtrErr    pointer to the vector is NULL
   ippStsSizeErr       length of the vector is less 3
   ippStsNoErr         otherwise
}

 function ippsWinBartlett_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBartlett_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBartlett_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBartlett_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBartlett_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBartlett_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBartlett_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBartlett_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBartlett_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBartlett_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBartlett_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBartlett_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:            ippsWinHann
  Parameters:
   pSrcDst          pointer to the vector
   len              length of the vector,  window size
  Return:
   ippStsNullPtrErr    pointer to the vector is NULL
   ippStsSizeErr       length of the vector is less 3
   ippStsNoErr         otherwise
  Functionality:    0.5*(1-cos(2*pi*n/(N-1)))
}

 function ippsWinHann_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHann_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHann_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHann_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHann_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHann_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHann_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHann_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsWinHann_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHann_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsWinHann_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHann_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:            ippsWinHamming
  Parameters:
   pSrcDst          pointer to the vector
   len              length of the vector,  window size
  Return:
   ippStsNullPtrErr    pointer to the vector is NULL
   ippStsSizeErr       length of the vector is less 3
   ippStsNoErr         otherwise
}

 function ippsWinHamming_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHamming_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHamming_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHamming_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsWinHamming_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHamming_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHamming_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHamming_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsWinHamming_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHamming_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHamming_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinHamming_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:            ippsWinBlackman
  Purpose:          multiply vector by Blackman windowing function
  Parameters:
   pSrcDst          pointer to the vector
   len              length of the vector,  window size
   alpha            adjustable parameter associated with the
                    Blackman windowing equation
   alphaQ15         scaled (scale factor 15) version of the alpha
   scaleFactor      scale factor of the output signal
  Return:
   ippStsNullPtrErr    pointer to the vector is NULL
   ippStsSizeErr       length of the vector is less 3,  for Opt it`s 4
   ippStsNoErr         otherwise
  Notes:
     parameter alpha value
         WinBlackmaStd   : -0.16
         WinBlackmaOpt   : -0.5 / (1+cos(2*pi/(len-1)))
}

 function ippsWinBlackman_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinBlackman_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinBlackman_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinBlackman_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi

 function ippsWinBlackman_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinBlackman_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinBlackman_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinBlackman_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi

 function ippsWinBlackmanStd_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanStd_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanStd_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanStd_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanOpt_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanOpt_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanOpt_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanOpt_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsWinBlackmanStd_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanStd_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanStd_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanStd_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanOpt_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanOpt_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanOpt_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanOpt_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsWinBlackman_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; alpha : double ): IppStatus; _ippapi
 function ippsWinBlackman_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ; alpha : double ): IppStatus; _ippapi

 function ippsWinBlackman_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; alpha : double ): IppStatus; _ippapi
 function ippsWinBlackman_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ; alpha : double ): IppStatus; _ippapi

 function ippsWinBlackmanStd_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanStd_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanStd_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanStd_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

 function ippsWinBlackmanOpt_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanOpt_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanOpt_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ): IppStatus; _ippapi
 function ippsWinBlackmanOpt_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:            ippsWinKaiser
  Purpose:          multiply vector by Kaiser windowing function
  Parameters:
   pSrcDst          pointer to the vector
   len              length of the vector,  window size
   alpha            adjustable parameter associated with the
                    Kaiser windowing equation
   alphaQ15         scaled (scale factor 15) version of the alpha
  Return:
   ippStsNullPtrErr    pointer to the vector is NULL
   ippStsSizeErr       length of the vector is less 1
   ippStsHugeWinErr    window in function is huge
   ippStsNoErr         otherwise
}

 function ippsWinKaiser_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinKaiser_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinKaiser_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinKaiser_16sc_I( pSrcDst : Ipp16scPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinKaiser_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinKaiser_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinKaiser_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinKaiser_32fc_I( pSrcDst : Ipp32fcPtr ; len : Int32 ; alpha : float ): IppStatus; _ippapi
 function ippsWinKaiser_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; alpha : Ipp64f ): IppStatus; _ippapi
 function ippsWinKaiser_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; alpha : Ipp64f ): IppStatus; _ippapi
 function ippsWinKaiser_64fc_I( pSrcDst : Ipp64fcPtr ; len : Int32 ; alpha : Ipp64f ): IppStatus; _ippapi
 function ippsWinKaiser_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; len : Int32 ; alpha : Ipp64f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Median filter
  ----------------------------------------------------------------------------

  Names:      ippsFilterMedianGetBufferSize
  Purpose:    Get sizes of working buffer for functions ipsFilterMedian
  Parameters:
   maskSize           median mask size (odd)
   dataType           data type
   pBufferSize        pointer to buffer size
  Return:
   ippStsNullPtrErr              pointer to pBufferSize is NULL
   ippStsMaskSizeErr             maskSize is is less or equal zero
   ippStsDataTypeErr             data type is incorrect or not supported.
   ippStsNoErr                   otherwise
}

 function ippsFilterMedianGetBufferSize( maskSize : Int32 ; dataType : IppDataType ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:      ippsFilterMedian
  Purpose:    filter source data by the Median Filter
  Parameters:
   pSrcDst            pointer to the source and destinaton vector
   pSrc               pointer to the source vector
   pDst               pointer to the destination vector
   len                length of the vector(s)
   maskSize           median mask size (odd)
   pDlySrc            pointer to the input  delay line values (length is (maskSize-1)), can be NULL
   pDlyDst            pointer to the output delay line values (length is (maskSize-1)), can be NULL
   pBuffer            pointer to the work buffer
  Return:
   ippStsNullPtrErr              pointer(s) to the data is NULL
   ippStsSizeErr                 length of the vector(s) is less or equal zero
   ippStsMaskSizeErr             maskSize is is less or equal zero
   ippStsEvenMedianMaskSize      median mask size is even warning
   ippStsNoErr                   otherwise
  Notes:
   if pDlySrc is NULL for all i < 0 pSrc[i] = pSrc[0]
}

 function ippsFilterMedian_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; maskSize : Int32 ; pDlySrc : Ipp32fPtr ; pDlyDst : Ipp32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFilterMedian_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; len : Int32 ; maskSize : Int32 ; pDlySrc : Ipp64fPtr ; pDlyDst : Ipp64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFilterMedian_32s( pSrc : Ipp32sPtr ; pDst : Ipp32sPtr ; len : Int32 ; maskSize : Int32 ; pDlySrc : Ipp32sPtr ; pDlyDst : Ipp32sPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFilterMedian_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; maskSize : Int32 ; pDlySrc : Ipp16sPtr ; pDlyDst : Ipp16sPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFilterMedian_8u( pSrc : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; maskSize : Int32 ; pDlySrc : Ipp8uPtr ; pDlyDst : Ipp8uPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFilterMedian_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; maskSize : Int32 ; pDlySrc : Ipp32fPtr ; pDlyDst : Ipp32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFilterMedian_64f_I( pSrcDst : Ipp64fPtr ; len : Int32 ; maskSize : Int32 ; pDlySrc : Ipp64fPtr ; pDlyDst : Ipp64fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFilterMedian_32s_I( pSrcDst : Ipp32sPtr ; len : Int32 ; maskSize : Int32 ; pDlySrc : Ipp32sPtr ; pDlyDst : Ipp32sPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFilterMedian_16s_I( pSrcDst : Ipp16sPtr ; len : Int32 ; maskSize : Int32 ; pDlySrc : Ipp16sPtr ; pDlyDst : Ipp16sPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFilterMedian_8u_I( pSrcDst : Ipp8uPtr ; len : Int32 ; maskSize : Int32 ; pDlySrc : Ipp8uPtr ; pDlyDst : Ipp8uPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Statistic functions
  ----------------------------------------------------------------------------

  Name:            ippsNorm
  Purpose:         calculate norm of vector
     Inf   - calculate C-norm of vector:  n = MAX |src1|
     L1    - calculate L1-norm of vector: n = SUM |src1|
     L2    - calculate L2-norm of vector: n = SQRT(SUM |src1|^2)
     L2Sqr - calculate L2-norm of vector: n = SUM |src1|^2
  Parameters:
    pSrc           source data pointer
    len            length of vector
    pNorm          pointer to result
    scaleFactor    scale factor value
  Returns:
    ippStsNoErr       Ok
    ippStsNullPtrErr  Some of pointers to input or output data are NULL
    ippStsSizeErr     The length of vector is less or equal zero
  Notes:
}

 function ippsNorm_Inf_16s32f( pSrc : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNorm_Inf_16s32s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsNorm_Inf_32f( pSrc : Ipp32fPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNorm_Inf_64f( pSrc : Ipp64fPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNorm_L1_16s32f( pSrc : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNorm_L1_16s32s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsNorm_L1_32f( pSrc : Ipp32fPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNorm_L1_64f( pSrc : Ipp64fPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNorm_L2_16s32f( pSrc : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNorm_L2_16s32s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsNorm_L2_32f( pSrc : Ipp32fPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNorm_L2_64f( pSrc : Ipp64fPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippsNorm_Inf_32fc32f( pSrc : Ipp32fcPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNorm_Inf_64fc64f( pSrc : Ipp64fcPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNorm_L1_32fc64f( pSrc : Ipp32fcPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNorm_L1_64fc64f( pSrc : Ipp64fcPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNorm_L2_32fc64f( pSrc : Ipp32fcPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNorm_L2_64fc64f( pSrc : Ipp64fcPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippsNorm_L1_16s64s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pNorm : Ipp64sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsNorm_L2Sqr_16s64s_Sfs( pSrc : Ipp16sPtr ; len : Int32 ; pNorm : Ipp64sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:            ippsNormDiff
  Purpose:         calculate norm of vectors
     Inf   - calculate C-norm of vectors:  n = MAX |src1-src2|
     L1    - calculate L1-norm of vectors: n = SUM |src1-src2|
     L2    - calculate L2-norm of vectors: n = SQRT(SUM |src1-src2|^2)
     L2Sqr - calculate L2-norm of vectors: n = SUM |src1-src2|^2
  Parameters:
    pSrc1, pSrc2   source data pointers
    len            length of vector
    pNorm          pointer to result
    scaleFactor    scale factor value
  Returns:
    ippStsNoErr       Ok
    ippStsNullPtrErr  Some of pointers to input or output data are NULL
    ippStsSizeErr     The length of vector is less or equal zero
  Notes:
}

 function ippsNormDiff_Inf_16s32f( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNormDiff_Inf_16s32s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsNormDiff_Inf_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNormDiff_Inf_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNormDiff_L1_16s32f( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNormDiff_L1_16s32s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsNormDiff_L1_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNormDiff_L1_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNormDiff_L2_16s32f( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNormDiff_L2_16s32s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; len : Int32 ; pNorm : Ipp32sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsNormDiff_L2_32f( pSrc1 : Ipp32fPtr ; pSrc2 : Ipp32fPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNormDiff_L2_64f( pSrc1 : Ipp64fPtr ; pSrc2 : Ipp64fPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippsNormDiff_Inf_32fc32f( pSrc1 : Ipp32fcPtr ; pSrc2 : Ipp32fcPtr ; len : Int32 ; pNorm : Ipp32fPtr ): IppStatus; _ippapi
 function ippsNormDiff_Inf_64fc64f( pSrc1 : Ipp64fcPtr ; pSrc2 : Ipp64fcPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNormDiff_L1_32fc64f( pSrc1 : Ipp32fcPtr ; pSrc2 : Ipp32fcPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNormDiff_L1_64fc64f( pSrc1 : Ipp64fcPtr ; pSrc2 : Ipp64fcPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNormDiff_L2_32fc64f( pSrc1 : Ipp32fcPtr ; pSrc2 : Ipp32fcPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi
 function ippsNormDiff_L2_64fc64f( pSrc1 : Ipp64fcPtr ; pSrc2 : Ipp64fcPtr ; len : Int32 ; pNorm : Ipp64fPtr ): IppStatus; _ippapi

 function ippsNormDiff_L1_16s64s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; len : Int32 ; pNorm : Ipp64sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsNormDiff_L2Sqr_16s64s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; len : Int32 ; pNorm : Ipp64sPtr ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                Cross-correlation Functions
  ----------------------------------------------------------------------------

  Names:  ippsCrossCorrNormGetBufferSize

  Purpose:     Get the size (in bytes) of the buffer for ippsCrossCorrNorm`s internal calculations.

  Parameters:
    src1Len     - Length of the first source vector.
    src2Len     - Length of the second source vector.
    dstLen      - Length of cross-correlation.
    lowLag      - Cross-correlation lowest lag.
    dataType    - Data type for convolution (Ipp32f|Ipp32fc|Ipp64f|Ipp64fc).
    algType     - Selector for the algorithm type. Possible values are the results of composition
                  of the  IppAlgType and IppsNormOp values.
    pBufferSize - Pointer to the calculated buffer size (in bytes).
  Return:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - pBufferSize is NULL.
    ippStsSizeErr     - Vector`s length is not positive.
    ippStsDataTypeErr - Unsupported data type.
    ippStsAlgTypeErr  - Unsupported algorithm or normalization type.
}

 function ippsCrossCorrNormGetBufferSize( src1Len : Int32 ; src2Len : Int32 ; dstLen : Int32 ; lowLag : Int32 ; dataType : IppDataType ; algType : IppEnum ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsCrossCorrNorm_32f, ippsCrossCorrNorm_32fc
              ippsCrossCorrNorm_64f, ippsCrossCorrNorm_64fc

  Purpose:    Calculate the cross-correlation of two vectors.

  Parameters:
     pSrc1   - Pointer to the first source vector.
     src1Len - Length of the first source vector.
     pSrc2   - Pointer to the second source vector.
     src2Len - Length of the second source vector.
     pDst    - Pointer to the cross correlation.
     dstLen  - Length of the cross-correlation.
     lowLag  - Cross-correlation lowest lag.
     algType - Selector for the algorithm type. Possible values are the results of composition
               of the  IppAlgType and IppsNormOp values.
     pBuffer - Pointer to the buffer for internal calculations.
  Return:
    ippStsNoErr      - OK.
    ippStsNullPtrErr - One of the pointers is NULL.
    ippStsSizeErr    - Vector`s length is not positive.
    ippStsAlgTypeErr - Unsupported algorithm or normalization type.
}

 function ippsCrossCorrNorm_32f( pSrc1 : Ipp32fPtr ; src1Len : Int32 ; pSrc2 : Ipp32fPtr ; src2Len : Int32 ; pDst : Ipp32fPtr ; dstLen : Int32 ; lowLag : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsCrossCorrNorm_64f( pSrc1 : Ipp64fPtr ; src1Len : Int32 ; pSrc2 : Ipp64fPtr ; src2Len : Int32 ; pDst : Ipp64fPtr ; dstLen : Int32 ; lowLag : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsCrossCorrNorm_32fc( pSrc1 : Ipp32fcPtr ; src1Len : Int32 ; pSrc2 : Ipp32fcPtr ; src2Len : Int32 ; pDst : Ipp32fcPtr ; dstLen : Int32 ; lowLag : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsCrossCorrNorm_64fc( pSrc1 : Ipp64fcPtr ; src1Len : Int32 ; pSrc2 : Ipp64fcPtr ; src2Len : Int32 ; pDst : Ipp64fcPtr ; dstLen : Int32 ; lowLag : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                AutoCorrelation Functions
  ----------------------------------------------------------------------------

  Names:  ippsAutoCorrNormGetBufferSize

  Purpose:     : Get the size (in bytes) of the buffer for ippsAutoCorrNorm`s internal calculations.

  Parameters:
     srcLen      - Source vector length.
     dstLen      - Length of auto-correlation.
     dataType    - Data type for auto corelation (Ipp32f|Ipp32fc|Ipp64f|Ipp64fc).
     algType     - Selector for the algorithm type.  Possible values are the results of
                   composition of the IppAlgType and IppsNormOp values.
     pBufferSize - Pointer to the calculated buffer size (in bytes).
  Return:
   ippStsNoErr       - OK.
   ippStsNullPtrErr  - pBufferSize is NULL.
   ippStsSizeErr     - Vector`s length is not positive.
   ippStsDataTypeErr - Unsupported data type.
   ippStsAlgTypeErr  - Unsupported algorithm or normalization type.
}

 function ippsAutoCorrNormGetBufferSize( srcLen : Int32 ; dstLen : Int32 ; dataType : IppDataType ; algType : IppEnum ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:  ippsAutoCorrNorm_32f,  ippsAutoCorrNorm_64f
          ippsAutoCorrNorm_32fc,  ippsAutoCorrNorm_64fc

  Purpose:    Calculate the auto-correlation,
              ippNormNone specifies the normal auto-correlation.
              ippNormA specifies the biased auto-correlation
              (the resulting values are divided by srcLen).
              ippNormB specifies the unbiased auto-correlation
              (the resulting values are divided by ( srcLen - n ),
              where "n" indicates current iteration).

  Parameters:
     pSrc    - Pointer to the source vector.
     srcLen  - Source vector length.
     pDst    - Pointer to the auto-correlation result vector.
     dstLen  - Length of auto-correlation.
     algType - Selector for the algorithm type. Possible values are the results
               of composition of the  IppAlgType and IppsNormOp values.
     pBuffer - Pointer to the buffer for internal calculations.
  Return:
   ippStsNoErr      - OK.
   ippStsNullPtrErr - One of the pointers is NULL.
   ippStsSizeErr    - Vector`s length is not positive.
   ippStsAlgTypeErr - Unsupported algorithm or normalization type.
}

 function ippsAutoCorrNorm_32f( pSrc : Ipp32fPtr ; srcLen : Int32 ; pDst : Ipp32fPtr ; dstLen : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsAutoCorrNorm_64f( pSrc : Ipp64fPtr ; srcLen : Int32 ; pDst : Ipp64fPtr ; dstLen : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsAutoCorrNorm_32fc( pSrc : Ipp32fcPtr ; srcLen : Int32 ; pDst : Ipp32fcPtr ; dstLen : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi
 function ippsAutoCorrNorm_64fc( pSrc : Ipp64fcPtr ; srcLen : Int32 ; pDst : Ipp64fcPtr ; dstLen : Int32 ; algType : IppEnum ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Sampling functions
{ ----------------------------------------------------------------------------


  Name:       ippsSampleUp
  Purpose:    upsampling, i.e. expansion of input vector to get output vector
              by simple adding zeroes between input elements
  Parameters:
   pSrc   (in)    pointer to the input vector
   pDst   (in)    pointer to the output vector
   srcLen (in)    length of input vector
   pDstLen (out)  pointer to the length of output vector
   factor (in)    the number of output elements,  corresponding to one element
                  of input vector.
   pPhase(in-out) pointer to value,  that is the position (0, ..., factor-1) of
                  element from input vector in the group of factor elements of
                  output vector. Out value is ready to continue upsampling with
                  the same factor (out = in).

  Return:
   ippStsNullPtrErr        one or several pointers pSrc,  pDst, pDstLen or pPhase
                           is NULL
   ippStsSizeErr           length of input vector is less or equal zero
   ippStsSampleFactorErr   factor <= 0
   ippStsSamplePhaseErr    *pPhase < 0 or *pPhase >= factor
   ippStsNoErr             otherwise
}

 function ippsSampleUp_32f( pSrc : Ipp32fPtr ; srcLen : Int32 ; pDst : Ipp32fPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi
 function ippsSampleUp_32fc( pSrc : Ipp32fcPtr ; srcLen : Int32 ; pDst : Ipp32fcPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi
 function ippsSampleUp_64f( pSrc : Ipp64fPtr ; srcLen : Int32 ; pDst : Ipp64fPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi
 function ippsSampleUp_64fc( pSrc : Ipp64fcPtr ; srcLen : Int32 ; pDst : Ipp64fcPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi
 function ippsSampleUp_16s( pSrc : Ipp16sPtr ; srcLen : Int32 ; pDst : Ipp16sPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi
 function ippsSampleUp_16sc( pSrc : Ipp16scPtr ; srcLen : Int32 ; pDst : Ipp16scPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsSampleDown
  Purpose:    subsampling, i.e. only one of "factor" elements of input vector
              are placed to output vector
  Parameters:
   pSrc   (in)    pointer to the input vector
   pDst   (in)    pointer to the output vector
   srcLen (in)    length of input vector
   pDstLen (out)  pointer to the length of output vector
   factor (in)    the number of input elements,  corresponding to one element
                  of output vector.
   pPhase(in-out) pointer to value,  that is the position (0, ..., factor-1) of
                  chosen element in the group of "factor" elements. Out value
                  of *pPhase is ready to continue subsampling with the same
                  factor.

  Return:
   ippStsNullPtrErr        one or several pointers pSrc,  pDst, pDstLen or pPhase
                        is NULL
   ippStsSizeErr           length of input vector is less or equal zero
   ippStsSampleFactorErr   factor <= 0
   ippStsSamplePhaseErr    *pPhase < 0 or *pPhase >=factor
   ippStsNoErr             otherwise
}

 function ippsSampleDown_32f( pSrc : Ipp32fPtr ; srcLen : Int32 ; pDst : Ipp32fPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi
 function ippsSampleDown_32fc( pSrc : Ipp32fcPtr ; srcLen : Int32 ; pDst : Ipp32fcPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi
 function ippsSampleDown_64f( pSrc : Ipp64fPtr ; srcLen : Int32 ; pDst : Ipp64fPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi
 function ippsSampleDown_64fc( pSrc : Ipp64fcPtr ; srcLen : Int32 ; pDst : Ipp64fcPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi
 function ippsSampleDown_16s( pSrc : Ipp16sPtr ; srcLen : Int32 ; pDst : Ipp16sPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi
 function ippsSampleDown_16sc( pSrc : Ipp16scPtr ; srcLen : Int32 ; pDst : Ipp16scPtr ; pDstLen : Int32Ptr ; factor : Int32 ; pPhase : Int32Ptr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  Definitions for Hilbert Functions
----------------------------------------------------------------------------

 Name:       ippsHilbert
 Purpose:    Computes Hilbert transform of the real signal.
 Arguments:
    pSrc         - Pointer to source real signal
    pDst         - Pointer to destination complex signal
    pSpec        - Pointer to Hilbert context.
    pBuffer      - Pointer to the buffer for internal calculations.
    scaleFactor  - Scale factor for output signal.
 Return:
    ippStsNoErr           - OK.
    ippStsNullPtrErr      - Error when any of the specified pointers is NULL.
    ippStsContextMatchErr - Error when pSpec initialized incorect.
}

 function ippsHilbert_32f32fc( pSrc : Ipp32fPtr ; pDst : Ipp32fcPtr ; pSpec : IppsHilbertSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:       ippsHilbertGetSize
 Purpose:    Get sizes (in bytes) of the IppsHilbertSpec spec structure and temporary buffer.
 Parameters:
    length      - Number of samples in Hilbert.
    hint        - Option to select the algorithmic implementation of the transform function (DFT).
    pSpecSize   - Pointer to the calculated spec size (in bytes).
    pSizeBuf    - Pointer to the calculated size of the external work buffer.
  Returns:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - Error when any of the specified pointers is NULL.
    ippStsSizeErr     - Error when length is less than 1.
}

 function ippsHilbertGetSize_32f32fc( length : Int32 ; hint : IppHintAlgorithm ; var pSpecSize : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

 Name:       ippsHilbertInit
 Purpose:    initializes Hilbert context structure.
 Parameters:
    length      - Number of samples in Hilbert.
    hint        - Option to select the algorithmic implementation of the transform function (DFT).
    pSpec       - Pointer to Hilbert context.
    pBuffer     - Pointer to the buffer for internal calculations.
  Returns:
    ippStsNoErr       - OK.
    ippStsNullPtrErr  - Error when any of the specified pointers is NULL.
    ippStsSizeErr     - Error when length is less than 1.
}

 function ippsHilbertInit_32f32fc( length : Int32 ; hint : IppHintAlgorithm ; pSpec : IppsHilbertSpecPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:         ippsFIRSparseGetStateSize,
                ippsFIRSparseInit
  Purpose:      ippsFIRSparseGetStateSize - calculates the size of the FIRSparse
                                            State  structure;
                ippsFIRSparseInit - initialize FIRSparse state - set non-zero taps, 
                their positions and delay line using external memory buffer;
  Parameters:
      pNZTaps     - pointer to the non-zero filter coefficients;
      pNZTapPos   - pointer to the positions of non-zero filter coefficients;
      nzTapsLen   - number of non-zero coefficients;
      pDlyLine    - pointer to the delay line values,  can be NULL;
      ppState     - pointer to the FIRSparse state created or NULL;
      order       - order of FIRSparse filter
      pStateSize  - pointer where to store the calculated FIRSparse State
                    structuresize (in bytes);
   Return:
      status      - status value returned,  its value are
         ippStsNullPtrErr       - pointer(s) to the data is NULL
         ippStsFIRLenErr        - nzTapsLen <= 0
         ippStsSparseErr        - non-zero tap positions are not in ascending order, 
                                  negative or repeated.
         ippStsNoErr            - otherwise
}

 function ippsFIRSparseGetStateSize_32f( nzTapsLen : Int32 ; order : Int32 ; pStateSize : Int32Ptr ): IppStatus; _ippapi

 function ippsFIRSparseInit_32f( ppState : IppsFIRSparseState_32fPtrPtr ; pNZTaps : Ipp32fPtr ; pNZTapPos : Ipp32sPtr ; nzTapsLen : Int32 ; pDlyLine : Ipp32fPtr ; pBuffer : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:         ippsIIRSparseGetStateSize,
                ippsIIRSparseInit
  Purpose:      ippsIIRSparseGetStateSize - calculates the size of the
                                            IIRSparse State structure;
                ippsIIRSparseInit - initialize IIRSparse state - set non-zero taps, 
                their positions and delay line using external memory buffer;
  Parameters:
      pNZTaps     - pointer to the non-zero filter coefficients;
      pNZTapPos   - pointer to the positions of non-zero filter coefficients;
      nzTapsLen1,
      nzTapsLen2  - number of non-zero coefficients according to the IIRSparseformula;
      pDlyLine    - pointer to the delay line values,  can be NULL;
      ppState     - pointer to the IIR state created or NULL;
      pStateSize  - pointer where to store the calculated IIR State structure
                                                             size (in bytes);
   Return:
      status      - status value returned,  its value are
         ippStsNullPtrErr       - pointer(s) to the data is NULL
         ippStsIIROrderErr      - nzTapsLen1 <= 0 or nzTapsLen2 < 0
         ippStsSparseErr        - non-zero tap positions are not in ascending order, 
                                  negative or repeated.
         ippStsNoErr            - otherwise
}

 function ippsIIRSparseGetStateSize_32f( nzTapsLen1 : Int32 ; nzTapsLen2 : Int32 ; order1 : Int32 ; order2 : Int32 ; pStateSize : Int32Ptr ): IppStatus; _ippapi

 function ippsIIRSparseInit_32f( ppState : IppsIIRSparseState_32fPtrPtr ; pNZTaps : Ipp32fPtr ; pNZTapPos : Ipp32sPtr ; nzTapsLen1 : Int32 ; nzTapsLen2 : Int32 ; pDlyLine : Ipp32fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:         ippsFIRSparse
  Purpose:       FIRSparse filter with float taps. Vector filtering
  Parameters:
      pSrc        - pointer to the input vector
      pDst        - pointer to the output vector
      len         - length data vector
      pState      - pointer to the filter state
  Return:
      ippStsNullPtrErr       - pointer(s) to the data is NULL
      ippStsSizeErr          - length of the vectors <= 0
      ippStsNoErr            - otherwise
}

 function ippsFIRSparse_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; pState : IppsFIRSparseState_32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Names:         ippsFIRSparseSetDlyLine_32f
                 ippsFIRSparseGetDlyLine_32f
  Purpose:       Get(set) delay line
  Parameters:
      pState      - pointer to the filter state
      pDlyLine    - pointer to the delay line values,  can be NULL;
  Return:
      ippStsNullPtrErr       - pointer(s) to the data is NULL
}

 function ippsFIRSparseSetDlyLine_32f( pState : IppsFIRSparseState_32fPtr ; const pDlyLine : Ipp32fPtr  ): IppStatus; _ippapi
 function ippsFIRSparseGetDlyLine_32f( pState : IppsFIRSparseState_32fPtr ; pDlyLine : Ipp32fPtr ): IppStatus; _ippapi

{----------------------------------------------------------------------------
  Names:         ippsIIRSparse
  Purpose:       IIRSparse filter with float taps. Vector filtering
  Parameters:
      pSrc                - pointer to input vector
      pDst                - pointer to output vector
      len                 - length of the vectors
      pState              - pointer to the filter state
  Return:
      ippStsNullPtrErr       - pointer(s) to the data is NULL
      ippStsSizeErr          - length of the vectors <= 0
      ippStsNoErr            - otherwise
}

 function ippsIIRSparse_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; pState : IppsIIRSparseState_32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsAddProductC
  Purpose:    multiplies elements of of a vector by a constant and adds product to
              the accumulator vector
  Parameters:
    pSrc                 pointer to the source vector
    val                  constant value
    pSrcDst              pointer to the source/destination (accumulator) vector
    len                  length of the vectors
  Return:
    ippStsNullPtrErr     pointer to the vector is NULL
    ippStsSizeErr        length of the vectors is less or equal zero
    ippStsNoErr          otherwise

  Notes:                 pSrcDst[n] = pSrcDst[n] + pSrc[n] * val,  n=0,1,2,..len-1.
}

 function ippsAddProductC_32f( pSrc : Ipp32fPtr ; const val : Ipp32f ; pSrcDst : Ipp32fPtr ; len : Int32 ): IppStatus; _ippapi

{----------------------------------------------------------------------------
  Name:  ippsSumWindow_8u32f      ippsSumWindow_16s32f
  Purpose:
  Return:
    ippStsNoErr        Ok
    ippStsNullPtrErr   one or more pointers are NULL
    ippStsMaskSizeErr  maskSize has a field with zero,  or negative value
  Arguments:
   pSrc        Pointer to the source vector
   pDst        Pointer to the destination vector
   maskSize    Size of the mask in pixels
}

 function ippsSumWindow_8u32f( pSrc : Ipp8uPtr ; pDst : Ipp32fPtr ; len : Int32 ; maskSize : Int32 ): IppStatus; _ippapi
 function ippsSumWindow_16s32f( pSrc : Ipp16sPtr ; pDst : Ipp32fPtr ; len : Int32 ; maskSize : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:  ippsCountInRange_32s
  Purpose: Computes the number of vector elements falling within the specified range.
  Return:
     ippStsNoErr       No errors,  it`s OK
     ippStsNullPtrErr  Either pSrc or pCounts equals to zero.
     ippStsLengthErr   The vector`s length is less than or equals to zero.
  Arguments:
     pSrc              A pointer to the source vector.
     len               Number of the vector elements.
     pCounts           A pointer to the output result.
     lowerBound        The upper boundary of the range.
     uppreBound        The lower boundary of the range.
}

 function ippsCountInRange_32s( pSrc : Ipp32sPtr ; len : Int32 ; pCounts : Int32Ptr ; lowerBound : Ipp32s ; upperBound : Ipp32s ): IppStatus; _ippapi


{
  Purpose:            Creates ramp vector

  Parameters:
    pDst              A pointer to the destination vector
    len               Vector`s length
    offset            Offset value
    slope             Slope coefficient

  Return:
    ippStsNoErr       No error
    ippStsNullPtrErr  pDst pointer is NULL
    ippStsBadSizeErr  Vector`s length is less or equal zero
    ippStsNoErr       No error

  Notes:              Dst[n] = offset + slope * n
}

 function ippsVectorSlope_8u( pDst : Ipp8uPtr ; len : Int32 ; offset : Ipp32f ; slope : Ipp32f ): IppStatus; _ippapi
 function ippsVectorSlope_16u( pDst : Ipp16uPtr ; len : Int32 ; offset : Ipp32f ; slope : Ipp32f ): IppStatus; _ippapi
 function ippsVectorSlope_16s( pDst : Ipp16sPtr ; len : Int32 ; offset : Ipp32f ; slope : Ipp32f ): IppStatus; _ippapi
 function ippsVectorSlope_32u( pDst : Ipp32uPtr ; len : Int32 ; offset : Ipp64f ; slope : Ipp64f ): IppStatus; _ippapi
 function ippsVectorSlope_32s( pDst : Ipp32sPtr ; len : Int32 ; offset : Ipp64f ; slope : Ipp64f ): IppStatus; _ippapi
 function ippsVectorSlope_32f( pDst : Ipp32fPtr ; len : Int32 ; offset : Ipp32f ; slope : Ipp32f ): IppStatus; _ippapi
 function ippsVectorSlope_64f( pDst : Ipp64fPtr ; len : Int32 ; offset : Ipp64f ; slope : Ipp64f ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:       ippsDiv_Round_8u_Sfs
              ippsDiv_Round_16u_Sfs
              ippsDiv_Round_16s_Sfs
              ippsDiv_Round_8u_ISfs
              ippsDiv_Round_16u_ISfs
              ippsDiv_Round_16s_ISfs


  Purpose:    divide every element of the source vector by the scalar value
              or by corresponding element of the second source vector and
              round to zero,  near or financial
  Arguments:
    val               the divisor value
    pSrc              pointer to the divisor source vector
    pSrc1             pointer to the divisor source vector
    pSrc2             pointer to the dividend source vector
    pDst              pointer to the destination vector
    pSrcDst           pointer to the source/destination vector
    len               vector`s length,  number of items
    rndMode           Rounding mode (ippRndZero, ippRndNear or ippRndFinancial)
    scaleFactor       scale factor parameter value
  Return:
    ippStsNullPtrErr     pointer(s) to the data vector is NULL
    ippStsSizeErr        length of the vector is less or equal zero
    ippStsDivByZeroErr   the scalar divisor value is zero
    ippStsDivByZero      Warning status if an element of divisor vector is
                      zero. If the dividend is zero than result is
                      NaN, if the dividend is not zero than result
                      is Infinity with correspondent sign. The
                      execution is not aborted. For the integer operation
                      zero instead of NaN and the corresponding bound
                      values instead of Infinity
   ippStsRoundModeNotSupportedErr Unsupported round mode
   ippStsNoErr          otherwise

  Note:
    DivC(v,X,Y)  :    Y[n] = X[n] / v
    DivC(v,X)    :    X[n] = X[n] / v
    Div(X,Y)     :    Y[n] = Y[n] / X[n]
    Div(X,Y,Z)   :    Z[n] = Y[n] / X[n]
}

 function ippsDiv_Round_8u_Sfs( pSrc1 : Ipp8uPtr ; pSrc2 : Ipp8uPtr ; pDst : Ipp8uPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDiv_Round_16s_Sfs( pSrc1 : Ipp16sPtr ; pSrc2 : Ipp16sPtr ; pDst : Ipp16sPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDiv_Round_16u_Sfs( pSrc1 : Ipp16uPtr ; pSrc2 : Ipp16uPtr ; pDst : Ipp16uPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

 function ippsDiv_Round_8u_ISfs( pSrc : Ipp8uPtr ; pSrcDst : Ipp8uPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDiv_Round_16s_ISfs( pSrc : Ipp16sPtr ; pSrcDst : Ipp16sPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi
 function ippsDiv_Round_16u_ISfs( pSrc : Ipp16uPtr ; pSrcDst : Ipp16uPtr ; len : Int32 ; rndMode : IppRoundMode ; scaleFactor : Int32 ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:              ippsZeroCrossing_*
  Purpose:           Counts the zero-cross measure for the input signal.

  Parameters:
    pSrc             Pointer to the input signal [len].
    len              Number of elements in the input signal.
    pValZCR          Pointer to the result value.
    zcType           Zero crossing measure type.
  Return:
    ippStsNoErr      Indicates no error.
    ippStsNullPtrErr Indicates an error when the pSrc or pRes pointer is null.
    ippStsRangeErr   Indicates an error when zcType is not equal to
                     ippZCR, ippZCXor or ippZCC
}

 function ippsZeroCrossing_16s32f( pSrc : Ipp16sPtr ; len : Ipp32u ; pValZCR : Ipp32fPtr ; zcType : IppsZCType ): IppStatus; _ippapi
 function ippsZeroCrossing_32f( pSrc : Ipp32fPtr ; len : Ipp32u ; pValZCR : Ipp32fPtr ; zcType : IppsZCType ): IppStatus; _ippapi

{ >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< }

{ ----------------------------------------------------------------------------

  Name:           ippsResamplePolyphase, ippsResamplePolyphaseFixed
  Purpose:        Resample input data.
   Arguments:
      pSrc      The pointer to the input vector.
      pDst      The pointer to the output vector.
      len       The number of input vector elements to resample.
      norm      The norming factor for output samples.
      factor    The resampling factor.
      pTime     The pointer to the start time of resampling (in input vector elements).
      pOutlen   The number of calculated output vector elements
      pSpec     The pointer to the resampling specification structure.
   Return Value
      ippStsNoErr        Indicates no error.
      ippStsNullPtrErr   Indicates an error when pSpec,  pSrc, pDst, pTime or pOutlen is NULL.
      ippStsSizeErr      Indicates an error when len is less than or equal to 0.
      ippStsBadArgErr    Indicates an error when factor is less than or equal to.
}

 function ippsResamplePolyphase_16s( pSrc : Ipp16sPtr ; len : Int32 ; pDst : Ipp16sPtr ; factor : Ipp64f ; norm : Ipp32f ; pTime : Ipp64fPtr ; pOutlen : Int32Ptr ; const pSpec : IppsResamplingPolyphase_16sPtr ): IppStatus; _ippapi
 function ippsResamplePolyphase_32f( pSrc : Ipp32fPtr ; len : Int32 ; pDst : Ipp32fPtr ; factor : Ipp64f ; norm : Ipp32f ; pTime : Ipp64fPtr ; pOutlen : Int32Ptr ; const pSpec : IppsResamplingPolyphase_32fPtr ): IppStatus; _ippapi

 function ippsResamplePolyphaseFixed_16s( pSrc : Ipp16sPtr ; len : Int32 ; pDst : Ipp16sPtr ; norm : Ipp32f ; pTime : Ipp64fPtr ; pOutlen : Int32Ptr ; const pSpec : IppsResamplingPolyphaseFixed_16sPtr ): IppStatus; _ippapi
 function ippsResamplePolyphaseFixed_32f( pSrc : Ipp32fPtr ; len : Int32 ; pDst : Ipp32fPtr ; norm : Ipp32f ; pTime : Ipp64fPtr ; pOutlen : Int32Ptr ; const pSpec : IppsResamplingPolyphaseFixed_32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippsResamplePolyphaseGetSize, ippsResamplePolyphaseFixedGetSize
  Purpose:        Determines the size required for the ResamplePolyphase or ResamplePolyphaseFixed.
   Arguments:
      window          The size of the ideal lowpass filter window.
      nStep           The discretization step for filter coefficients
      inRate          The input rate for resampling with fixed factor.
      outRate         The output rate for resampling with fixed factor.
      len             The filter length for resampling with fixed factor.
      pSize           Required size in bytes
      pLen            Filter len
      pHeight         Number of filter
      hint            Suggests using specific code. The values for the hint argument are described in "Flag and Hint Arguments"

   Return Value
      ippStsNoErr       Indicates no error.
      ippStsNullPtrErr  Indicates an error when pSize,  pLen or pHeight are NULL.
      ippStsSizeErr     Indicates an error when inRate,  outRate or len is less than or equal to 0.
}

 function ippsResamplePolyphaseGetSize_16s( window : Ipp32f ; nStep : Int32 ; var pSize : Int32 ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsResamplePolyphaseGetSize_32f( window : Ipp32f ; nStep : Int32 ; var pSize : Int32 ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsResamplePolyphaseFixedGetSize_16s( inRate : Int32 ; outRate : Int32 ; len : Int32 ; var pSize : Int32 ; pLen : Int32Ptr ; pHeight : Int32Ptr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsResamplePolyphaseFixedGetSize_32f( inRate : Int32 ; outRate : Int32 ; len : Int32 ; var pSize : Int32 ; pLen : Int32Ptr ; pHeight : Int32Ptr ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippsResamplePolyphaseInit, ippsResamplePolyphaseFixedInit
  Purpose:        Initializes ResamplePolyphase of ResamplePolyphaseFixed structures
   Arguments:
      window          The size of the ideal lowpass filter window.
      nStep           The discretization step for filter coefficients
      inRate          The input rate for resampling with fixed factor.
      outRate         The output rate for resampling with fixed factor.
      len             The filter length for resampling with fixed factor.
      rollf           The roll-off frequency of the filter.
      alpha           The parameter of the Kaiser window.
      pSpec           The pointer to the resampling specification structure to be created.
      hint            Suggests using specific code. The values for the hint argument are described in "Flag and Hint Arguments"
   Return Value
      ippStsNoErr       Indicates no error.
      ippStsNullPtrErr  Indicates an error when pSpec is NULL.
      ippStsSizeErr     Indicates an error when inRate,  outRate or len is less than or equal to 0.
}

 function ippsResamplePolyphaseInit_16s( window : Ipp32f ; nStep : Int32 ; rollf : Ipp32f ; alpha : Ipp32f ; pSpec : IppsResamplingPolyphase_16sPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsResamplePolyphaseInit_32f( window : Ipp32f ; nStep : Int32 ; rollf : Ipp32f ; alpha : Ipp32f ; pSpec : IppsResamplingPolyphase_32fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsResamplePolyphaseFixedInit_16s( inRate : Int32 ; outRate : Int32 ; len : Int32 ; rollf : Ipp32f ; alpha : Ipp32f ; pSpec : IppsResamplingPolyphaseFixed_16sPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi
 function ippsResamplePolyphaseFixedInit_32f( inRate : Int32 ; outRate : Int32 ; len : Int32 ; rollf : Ipp32f ; alpha : Ipp32f ; pSpec : IppsResamplingPolyphaseFixed_32fPtr ; hint : IppHintAlgorithm ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippsResamplePolyphaseSetFixedFilter
  Purpose:        Set filter coefficient
   Arguments:
      pSpec           The pointer to the resampling specification structure to be created.
      pSrc            Input vector of filter coefficients [height][step]
      step            Lenght of filter
      height          Number of filter
   Return Value
      ippStsNoErr       Indicates no error.
      ippStsNullPtrErr  Indicates an error when pSpec or pSrc are NULL.
      ippStsSizeErr     Indicates an error when step or height is less than or equal to 0.
}

 function ippsResamplePolyphaseSetFixedFilter_16s( pSrc : Ipp16sPtr ; step : Int32 ; height : Int32 ; pSpec : IppsResamplingPolyphaseFixed_16sPtr ): IppStatus; _ippapi
 function ippsResamplePolyphaseSetFixedFilter_32f( pSrc : Ipp32fPtr ; step : Int32 ; height : Int32 ; pSpec : IppsResamplingPolyphaseFixed_32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:           ippsResamplePolyphaseGetFixedFilter
  Purpose:        Get filter coefficient
   Arguments:
      pSpec           The pointer to the resampling specification structure to be created.
      pDst            Input vector of filter coefficients [height][step]
      step            Lenght of filter
      height          Number of filter
   Return Value
      ippStsNoErr       Indicates no error.
      ippStsNullPtrErr  Indicates an error when pSpec or pSrc are NULL.
      ippStsSizeErr     Indicates an error when step or height is less than or equal to 0.
}

 function ippsResamplePolyphaseGetFixedFilter_16s( pDst : Ipp16sPtr ; step : Int32 ; height : Int32 ; const pSpec : IppsResamplingPolyphaseFixed_16sPtr ): IppStatus; _ippapi
 function ippsResamplePolyphaseGetFixedFilter_32f( pDst : Ipp32fPtr ; step : Int32 ; height : Int32 ; const pSpec : IppsResamplingPolyphaseFixed_32fPtr ): IppStatus; _ippapi

{FIR API New Design}
{ ----------------------------------------------------------------------------

  Name:         ippsFIRSRGetSize, ippsFIRSRInit_32f, ippsFIRSRInit_64f
                ippsFIRSR_32f, ippsFIRSR_64f
  Purpose:      Get sizes of the FIR spec structure and temporary buffer
                initialize FIR spec structure - set taps and delay line
                perform FIR filtering
                and close it
  Parameters:
      pTaps       - pointer to the filter coefficients
      tapsLen     - number of coefficients
      tapsType    - type of coefficients (ipp32f or ipp64f)
      pSpecSize   - pointer to the size of FIR spec
      pBufSize    - pointer to the size of temporal buffer
      algType     - mask for the algorithm type definition (direct, fft, auto)
      pDlySrc     - pointer to the input  delay line values,  can be NULL
      pDlyDst     - pointer to the output delay line values,  can be NULL
      pSpec       - pointer to the constant internal structure
      pSrc        - pointer to the source vector.
      pDst        - pointer to the destination vector
      numIters    - length  of the destination vector
      pBuf        - pointer to the work buffer
   Return:
      status      - status value returned,  its value are
         ippStsNullPtrErr       - one of the specified pointer is NULL
         ippStsFIRLenErr        - tapsLen <= 0
         ippStsContextMatchErr  - wrong state identifier
         ippStsNoErr            - OK
         ippStsSizeErr          - numIters is not positive
         ippStsAlgTypeErr       - unsupported algorithm type
         ippStsMismatch         - not effective algorithm.
}

 function ippsFIRSRGetSize( tapsLen : Int32 ; tapsType : IppDataType ; var pSpecSize : Int32 ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippsFIRSRInit_32f( pTaps : Ipp32fPtr ; tapsLen : Int32 ; algType : IppAlgType ; pSpec : IppsFIRSpec_32fPtr ): IppStatus; _ippapi
 function ippsFIRSRInit_64f( pTaps : Ipp64fPtr ; tapsLen : Int32 ; algType : IppAlgType ; pSpec : IppsFIRSpec_64fPtr ): IppStatus; _ippapi
 function ippsFIRSRInit_32fc( pTaps : Ipp32fcPtr ; tapsLen : Int32 ; algType : IppAlgType ; pSpec : IppsFIRSpec_32fcPtr ): IppStatus; _ippapi
 function ippsFIRSRInit_64fc( pTaps : Ipp64fcPtr ; tapsLen : Int32 ; algType : IppAlgType ; pSpec : IppsFIRSpec_64fcPtr ): IppStatus; _ippapi
 function ippsFIRSR_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_32fPtr ; pDlySrc : Ipp32fPtr ; pDlyDst : Ipp32fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRSR_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_64fPtr ; pDlySrc : Ipp64fPtr ; pDlyDst : Ipp64fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRSR_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_32fcPtr ; pDlySrc : Ipp32fcPtr ; pDlyDst : Ipp32fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRSR_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_64fcPtr ; pDlySrc : Ipp64fcPtr ; pDlyDst : Ipp64fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRSR_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_32fPtr ; pDlySrc : Ipp16sPtr ; pDlyDst : Ipp16sPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRSR_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_32fcPtr ; pDlySrc : Ipp16scPtr ; pDlyDst : Ipp16scPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  Name:         ippsFIRMRGetSize,
                ownippsFIRMRInit_32f, ownippsFIRMRInit_64f, ownippsFIRMRInit_32fc, ownippsFIRMRInit_64fc
                ippsFIRMR_32f, ippsFIRMR_32fc, ippsFIRMR_64f, ippsFIRMR_64fc, ippsFIRMR_16s, ippsFIRMR_16sc,
  Purpose:      Get sizes of the FIR spec structure and temporary buffer, 
                initialize FIR spec structure - set taps and delay line, 
                perform multi rate FIR filtering

  Parameters:
      pTaps       - pointer to the filter coefficients
      tapsLen     - number of coefficients
      tapsType    - type of coefficients (ipp32f or ipp64f)
      pSpecSize   - pointer to the size of FIR spec
      pBufSize    - pointer to the size of temporal buffer
      pDlySrc     - pointer to the input  delay line values,  can be NULL
      pDlyDst     - pointer to the output delay line values,  can be NULL
      upFactor    - multi-rate up factor;
      upPhase     - multi-rate up phase;
      downFactor  - multi-rate down factor;
      downPhase   - multi-rate down phase;
      pSpec       - pointer to the constant internal structure
      pSrc        - pointer to the source vector.
      pDst        - pointer to the destination vector
      numIters    - length  of the destination vector
      pBuf        - pointer to the work buffer
   Return:
      status      - status value returned,  its value are
         ippStsNullPtrErr       - one of the specified pointer is NULL
         ippStsFIRLenErr        - tapsLen <= 0
         ippStsFIRMRFactorErr   - factor <= 0
         ippStsFIRMRPhaseErr    - phase < 0 || factor <= phase
         ippStsContextMatchErr  - wrong state identifier
         ippStsNoErr            - OK
         ippStsSizeErr          - numIters is not positive
}

 function ippsFIRMRGetSize( tapsLen : Int32 ; upFactor : Int32 ; downFactor : Int32 ; tapsType : IppDataType ; var pSpecSize : Int32 ; var pBufSize : Int32 ): IppStatus; _ippapi
 function ippsFIRMRInit_32f( pTaps : Ipp32fPtr ; tapsLen : Int32 ; upFactor : Int32 ; upPhase : Int32 ; downFactor : Int32 ; downPhase : Int32 ; pSpec : IppsFIRSpec_32fPtr ): IppStatus; _ippapi
 function ippsFIRMRInit_64f( pTaps : Ipp64fPtr ; tapsLen : Int32 ; upFactor : Int32 ; upPhase : Int32 ; downFactor : Int32 ; downPhase : Int32 ; pSpec : IppsFIRSpec_64fPtr ): IppStatus; _ippapi
 function ippsFIRMRInit_32fc( pTaps : Ipp32fcPtr ; tapsLen : Int32 ; upFactor : Int32 ; upPhase : Int32 ; downFactor : Int32 ; downPhase : Int32 ; pSpec : IppsFIRSpec_32fcPtr ): IppStatus; _ippapi
 function ippsFIRMRInit_64fc( pTaps : Ipp64fcPtr ; tapsLen : Int32 ; upFactor : Int32 ; upPhase : Int32 ; downFactor : Int32 ; downPhase : Int32 ; pSpec : IppsFIRSpec_64fcPtr ): IppStatus; _ippapi

 function ippsFIRMR_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_32fPtr ; pDlySrc : Ipp32fPtr ; pDlyDst : Ipp32fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRMR_64f( pSrc : Ipp64fPtr ; pDst : Ipp64fPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_64fPtr ; pDlySrc : Ipp64fPtr ; pDlyDst : Ipp64fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRMR_32fc( pSrc : Ipp32fcPtr ; pDst : Ipp32fcPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_32fcPtr ; pDlySrc : Ipp32fcPtr ; pDlyDst : Ipp32fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRMR_64fc( pSrc : Ipp64fcPtr ; pDst : Ipp64fcPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_64fcPtr ; pDlySrc : Ipp64fcPtr ; pDlyDst : Ipp64fcPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

 function ippsFIRMR_16s( pSrc : Ipp16sPtr ; pDst : Ipp16sPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_32fPtr ; pDlySrc : Ipp16sPtr ; pDlyDst : Ipp16sPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi
 function ippsFIRMR_16sc( pSrc : Ipp16scPtr ; pDst : Ipp16scPtr ; numIters : Int32 ; pSpec : IppsFIRSpec_32fcPtr ; pDlySrc : Ipp16scPtr ; pDlyDst : Ipp16scPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

                  IIRIIR filters (analogue of FILTFILT)
  ----------------------------------------------------------------------------

          Initialize IIRIIR state,  calculate required memory buffer size
  ----------------------------------------------------------------------------
                    Order of taps = b0,b1,...,bN,a0,a1,...,aN
                                    N = order
                    Delay line is in the Direct Form II format
  ----------------------------------------------------------------------------

  Name:         ippsIIRIIRGetStateSize, 
                ippsIIRIIRInit

  Purpose:      ippsIIRIIRGetStateSize - calculates the size of the IIRIIR
                                                          State structure;
                ippsIIRIIRInit - initialize IIRIIR state with IIR taps 
                and delay line using external memory buffer;
  Parameters:
      pTaps       - pointer to the filter coefficients;
      order       - order of the filter;
      pDlyLine    - pointer to the delay line,  can be NULL;
      ppState     - double pointer to the IIRIIR state;
      tapsFactor  - scaleFactor for taps (integer version);
      pBufferSize - pointer where to store the calculated IIRIIR 
                                 State structure size (in bytes);
   Return:
      status      - status value returned,  its value are
         ippStsNullPtrErr   - pointer(s) ppState or pTaps is NULL;
                              if IIRIIRInit is called with pDlyLine==NULL then 
                              it forms delay line itself that minimizes start-up
                              and ending transients by matching initial
                              conditions to remove DC offset at beginning 
                              and end of input vector.
         ippStsIIROrderErr  - order <= 0
         ippStsDivByZeroErr - a0 == 0.0 ( pTaps[order+1] == 0.0 )
         ippStsNoErr        - otherwise
}

 function ippsIIRIIRGetStateSize64f_32f( order : Int32 ; var pBufferSize : Int32 ): IppStatus; _ippapi
 function ippsIIRIIRInit64f_32f( pState : IppsIIRState64f_32fPtrPtr ; pTaps : Ipp64fPtr ; order : Int32 ; pDlyLine : Ipp64fPtr ; pBuf : Ipp8uPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  IIRIIR Filtering
{ ----------------------------------------------------------------------------


  Names:         ippsIIRIIR
  Purpose:       performs zero-phase digital IIR filtering by processing 
   the input vector in both the forward and reverse directions. After filtering
   the data in the forward direction,  IIRIIR runs the filtered sequence in the
   reverse (flipped) order back through the filter. The result has the following 
   characteristics:
       - Zero-phase distortion
       - A filter transfer function is equal to the squared magnitude of the 
         original IIR transfer function
       - A filter order that is double the specified IIR order
  Parameters:
      pState              - pointer to filter context
      pSrcDst             - pointer to input/output vector in in-place ops
      pSrc                - pointer to input vector
      pDst                - pointer to output vector
      len                 - length of the vectors
  Return:
      ippStsContextMatchErr  - wrong context identifier
      ippStsNullPtrErr       - pointer(s) to the data is NULL
      ippStsLengthErr        - length of the vectors < 3*(IIR order)
      ippStsNoErr            - otherwise
}

 function ippsIIRIIR64f_32f( pSrc : Ipp32fPtr ; pDst : Ipp32fPtr ; len : Int32 ; pState : IppsIIRState64f_32fPtr ): IppStatus; _ippapi
 function ippsIIRIIR64f_32f_I( pSrcDst : Ipp32fPtr ; len : Int32 ; pState : IppsIIRState64f_32fPtr ): IppStatus; _ippapi

{ ----------------------------------------------------------------------------

  IIRIIR - Work with Delay Line
{ ----------------------------------------------------------------------------


  Names:      ippsIIRIIRGetDlyLine, ippsIIRIIRSetDlyLine
  Purpose:    set or get delay line
  Parameters:
      pState              - pointer to IIR filter context
      pDlyLine            - pointer where from load or where to store delay line
  Return:
      ippStsContextMatchErr  - wrong context identifier
      ippStsNullPtrErr       - pointer(s) pState or pDelay is NULL
                               if IIRIIRSet is called with pDlyLine==NULL then 
                               the function forms delay line itself that minimizes 
                               start-up and ending transients by matching initial
                               conditions to remove DC offset at beginning 
                               and end of input vector.
      ippStsNoErr            - otherwise
}

 function ippsIIRIIRGetDlyLine64f_32f( pState : IppsIIRState64f_32fPtr ; pDlyLine : Ipp64fPtr ): IppStatus; _ippapi
 function ippsIIRIIRSetDlyLine64f_32f( pState : IppsIIRState64f_32fPtr ; const pDlyLine : Ipp64fPtr ): IppStatus; _ippapi


{
               Intel(R) Integrated Performance Primitives
               Vector Math (ippVM)
}

{ ----------------------------------------------------------------------------

                   Functions declarations

{ ----------------------------------------------------------------------------

  Name:       ippvmGetLibVersion
  Purpose:    getting of the library version
  Returns:    the structure of information about version
              of ippVM library
  Parameters:

  Notes:      not necessary to release the returned structure
}

 function ippvmGetLibVersion: IppLibraryVersionPtr; _ippapi


 function ippsAbs_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAbs_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAdd_32f_A24( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAdd_64f_A53( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsSub_32f_A24( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSub_64f_A53( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsMul_32f_A24( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsMul_64f_A53( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsInv_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInv_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInv_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInv_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInv_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInv_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsDiv_32f_A11( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsDiv_32f_A21( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsDiv_32f_A24( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsDiv_64f_A26( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsDiv_64f_A50( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsDiv_64f_A53( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsSqrt_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSqrt_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSqrt_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSqrt_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSqrt_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSqrt_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsInvSqrt_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInvSqrt_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInvSqrt_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInvSqrt_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInvSqrt_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInvSqrt_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsCbrt_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCbrt_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCbrt_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCbrt_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCbrt_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCbrt_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsInvCbrt_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInvCbrt_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInvCbrt_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInvCbrt_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInvCbrt_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsInvCbrt_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsPow_32f_A11( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow_32f_A21( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow_32f_A24( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow_64f_A26( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow_64f_A50( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow_64f_A53( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsPow2o3_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow2o3_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow2o3_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow2o3_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow2o3_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow2o3_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsPow3o2_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow3o2_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow3o2_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow3o2_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow3o2_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow3o2_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsSqr_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSqr_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsPowx_32f_A11( a : Ipp32fPtr ; const b : Ipp32f ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPowx_32f_A21( a : Ipp32fPtr ; const b : Ipp32f ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPowx_32f_A24( a : Ipp32fPtr ; const b : Ipp32f ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPowx_64f_A26( a : Ipp64fPtr ; const b : Ipp64f ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPowx_64f_A50( a : Ipp64fPtr ; const b : Ipp64f ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPowx_64f_A53( a : Ipp64fPtr ; const b : Ipp64f ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsExp_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExp_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExp_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExp_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExp_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExp_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsExpm1_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExpm1_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExpm1_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExpm1_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExpm1_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExpm1_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsLn_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLn_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLn_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLn_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLn_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLn_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsLog10_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog10_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog10_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog10_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog10_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog10_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsLog1p_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog1p_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog1p_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog1p_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog1p_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog1p_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsCos_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCos_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCos_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCos_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCos_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCos_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsSin_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSin_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSin_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSin_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSin_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSin_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsSinCos_32f_A11( a : Ipp32fPtr ; r1 : Ipp32fPtr ;r2 : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinCos_32f_A21( a : Ipp32fPtr ; r1 : Ipp32fPtr ;r2 : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinCos_32f_A24( a : Ipp32fPtr ; r1 : Ipp32fPtr ;r2 : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinCos_64f_A26( a : Ipp64fPtr ; r1 : Ipp64fPtr ;r2 : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinCos_64f_A50( a : Ipp64fPtr ; r1 : Ipp64fPtr ;r2 : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinCos_64f_A53( a : Ipp64fPtr ; r1 : Ipp64fPtr ;r2 : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsTan_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTan_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTan_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTan_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTan_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTan_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAcos_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcos_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcos_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcos_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcos_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcos_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAsin_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsin_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsin_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsin_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsin_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsin_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAtan_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAtan2_32f_A11( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan2_32f_A21( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan2_32f_A24( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan2_64f_A26( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan2_64f_A50( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan2_64f_A53( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsCosh_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCosh_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCosh_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCosh_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCosh_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCosh_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsSinh_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinh_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinh_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinh_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinh_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinh_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsTanh_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTanh_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTanh_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTanh_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTanh_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTanh_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAcosh_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcosh_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcosh_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcosh_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcosh_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcosh_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAsinh_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsinh_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsinh_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsinh_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsinh_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsinh_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAtanh_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtanh_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtanh_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtanh_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtanh_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtanh_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsErf_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErf_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErf_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErf_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErf_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErf_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsErfInv_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfInv_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfInv_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfInv_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfInv_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfInv_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsErfc_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfc_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfc_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfc_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfc_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfc_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsErfcInv_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfcInv_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfcInv_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfcInv_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfcInv_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsErfcInv_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsCdfNorm_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCdfNorm_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCdfNorm_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCdfNorm_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCdfNorm_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCdfNorm_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsCdfNormInv_32f_A11( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCdfNormInv_32f_A21( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCdfNormInv_32f_A24( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCdfNormInv_64f_A26( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCdfNormInv_64f_A50( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCdfNormInv_64f_A53( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsHypot_32f_A11( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsHypot_32f_A21( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsHypot_32f_A24( a : Ipp32fPtr ; b : Ipp32fPtr ;r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsHypot_64f_A26( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsHypot_64f_A50( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsHypot_64f_A53( a : Ipp64fPtr ; b : Ipp64fPtr ;r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi



 function ippsAbs_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAbs_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAbs_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAbs_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAbs_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAbs_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsArg_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsArg_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsArg_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsArg_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsArg_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsArg_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAdd_32fc_A24( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAdd_64fc_A53( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsSub_32fc_A24( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSub_64fc_A53( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsMul_32fc_A11( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsMul_32fc_A21( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsMul_32fc_A24( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsMul_64fc_A26( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsMul_64fc_A50( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsMul_64fc_A53( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsDiv_32fc_A11( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsDiv_32fc_A21( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsDiv_32fc_A24( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsDiv_64fc_A26( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsDiv_64fc_A50( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsDiv_64fc_A53( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsCIS_32fc_A11( a : Ipp32fPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCIS_32fc_A21( a : Ipp32fPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCIS_32fc_A24( a : Ipp32fPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCIS_64fc_A26( a : Ipp64fPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCIS_64fc_A50( a : Ipp64fPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCIS_64fc_A53( a : Ipp64fPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsConj_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsConj_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsMulByConj_32fc_A11( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsMulByConj_32fc_A21( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsMulByConj_32fc_A24( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsMulByConj_64fc_A26( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsMulByConj_64fc_A50( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsMulByConj_64fc_A53( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsCos_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCos_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCos_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCos_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCos_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCos_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsSin_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSin_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSin_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSin_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSin_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSin_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsTan_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTan_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTan_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTan_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTan_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTan_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsCosh_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCosh_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCosh_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCosh_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCosh_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCosh_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsSinh_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinh_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinh_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinh_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinh_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSinh_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsTanh_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTanh_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTanh_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTanh_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTanh_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTanh_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAcos_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcos_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcos_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcos_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcos_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcos_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAsin_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsin_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsin_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsin_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsin_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsin_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAtan_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtan_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAcosh_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcosh_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcosh_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcosh_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcosh_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAcosh_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAsinh_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsinh_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsinh_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsinh_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsinh_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAsinh_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsAtanh_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtanh_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtanh_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtanh_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtanh_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsAtanh_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsExp_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExp_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExp_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExp_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExp_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsExp_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsLn_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLn_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLn_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLn_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLn_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLn_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsLog10_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog10_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog10_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog10_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog10_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsLog10_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsSqrt_32fc_A11( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSqrt_32fc_A21( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSqrt_32fc_A24( a : Ipp32fcPtr ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSqrt_64fc_A26( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSqrt_64fc_A50( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsSqrt_64fc_A53( a : Ipp64fcPtr ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsPow_32fc_A11( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow_32fc_A21( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow_32fc_A24( a : Ipp32fcPtr ; b : Ipp32fcPtr ;r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow_64fc_A26( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow_64fc_A50( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPow_64fc_A53( a : Ipp64fcPtr ; b : Ipp64fcPtr ;r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsPowx_32fc_A11( a : Ipp32fcPtr ; const b : Ipp32fc ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPowx_32fc_A21( a : Ipp32fcPtr ; const b : Ipp32fc ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPowx_32fc_A24( a : Ipp32fcPtr ; const b : Ipp32fc ; r : Ipp32fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPowx_64fc_A26( a : Ipp64fcPtr ; const b : Ipp64fc ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPowx_64fc_A50( a : Ipp64fcPtr ; const b : Ipp64fc ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsPowx_64fc_A53( a : Ipp64fcPtr ; const b : Ipp64fc ; r : Ipp64fcPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsFloor_32f( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsFloor_64f( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsCeil_32f( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsCeil_64f( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsTrunc_32f( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsTrunc_64f( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsRound_32f( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsRound_64f( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsRint_32f( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsRint_64f( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsNearbyInt_32f( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsNearbyInt_64f( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsModf_32f( a : Ipp32fPtr ; r1 : Ipp32fPtr ;r2 : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsModf_64f( a : Ipp64fPtr ; r1 : Ipp64fPtr ;r2 : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi

 function ippsFrac_32f( a : Ipp32fPtr ; r : Ipp32fPtr ; n : Ipp32s ): IppStatus; _ippapi
 function ippsFrac_64f( a : Ipp64fPtr ; r : Ipp64fPtr ; n : Ipp32s ): IppStatus; _ippapi


{ AvO, deprecated or removed (incomplete) }

 function ippiRGBToYCbCr_JPEG_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize ): IppStatus; _ippapi
 function ippiRGBToYCbCr_JPEG_8u_C3P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize): IppStatus; _ippapi
 function ippiRGBToYCbCr_JPEG_8u_C4P3R( pSrc : Ipp8uPtr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize): IppStatus; _ippapi

 function ippiYCbCrToRGB_JPEG_8u_P3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8u_3Ptr ; dstStep : Int32 ; roiSize : IppiSize): IppStatus; _ippapi
 function ippiYCbCrToRGB_JPEG_8u_P3C3R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize): IppStatus; _ippapi
 function ippiYCbCrToRGB_JPEG_8u_P3C4R( pSrc : Ipp8u_3Ptr ; srcStep : Int32 ; pDst : Ipp8uPtr ; dstStep : Int32 ; roiSize : IppiSize ; aval : Ipp8u ): IppStatus; _ippapi

end.
