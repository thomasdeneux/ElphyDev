Hpage JDBC; { JDBC }
{$P
 JDBC signifie Java Data Base Connectivity
 C'est une API qui permet aux programmes JAVA d'accéder à toutes sortes de bases de données
à condition de disposer des bons drivers
 Ce système a été implémenté pour Delphi sous la forme d'une librairie appelée ZeosLib et
nous avons utilisé Zeoslib pour implémenter JDBC dans Elphy.

 Nous avons essayé de suivre au plus près la syntaxe originale pour faire en sorte que l'abondante
littérature disponible sur le web puisse servir de documentation pour l'accès aux bases de données via Elphy

 Actuellement, Elphy gère l'accès à un seul type de serveur (postgresql) mais il serait facile de mettre en
place l'accès à d'autres types de serveurs.


}

Object
  TDBconnection (Tobject)
{$H Objet permettant la gestion d'une base de données.

  La base proprement dite, qu'elle soit locale ou distante, doit être créée en dehors de Elphy.
  TDBconnection permet d'établir la connection avec cette base ( voir create@ ) , d'ajouter ou modifier des données
ou de consulter ces données.

}

  TDBUnic (Tobject)
{$H Objet permettant d'accéder à la base de données.

}

  TDBModel (Tobject)
{$H Objet permettant d'accéder aux propriétés d'une table de la base de données.

}

  TDBQuerySet (Tobject)
{$H Objet représentant une liste de TDBObject@.

}

  TDBManager (Tobject)
{$H Objet représentant une entité responsable de l'insertion et de la recherche d'enregistrement dans la base de données.

}

  TDBresultset(Tobject)
{$H Objet contenant le résultat d'une requête SQL

 On considère que le résultat d'une requête SQL est un tableau de données auquel
on accède ligne par ligne.

 La méthode Next@ permet de sélectionner la ligne suivante du tableau. Juste après la requête,
aucune ligne n'est sélectionnée, il faut appeler Next pour sélectionner la première ligne.

}
  TDBconnectionMetadata (Tobject)
  TDBstatement (Tobject)
  TDBPreparedStatement (TDBstatement)
  TDBCallableStatement (TDBPreparedStatement)
  TDBresultsetMetadata (Tobject)
  TDBBlob (Tobject)
  TDBNotification (Tobject)
  TDBSequence (Tobject)


  TDBObject (Tobject)
{$H Objet représentant une ligne d'une table de la base de données. Ajoute de nouvelles fonctionnalités a la classe TDBrecord@.

}

  TDBgrid(TDBgrid0)
{$H L'objet TDBgrid permet d'afficher les données contenues dans un objet TDBresultset@

  Le constructeur create@ contient un seul paramètre qui est l'objet TDBresultset que l'on veut visualiser.

  Il suffit ensuite d'appeler la méthode show@ pour voir la grille dans une fenêtre.
  On peut aussi ranger cette fenêtre dans un cadre de Tmultigraph@ au moyen de (Tmultigraph.AddObjectEx)@(Tmultigraph.AddObjectEx)

  Les propriétés de la grille peuvent être modifiées: largeur et hauteur des colonnes (DefaultColWidth@, DefaultRowHeight@ ,ColWidths@ ),
jeu de caractères utilisé (font@) , couleurs ( color@, FixedColor@ ), Visibilité des noms de colonnes et de rangées ( FirstColVisible@,
FirstRowVisible@ ).

  Le gestionnaire d'événements OnSelectCell@ permet de réagir à la sélection d'une cellule.
  Le gestionnaire d'événements OnDblClick@ permet de réagir au double clic sur une cellule.

  Les colonnes et les lignes sont numérotées en commençant à la valeur zéro.

  La colonne 0 contient les numéros de lignes
  La rangée 0 contient les noms des colonnes.

  En modifiant FirstColVisible@ et FirstRowVisible@, on peut masquer la colonne 0 et la ligne 0 mais cela ne change pas la numérotation.

}

end;

  Const
        {$T types SQL }

{$H Constantes utilisées par TDBconnection@
}
  sql_Unknown=        0;
  sql_Boolean=        1;
  sql_Shortint=       2;
  sql_Smallint=       3;
  sql_Integer=        4;
  sql_Long=           5;
  sql_Single=         6;
  sql_Double=         7;
  sql_BigDecimal=     8;
  sql_String=         9;
  sql_UnicodeString= 10;
  sql_Bytes=         11;
  sql_Date=          12;
  sql_Time=          13;
  sql_Timestamp=     14;
  sql_AsciiStream=   15;
  sql_UnicodeStream= 16;
  sql_BinaryStream=  17;


procedure DBgetSupportedProtocols(var memo:TMemo);

procedure TDBconnection.create(protocol,host:string;port:integer;base,user,password:string);
{$H Constructeur de l'objet TDBconnection@

 La méthode établit la connection avec le serveur. Une erreur est générée si cela est impossible.

 Protocol est le nom du protocol utilisé. Par défaut, si on laisse la chaîne vide, c'est le protocole posgresql-8
qui est utilisé.
 Un grand nombre de protocoles sont disponibles dans la bibliothèque Zeos mais actuellement, seul postgresql-8
a été testé.

 Host est le nom de la machine serveur. Par défaut, si la chaîne host est laissée vide, sa valeur est 'localhost'.

 Port est le numéro du port utilisé.

 Base est le nom de la base de données
 User est le nom d'utilisateur
 Password est le mot de passe
}


procedure TDBconnection.CreateStatement(var ss: TDBstatement);
procedure TDBconnection.PrepareStatement(SQL: string;var  ss:TDBPreparedStatement);
procedure TDBconnection.PrepareCall(SQL: string;var ss: TDBCallableStatement);

procedure TDBconnection.CreateStatementWithParams(var Info: Tmemo;var ss:TDBstatement);
procedure TDBconnection.PrepareStatementWithParams(SQL: string; var Info: Tmemo;var ss:TDBPreparedStatement);
procedure TDBconnection.PrepareCallWithParams(SQL: string; var Info: Tmemo;var ss:TDBCallableStatement);

function TDBconnection.NativeSQL(SQL: string): string;

property TDBconnection.AutoCommit: Boolean;


property TDBconnection.Metadata: TDBconnectionMetadata readonly;
property TDBconnection.IsReadOnly: Boolean;

property TDBconnection.Catalog: string;

property TDBconnection.TransactionIsolation:integer;

procedure TDBconnection.commit;
procedure TDBconnection.rollback;


procedure TDBconnection.insertDBrecord(tableName:string;var db:TdbRecord);
{$H Ajoute un nouvel enregistrement dans la table de nom tableName.

 Les données introduites sont contenues dans un objet de type TDBrecord@.
}


{**** TDBModel ****}

procedure TDBModel.Create(table:String);
{$H Crée un objet de type TDBModel@ à partir d'une table de la base de données.

}

function TDBModel.hasKey(key:String):Boolean;
{$H Indique si la chaîne 'key' fait bien partie des champs du modèle.

}

function TDBModel.isPKey(key:String):Boolean;
{$H Indique si la chaîne 'key' fait bien partie des champs constituant la clef primaire du modèle.

}

function TDBModel.isFKey(key:String):Boolean;
{$H Indique si la chaîne 'key' fait bien partie de l'ensemble des clefs étrangères du modèle.

}

function TDBModel.nPKeys:Integer;
{$H Renvoie le nombre de champs constituant la clef primaire du modèle.

}

function TDBModel.nFKeys:Integer;
{$H Renvoie le nombre de clefs étrangères du modèle.

}

function TDBModel.getTable:String;
{$H Renvoie le nom de la table de la base de données relative au modèle.

}

function TDBModel.getConstraint(key:String):String;
{$H Renvoie le type de contrainte du champ 'key' du modèle.

}

function TDBModel.getType(key:String):String;
{$H Renvoie le type du champ 'key' du modèle.

}

procedure TDBModel.getFields(var memo:TMemo);
{$H Stocke dans un object TMemo@ les champs constituant le modèle.

}

procedure TDBModel.getPKeys(var memo:TMemo);
{$H Stocke dans un TMemo@ les champs constituant les clefs primaires du modèle.

}

procedure TDBModel.getFKeys(var memo:TMemo);
{$H Stocke dans un TMemo@ les champs correspondant aux clefs étrangères du modèle.

}

procedure TDBModel.getLookup(key:String;var memo:TMemo);
{$H Stocke dans un TMemo@ la combinaison des tables et champs référencés à partir de la clef étrangère 'key' du modèle.

}

{**** TDBQuerySet ****}

procedure TDBQuerySet.Create;
{$H Crée un objet de type TDBQuerySet@ qui stocke une liste de TDBObject@.

  NB : En pratique il n'y a pas besoin d'utiliser cette fonction puisque c'est un TDBManager@ qui génère automatiquement ce type d'objet.

}

procedure TDBQuerySet.remove;
{$H Retire à la fois les objets contenus dans un TDBQuerySet@ et leur alter ego dans la base de données.

}

procedure TDBQuerySet.getObject(index:Integer;var dbobject:TDBObject);
{$H Sélectionne l'objet d'indice 'index' situé dans un TDBQuerySet@.

}

procedure TDBQuerySet.getResultSet(var resultset:TDBResultSet);
{$H Convertit la liste d'objets contenus dans le TDBQuerySet@ en un TDBResultSet@.

}

procedure TDBQuerySet.clear;
{$H Efface le contenu d'un objet TDBQuerySet@ sans affecter la base de données.

}

function TDBQuerySet.countObjects:Integer;
{$H Renvoie le nombre d'objets contenu dans un objet TDBQuerySet@.

}

{**** TDBManager ****}

procedure TDBManager.Create(var model:TDBModel);
{$H Crée un objet de type TDBManager@ responsable de l'insertion et de la recherche d'objets de type TDBObject à partir du TDBModel@ 'model'.

}

procedure TDBManager.get(where:String;var dbobject:TDBObject);
{$H Renvoie un TDBObject@ correspondant à la condition SQL 'where'.

}

procedure TDBManager.all(order:String;var qset:TDBQuerySet);
{$H Renvoie la liste de tous les TDBObject@ classés suivant l'ordre défini par 'order'.

}

procedure TDBManager.filter(where,order:String;var qset:TDBQuerySet);
{$H Renvoie la liste de tous les TDBObject@ correspondant à la condition SQL 'where' classés suivant l'ordre défini par 'order'.

}

procedure TDBManager.search(join,where,order:String;var qset:TDBQuerySet);
{$H Renvoie la liste de tous les TDBObject@ correspondant à la jointure 'join' et la condition SQL 'where' et classés suivant l'ordre défini par 'order'.

}

procedure TDBManager.insert(var dbobject:TDBObject;commit:Boolean);
{$H Insère un TDBObject@ dans la base de données.

}



{************************************************** TDBstatement *****************************}

procedure TDBstatement.ExecuteQuery(SQL: string;var ss:TDBresultset);
procedure TDBstatement.ExecuteQuery(var SQL: Tmemo;var ss:TDBresultset);
{$H Envoie une commande SQL renvoyant un résultat.

 L'argument peut être soit une chaîne, soit un objet Tmemo@.

 Les résultats sont dans l'objet ss de type TDBresultset@
}

function TDBstatement.ExecuteUpdate(SQL: string): Integer;
function TDBstatement.ExecuteUpdate(var SQL:Tmemo): Integer;
{$H Envoie une commande SQL ne renvoyant pas de résultat.

 L'argument peut être soit une chaîne, soit un objet Tmemo@.
}

property TDBstatement.FetchDirection:integer;
property TDBstatement.FetchSize: Integer;
property TDBstatement.ResultSetConcurrency:integer;
property TDBstatement.ResultSetType:integer;
property TDBstatement.PostUpdates:integer;
property TDBstatement.LocateUpdates:integer;


procedure TDBstatement.Close;

{*************************************************** TDBPreparedStatement *********************}

procedure TDBPreparedStatement.ExecuteQueryPrepared(var ss: TDBresultset);
function TDBPreparedStatement.ExecuteUpdatePrepared: Integer;
function TDBPreparedStatement.ExecutePrepared: Boolean;

procedure TDBPreparedStatement.SetDefaultValue(ParameterIndex: Integer; Value: string);

procedure TDBPreparedStatement.SetNull(ParameterIndex: Integer; SQLType: integer);
procedure TDBPreparedStatement.SetBoolean(ParameterIndex: Integer; Value: Boolean);
procedure TDBPreparedStatement.setShortint(ParameterIndex: Integer; Value: ShortInt);
procedure TDBPreparedStatement.setSmallint(ParameterIndex: Integer; Value: SmallInt);
procedure TDBPreparedStatement.SetInteger(ParameterIndex: Integer; Value: Integer);
procedure TDBPreparedStatement.SetSingle(ParameterIndex: Integer; Value: Single);
procedure TDBPreparedStatement.SetDouble(ParameterIndex: Integer; Value: Double);
procedure TDBPreparedStatement.SetString(ParameterIndex: Integer; Value: string);

procedure TDBPreparedStatement.SetElphyObject(ParameterIndex: Integer; var obj:Tobject);

procedure TDBPreparedStatement.ClearParameters;

{**************************************** Callable SQL statement ****************}

procedure TDBCallableStatement.RegisterOutParameter(ParameterIndex: Integer; SQLType: Integer);
function TDBCallableStatement.WasNull: Boolean;

function TDBCallableStatement.IsNull(ParameterIndex: Integer): Boolean;
function TDBCallableStatement.GetString(ParameterIndex: Integer): string;
function TDBCallableStatement.GetBoolean(ParameterIndex: Integer): Boolean;
function TDBCallableStatement.GetShortint(ParameterIndex: Integer): ShortInt;
function TDBCallableStatement.GetSmallint(ParameterIndex: Integer): SmallInt;
function TDBCallableStatement.GetInteger(ParameterIndex: Integer): Integer;
function TDBCallableStatement.GetSingle(ParameterIndex: Integer): Single;
function TDBCallableStatement.GetDouble(ParameterIndex: Integer): Double;



{***************************************** TDBresultset ***************************}

procedure TDBResultSet.Create;
function TDBresultset.Next: Boolean;
procedure TDBresultset.Close;
function TDBresultset.WasNull: Boolean;

function TDBresultset.IsNull(ColumnIndex: Integer): Boolean;
function TDBresultset.IsNull(ColumnName: string): Boolean;

function TDBresultset.GetString(ColumnIndex: Integer): string;
function TDBresultset.GetString(ColumnName: string): string;

function TDBresultset.GetBoolean(ColumnIndex: Integer): Boolean;
function TDBresultset.GetBoolean(ColumnName: string): Boolean;

function TDBresultset.GetShortint(ColumnIndex: Integer): ShortInt;
function TDBresultset.GetShortint(ColumnName: string): ShortInt;

function TDBresultset.GetSmallint(ColumnIndex: Integer): SmallInt;
function TDBresultset.GetSmallint(ColumnName: string): SmallInt;

function TDBresultset.GetInteger(ColumnIndex: Integer): Integer;
function TDBresultset.GetInteger(ColumnName: string): Integer;

function TDBresultset.GetSingle(ColumnIndex: Integer): Single;
function TDBresultset.GetSingle(ColumnName: string): Single;

function TDBresultset.GetDouble(ColumnIndex: Integer): Double;
function TDBresultset.GetDouble(ColumnName: string): Double;

function TDBresultset.GetDateTime(ColumnIndex: Integer): TDateTime;
function TDBresultset.GetDateTime(ColumnName: string): TDateTime;

procedure TDBresultset.GetElphyObject(ColumnIndex: Integer; var obj:Tobject);
procedure TDBresultset.GetElphyObject(ColumnName:string; var obj:Tobject);

property TDBresultset.Metadata: TDBresultsetMetadata readonly;
function TDBresultset.FindColumn(ColumnName: string): Integer;

function TDBresultset.IsBeforeFirst: Boolean;
function TDBresultset.IsAfterLast: Boolean;
function TDBresultset.IsFirst: Boolean;
function TDBresultset.IsLast: Boolean;
procedure TDBresultset.BeforeFirst;
procedure TDBresultset.AfterLast;
function TDBresultset.First: Boolean;
function TDBresultset.Last: Boolean;
function TDBresultset.GetRow: Integer;
function TDBresultset.MoveAbsolute(Row: Integer): Boolean;
function TDBresultset.MoveRelative(Rows: Integer): Boolean;
function TDBresultset.Previous: Boolean;

function TDBresultset.RowUpdated: Boolean;
function TDBresultset.RowInserted: Boolean;
function TDBresultset.RowDeleted: Boolean;

procedure TDBresultset.UpdateNull(ColumnIndex: Integer);
procedure TDBresultset.UpdateNull(ColumnName: string);

procedure TDBresultset.UpdateBoolean(ColumnIndex: Integer; Value: Boolean);
procedure TDBresultset.UpdateBoolean(ColumnName: string; Value: Boolean);

procedure TDBresultset.UpdateShortint(ColumnIndex: Integer; Value: ShortInt);
procedure TDBresultset.UpdateShortint(ColumnName: string; Value: ShortInt);

procedure TDBresultset.UpdateSmallint(ColumnIndex: Integer; Value: SmallInt);
procedure TDBresultset.UpdateSmallint(ColumnName: string; Value: SmallInt);

procedure TDBresultset.UpdateInteger(ColumnIndex: Integer; Value: Integer);
procedure TDBresultset.UpdateInteger(ColumnName: string; Value: Integer);

procedure TDBresultset.UpdateSingle(ColumnIndex: Integer; Value: Single);
procedure TDBresultset.UpdateSingle(ColumnName: string; Value: Single);

procedure TDBresultset.UpdateDouble(ColumnIndex: Integer; Value: Double);
procedure TDBresultset.UpdateDouble(ColumnName: string; Value: Double);

procedure TDBresultset.UpdateDateTime(ColumnIndex: Integer; Value: TdateTime);
procedure TDBresultset.UpdateDateTime(ColumnName: string; Value: TdateTime);

procedure TDBresultset.UpdateString(ColumnIndex: Integer; Value: string);
procedure TDBresultset.UpdateString(ColumnName: string; Value: string);

procedure TDBresultset.UpdateElphyObject(ColumnIndex: Integer; var obj:Tobject);
procedure TDBresultset.UpdateElphyObject(ColumnName: string; var obj:Tobject);


procedure TDBresultset.InsertRow;
procedure TDBresultset.UpdateRow;
procedure TDBresultset.DeleteRow(num:integer);
procedure TDBresultset.RefreshRow;
procedure TDBresultset.CancelRowUpdates;
procedure TDBresultset.MoveToInsertRow;
procedure TDBresultset.MoveToCurrentRow;

procedure TDBresultset.show;

procedure TDBresultset.getDBrecord(var db:TDBrecord;num:integer);
procedure TDBresultset.setDBrecord(var db:TDBrecord;num:integer);
procedure TDBresultset.deleteDBrecord(num:integer);
procedure TDBresultset.insertDBrecord(var db:TDBrecord);
function TDBresultset.RowCount:integer;

property TDBresultset.keys: string;

{********************************************* ResultSet metadata *********************}

function TDBresultsetMetadata.GetColumnCount: Integer;
function TDBresultsetMetadata.IsAutoIncrement(Column: Integer): Boolean;
function TDBresultsetMetadata.IsCaseSensitive(Column: Integer): Boolean;
function TDBresultsetMetadata.IsSearchable(Column: Integer): Boolean;
function TDBresultsetMetadata.IsCurrency(Column: Integer): Boolean;
function TDBresultsetMetadata.IsNullable(Column: Integer): integer;

function TDBresultsetMetadata.IsSigned(Column: Integer): Boolean;
function TDBresultsetMetadata.GetColumnDisplaySize(Column: Integer): Integer;
function TDBresultsetMetadata.GetColumnLabel(Column: Integer): string;
function TDBresultsetMetadata.GetColumnName(Column: Integer): string;
function TDBresultsetMetadata.GetSchemaName(Column: Integer): string;
function TDBresultsetMetadata.GetPrecision(Column: Integer): Integer;
function TDBresultsetMetadata.GetScale(Column: Integer): Integer;
function TDBresultsetMetadata.GetTableName(Column: Integer): string;
function TDBresultsetMetadata.GetCatalogName(Column: Integer): string;
function TDBresultsetMetadata.GetColumnType(Column: Integer): integer;
function TDBresultsetMetadata.GetColumnTypeName(Column: Integer): string;
function TDBresultsetMetadata.IsReadOnly(Column: Integer): Boolean;
function TDBresultsetMetadata.IsWritable(Column: Integer): Boolean;
function TDBresultsetMetadata.IsDefinitelyWritable(Column: Integer): Boolean;
function TDBresultsetMetadata.GetDefaultValue(Column: Integer): string;



{********************************************** TDBGrid **********************************}

procedure TDBgrid.create(src:TDBresultSet);
{$H Constructeur de TDBgrid

 src est l'objet TDBresultSet qui sera visualisé dans la grille.
}


{***************************************  Compléments à Tdialog  **************************}

procedure Tdialog.setDBresultSet(var Rset:TDBresultSet);
{$H Associe l'objet Rset au dialogue.

  Il sera possible ensuite d'éditer certains champs de Rset dans le dialogue.
  La valeur éditée correspondra à la ligne de numéro DBcurrentRow@ .

  Voir getDBinteger@, getDBreal@, getDBstring@, getDBdateTime@, getDBboolean@.
}
property Tdialog.DBcurrentRow:integer;
{$H Numéro de la ligne courante dans le resultset associé.

 Les valeurs correspondant à cette ligne apparaissent dans le dialogue.

}

procedure Tdialog.DBsetValues(var db: TDBrecord);
{$H Range les valeurs contenues dans db dans les contrôles du dialogue.

  Si un nom de champ de db ne correspond pas à un nom de colonne du resultset associé ou bien
si le type du champ de db n'est pas compatible avec cette colonne, la valeur est ignorée

  Le resultset associé n'est pas affecté par cette opération
}
procedure Tdialog.DBgetValues(var db: TDBrecord);
{$H Range dans db les champs du dialogue correspondant aux colonnes du resultset associé.
}

procedure Tdialog.DBgetCheckedValues(var db: TDBrecord);
{$H Range dans db les champs du dialogue correspondant aux colonnes du resultset associé, à condition
que la checkbox située à côté du champ soit cochée.
}

function Tdialog.getDBInteger(title:String;n,FieldNum:integer):integer;
function Tdialog.getDBInteger(title:String;n,FieldNum,id:integer):integer;
function Tdialog.getDBInteger(title:String;n:integer;FieldName:string):integer;
function Tdialog.getDBInteger(title:String;n:integer;FieldName:string;id:integer):integer;
{$H Saisie d'une valeur entière correspondant à une colonne d'une table d'une base données.

 Il faut avoir associé auparavant le dialogue à un objet TDBresultset@ avec setResultset.

 La méthode fonctionne comme getInteger@ ou getIntegerA@ mais la donnée se trouve dans une table, plus précisément dans un objet
TDBresultset@ au lieu de se trouver dans une variable.
 La valeur courante correspond à la ligne DBcurrentRow@ dans le resultset.

 title est le titre apparaissant à côté du champ de saisie dans le dialogue
 n est approximativement la largeur du champ en nombre de caractères.
 On peut indiquer soit le numéro de colonne du resultset avec FieldNum, soit le nom de la colonne avec FieldName.

 id est nombre qui identifie le contrôle. Quand il est omis, la fonction renvoie automatiquement la valeur de l'identificateur.
 Cette valeur est utilisée par le gestionnaire d'événement s'il existe (voir OnEvent@ ).

}


function Tdialog.getDBReal(title:String;n,m,FieldNum:integer):integer;
function Tdialog.getDBReal(title:String;n,m,FieldNum,id:integer):integer;
function Tdialog.getDBReal(title:String;n,m:integer;FieldName:string):integer;
function Tdialog.getDBReal(title:String;n,m:integer;FieldName:string;id:integer):integer;
{$H Saisie d'une valeur réelle correspondant à une colonne d'une table d'une base données.

 Il faut avoir associé auparavant le dialogue à un objet TDBresultset@ avec setResultset.

 La méthode fonctionne comme getReal@ ou getRealA@ mais la donnée se trouve dans une table, plus précisément dans un objet
TDBresultset@ au lieu de se trouver dans une variable.
 La valeur courante correspond à la ligne DBcurrentRow@ dans le resultset.

 title est le titre apparaissant à côté du champ de saisie dans le dialogue
 n est approximativement la largeur du champ en nombre de caractères.
 m est le nombre de décimales.
 On peut indiquer soit le numéro de colonne du resultset avec FieldNum, soit le nom de la colonne avec FieldName.

 id est nombre qui identifie le contrôle. Quand il est omis, la fonction renvoie automatiquement la valeur de l'identificateur.
 Cette valeur est utilisée par le gestionnaire d'événement s'il existe (voir OnEvent@ ).

}

function Tdialog.getDBRealString(title,StSuffix:String;n,m,FieldNum:integer):integer;
function Tdialog.getDBRealString(title,StSuffix:String;n,m,FieldNum,id:integer):integer;
function Tdialog.getDBRealString(title,StSuffix:String;n,m:integer;FieldName:string):integer;
function Tdialog.getDBRealString(title,StSuffix:String;n,m:integer;FieldName:string;id:integer):integer;
{$H Saisie d'une valeur réelle stockée sous la forme d'une chaîne de caractères.

 La chaîne est rangée dans une colonne d'une table d'une base données.

 Il faut avoir associé auparavant le dialogue à un objet TDBresultset@ avec setResultset.

 La méthode fonctionne comme getDBReal@ ou getDBRealA@ mais la donnée est rangéee dans la table
sous la forme d'une chaîne de caractères. De plus, des unités apparaissent dans la chaîne après la valeur.
 On indique ces unités dans la chaîne stSuffix. Par exemple, si la valeur saisie est 0.55 et si stSuffix vaut " ms".
La chaîne stockée sera "0.55 ms"

 title est le titre apparaissant à côté du champ de saisie dans le dialogue
 stSuffix est la chaîne ajoutée automatiquement après la valeur.
 n est approximativement la largeur du champ en nombre de caractères.
 m est le nombre de décimales.
 On peut indiquer soit le numéro de colonne du resultset avec FieldNum, soit le nom de la colonne avec FieldName.

 id est nombre qui identifie le contrôle. Quand il est omis, la fonction renvoie automatiquement la valeur de l'identificateur.
 Cette valeur est utilisée par le gestionnaire d'événement s'il existe (voir OnEvent@ ).
}


function Tdialog.getDBString(title:String;n,FieldNum:integer):integer;
function Tdialog.getDBString(title:String;n,FieldNum,id:integer):integer;
function Tdialog.getDBString(title:String;n:integer;FieldName:string):integer;
function Tdialog.getDBString(title:String;n:integer;FieldName:string;id:integer):integer;
{$H Saisie d'une chaîne de caractères correspondant à une colonne d'une table d'une base données.

 Il faut avoir associé auparavant le dialogue à un objet TDBresultset@ avec setResultset.

 La méthode fonctionne comme getString@ ou getStringA@ mais la donnée se trouve dans une table, plus précisément dans un objet
TDBresultset@ au lieu de se trouver dans une variable.
 La valeur courante correspond à la ligne DBcurrentRow@ dans le resultset.

 title est le titre apparaissant à côté du champ de saisie dans le dialogue
 n est approximativement la largeur du champ en nombre de caractères.
 On peut indiquer soit le numéro de colonne du resultset avec FieldNum, soit le nom de la colonne avec FieldName.

 id est nombre qui identifie le contrôle. Quand il est omis, la fonction renvoie automatiquement la valeur de l'identificateur.
 Cette valeur est utilisée par le gestionnaire d'événement s'il existe (voir OnEvent@ ).

}

function Tdialog.getDBBoolean(title:String;FieldNum:integer):integer;
function Tdialog.getDBBoolean(title:String;FieldNum,id:integer):integer;
function Tdialog.getDBBoolean(title:String;FieldName:string):integer;
function Tdialog.getDBBoolean(title:String;FieldName:string;id:integer):integer;
{$H Saisie d'un booléen correspondant à une colonne d'une table d'une base données.

 Il faut avoir associé auparavant le dialogue à un objet TDBresultset@ avec setResultset.

 La méthode fonctionne comme getBoolean@ ou getBooleanA@ mais la donnée se trouve dans une table, plus précisément dans un objet
TDBresultset@ au lieu de se trouver dans une variable.
 La valeur courante correspond à la ligne DBcurrentRow@ dans le resultset.

 title est le titre apparaissant à côté du champ de saisie dans le dialogue
 On peut indiquer soit le numéro de colonne du resultset avec FieldNum, soit le nom de la colonne avec FieldName.

 id est nombre qui identifie le contrôle. Quand il est omis, la fonction renvoie automatiquement la valeur de l'identificateur.
 Cette valeur est utilisée par le gestionnaire d'événement s'il existe (voir OnEvent@ ).

}


function Tdialog.getDBMemo(title:String;n,Nline,flags,FieldNum:integer):integer;
function Tdialog.getDBMemo(title:String;n,Nline,flags,FieldNum,id:integer):integer;
function Tdialog.getDBMemo(title:String;n,Nline,flags:integer;FieldName:string):integer;
function Tdialog.getDBMemo(title:String;n,Nline,flags:integer;FieldName:string;id:integer):integer;
{$H Saisie d'une chaîne de caractères correspondant à une colonne d'une table d'une base données.

 Il faut avoir associé auparavant le dialogue à un objet TDBresultset@ avec setResultset.

 La méthode fonctionne comme getMemo@ mais la donnée se trouve dans une table, plus précisément dans un objet
TDBresultset@ au lieu de se trouver dans une variable.
 La valeur courante correspond à la ligne DBcurrentRow@ dans le resultset.

 title est le titre apparaissant à côté du champ de saisie dans le dialogue
 n est approximativement la largeur du champ en nombre de caractères.
 Nline est approximativement la hauteur du champ en nombre de caractères.
 Flags n'est pas utilisé pour le moment.
 
 On peut indiquer soit le numéro de colonne du resultset avec FieldNum, soit le nom de la colonne avec FieldName.

 id est nombre qui identifie le contrôle. Quand il est omis, la fonction renvoie automatiquement la valeur de l'identificateur.
 Cette valeur est utilisée par le gestionnaire d'événement s'il existe (voir OnEvent@ ).

}



function Tdialog.getDBdateTime(mode: integer; title:String;n,FieldNum:integer):integer;
function Tdialog.getDBdateTime(mode: integer; title:String;n,FieldNum,id:integer):integer;
function Tdialog.getDBdateTime(mode: integer; title:String;n:integer;FieldName:string):integer;
function Tdialog.getDBdateTime(mode: integer; title:String;n:integer;FieldName:string;id:integer):integer;
{$H Saisie d'une valeur de type TdateTime@ correspondant à une colonne d'une table d'une base données.

 Il faut avoir associé auparavant le dialogue à un objet TDBresultset@ avec setResultset.

 La valeur courante correspond à la ligne DBcurrentRow@ dans le resultset.

 Mode peut prendre l'une des valeurs entières 1, 2 ou 3.
 Si mode=1, seule la date est saisie
 Si mode=2, seule l'heure est saisie
 Si mode=3, la date et l'heure sont saisies

 title est le titre apparaissant à côté du champ de saisie dans le dialogue
 n est approximativement la largeur du champ en nombre de caractères.
 On peut indiquer soit le numéro de colonne du resultset avec FieldNum, soit le nom de la colonne avec FieldName.

 Pour modifier la variable , l'utilisateur doit cliquer sur un bouton situé à la droite du
contrôle d'édition. Ce qui fait apparaitre un dialogue dans lequel la saisie est facilitée

 La modification directe dans le contrôle d'édition est interdite.

 Le format d'affichage est yyyy-mm-dd hh:mn:ss:mms

 yyyy est l'année
 mm le mois
 dd le jour

 hh l'heure
 mn le nombre de minutes
 dd le nombre de secondes
 mms le nombre de millisecondes

 La partie date ou la partie heure sont omises suivant le mode.

 id est nombre qui identifie le contrôle. Quand il est omis, la fonction renvoie automatiquement la valeur de l'identificateur.
 Cette valeur est utilisée par le gestionnaire d'événement s'il existe (voir OnEvent@ ).

}


function Tdialog.getDBStringList(title,names,values: string; Field: integer):integer;
function Tdialog.getDBStringList(title,names,values: string; Field, id: integer):integer;
function Tdialog.getDBStringList(title,names,values: string; FieldName:string):integer;
function Tdialog.getDBStringList(title,names,values: string; FieldName:string; id:integer):integer;
{$H Saisie d'une valeur entière prise dans une liste, et correspondant à une colonne d'une table d'une base données.

 Il faut avoir associé auparavant le dialogue à un objet TDBresultset@ avec setResultset.

 La méthode fonctionne comme getStringList@ mais la donnée se trouve dans une table, plus précisément dans un objet
TDBresultset@ au lieu de se trouver dans une variable.
 La valeur courante correspond à la ligne DBcurrentRow@ dans le resultset.

 title est le titre apparaissant à côté du champ de saisie dans le dialogue
 names est une chaîne de caractères contenant la liste d'options
 values est une chaîne de caractères contenant la liste des valeurs entières correspondantes.
 Les noms et les valeurs doivent être séparés par une barre verticale.

 Exemple:
 @f6                  names = 'Un | Deux | Trois'
 @f6                  values= '12 | 32 | 44'

 Il doit y avoir autant de noms que de valeurs.

 On peut indiquer soit le numéro de colonne du resultset avec FieldNum, soit le nom de la colonne avec FieldName.

 id est nombre qui identifie le contrôle. Quand il est omis, la fonction renvoie automatiquement la valeur de l'identificateur.
 Cette valeur est utilisée par le gestionnaire d'événement s'il existe (voir OnEvent@ ).

}


function Tdialog.getDBfield(nSt,n,m,FieldNum:integer):integer;
function Tdialog.getDBfield(nSt,n,m,FieldNum,id:integer):integer;
{$H Saisie d'une valeur de type quelconque correspondant à une colonne d'une table d'une base données.

 Il faut avoir associé auparavant le dialogue à un objet TDBresultset@ avec setResultset.

 La valeur courante correspond à la ligne DBcurrentRow@ dans le resultset.

 Pour les chaines de caractères, nSt  est approximativement la largeur du champ en nombre de caractères.
 Pour les nombres, n est approximativement la largeur du champ en nombre de caractères.
 Pour les nombres réels, m est le nombre de décimales.

 FieldNum est le numéro de colonne du resultset.

 id est nombre qui identifie le contrôle. Quand il est omis, la fonction renvoie automatiquement la valeur de l'identificateur.
 Cette valeur est utilisée par le gestionnaire d'événement s'il existe (voir OnEvent@ ).
}

{**** TDBObject ****}

procedure TDBObject.create;
{$H Crée un nouveau TDBObject@.

}

procedure TDBObject.save(commit:Boolean);
{$H Met à jour les propriétés de l'objet dans la base de données.

 - commit : indique si la base de données doit être automatiquement mise à jour

}

procedure TDBObject.remove(commit:Boolean);
{$H Efface le TDBObject de la base de données.

 - commit : indique si la base de données doit être automatiquement mise à jour
}


procedure TDBObject.AddField(st:string;tp:integer);
procedure TDBObject.DeleteField(st:string);
procedure TDBObject.clear;
function TDBObject.FieldExists(st:string):boolean;
property TDBObject.ImplicitValue(stName:string):variant implicit;
property TDBObject.count:integer readonly;
property TDBObject.Vtype(n:integer):integer readonly;
property TDBObject.Names(n:integer):string readonly;
property TDBObject.ValString(n:integer):string readonly;

{**** Shortcuts ****}
{**** For string manipulations ****}
procedure splitString(st,separator:String;var memo:TMemo);
procedure replaceString(source,target:String;var st:String);


function dbUnic:TDBUnic;
{$H Correspond à l'objet unique TDBUnic@ qui interagit avec le système de base de données.

}

procedure TDBUnic.initConnection(protocol,host:String;port:Integer;database,login,password:String);
{$H Connecte Elphy à la base de données :

 - protocol : protocole utilisé (par défaut utiliser '')
 - host : adresse IP du serveur (local:127.0.0.1)
 - port : port de communication du serveur (choisir par défaut 5432)
 - database : name of the database
 - login : identifiant de l'utilisateur
 - password : mot de passe

}

procedure TDBUnic.closeConnection;
{$H Déconnecte Elphy de la base de données

}

procedure TDBUnic.launchCommit;
{$H Force l'insertion des données dans la base.

}

{**** For Analysis Model Install and Uninstall ****}
procedure TDBUnic.installAnalysisModel;
{$H Installe le modèle utile au stockage des analyses.

}

procedure TDBUnic.uninstallAnalysisModel;
{$H Désinstalle le modèle utile au stockage des analyses.

}

procedure TDBUnic.getModels(var memo:TMemo);
{$H Stocke la liste des tables présentes dans la base de données.

}

{**** For Analysis Types Definition, Updates and deletion ****}
procedure TDBUnic.defineAnalysisType(id,usecase,path:String;commit:Boolean);
{$H Défini un nouveau type d'analyse dans la base de données :
 - id : identifiant de l'analyse
 - usecase : ce qu'est supposé faire le type d'analyse
 - path : la localisation du fichier contentna le programme qui réalise le type d'analyse
 - commit : indique si la base de données doit être automatiquement mise à jour
}

procedure TDBUnic.renameAnalysisType(old_id,new_id:String;commit:Boolean);
{$H Donne un nouvel identifiant 'new_id' à l'analyse nommée 'old_id' :
 - old_id : l'identifiant actuel du type d'analyse
 - new_id : le nouvel identifiant
 - commit : indique si la base de données doit être automatiquement mise à jour
}

procedure TDBUnic.relocateAnalysisType(id,new_path:String;commit:Boolean);
{$H Relocalise le type d'analyse :
 - id : l'identifiant du type d'analyse
 - new_path : le nouveau chemin du fichier contenant le programme d'analyse
 - commit : indique si la base de données doit être automatiquement mise à jour
}

procedure TDBUnic.explainAnalysisType(id,usecase:String;commit:Boolean);
{$H Redéfinit l'explication de l'analyse :
 - id : l'identifiant du type d'analyse
 - usecase : la nouvelle explication
 - commit : indique si la base de données doit être automatiquement mise à jour
}

procedure TDBUnic.removeAnalysisType(id:String;commit:Boolean);
{$H Efface un type d'analyse ainsi que toutes les entrées/sortie/analyses qui en sont dépendentes :
 - id : l'identifiant du type d'analyse
 - commit : indique si la base de données doit être automatiquement mise à jour
}

procedure TDBUnic.defineInputOutput(analysis_type,name,iotype,iocoding,usecase:String;commit:Boolean);
{$H Définit une nouvelle entrée/sortie pour un type d'analyse :
 - analysis_type : l'identifiant du type d'analyse
 - name : l'identifiant de l'entrée/sortie
 - usecase : le rôle de l'entrée/sortie
 - iotype : spécifie si on a affaire à une Entrées (Input) ou un sortie (Output)
 - iocoding : le type de codage correspondant à l'entrée/sortie choisi parmi [str,int,bool,float,file]
 - commit : indique si la base de données doit être automatiquement mise à jour
}

procedure TDBUnic.removeInputOutput(analysis_type,name:String;commit:Boolean);
{$H Efface une entrée/sortie et les valeurs qu'elle peut prendre dans un analyse

 - analysis_type : l'identifiant du type d'analyse
 - name : l'identifiant de l'entrée/sortie
 - commit : indique si la base de données doit être automatiquement mise à jour

}

procedure TDBUnic.renameInputOutput(analysis_type,old_name,new_name:String;commit:Boolean);
{$H Renomme une entrée/sortie :
 - analysis_type : l'identifiant du type d'analyse
 - old_name : ancien identifiant de l'entrée/sortie
 - new_path : nouvel identifiant de l'entrée/sortie
 - commit : indique si la base de données doit être automatiquement mise à jour
}

procedure TDBUnic.explainInputOutput(analysis_type,name,usecase:String;commit:Boolean);
{$H Redéfinit le rôle de l'entrée/sortie dans un type d'analyse :
 - analysis_type : l'identifiant du type d'analyse
 - name : l'identifiant de l'entrée/sortie
 - usecase : le nouveau rôle de l'entrée/sortie
 - commit : indique si la base de données doit être automatiquement mise à jour
}

procedure TDBUnic.storeAnalysis(var analysis_object:TDBObject;commit:Boolean);
{$H Stores a complete analysis :
 - analysis_object : le TDBObject@ qui contient tous les paramètres de l'analyse, il doit contenir ces champs :

  + id : l'identifiant de l'analyse
  + component : le nom du type d'analyse relatif à cette nouvelle analyse
  + si in1 ... inN and out1 ... outM correspondent à  des noms d'entrées/sorties d'un type d'analyse, le TDBObject@ doit contenir des champs qui portent le même nom

  Un champ nommé 'comments' peut être ajouté pour stocker un commentaire spécifique sur l'analyse

 - commit : indique si la base de données doit être automatiquement mise à jour
}

procedure TDBUnic.removeAnalysis(id:String;commit:Boolean);
{$H Efface une analyse :
 - id : l'identifiant de l'analyse
 - commit : indique si la base de données doit être automatiquement mise à jour
}

procedure TDBUnic.getAnalyses(analysis_type,condition,order:String;var resultset:TDBResultSet);
{$H Stocke la liste de toutes les analyses d'un type d'analyse 'analysis_type' donné respectant la condition 'condition' dans un TDBResultSet@ 'resultset'
 - id : l'identifiant du type d'analyse
 - condition : la clause SQL 'WHERE' qui permet de filtrer les analyses
 - order : ordre de tri
 - resultset : le TDBResultSet@ qui contiendra le résultat

 Example :

     getAnalyses('myAnalysisType', '"Input1" > 10 AND "Input1" < 20 AND "Output" > 100', 'Input1', resultset);

 NB :
     Sachant que 'condition' est du SQL, si les entrées/sorties contiennent des majuscules, la condition doit être encadrée par des guillemets (").

}

procedure TDBUnic.getStatistics(var resultset:TDBResultSet);
{$H Calcule diverses statistiques sur l'ensemble des analyses contenues dans le TDBResultSet@ 'resultset'

 NB : As getStatistics needs the SQL script generated during getAnalyses, it is necessary to launch getAnalyses before getStatistics.

}

procedure TDBUnic.getAnalysesAsObjects(analysis_type,condition,order:String;var queryset:TDBQuerySet);
{$H Stockes toutes les analyses correspondant à un type d'analyse spécifique et respectant une condition spécifique sous forme de TDBQuerySet@
 - id : l'identifiant du type d'analyse
 - condition : la clause SQL 'WHERE' qui permet de filtrer les analyses
 - order : ordre de tri
 - queryset: la liste des TDBObject@ correspondant à la condition SQL

 Example :

     getAnalyses('myAnalysisType', '"Input1" > 10 AND "Input1" < 20 AND "Output" > 100', 'Input1', queryset);

 NB :
     Sachant que 'condition' est du SQL, si les entrées/sorties contiennent des majuscules, la condition doit être encadrée par des guillemets (").


}



Hpage DBUnic; {Bibliothèque d'accès à la base de données}

{$P
 Cette bibliothèque a été développée pour fournir aux utilisateurs d'Elphy une interface d'accès à la base de données où aucune connaissance préalable du langage SQL n'est requise.
}
{$P Quelques concepts de base concernant les bases de données :

 Une base de données permet de recueillir de manière cohérente et de restituer de manière efficace les données relatives aux divers états que peut prendre un système.
L'acquisition des données et leur récupération par un utilisateur ne peuvent être opérationnelles qu'à condition d'intégrer dans la base de données un modèle du système.
Ce dernier est constitué d'un ensemble d' 'entités' interdépendantes qui représentent les concepts clefs du système et qui permettent de diviser celui-ci en plusieurs sous-ensembles de 'paramètres' ou 'attributs' caractéristiques.
Chaque entité possède elle-même un état, directement lié à celui du système, qui définit l'ensemble des valeurs que peuvent prendre les paramètres de l'entité.
La combinaison de ces valeurs est plus communément appelée 'enregistrement'.
D'un point de vue implémentation, on utilisera les termes 'table' et 'champ' pour identifier respectivement 'entité' et 'paramètre'.

 L'interaction entre utilisateur et base de données se fait par le biais de 'commandes' ou 'requêtes' écrites en langage SQL.
Ces requêtes permettent d'insérer, d'extraire, de mettre à jour ou encore d'effacer des données.
}
{$P Descriptif général de la bibliothèque :

 C'est un ensemble de 5 classes (TDBModel@,TDBManager@,TDBObject@,TDBQuerySet@,TDBUnic@).
Il peut être scindé en deux sous-ensembles distincts : (TDBModel@, TDBManager@, TDBObject@, TDBQuerySet@) et (TDBUnic@).
Le premier propose une représentation des éléments clefs d'une base de données tels que les tables ou les enregistrements
et se charge de générer automatiquement les requêtes SQL d'insertion, d'extraction, de modification ou d'effacement des données en fonction des actions utilisateurs sur les instances
de ces classes quelque soit le modèle présent dans la base de données et d'encapsuler les résultats dans des objets manipulables sous Elphy.
Le second permet d'initialiser la connection avec la base de données et les détails bas niveaux de la bibliothèque
et possède un ensemble de fonctionnalités spécifiques au stockage de données relatives aux analyses.

 Un fichier 'analysisTools.PG2' est associé à la bibliothèque. Il contient :

 - une fonction qui permet de s'authentifier et d'activer l'accès à la base de données ('Login')
 - quelques exemples d'utilisation de la bibliothèque ('Test Analyses Storage', 'Analysis Test Suite')
 - des fonctions qui permettent d'activer le modèle lié aux analyses ('Install Analysis Model', 'Uninstall Analysis Model')
 - des fonctions qui activent l'interface de visualisation des analyses ('Analyses Visualizer')
 - un programme qui stocke les résultats d'analyse de la bistabilité de Nazied ('Bistability Analyses')
}
{$P Descriptif des classes TDBModel, TDBManager, TDBObject et TDBQuerySet :

 La classe TDBModel@ représente une table particulière de la base de données.
Elle permet d'extraire les propriétés générales d'une table et entre autres de déterminer :

 - quels sont les champs contenus dans une table ((TDBModel.getFields)@(TDBModel.getFields))
 - quel est le type associé à chaque champ ((TDBModel.getConstraint)@(TDBModel.getConstraint))
 - quels sont parmi ces champs ceux qui forment la clef primaire ((TDBModel.getPKeys)@(TDBModel.getPKeys))
 - quels sont ceux parmi ces champs qui sont des clefs étrangères ((TDBModel.getFKeys)@(TDBModel.getFKeys))
 - à quels champs ces clefs étrangères font elles référence ((TDBModel.getLookup)@(TDBModel.getLookup))

 NB : Associée à la fonction (TDBUnic.getModels)@(TDBUnic.getModels), il est possible d'avoir une vision globale du modèle intégré dans la base de données.

 Chaque table contient une liste d'enregistrements. Une requête SQL sur la base permet :

  - d'insérer un nouvel enregistrement dans la liste (INSERT)
  - de récupérer la liste complète ou filtrée des enregistrements (SELECT)
  - de mettre à jour une liste d'enregistrements (UPDATE)
  - d'effacer une liste d'enregistrements (DELETE)

 Les classes TDBObject@ et TDBQuerySet@ représentent respectivement un enregistrement et une liste d'enregistrements.
Un objet de type TDBQuerySet@ correspond alors à une liste d'objets TDBObject@. La classe TDBManager@ est responsable de l'insertion, de l'extraction et de l'effacement d'enregistrements.
L'utilisateur peut insérer un nouvel enregistrement dans la table ou bien y récupérer un ou plusieurs enregistrements via un TDBManager@.
L'insertion s'effectue par le biais de la fonction (TDBManager.insert)@(TDBManager.insert) à partir d'un TDBObject (cf Ex1).
La récupération se fait grâce aux fonctions suivantes :

 - (TDBManager.get)@(TDBManager.get) qui génère un TDBObject@ à partir d'une liste qui possède un enregistrement unique (cf Ex2)
 - (TDBManager.all)@(TDBManager.all) qui génère un TDBQuerySet@ à partir de la liste complète des enregistrements (cf Ex4)
 - (TDBManager.filter)@(TDBManager.filter) qui génère un TDBQuerySet@ à partir de la liste filtrée d'enregistrements qui respectent certains critères (cf Ex5)

 L'effacement d'un enregistrement ou d'une liste d'enregistrements est respectivement accompli par le biais des fonctions (TDBObject.remove)@(TDBObject.remove) (cf Ex3) et (TDBQuerySet.remove)@(TDBQuerySet.remove) (cf Ex4 et Ex5).

 La valeur des champs est accessible comme pour un TDBRecord@, par le biais de la propriété (TDBRecord.ImplicitValue)@(TDBRecord.ImplicitValue).
Pour mettre à jour un enregistrement, il suffit d'affecter de nouvelles valeurs aux paramètres contenus dans un TDBObject@ et d'utiliser la méthode (TDBObject.save)@(TDBObject.save) pour mettre à jour la base de données (cf Ex2).
}
{$P Descriptif de la classe TDBUnic :

 Comme signalé en introduction, cette classe se charge d'initialiser la connection entre Elphy et le système de base de données via la fonction (TDBUnic.initConnection)@(TDBUnic.initConnection).
En ce qui concerne le modèle relatif aux analyses, il peut être directement intégré à la base de données via la fonction (TDBUnic.installAnalysisModel)@(TDBUnic.installAnalysisModel).
De plus, la classe expose des fonctions de plus haut niveau que celles offertes par les classes précédemment décrites pour faciliter la vie de l'utilisateur.
Le modèle ne contient pas moins de 18 tables, par conséquent il n'est plus réaliste d'un point de vue utilisateur d'aborder une table en particulier, mais d'agir sur un ensemble de tables pour :

 - cacher à l'utilisateur la complexité du modèle
 - garantir son intégrité lors de diverses mises à jour
 - éviter certaines tâches répétitives liées à la navigation du programme dans le modèle.

 Pour stocker une analyse dans la base de données (cf Ex7), il est au préalable nécessaire, d'une part, de spécifier le type d'analyse sur lequel elle se base
et d'autre part dedéfinir quelles en sont les entrées-sorties (cf Ex6). Ensuite, il suffit de créer un nouveau TDBObject@ qui doit contenir obligatoirement les champs suivants :

  + id : l'identifiant de l'analyse
  + component : le nom du type d'analyse relatif à cette nouvelle analyse

 De plus, si in1 ... inN and out1 ... outM correspondent à  des noms d'entrées/sorties d'un type d'analyse, le TDBObject@ doit contenir des champs qui portent le même nom.
Un champ nommé 'comments' peut être éventuellement ajouté pour stocker un commentaire spécifique sur l'analyse. Au final, pour effectivement insérer l'analyse il faut utiliser la fonction (TDBUnic.storeAnalysis)@(TDBUnic.storeAnalysis).

 Pour retrouver une liste d'analyses correspondant à certains critères d'entrées-sorties, il suffit d'utiliser la fonction (TDBUnic.getAnalysesAsObjects)@(TDBUnic.getAnalysesAsObjects) qui génère un TDBQuerySet@.
Il suffit de faire une itération sur cette liste de TDBObject@ pour accéder aux paramètres de chaque analyse.

 NB: Sous Elphy n'existe qu'un seul représentant de la classe TDBUnic. Il est accessible globalement dans un script Elphy sous le nom de dbUnic.
}
{$P Descriptif de l'interface graphique fournie dans analysisTools.PG2:

 Après compilation, il suffit de sélectionner le programme 'Login' pour rendre effectif l'accès à la base.
Si le modèle relatif aux analyses n'est pas installé dans le système de base de données, il suffit de sélectionner le programme 'Install Analysis Model'.
Ensuite, il faut sélectionner le programme 'Analyses Visualizer'. Un nouvelle page est créée sous Elphy, celle-ci contient 4 cadres :

 - 1er cadre : Liste des types d'analyse avec possibilité d'ajouter un nouveau type, de modifier ou d'effacer un type existant
 - 2ème cadre : Liste des entrées-sorties relatives à un type d'analyse avec possibilité d'en ajouter une nouvelle ou d'en effacer une existance
 - 3ème cadre : Liste des analyses basées sur un type d'analyse spécifique avec possiblité d'en ajouter une nouvelle, d'en effacer une existance ou de filtrer cette liste par rapport à certain critères sur les valeurs d'entrées-sorties
 - 4ème cadre : Calcul du minimum, maximum, de la valeur moyenne, du médian et de l'écart type pour chaque paramètre de la liste d'analyses du 3ème cadre

 NB1 : L'aspect graphique est surtout prévu pour visualiser les analyses déjà intégrées dans la base de données.
On préférera créer de nouvelles analyses par le biais des fonctionnalités de la classe TDBUnic@ directement dans un programme (cf Ex 6 et 7).

 NB2 : Avant compilation, remplacer la valeur de la constante ROOT_FILES par le chemin du répertoire contenant les fichiers Elphy dont les noms pourraient être mis en entrée-sortie de type 'file' d'un type d'analyse.
Ainsi le programme sera capable d'ouvrir le fichier lorsque l'utilisateur clique sur le nom du fichier. 
}

{$P Notes sur les analyses de Bistabilité :

 Avant compilation, il faut remplacer la valeur de la constante ROOT_CSV par le chemin du répertoire où se situe les fichiers CSV fournis avec le programme.
Après compilation, il suffit de sélectionner le programme 'Bistability Analyses'.

}
{$P Exemples :

 Ex1 : Création d'un nouvel enregistrement, on suppose que la base de données possède une table helmholtz_experiment
et que le modèle de la table contient les champs ref, start_datetime et end_datetime

 @f6 var
 @f6     model:TDBModel;
 @f6     manager:TDBManager;
 @f6     dbobject:TDBObject;

 @f6 begin
 @f6     dbUnic.initConnection('', '127.0.0.1', 5432, 'helmholtz', 'login', 'password');
 @f6     model.Create('helmholtz_experiment');
 @f6     manager.Create(model);
 @f6     dbobject.Create;
 @f6     dbobject.ref := 'new_experiment';
 @f6     dbobject.start_datetime := '2009-01-01 10:00:00';
 @f6     dbobject.end_datetime := '2009-01-01 11:30:00';
 @f6     dbobject.notes := 'notes about the experiment';
 @f6     manager.insert(obj,False);
 @f6     dbUnic.launchCommit;
 @f6     dbUnic.closeConnection;
 @f6 end;

 Ex2: Recherche et modification d'un enregistrement unique

 @f6 var
 @f6     model:TDBModel;
 @f6     manager:TDBManager;
 @f6     dbobject:TDBObject;

 @f6 begin
 @f6     dbUnic.initConnection('', '127.0.0.1', 5432, 'helmholtz', 'login', 'password');
 @f6     model.Create('helmholtz_experiment');
 @f6     manager.Create(model);
 @f6     manager.get('ref=''experiment_1''', dbobject);
 @f6     dbobject.notes := 'new notes concerning new_experiment';
 @f6     dbobject.start_datetime := '2009-01-01 10:30:00';
 @f6     dbobject.end_datetime := '2009-01-01 12:30:00';
 @f6     dbobject.save(False);
 @f6     dbUnic.launchCommit;
 @f6     dbUnic.closeConnection;
 @f6 end;

 Ex3: Recherche et effacement d'un enregistrement unique

 @f6 var
 @f6     model:TDBModel;
 @f6     manager:TDBManager;
 @f6     dbobject:TDBObject;

 @f6 begin
 @f6     dbUnic.initConnection('', '127.0.0.1', 5432, 'helmholtz', 'login', 'password');
 @f6     model.Create('helmholtz_experiment');
 @f6     manager.Create(model);
 @f6     manager.get('ref=''experiment_1''', dbobject);
 @f6     dbobject.remove(False);
 @f6     dbUnic.launchCommit;
 @f6     dbUnic.closeConnection;
 @f6 end;

 Ex4: Balayer et effacer la liste de tous les enregistrements

 @f6 var
 @f6     model:TDBModel;
 @f6     manager:TDBManager;
 @f6     dbobject:TDBObject;
 @f6     dbobjects:TDBQuerySet;
 @f6     i:Integer;

 @f6 begin
 @f6     dbUnic.initConnection('', '127.0.0.1', 5432, 'helmholtz', 'login', 'password');
 @f6     model.Create('helmholtz_experiment');
 @f6     manager.Create(model);
 @f6     manager.all('ref', dbobjects);
 @f6     for i := 1 to dbobjects.countObjects do
 @f6         begin
 @f6             dbobjects.getObjects(i-1,dbobject);
 @f6             messageBox('ref:' + dbobject.ref);
 @f6         end;
 @f6     dbobjects.remove(False);
 @f6     dbUnic.launchCommit;
 @f6     dbUnic.closeConnection;
 @f6 end;

 Ex5: Balayer et effacer une liste filtrée  d'enregistrements

 @f6 var
 @f6     model:TDBModel;
 @f6     manager:TDBManager;
 @f6     dbobject:TDBObject;
 @f6     dbobjects:TDBQuerySet;
 @f6     i:Integer;

 @f6 begin
 @f6     dbUnic.initConnection('', '127.0.0.1', 5432, 'helmholtz', 'login', 'password');
 @f6     model.Create('helmholtz_experiment');
 @f6     manager.Create(model);
 @f6     manager.filter('ref LIKE ''experiment_%''','ref', dbobject);
 @f6     for i := 1 to dbobjects.countObjects do
 @f6         begin
 @f6             dbobjects.getObjects(i-1,dbobject);
 @f6             messageBox('ref:' + dbobject.ref);
 @f6         end;
 @f6     dbobjects.remove(False);
 @f6     dbUnic.launchCommit;
 @f6     dbUnic.closeConnection;
 @f6 end;

 Ex6 : Spécifier un nouveau type d'analyse

 @f6    begin
 @f6        dbUnic.initConnection('', '127.0.0.1', 5432, 'helmholtz', 'login', 'password');
 @f6        dbUnic.defineAnalysisType('analysis_type_1','comments concerning the analysis type','path/to/file.pg2',True);
 @f6        dbUnic.defineInputOutput('analysis_type_1','input_1','Input','int','comments concerning input_1',True);
 @f6        dbUnic.defineInputOutput('analysis_type_1','input_2','Input','int','comments concerning input_2',True);
 @f6        dbUnic.defineInputOutput('analysis_type_1','input_3','Input','int','comments concerning input_3',True);
 @f6        dbUnic.defineInputOutput('analysis_type_1','output','Output','int','comments concerning output',True);
 @f6        dbUnic.closeConnection;
 @f6    end;

 Ex7 : Stocker une analyse relative à un type d'analyse

 @f6    var
 @f6        analysis:TDBObject;

 @f6    begin
 @f6        dbUnic.initConnection('', '127.0.0.1', 5432, 'helmholtz', 'login', 'password');
 @f6        analysis.Create;
 @f6        analysis.component := 'analysis_type_1';
 @f6        analysis.id := 'analysis_type_1_analysis_1';
 @f6        analysis.comments := 'some comments concerning the analysis';
 @f6        analysis.input_1 := 1;
 @f6        analysis.input_2 := 2;
 @f6        analysis.input_3 := 3;
 @f6        analysis.output := 1 + 2 + 3;
 @f6        dbUnic.storeAnalysis(analysis,True);
 @f6        dbUnic.closeConnection;
 @f6    end;

 Ex8 : Générer une liste filtrée d'analyse

 @f6    var
 @f6        analyses:TDBQuerySet;
 @f6        analysis:TDBObject;
 @f6        i:Integer;

 @f6    begin
 @f6        dbUnic.initConnection('', '127.0.0.1', 5432, 'helmholtz', 'login', 'password');
 @f6        dbUnic.getAnalysesAsObjects('analysis_type_1','output = 3','id',analyses);
 @f6        for i := 1 to analyses.countObjects do
 @f6            begin
 @f6                 analyses.getObject(i-1,analysis);
 @f6                 messageBox(analysis.id);
 @f6            end;
 @f6        dbUnic.closeConnection;
 @f6    end;
}




