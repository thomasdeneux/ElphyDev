
Object
  Tobject
{$H Tobject est l'ancêtre de tous les objets (excepté Tsystem@).

 Sa propriété SysName@ contient le nom de l'objet.
 Tout objet peut être détruit avec la méthode free@ .
 
}

  Tacquis1       (Tobject)
{$H Tacquis1 est un simple conteneur qui assure la compatibilité avec Acquis1.

 Il contient:
  - des vecteurs appelés c1@ , c2@ ,...,c12@
  - des graphes appelés g1@ , g2@ ,...,g12@

 On accède aussi à ces objets avec les propriétés c@ ou g@ .

 On peut utiliser ces objets sans avoir à les créer.

 Il existe un objet unique appelé Acquis1@ de type Tacquis1, qui ne peut être
détruit par l'utilisateur et qui bénéficie d'un (with implicite)@ .
}
  TwinObject     (Tobject)
{$H TwinObject est l'ancêtre de tous les objets qui possédent une fenêtre,
sauf l'objet Tmultigraph@ .

 Cette fenêtre peut être affichée avec Show@ et cachée avec Hide@ . Sa position
est donnée par WinTop@ et WinLeft@ . Ses dimensions sont données par WinWidth@
et WinHeight@ .
}

  Tplot          (TwinObject)
{$H Tplot est l'ancêtre de tous les objets qui peuvent être affichés dans une fenêtre.
Les objets descendant de Tplot possèdent leur propre fenêtre qui peut être
visualisée en appelant la méthode Show@ . Ils peuvent également être glissés à partir
de l'inspecteur d'objets dans une fenêtre multigraph. On peut provoquer leur réaffichage
en utilisant leur méthode invalidate@ ou leur méthode refresh@.

 Tplot engendre TdataPlot@ qui lui-même engendre TdataObject@. TdataObject étant le
parent des objets réels basés sur Tvector@ et Tmatrix@ .
}
  TdataPlot      (Tplot)
{$H TdataPlot est construit à partir de Tplot en ajoutant des paramètres de visualisation

Chaque objet descendant de TdataPlot possède ses propres paramètres d'affichage:
 Xmin@, Xmax@, Ymin@ et Ymax@ définissent le système de coordonnées. Ces propriétés
peuvent être modifiée en une seule instruction avec la méthode SetWorld@.
 Cpx@, Cpy@ et Cpz@ sont les coefficients de couplages respectivement suivant les
axes X, Y et Z. Quand plusieurs objets ont les mêmes coefficients de couplage
suivant un axe donné, le système modifie automatiquement les coordonnées  suivant
cet axe de tous ces objets dés qu' une coordonnée d'un des objets est modifiée.

 Les propriétés LogX@ et LogY@ permettent d'imposer une échelle logarithmique suivant X ou Y.

 Les propriétés Xscale@, Yscale@, Xticks@, Yticks@, RightTicks@, TopTicks@ et ScaleColor@
permettent de modifier l'aspect des graduations.

 Les méthodes AutoScaleX@ et AutoScaleY@ permettent de cadrer l'affichage.

 Tdataplot engendre TdataObject@ , le parent des objets réels basés sur Tvector@ et Tmatrix@ .
}
  TdataObject    (TdataPlot)
{$H TdataObject est construit à partir de Tdataplot en ajoutant des paramètres
liés aux données.

TdataObject est le parent des objets réels basés sur Tvector@ et Tmatrix@ .

 Les paramètres Dx@ et X0@ définissent la correspondance entre unités fichiers et unités
réelles suivant l'axe des X.

 Les paramètres Dy@ et Y0@ définissent la correspondance entre unités fichiers et unités
réelles suivant l'axe des Y.

 Istart@ et Iend@ définissent les indices de début et de fin des données.
Xstart et Xend définissent les abscisses réelles de début et de fin des données.

 convX et invConvX (respectivement convY@ et invconvY@) permettent de transformer des
coordonnées fichier en coordonnées réelles et réciproquement.
}

  TuserPlot      (Tplot)
{$H TuserPlot est un objet dont la procédure de dessin OnPaint@ est définie par
l'utilisateur.
}
 
  Tvector        (TdataObject)
{$H Un vecteur peut être défini comme une suite ordonnée de nombres. Dans ce sens,
tout système d’acquisition analogique crée des vecteurs, chaque nombre étant un
échantillon prélevé à intervalle régulier sur une entrée analogique, et tout fichier
de données analogiques contient des vecteurs.

 Pour manipuler commodément ces vecteurs, on définit l’objet Tvector qui uniformise
l'accès aux données contenues dans le vecteur. En effet, les données peuvent exister
physiquement de façons très différentes soit parce que leurs types sont différents
(entiers sur 2 ou 4 octets, réels sur 4, 6, 8 ou 10 octets), soit parce qu'elles
résident en mémoire ou sur un disque, soit encore parce qu'elles appartiennent à des
structures complexes (multiplexage, segmentation des données). Mais les méthodes
de Tvector permettent à l'utilisateur d'oublier les problèmes liés à la diversité
de l'implémentation des données.

 Un vecteur peut être créé par le programme en appelant le constructeur create@ ou
bien par le menu Objects/New. Dans les deux cas, il faut donner le (type de nombre)@(types de nombre),
l’indice de début Istart@ et l’indice de fin Iend@ . Il est possible de modifier ces
valeurs par la suite en appelant la méthode modify@ .

 Parfois, le vecteur appartient à un autre objet. C’est le cas lorsque l’on ouvre
un fichier de données (voir TdataFile@ ): la structure du vecteur est alors imposée
par le contenu du fichier de données. On peut contrôler cette structure avec les
fonctions NumType@, Istart@ et Iend@ qui donnent respectivement le (type des nombres)@(types de nombre),
l’indice de début et l’indice de fin, mais on ne peut pas la modifier.

 Un élément du vecteur d’indice i correspond à une abscisse réelle donnée par la
relation:
	x = Dx*i+X0
 Dx@ et X0@ sont les paramètres d’échelle suivant X.
 La fonction Convx@ est définie par la relation précédente. La fonction invConvx@ est
l’inverse de ConvX.

 Les fonctions Xstart@ et Xend@ renvoient les abscisses réelles du premier et du
dernier point du vecteur.

 Les éléments d’un vecteur sont soit d’un type entier, soit d’un type réel. Quand
le type est entier (t_byte, t_short, t_word, t_smallint ou t_longint), on associe à
chaque valeur j d’un élément de vecteur une valeur réelle y donnée par la relation:
	y = Dy*j+Y0
 Dy@ et Y0@ sont les paramètres d’échelle suivant Y.

 La fonction Convy@ est définie par la relation précédente. La fonction invConvy@ est
l’inverse de ConvY.
 Cette situation correspond classiquement aux vecteurs créés par un logiciel
d’acquisition du type Acquis1 ou Clampex. Le logiciel range dans un fichier des
nombres compris par exemple entre -2048 et +2047 mais l’utilisateur est intéressé
par la signification réelle de ces nombres. Cette valeur réelle est fournie par la
relation ci-dessus.

 Pour accéder à un élément du vecteur, on peut utiliser la propriété Jvalue@ si l’on
s’intéresse aux valeurs brutes (ou valeurs fichier) ou la propriété Yvalue@ si l’on
s’intéresse aux valeurs réelles.

 Quand les éléments du vecteur sont d’un type réel (t_single, t_real, t_double ou
t_extended), les lois de conversion suivant Y ne sont pas utilisées. On accède aux
valeurs en utilisant la propriété Yvalue uniquement.

 Alors que Jvalue et Yvalue utilisent un argument entier qui représente l’indice
du vecteur, la propriété Rvalue@ utilise un argument réel qui représente une abscisse
réelle.

 Tvector hérite des propriétés et méthodes d’affichage de TdataObject. Les
coordonnées d’affichage Xmin@, Xmax@, Ymin@ et Ymax@ sont toujours exprimées en
coordonnées réelles. La couleur de tracé est fixée par la propriété Color@ et le
mode de tracé par la propriété Mode@. Certains modes utilisent deux couleurs, la
deuxième couleur est rangée dans la propriété color2@.
 Quand le mode utilise des symboles, leur taille est fixée par SymbolSize@ .

 Quelques méthodes (maxi, mini, etc..) permettent de faire des calculs sur un
vecteur mais les calculs les plus intéressants sont effectués en utilisant les procédures
standard sur les vecteurs.

}
  Tpsth          (Tvector)
{$H L'objet Tpsth permet le calcul de psths (post-stimulus time histogram) à partir
de données contenues dans des vecteurs événements. Un vecteur événement étant un
vecteur qui contient une liste de dates.

 Dans le constructeur create@, on donne les mêmes paramètres que pour un vecteur
ainsi qu'une (largeur de classe)@BinWidth . Ensuite, il suffit d'appeler la méthode
Add@ ou AddEx@ autant de fois qu'il est nécessaire pour accumuler des vecteurs
d'événements dans l'histogramme. Le psth possède une propriété count@ qui mémorise
le nombre de vecteurs accumulés. L'affichage peut exprimer les ordonnées en nombre
d'événements ou bien en Hertz suivant la valeur de la propriété InHz@ .
 La méthode reset@ permet de mettre le contenu du psth à zéro.

 Tpsth possède également toutes les propriétés et méthodes de l'objet Tvector@ .
}
  Tcorrelogram   (Tpsth)
{$H L'objet Tcorrelogram permet le calcul de corrélogrammes sur des vecteurs
d'événements. Les méthodes et propriétés sont les mêmes que celles de Tpsth@. Seule
la méthode Add@ diffère.

 Il ne s'agit pas de calcul de fonctions de corrélation sur des vecteurs ordinaires.
Pour cela, il faut utiliser les procédures Corre@ ou CrossCorre@ .
}
  Tgraph         (TdataPlot)
{$H L'objet Tgraph permet de représenter un graphe défini par deux séries de valeurs
contenues dans deux vecteurs. Un troisième vecteur peut éventuellement contenir des
incertitudes.

  Les vecteurs n'ont pas forcément des indices de début et de fin identiques mais
mais un point du graphe correspond toujours au même indice dans chaque vecteur.

Le constructeur create@ reçoit en paramètre les deux vecteurs ainsi que les indices
de début et de fin.
 La méthode modify@ permet de modifier la définition du graphe sans détruire l'objet.

 La propriété booléenne AutoLimit@ indique à l'objet qu'il faut toujours prendre la valeur
minimale possible pour l'indice de début et la valeur maximale possible pour l'indice
de fin.
 On considère aussi que Autolimit est vrai si l'indice de début est supérieur à l'indice
de fin dans create ou modify.

 Avec setErrorData@ , on indique le vecteur contenant les valeurs d'erreur. Dans ce cas,
des barres d'erreur seront affichées sur le graphe.

 Tgraph possède également toutes les propriétés et méthodes de TdataPlot@ .

}
  Tmatrix        (TdataObject)
{$H Tmatrix implémente une matrice au sens ordinaire , à savoir un tableau de
nombres à deux dimensions.

 Il est important de remarquer que la vocation première de Tmatrix a été la représentation
graphique de données et non pas le calcul matriciel. En conséquence, certaines notations
ne correspondent pas aux conventions utilisées dans les logiciels de calcul matriciel.
En particulier, un élément (i,j) correspond à un emplacement d'abscisse I et d'ordonnée J
dans un repère cartésien et non pas à l'élément de la ligne I dans la colonne J d'un tableau de nombres.

 Dans le constructeur create@ , on indique le (type de nombre)@(types de nombre) et
les indices de début et de fin pour chacune des dimensions.
Ces paramètres peuvent être modifiés sans détruire l'objet au moyen de modify@.
 Les fonctions Istart@ , Iend@, Jstart@ et Jend@ renvoient les valeurs des indices limites.

 D'une façon générale, nous appellons i et j les indices d'un élément de la matrice.
Le contenu d'un élément est appelé K s'il s'agit d'une valeur entière et Z s'il
s'agit d'une valeur réelle.

 Comme pour un vecteur, on définit des facteurs d'échelle pour chacune des coordonnées.
 A un indice i correspond un abscisse réelle x donnée par la relation x=Dx*i+x0 .
 A un indice j correspond un ordonnée réelle y donnée par la relation x=Dy*j+y0 .
 A une valeur entière k correspond une valeur réelle z donnée par la relation z:=Dz*k+z0 .
 Dx@ et x0@, Dy@ et y0@, Dz@ et z0@ sont respectivement les paramètres d'échelle
suivant les axes X, Y et Z.

 Les trois relations ci-dessus sont définissent respectivement les fonctions convx@,
convy@ et convz@ . Les fonctions inverses étant respectivement invCOnvx@ , invConvy@
et invConvZ@.

 Les facteurs d'échelle suivant Z ne sont effectivement utilisés que si le type des
éléments de la matrice est un type entier.

 Pour accéder à un élément de type entier, on utilise la propriété Kvalue@ . Pour
accéder à un élément de type réel, on utilise la propriété Zvalue@ .

 L'affichage standard de la matrice est un quadrillage dans lequel chaque petit
rectangle a une couleur qui dépend de la valeur de l'élément de matrice
correspondant. La façon dont cette couleur est calculée dépend des propriétés
PaletteType@ , PalColor@ et TwoColors@ .

 La région de la matrice affichée est définie par Xmin@, Xmax@, Ymin@ et Ymax@.

 Les propriétés Zmin@ et Zmax@ déterminent les valeurs correspondant aux couleurs
extrêmes de la palette.
 L'aspect de la matrice dépend de AspectRatio@ et son orientation de Theta@ .

}
  TplotArray   (TdataObject)
{$H TplotArray est un objet intermédiaire permettant de définir TvectorArray@ et
TaverageArray@.

 Il ne possède pas de constructeur .
}

  TVectorArray   (TplotArray)
{$H TvectorArray simplifie la manipulation d'un tableau de vecteurs à deux dimensions.

 Par exemple, au lieu de déclarer une variable vec:array[1..10,1..10] of Tvector,
vous pouvez déclarer la variable vec:TvectorArray. Les indices du tableau (ici 1,10,1,10)
sont fixés en appelant le constructeur create@ . Les paramètres des vecteurs doivent
ensuite être fixés en appelant initObjects@. Ces vecteurs auront bien sûr tous la
même structure.

 Ensuite, tous les paramètres d'affichage (Xmin@, Xmax@, color@, logX@, logY@, etc..)
et tous les paramètres d'échelle (Dx@, x0@, Dy@, y0@, unitX@, unitY@) pourront être
fixés en une seule opération.
 Par exemple, l'instruction vec.Xmax:=10 aura pour effet de donner la valeur 10 à la
propriété Xmax de tous les vecteurs du tableau.
 De plus tous les vecteurs pourront être affichés dans une même fenêtre sous la forme
d'une grille.
 Les méthodes AutoScaleX@ et AutoScaleY@ agiront aussi sur tous les vecteurs du tableau.

 On peut malgré tout accéder aux vecteurs individuellement au moyen de la propriété V@ .
Comme V est la propriété par défaut, on peut aussi accéder aux vecteurs en écrivant directement vec[i,j],
comme s'il s'agissait d'un tableau ordinaire.
}

  TpsthArray      (TVectorArray)
{$H TpsthArray simplifie la manipulation d'un tableau d'objets Tpsth@ à deux
dimensions.

 Son fonctionnement est le même que celui de TvectorArray@ .

 Après avoir utilisé le constructeur create@, il faut appeler initObjects@ pour
créer effectivement les objets.
 La propriété V@ permet d'accéder à chaque objet individuellement.

}

  TcorrelogramArray      (TVectorArray)
{$H TCorrelogramArray simplifie la manipulation d'un tableau d'objets TCorrelogram@
à deux dimensions.

 Son fonctionnement est le même que celui de TvectorArray@ .

 Après avoir utilisé le constructeur create@, il faut appeler initObjects@ pour
créer effectivement les objets.
 La propriété V@ permet d'accéder à chaque objet individuellement.

}


  TAverageArray   (TVectorArray)
{$H TaverageArray simplifie la manipulation d'un tableau d'objets Taverage@ à deux
dimensions.

 Son fonctionnement est le même que celui de TvectorArray@ .

 Après avoir utilisé le constructeur create@, il faut appeler initObjects@ pour
créer effectivement les objets.
 La propriété V@ permet d'accéder à chaque objet individuellement.

}

  TmatrixArray   (TplotArray)
  
  T2DcorreArray  (TplotArray)

  TmgPage        (Tobject)
{$H TmgPage représente une page de l'objet Tmultigraph@

 La propriété MgPage@(Tmultigraph.MgPage) de Tmultigraph est de type TmgPage.

}
  TMgVparams (Tobject)
{$H TMgVparams contient un ensemble de paramètres de visualisation.

 TMgPage contient une propriété Vparams@(TMGpage.Vparams) de type TmgVparams.

}

  TmultiGraph    (TwinObject)
  {$H Tmultigraph est l'objet qui permet d'afficher toutes sortes d'objets (vecteurs,
graphes, fonctions, texte, etc..) dans une même page.

 La fenêtre principale de Elphy contient un objet multigraph particulier appelé
Multigraph0@. C'est pourquoi ce nom apparait toujours dans l'inspecteur d'objets. Cet
objet occupe la quasi-totalité de la fenêtre principale: le menu, le panneau supérieur
contenant les boutons et le panneau inférieur (status line) ne font pas partie de
l'objet Multigraph.
 Il est possible de créer d'autres objets multigraph mais cela présente en général peu
d'intérêt sauf si votre système contient deux écrans. Il est alors intéressant de
placer un objet Multigraph sur chaque écran.

 Multigraph0 bénéficie de ce que nous appelons un (WITH IMPLICITE)@. Ce qui signifie
qu'il n'est pas nécessaire de faire précéder le nom d'une méthode par le nom de l'objet.
 Ex: au lieu d'écrire multigraph0.penColor:=cl_blue, on peut écrire directement
penColor:=cl_blue.

 L'objet multigraph peut contenir une ou plusieurs pages que l'utilisateur peut
sélectionner en choisissant l'onglet correspondant. Cette sélection peut aussi se
faire par programme en modifiant la propriété page@ .

 Chaque page peut contenir une ou plusieurs fenêtres. Ces fenêtres peuvent
être mises en place par l'utilisateur en activant le menu Design. Elles peuvent
aussi être mises en place par programme en utilisant NewWindow@, DestroyAllWindows@,
destroyWindows@, divideWindow@, defineWindow@, initGrid@, defineGrid@.
 Les fenêtres sont numérotées dans l'ordre de leur création. Les coordonnées sont
exprimées en pixels. Les propriétés pageWidth@ et pageHeight renvoient les dimensions
d'une page. Le nombre de fenêtres dans une page est donné par wincount@.

  Chaque fenêtre multigraph peut recevoir un ou plusieurs objets affichables (des
descendants de Tplot). Au moyen de la souris, on place un objet dans une fenêtre en
le faisant glisser à partir de l'inspecteur d'objet et en le lachant dans la fenêtre.
Par programme, on utilise addObject@ ou addObjectOnGrid@ . Pour enlever tous les
objets d'une fenêtre, on appelle clearObjects@.

 Chaque page de l'objet multigraph est un bitmap. Dans un souci de vitesse, le
mécanisme de mise à jour de ces bitmaps est assez sophistiqué. En particulier,
les objets ne sont redessinés sur ces bitmaps que lorsque cela est nécessaire. Si une
page reste en permanence en arrière plan, cette page n'est jamais redessinée. Elle ne
sera mise à jour que si l'utilisateur la fait passer au premier plan.
 Pendant le déroulement d'un programme, l'affichage ne se fera pas forcément
immédiatement même si plusieurs objets ont été invalidés. Pour obtenir une mise à jour
immédiate, il faut appeler la méthode update@ .
 On peut aussi forcer la page courante à se redessiner complètement en appelant
refresh@. (Attention! Cette méthode étant partagée par plusieurs x objets bénéficiant d'un
With implicite, il vaut mieux écrire multigraph0.refresh)

 L'objet multigraph possède un certain nombre de méthodes qui permettent de dessiner
directement dans une fenêtre. Ces méthodes peuvent être appelées à tout moment dans
n'importe quel programme mais si on ne prend aucune précaution, le dessin risque fort
de disparaitre de la page de façon inattendue. En effet, l'objet multigraph ne se
soucie que de l'affichage des objets déposés dans ses fenêtres et ignore complètement
les dessins entrepris par l'utilisateur à moins que ces dessins ne soient eux-mêmes
liés à un objet (voir TuserPlot@ ou la méthode OnDisplay@(Tvector.ondisplay) de Tvector).

 On dessine toujours sur la page courante.
 Il est intéressant d'écrire une procédure de dessin si l'on veut ajouter des symboles
ou des repères sur un graphe.
 Il faut d'abord préciser la fenêtre qui va recevoir le dessin avec setWindow@ ou
selectWindow@.
 Puis, il faut indiquer le système de coordonnées utilisé avec setWorld@ ou selectWorld@.
 Ensuite, on peut appeler moveto@, lineto@, line@, lineHor@ ou lineVer@ pour tracer des
droites. PenColor@ définit la couleur de tracé. DisplaySymbol@ permet d'afficher un symbole.
OutText@ ou outTextW@ permettent d'afficher du texte.

}
  Tdatafile      (TwinObject)
{$H TdataFile est l'objet qui permet la visualisation et l'analyse de fichiers de
données provenant de Elphy, Acquis1, les logiciels Axon, et quelques autres.

 Ces fichiers contiennent une ou plusieurs voies (ou canaux) multiplexées et peuvent
être organisés en épisodes (ou séquences), un épisode correspondant à une acquisition
de durée fixe répétée un certain nombre de fois.

 L'idée de l'objet TdataFile est de mettre à la disposition de l'utilisateur
des vecteurs correspondant à chaque voie, qui vont permettre une manipulation
facile des données, aussi bien au niveau des commandes qu'au niveau de la
programmation. Ces vecteurs sont appelés v1@, v2@, v3@, etc... (La propriété v@
a le même usage). Dés que l'on charge un fichier, ces vecteurs contiennent les
données correspondant au premier épisode (ou bien à la totalité du fichier si le
fichier est continu) . Signalons qu'à ce stade, aucun transfert ou conversion de
données n'est effectué, Elphy va chercher les données directement dans le fichier en
fonction de ses besoins.

 Il existe un objet de type TdataFile particulier appelé datafile0@ qui existe
toujours et ne peut être détruit par l'utilisateur. Les commandes associées à
cet objet sont incorporées à la fenêtre principale de Elphy. Ce objet bénéficie
d'un (with implicite)@, ce qui permet une manipulation facile de ses méthodes.

 Les commandes associées à d'autres objets de type TdataFile sont implémentées
dans une fenêtre distincte.

 Le constructeur create@ permet la création d'un objet TdataFile.
 Pour charger un fichier, on appelle NewFile@.
 Les propriétés EpCount@ et ChannelCount@ indiquent alors le nombre d'épisodes et
le nombre de voies du fichier.

 Pour changer d'épisode, il suffit de modifier la valeur de la propriété EpNum@.

 Les fichiers de données Elphy ou Acquis1 peuvent contenir des voies événements
et des voies tags. Aux voies événements sont associés les vecteurs e1@, e2@,
e3@, etc... Aux voies tags sont associés les vecteurs Vtag1@ et Vtag2@ .
 Les propriétés e@ et Vtag@ permettent aussi d'accéder à ces vecteurs.

 Plusieurs méthodes permettent le calcul de moyennes d'épisodes. Les calculs se
font toujours simultanément sur toutes les voies. Les résultats se trouvent dans
les vecteurs m1@, m2@, m3@, etc... Pour mettre à zéro les moyennes, on appelle
clearAverage@, pour accumuler l'épisode courant, on appelle AddToAverage@. Il
n'y a aucun risque de compter deux fois un épisode car le système mémorise
les épisodes marqués.
 Le type des vecteurs moyennes est défini par AverageType@.
 Lorsque le fichier de données est continu, on peut aussi moyenner des segments
de longueur donnée pris en divers endroits du fichier. Les bornes du segment
sont alors fixées par InitAverages@ et on utilise AddToAverage1@ au lieu de
AddToAverage .
 La propriété m@ permet aussi d'accéder aux moyennes.

 Les méthodes getFileInfo@, setFileInfo@, readFileInfo@, writeFileInfo@,
resetFileInfo@ et FileInfoSize@ permettent de gérer les (informations fichier)@
(fichiers Acquis1 ou Elphy).

 Les méthodes getEpInfo@, setEpInfo@, readEpInfo@, writeEpInfo@,
resetEpInfo@ et EpInfoSize@ permettent de gérer les (informations d'épisode)@
(fichiers Acquis1 ou Elphy).

}
  TrealArray     (TwinObject)
{$H TrealArray permet de gérer un tableau de nombres réels à deux dimensions.

 Ces nombres sont de type extended (réels sur 10 octets).

 Il existe un objet particulier (realArray0) de type TrealArray qui appartient au
système. Cet objet est accessible au moyen de la commande SpreadSheet dans le menu
principal. RealArray0 benéficie d'un (with implicite)@ , ce qui rend ses propriétés
et méthodes accesibles sans indiquer le nom de l'objet.

 Pour créer un nouvel objet TrealArray, on appelle son constructeur create@ en indiquant
les nombres de lignes et de colonnes souhaités. Le nombre de colonnes est limité à 256
alors que le nombre de lignes n'est en fait limité que par la mémoire disponible sur votre
système. Il n'y a pas d'inconvénient à demander un grand nombre de lignes car le nombre
effectif de lignes allouées va s'ajuster en fonction des besoins.

 La propriété t@ permet d'accéder aux cellules du tableau. On peut sauver et charger le
tableau avec SSsave@ et SSload@ . Le tableau est toujours sauvé en mode texte en utilisant
le nombre de décimales affichées.

 Chaque colonne du tableau est un vecteur. Ces vecteurs sont accessibles à travers
la propriété tn@ . Ces vecteurs ont la particularité d'être extensibles. En effet, quand
on crée le tableau ou lorsque l'on appelle SSclear@ , tous les vecteurs contiennent zéro
élément (Istart=1 et Iend=0). Ensuite, à chaque fois que l'on écrit une valeur dans le
tableau (par programme ou dans l'éditeur), le vecteur correspondant à la colonne d'écriture
s'allonge si nécessaire pour atteindre la ligne d'écriture.

 En affectant la propriété SSindex@, on peut imposer le nombre de lignes d'un vecteur.
}

  Tfunction      (Tvector)
  {$H Tfunction permet de manipuler une fonction réelle de variable réelle.

   La première utilité est la représentation graphique d'une fonction mais Tfunction
permet aussi de définir un modèle pour les ajustements de fonction (voir TCurveFitting@ )

   L'utilisateur peut définir la fonction de trois façons différentes:
   1- en introduisant l'expression de la fonction dans la propriété Text@ .
   2- en choisissant un modèle standard en affectant la propriété StandardModel@ .
   3- en écrivant une fonction dans le programme et en affectant la propriété PgFunction@

   Le graphe sera précisé (extension et résolution) au moyen de setGraphParam@ ou
matchVector@ .
   Par défaut, la variable s'appelle x mais ce nom peut être modifié avec la propriété
argument@ .
   Les valeurs numériques des paramètres sont accessibles avec la propriété Param@ .

   Tfunction étant un descendant de Tvector, il est possible d'appliquer toutes les
procédures de manipulation de vecteur à un objet Tfunction. Signalons que la propriété
Rvalue@ renvoie toujours la valeur exacte de la fonction pour un argument donné.

  }
  TcurveFitting  (Tfunction)
{$H TcurveFitting se présente comme un descendant de Tfunction@ . La fonction à ajuster
se définit donc au moyen de Text@ ou bien en sélectionnant un modèle standard avec
StandardModel@.

 Les modèles standard ont l'avantage de pouvoir être automatiquement initialisés (voir
Initialize@).

 Un calcul de fit commence toujours par un appel à reset@ qui initialise les variables
internes de l'objet mais ne touche pas à la fonction.
 On définit ensuite les données à analyser avec setXdata@ , setYdata@ et setErrorData@ .

 La région à analyser peut être définie avec XstartFit@ et XendFit@ ou bien
IstartFit@ et IendFit@. Dans le premier cas, on travaille sur les abscisses réelles
des points. Dans le second cas, on travaille sur les indices des points dans les
vecteurs.


 L'origine peut éventuellement être modifiée avec Xorigin@ .
 Le poids statistique de chaque donnée peut être modifié avec la propriété mode@ .
 La propriété MaxData@ permet d'indiquer le nombre de points effectivement utilisés pour
le calcul.
 La propriété Clamp@ permet de fixer un ou plusieurs paramètres. Ces paramètres se
comporteront donc comme des constantes et ne seront pas ajustés.

 Enfin, la fonction Execute@ lance le calcul. Cette fonction renvoie false si une
erreur s'est produite pendant le calcul, true dans le cas contraire.

 En sortie, les valeurs des paramètres sont dans Param@ et si l'objet Tcurvefitting
a été rangé dans la même fenêtre que le graphe source avec les coordonnées adéquates,
il est possible d'apprécier visuellement le résultat.

}

  TMatFunction      (Tmatrix)
  {$H TMatFunction permet de manipuler une fonction réelle de deux variables réelles.

   TmatFunction permet la représentation graphique d'une fonction z=f(x,y) sous une
forme matricielle et permet de définir un modèle pour les ajustements de fonctions à
deux variables (voir TMatFitting@ )

   L'utilisateur peut introduire l'expression de la fonction dans la propriété Text@ .
   Le graphe sera précisé (extension et résolution) au moyen de setGraphParam@ ou
matchMatrix@ .
   Par défaut, les variables s'appellent x et y mais ces noms peut être modifiés avec la
propriété argument@ .
   Les valeurs numériques des paramètres sont accessibles avec la propriété Param@ .

   Il est possible de sélectionner un modèle standard avec StandardModel@ .

   TmatFunction étant un descendant de Tmatrix, il est possible d'appliquer toutes les
procédures de manipulation de matrice à un objet TmatFunction. Toutefois, les propriétés et
méthodes qui modifient des valeurs de la matrice sont sans effet.
Signalons que la propriété Rvalue@ renvoie toujours la valeur exacte de la fonction
pour deux arguments donnés.

  }
  TmatFitting  (TmatFunction)
{$H TmatFitting se présente comme un descendant de TmatFunction@ . La fonction à ajuster
se définit donc au moyen de Text@ ou bien en sélectionnant un modèle standard avec
StandardModel@.

 Les modèles standard ont l'avantage de pouvoir être automatiquement initialisés (voir
Initialize@).

 Un calcul de fit commence toujours par un appel à reset@ qui initialise les variables
internes de l'objet mais ne touche pas à la fonction.
 On définit ensuite les données à analyser avec setdata@ et setErrorData@ .

 Les données à analyser sont définies par tous les éléments de la matrice sauf si
la propriété UseSelection@ vaut true. Dans ce cas, seuls les éléments sélectionnés
sont pris en compte.

 Le poids statistique de chaque donnée peut être modifié avec la propriété mode@ .
 La propriété Clamp@ permet de fixer un ou plusieurs paramètres. Ces paramètres se
comporteront donc comme des constantes et ne seront pas ajustés.

 Enfin, la méthode Execute@ lance le calcul.

 En sortie, les valeurs des paramètres sont dans Param@.

}


  Tdialog        (TWinObject)
{$H Tdialog permet de créer des dialogues modaux ou non modaux.

 Un dialogue est une fenêtre contenant des contrôles (champs de saisie, boutons, barres de
défilement, etc..).
 Un dialogue est dit modal lorsque l'utilisateur doit le refermer s'il souhaite intervenir
dans une autre fenêtre.
 Un dialogue est non modal lorsqu'il peut rester ouvert en permanence. Un tel dialogue est
en général plus difficile à gérer qu'un dialogue modal.

 L'objet doit d'abord être créé au moyen du constructeur create@ .

 Les méthodes getInteger@, getReal@, getString@ ou getBoolean@ permettent
de saisir respectivement une variable de type entier, réel, chaîne de caractères ou booléen.
 getColor@ permet de saisir une couleur.
 getStringList@ permet à l'utilisateur de faire un choix dans une liste d'options.
 getCommand@ met en place un bouton.

 La méthode Show@ ouvre le dialogue sous une forme non modale
 La méthode ShowModal@ ouvre le dialogue sous une forme modale.

 Un dialogue peut aussi être inséré dans une fenêtre de l'objet Tmultigraph au moyen de
la méthode AddDialog@(Tmultigraph.addDialog)

 Un dialogue peut comporter un ou plusieurs boutons standard (OK, Cancel, Yes, No, ...).
Ces boutons sont installés au moyen de setButtons@ .
 Lorsque le dialogue est modal, le fait de cliquer sur un bouton standard ferme le
dialogue et la fonction showModal renvoie un code caractéristique du bouton
( (Modal result)@ )

 La structure typique d'une procédure de dialogue modal sera la suivante:

 @f6 var
 @f6   dialog:Tdialog;
 @f6   w,h:integer;
 @f6   theta:real;

 @f6 procedure Params;
 @f6 var
 @f6   ii:integer;
 @f6 begin
 @f6   with dialog do
 @f6   begin
 @f6     create;

 @f6     getInteger('Height',h,6);
 @f6     getInteger('Width',w,6);
 @f6     getReal('Theta',theta,10,3);
 @f6     ...
 @f6     ii:=showModal;
 @f6     if ii=MR_OK then updateVar;
 @f6   end;
 @f6
 @f6 end;


 Le rôle de la méthode updatevar@ est de mettre à jour les variables associées
aux contrôles.
 Réciproquement, la méthode update@ permet de mettre à jour les contrôles quand
on modifie les variables.

 Lorsque le dialogue est non modal, il est nécessaire de gérer les actions de
l'utilisateur d'une manière particulière. Pour cela, on utilise la propriété
OnEvent@ ou encore la propriété OnChange@. Ces propriétés doivent recevoir
l'adresse d'une procédure qui sera appelée à chaque intervention de l'utilisateur
dans le dialogue.

 La structure typique d'une procédure de dialogue non modal sera la suivante:

 @f6 var
 @f6   dialog:Tdialog;
 @f6   x,y:real;
 @f6   id1,id2,id3: integer;

 @f6 procedure ParamsEvents(num:integer);
 @f6 begin
 @f6   if num=id3 then  // id3 est l'identificateur du bouton
 @f6   begin
 @f6     dialog.updatevar;
 @f6     messageCentral('x+y='+Rstr(x+y,10,3));
 @f6   end;
 @f6 end;

 @f6 procedure Params;
 @f6 var
 @f6   ii:integer;
 @f6 begin
 @f6   with dialog do
 @f6   begin
 @f6     create('');

 @f6     id1:=getReal('X',x,10,3);
 @f6     id2:=getReal('Y',y,10,3);
 @f6     id3:=getCommand('GO', 0 );
 @f6     onEvent:=ParamsEvents;
 @f6     show;
 @f6   end;
 @f6
 @f6 end;

 La procédure ParamsEvent est associée au dialogue dans l'instruction onEvent:=ParamsEvents;
 ParamsEvent est souvent appelée un gestionnaire d'événement.
 Le nom de la procédure est arbitraire mais elle doit avoir un paramètre et un seul de type integer.
 Son fonctionnement est le suivant: à chaque contrôle est associé un identificateur, et à chaque fois que l'utilisateur
utilise un contrôle, le gestionnaire d'événement est appelé avec pour paramètre la valeur de l'identificateur.

 L'identificateur peut être fixé automatiquement comme dans l'exemple ci-dessus où les variables id1,id2... reçoivent les valeurs
des identificateurs. Cet identificateur peut aussi être fixé par l'utilisateur comme dans la variante ci-dessous:

 @f6     getRealA('X',x,10,3, 101);
 @f6     getRealA('Y',y,10,3, 102);
 @f6     getCommandA('GO', 0, 103 );

 Dans ce cas, il aurait fallu écrire
 @f6       if num=103 then
 dans le gestionnaire d'événement.

 La méthode AddText@ permet d'ajouter du texte à la droite d'un contrôle
existant alors que ModifyText@ permet de modifier ce texte.

 La méthode AddScrollBar@ permet d'ajouter une barre de défilement à la droite
d'un contrôle existant.

 L'aspect du dialogue peut être amélioré en utilisant les panels@(Utilisation des panels)
}


  Tjpsth         (Tmatrix)
  T2Dcorre       (Tmatrix)

  TobjectFile    (Tobject)
{$H TobjectFile permet de gérer des fichiers d'objets.

 Quand on sauve un objet dans un tel fichier, toutes les propriétés de l'objet
et toutes les données qu'il contient sont sauvées dans le fichier.
 Quand on recharge l'objet, on retrouve donc toutes les propriétés et toutes les
données dans l'état où elles se trouvaient au moment de la sauvegarde.

 On peut sauver des objets de types différents dans un même fichier. Pour recharger
convenablement les objets par programme, il faut savoir comment les objets ont été
sauvés ( dans quel ordre, quel est leur type, etc...).

 Pour créer un nouveau fichier, on appelle createFile@. Ensuite, les appels successifs
à la méthode save@ permettent de sauver des objets. Enfin, la méthode close@ ferme le fichier.

 Pour ouvrir un fichier existant, on appelle openFile@ . Puis, les appels successifs
à load@ ou load1@ permettent de charger des objets. Ensuite, la méthode close@ ferme
le fichier.

 Il n'est pas possible de supprimer un élément du fichier. Il n'est pas non plus possible
d'insérer un élément. Chaque objet sauvé est rangé à la fin du fichier.

 Les méthodes SearchAndLoad@ et SearchTypeAndLoad@ permettent de charger un objet sans connaitre
son emplacement.

 Les propriétés ClassNames@ et ObjNames@ donnent tous les noms et tous les types d'objets contenus
dans le fichier.

}

  TbinaryFile    (Tobject)
{$H TbinaryFile permet de gérer un fichier binaire.

 Un fichier binaire peut contenir toutes sortes de données, sans aucune restriction.
 Le contenu d'un tel fichier est donc sous la responsabilité du programmeur.

 Avec Rewrite@ , on crée un nouveau fichier. Avec Reset@, on ouvre un fichier existant.
 Ces deux méthodes sont des constructeurs de l'objet.

 Avec Close@, on ferme le fichier et on détruit l'objet.

 Avec seek@ , on place le pointeur d'écriture/lecture en un point quelconque.

 Avec Read@ et Write@, on lit ou on écrit une variable en totalité.
 Avec BlockRead@ et Blockwrite@, on a la possiblité de lire ou écrire une partie
d'une variable.

 Certains objets comme les vecteurs et les matrices peuvent lire ou écrire directement des
données dans les fichiers binaires.
 Voir SaveSingleData@(Tvector.SaveSingleData) et LoadSingleData@(Tvector.LoadSingleData) .

 Voir aussi l'(exemple d'utilisation d'un fichier binaire)@(Fichier binaire:exemple)
}

 TtextFile    (Tobject)
{$H TtextFile permet de gérer un fichier texte.

}

  Tdetect        (TwinObject)
  {$H Tdetect permet de détecter des événements sur un vecteur.

 Avec InstallSource@ , vous indiquez le vecteur sur lequel les événements sont
recherchés. Les propriétés Xstart@ et Xend@ permettent de limiter la zone de recherche.
 Par défaut, tout le vecteur est exploré.

 Le (mode de détection)@(Modes de détection) est rangé dans la propriété mode@.
 Les propriétés Height@ et Length@ doivent contenir des paramètres spécifiques au mode
demandé. Dans certains cas, Length@ n'est pas utilisés.

 La méthode Execute@ lance la recherche.

 Quand la recherche est terminée, le vecteur Vevent@ contient les dates d'événements. Il
est facile de contrôler les résultats en rangeant Vevent dans la même fenêtre que le
vecteur source et en couplant les coordonnées suivant X.

 Les vecteurs Vaux@ quant à eux, contiennent, pour chaque événement détecté, des
paramètres qui dépendent du mode choisi.

 La propriété count@ indique le nombre de détection.

}
  TalphaDetect   (TwinObject)

  TrevCorAnalysis(TwinObject)
{$H Objet obsolète

  A l'origine, cet objet permettait d'analyser les données d'expériences du type Sparse Noise
  Aujourd'hui, toutes les propriétés et méthodes de TrevCorAnalysis sont implémentées dans Trevcor@
}

  TwaveFile(Tobject)
{$H TwaveFile permet de créer un fichier AUDIO au format WAVE à partir d'un ou
deux vecteurs.

 Le code du format est PCM. Les données sont codées sur 16 bits.

 Avec CreateFile@, on crée le fichier.
 Puis, avec saveVector@ ou save2vectors@ , on range les signaux contenus dans un ou deux vecteurs
dans le fichier.
}

  TaviBuilder(Tobject)
{$H TaviBuilder permet de construire un fichier video image par image.

 Le fichier créé est de type AVI. Les images peuvent être compressées au format RLE8
(Run Length Encoding) ou non compressées, suivant la valeur de la propriété Compress@
(True par défaut).

 Il faut d'abord ouvrir un nouveau fichier au moyen de createFile@ .
 Ensuite, on peut fixer la propriété Rate@ qui détermine le nombre d'images par
secondes (par défaut rate=20).

 Par défaut, toute la page courante représentera une image du film mais on peut
se restreindre à une partie de cette page au moyen de setWindow@ ou setWindowEx@ .

 La méthode save@ sauve une image. D'une façon générale, on écrira une boucle
qui affiche toutes les images successives et qui sauve chaque image dans le
fichier.

 La méthode closeFile@ ferme le fichier.

 Les méthodes CreateFile@ et CloseFile@ sont les constructeur et destructeur
de l'objet.
}
  TVlist0(TdataPlot)
{$H TVlist0 est l'ancêtre des objets réels TVlist@ et TsyncList@.

 Il ne possède pas de constructeur et regroupe les propriétés communes à ces
deux objets.
}

  TsyncList(TVList0)
  TVList(TVlist0)

{$H TVlist permet de gérer une liste de vecteurs.

  Une liste peut être considérée comme un tableau à une dimension dont la taille
peut être modifiée dynamiquement.

  Une fois l'objet créé avec Create@ , il est possible d'ajouter des vecteurs à
la liste avec AddVector@ ou InsertVector@.
  La méthode AddVector crée un clone du vecteur donné comme paramètre et range ce
nouveau vecteur à la fin de la liste.
  La méthode InsertVector crée un clone du vecteur donné comme paramètre et range ce
nouveau vecteur dans la liste, dans une position donnée comme paramètre.
  Ensuite, il est possible de manipuler les vecteurs de la liste avec la propriété V@ .

  La méthode DeleteVector@ permet de supprimer un des vecteurs de la liste.




}

  Taverage(Tvector)

{$H Taverage permet de moyenner des vecteurs comme le font les procédures de
moyenne d'un objet TdataFile, mais d'une façon plus autonome.

 Taverage doit d'abord être initialisé en appelant son constructeur create@ (on
utilisera de préférence un type de nombre réel: t_single) et en fixant les
paramètres d'échelle suivant X.

 Ensuite, les méthodes add@ ou addEx@ permettent d'accumuler un vecteur dans la
moyenne. Reset@ permet la remise à zéro de la moyenne alors que count@ indique
le nombre de vecteurs accumulés.

 Pendant le calcul, on peut aussi calculer les vecteurs VStdDev@ , VstdUp@ et VstdDw@
qui contiendront respectivement l'écart-type, la moyenne augmentée de l'écart-type
et la moyenne diminuée de l'écart-type.

 Pour activer ce calcul, il faut mettre la propriété StdOn@ à true.
}

  Tdac2file(Tobject)
{$H Tdac2file permet de sauver des fichiers de données au format Dac2. Les fichiers
peuvent être continus ou séquencés et peuvent contenir plusieurs voies multiplexées.

 Le constructeur create@ crée l'objet mais ne crée pas de fichier. Il faut d'abord
fixer le nombre de voies en affectant la propriété ChannelCount@ puis appeler
setChannel@ pour chaque voie. On peut spécifier la propriété Continuous@ qui détermine
la façon dont les données sont sauvées.

On peut alors créer le fichier avec CreateFile@ et
sauver des données avec save@ . Enfin, la méthode close@ ferme le fichier.

 La méthode Append permet d'ouvrir un fichier existant et d'ajouter ensuite des
données dans le fichier.

 @b @ul Exemple 1: @notb @notul

 @f6 procedure save;
 @f6 var
 @f6   f:Tdac2file;
 @f6   i:integer;
 @f6
 @f6 begin
 @f6   f.create('');
 @f6   f.channelCount:=2;
 @f6   f.setChannel(1,v1,v1.Xstart,v1.Xend);
 @f6   f.setChannel(2,v3,v3.Xstart,v3.Xend);
 @f6   f.createFile('c:\data\data1.dat');
 @f6
 @f6   for i:=1 to Epcount do
 @f6   begin
 @f6     EpNum:=i;
 @f6     f.save;
 @f6   end;
 @f6   f.close;
 @f6 end;

 On remarquera que l'on appelle setChannel AVANT de créer le fichier. C'est nécessaire car
les informations fournies à ce moment seront rangées dans l'entête de fichier.

 Ensuite, pour sauver différentes séquences, on peut changer le contenu des différents vecteurs
et appeler simplement la méthode save@

 Eventuellement, on peut changer les vecteurs utilisés en appelant setChannel avant chaque save
mais il faut veiller à garder dans chaque voie des vecteurs ayant la même structure.
 En effet, dans un fichier au format Dac2 , toutes les séquences doivent avoir le même format.

 Dans l'exemple qui suit, on sauve le contenu d'un objet TVlist dans un fichier Dac2. Il faut que tous les vecteurs
de la liste aient la même structure, sinon une erreur d'exécution sera générée.

 @b @ul Exemple 2: @notb @notul

 @f6 procedure save(var Vlist:TVlist);
 @f6 var
 @f6   f:Tdac2file;
 @f6   i:integer;
 @f6
 @f6 begin
 @f6   f.create('');
 @f6   f.setChannel(1,Vlist.v[1],Vlist.v[1].Xstart,Vlist.v[1].Xend);
 @f6   f.createFile('c:\data\data1.dat');
 @f6
 @f6   for i:=1 to Vlist.count do
 @f6   begin
 @f6     f.setChannel(1,Vlist.v[i],Vlist.v[i].Xstart,Vlist.v[i].Xend);
 @f6     f.save;
 @f6   end;
 @f6   f.close;
 @f6 end;

}

  Tcursor(TwinObject)
{$H Tcursor permet de manipuler un curseur qui apparait sous la forme d'une ligne
verticale ou horizontale superposée au graphe d'un objet descendant de TdataPlot.

 Un curseur peut  être défini et manipulé entièrement sans faire intervenir la
programmation.

 L'utilisateur peut déplacer le curseur au moyen d'une barre de défilement située
dans la petite fenêtre associée au curseur ou bien en attrapant la poignée du curseur
au moyen de la souris.

 La fenêtre du curseur contient les informations de position du curseur. Ces informations
peuvent prendre diverses formes définies par la propriété WinContent@ .

 Un curseur peut éventuellement être double (Propriété DoubleCursor@ ), il permet alors de
mesurer commodément des différences de position.

 Un curseur doit être associé à un objet descendant de TdataPlot en utilisant
installSource@ .

 Il existe 3 styles de curseur appelés style X, style Y et style Index.
 En style X ou Y, le curseur ne tient pas compte des données contenues dans
l'objet source, sa propriété position@ reflète effectivement l'abscisse ou l'ordonnée
du curseur.
 En style Index (applicable seulement aux descendants de Tvector), le curseur se place
obligatoirement sur un point de l'objet source et sa propriété position@ contient l'indice
de ce point. Si l'on veut connaitre ou modifier l'abscisse ou l'ordonnée correspondante,
il faut utiliser respectivement les propriétés Xposition@ et Yposition@ .


}


  TimageVector(Tvector)
{$H TimageVector permet d'afficher un vecteur dans une fenêtre Multigraph avec des
coordonnées différentes.

 Son constructeur create@ est suffisant pour définir l'objet. On fournit le vecteur
source comme unique paramètre.

 Avec InstallSource@, on peut éventuellement modifier le vecteur source.

 TimageVector se comporte comme un vecteur dont les données sont dans un autre vecteur.
}

  TMTag(TdataObject)
{$H TMtag est le type de l'objet Mtag dans Tdatafile@.

 Cet objet contient les tags manuels. Les tags manuels sont créés au moment de
l'acquisition en frappant certaines touches (actuellement CTRL-0 à CTRL-9).
 On range  dans le fichier de données les dates et les codes (valeurs de 0 à 9)
des touches enfoncées.

 Ces dates et ces codes sont accessibles à la relecture avec les propriétés
times@ et Codes@.
 La propriété Itimes@ permet de lire les dates exprimées en intervalles
d'échantillonnage.
}

  TcolorMap(TdataPlot)
{$H TcolorMap permet d'afficher une carte des couleurs dans une fenêtre Multigraph.

 Cette carte est destinée à faciliter la lecture de matrices affichées à l'écran.
 Pour cela il faut faire coïncider les coordonnées Zmin-Zmax de la matrice avec
les coordonnées Xmin-Xmax ou Ymin-Ymax selon l'orientation choisie pour la carte
des couleurs. Ceci sera fait automatiquement si on donne à la matrice et à la carte
des couleurs le même coefficient de couplage CPZ@ .

 La carte des couleurs ressemble beaucoup à une matrice dont l'une des dimensions
est égale à l'unité. C'est pourquoi on retrouve pratiquement dans cet objet
toutes les propriétés d'une matrice.

 Les propriétés les plus importantes sont PalName@, twoColors@ et PalColor@ .
 Et aussi ColCount@  et direction@ .


}

  Tfont(Tobject)
{$H L'objet Tfont contient les propriétés d'une police de caractères.

 Il n'est pas possible de créer un tel objet mais plusieurs objets tels que Tmultigraph@
ou Tmemo@ contiennent une propriété Font de type Tfont.

 Les propriétés clés sont Name@ , Size@ , Color@ et Style@ .
}

  Tmemo(Tplot)
{$H L'objet Tmemo permet de saisir du texte dans un éditeur et de l'afficher dans une
fenêtre multigraph.


 La propriété Comment@ de TdataFile@ ou de Tacquisition@ est de type Tmemo. Dans ce cas,
Tmemo permet simplement d'accéder au texte du commentaire.

 Tmemo donne aussi un moyen pratique d'afficher du texte sur l'écran multigraph.

 La propriété Lines@ permet d'accéder à une ligne du texte (les indices commencent
à 1). La propriété Font@ permet de modifier la police de caractère.

 Les méthodes insert@ et delete@ permettent respectivement d'insérer ou supprimer
une ligne.
}

  TpolyLine
{$H L'objet Tpolyline permet de gérer une liste ordonnée de couples de nombres (x,y).

 Il n'est pas possible de créer un objet Tpolyline mais l'objet TXYPlot@ (tout comme
son descendant TcontourPlot@) possède une propriété PolyLines@(TXYplot.PolyLine) de type Tpolyline.

 Les couples (x,y) sont les coordonnées de points formant une courbe quelconque que
l'on souhaite afficher dans une fenêtre.

 Pour vider la liste, on appelle Clear@. Pour ajouter un point à la fin de la liste,
on appelle addPoint@.  La propriété count@ indique le nombre de points contenus dans la liste.

 Les propriétés X@ et Y@ permettent d'accéder directement aux coordonnées des points (les
points sont numérotés de 1 à count) .

 Avec LoadFromVectors@ , on peut charger directement une polyline à partir de deux vecteurs

 Avec LoadPolyLine@ , on peut copier une polyline dans une autre.

}

  TXYplot (TdataPlot)
{$H L'objet TXYplot permet d'afficher une ou plusieurs courbes dans une fenêtre.

 Sa finalité est la même que celle de Tgraph@ mais les différences essentielles sont les
suivantes:
 - TxyPlot contient ses propres données et ne fait aucune référence à des objets extérieurs
alors que Tgraph fait référence à des vecteurs qui contiennent les données.

 - TxyPlot permet d'afficher plusieurs courbes à la fois alors que Tgraph permet de
n'en afficher qu'une seule.

 Chaque courbe est définie par un objet de type Tpolyline@ . Ces objets sont contenus dans
la propriété PolyLines@ .

 Après avoir appelé le constructeur create@ , on peut ajouter une courbe avec AddPolyLine@.
 Le nombre de courbes est donné par la propriété count@.

 La méthode Clear supprime toutes les courbes.


}
  TcontourPlot(TXYplot)
{$H TcontourPlot permet de calculer et d'afficher des courbes de niveau, les données
étant contenues dans une matrice.

 Le calcul se fait en appelant Calculate@. On peut appeler cette méthode plusieurs
fois avec des paramètres différents. Chaque calcul n'efface pas le précédent mais ajoute
un nouvel objet Tpolyline@ dans TcontourPlot.

 Avec setOptions@, il est possible d'exclure du calcul certains éléments de la matrice.
}

  TplotVideo(Tplot)

{$H TplotVideo permet de faire défiler une liste d'images dans une fenêtre.

 Une image est formée par un ou plusieurs objets descendant de Tplot@.

 Après l'appel du constructeur create@ ou de la méthode clear@, la liste d'images
est vide.

 On ajoute une image dans la liste avec addPlot@ .
 On peut ensuite compléter cette image en ajoutant des objets avec addPlot2.

 Quand l'objet PlotVideo est rangé dans une fenêtre multigraph, seule l'image
de numéro imageIndex@ est affichée.
 Le menu associé à l'objet PlotVideo contient une commande Show Command.
Cette commande permet de faire apparaitre une fenêtre de commande qui contient
une barre de défilement, et cette barre de défilement permet de changer
rapidement l'image affichée.

}

  TcursorList(TwinObject)
{$H TcursorList permet d'associer une famille de curseurs à un fichier d'événements.

 Typiquement, cet objet permet de résoudre le problème suivant: on vient de détecter des
événements (vecteur evt) sur un vecteur Source. On souhaite visualiser ces détections d'une part
sous la forme de traits verticaux sur les emplacements des détections, d'autre part sous
la forme d'un zoom sur un événement sélectionné. On souhaite également corriger manuellement
les détections, c'est à dire modifier des positions ou encore ajouter ou supprimer un
événement.

 Avec TcursorList, il suffit, après création avec create@ , d'appeler installVevent@ en
donnant le vecteur événements comme paramètre, d'appeler installVdisplay@ avec le vecteur
source comme paramètre et d'appeler installVzoom@ avec pour paramètre un vecteur qui sera
une image du vecteur source.

 TcursorList peut être créé et utilisé manuellement, sans recours à la programmation.

 @b @ul Exemple 1: @notb @notul

 @f6
 @f6 var
 @f6   detect:Tdetect;
 @f6   Clist:TcursorList;
 @f6   zoom:TimageVector;
 @f6
 @f6 procedure test;
 @f6 begin
 @f6   with detect do           (* détecter des événements sur v1 *)
 @f6   begin
 @f6     create('');
 @f6     Height:=10;
 @f6     mode:=sm_max;
 @f6     installSource(v1);
 @f6   end;
 @f6
 @f6   zoom.create('',v1);      (* créer une image de v1 *)
 @f6
 @f6   with Clist do
 @f6   begin
 @f6     create('');
 @f6     installVevent(detect.Vevent);
 @f6     installVdisplay(v1);
 @f6     installVzoom(zoom);
 @f6     show;
 @f6   end;
 @f6  (* On range v1 dans la première fenêtre de la page 1 et zoom dans la seconde fenêtre *)
 @f6   addObject(1,1,v1);
 @f6   addObject(1,2,zoom);
 @f6 end;
 @f6
 @f6 (* A ce stade, on verra un curseur sur v1 placé sur chaque événement détecté alors
 @f6    que le vecteur zoom aura un affichage centré sur l'évenement courant.
 @f6    Les commandes de la fenêtre de Clist permettent de modifier les curseurs,
 @f6    d'en supprimer un ou d'en ajouter un.
 @f6    Toutes les modifications seront immédiatement appliquées à detect.Vevent
 @f6 *)
}

  TsymbPlot(TPlot)
{$H TsymbPlot est l'ancêtre d'une famille d'objets destinés à s'afficher sur un autre objet
(en général sur un vecteur).

 Ces objets sont intéressants pour afficher le résultat de mesures sur un vecteur.

 Parmi les descendants de TsymbPlot, on trouve Tsymbol@, TlineHor@, TlineVer@, Tline@, TlinearFunc@ , Tellipse et TbarSymbol

 Ces objets s'affichent dans une fenêtre Multigraph en utilisant le système de coordonnées
du premier objet de la fenêtre.
 S'il n'y a pas d'autre objet dans la fenêtre avant l'objet TsymbPlot, on considère que le système
de coordonnées est tel que Ymin=-100 et Ymax=+100 . On considère aussi que le rapport d'aspect
est égal à 1.

 Les propriétés communes à ces objets sont color@ et visible@.

 La propriété Visible@ est toujours vraie par défaut. Il peut être commode de lui donner
la valeur False pour masquer l'objet sans le retirer de la fenêtre.
}
  Tsymbol(TsymbPlot)
{$H Objet permettant l'affichage d'un symbole sur un autre objet. Voir TsymbPlot@ .

 Les propriétés x@ et y@ sont les coordonnées du symbole.
 Color@ est sa couleur, size@ est sa taille.
 Style@ définit le type de symbole. Les styles sont les mêmes que ceux qui sont utilisés
 pour afficher un vecteur, on peut donc utiliser les constantes définissant les
(modes d'affichage)@ .Toutefois, certaines constantes ne seront pas utilisables (lignes,
histogrammes, etc...)

}
  Tellipse(TsymbPlot)
{$H  Objet permettant l'affichage d'une ellipse sur un autre objet. Voir TsymbPlot@ .
}

  TbarSymbol(TsymbPlot)
{$H  Objet permettant l'affichage d'une barre sur un autre objet. Voir TsymbPlot@ .
}

  TlineHor(TsymbPlot)
{$H Objet permettant l'affichage d'une ligne horizontale sur un autre objet. Voir TsymbPlot@ .

 La propriété y@ est l'ordonnée de la ligne.
 Color@ est sa couleur, width@ est la largeur du trait.
 Style@ définit le type de trait. Vous pouvez utiliser les constantes (types de trait)@ .
}
  TlineVer(TsymbPlot)
{$H Objet permettant l'affichage d'une ligne verticale sur un autre objet. Voir TsymbPlot@ .

 La propriété x@ est l'abscisse de la ligne.
 Color@ est sa couleur, width@ est la largeur du trait.
 Style@ définit le type de trait. Vous pouvez utiliser les constantes (types de trait)@ .

}
  Tline(TsymbPlot)
 {$H Objet permettant l'affichage d'un segment de droite sur un autre objet. Voir TsymbPlot@ .

 Les propriétés x1@ et y1@ définissent la première extrémité du segment.
 Les propriétés x2@ et y2@ définissent la seconde extrémité du segment.

 Color@ est sa couleur, width@ est la largeur du trait.
 Style@ définit le type de trait. Vous pouvez utiliser les constantes (types de trait)@ .

}
  TlinearFunc(TsymbPlot)
 {$H Objet permettant l'affichage d'une droite quelconque sur un autre objet. Voir TsymbPlot@ .

 Les propriétés a@ et b@ définissent l'équation de la droite y=a*x+b
 Color@ est sa couleur, width@ est la largeur du trait.
 Style@ définit le type de trait. Vous pouvez utiliser les constantes (types de trait)@ .

}
  Twavelet(TwinObject)
{$H Objet permettant la décomposition d'un vecteur en ondelettes.

 C'est en fait une encapsulation de l'objet fourni par la bibliothèque ISPL (Intel Signal Processing Library).

 Pour décomposer un vecteur, il faut d'abord fixer le type d'ondelette utilisée WtType@ ainsi que les paramètres
optionnels Par1@ et Par2@ .

 Ensuite, on appelle Decompose@ . On donne à cette méthode le vecteur à décomposer et le niveau de
décomposition souhaité. Le niveau effectivement utilisé se trouve dans la propriété Level@ .

 Le resultat de la décomposition se trouve dans le vecteur Vtemp@, tel qu'il a été construit par ISPL.
 Ce vecteur contient en fait une succession de blocs de tailles différentes et il n'est pas aisé de
l'utiliser directement. Pour simplifier l'accès aux résultats, nous avons introduit les vecteurs VD@ et VA@ .

 VD[i] contient le ième détail (i doit être compris entre 1 et Level)
 VA contient la dernière approximation ( de rang Level )

 En appelant Reconstruct@, on reconstruit le vecteur de départ. Le résultat sera identique au vecteur original
si on n'a pas modifié Vtemp. Mais en général, on modifiera Vtemp@ (à travers VD et VA) afin d'effectuer
un traitement adéquat du signal.

 Scalogram@ permet de construire directement un scalogramme. Le scalogramme est une matrice
dont chaque ligne i contient soit l'approximation de rang i, soit une reconstruction basée sur
l'approximation de rang i.

}

  TmatList(TdataPlot)
{$H TmatList permet de gérer une liste de matrices.
  Son comportement est très semblable à celui de TVlist@ .

  Une liste peut être considérée comme un tableau à une dimension dont la taille
peut être modifiée dynamiquement.

  Une fois l'objet créé avec Create@ , il est possible d'ajouter des matrices à
la liste avec AddMatrix@ ou InsertMatrix@.
  La méthode AddMatrix crée un clone de la matrice donnée comme paramètre et range cette
nouvelle matrice à la fin de la liste.
  La méthode InsertMatrice crée un clone de la matrice donnée comme paramètre et range cette
nouvelle matrice dans la liste, dans une position donnée comme paramètre.
  Ensuite, il est possible de manipuler les matrices de la liste avec la propriété M@ .

  La méthode DeleteMatrice@ permet de supprimer une des matrices de la liste.
}

  TmatAverage(Tmatrix)

{$H TmatAverage permet de moyenner des matrices.

 C'est l'équivalent de Taverage@ pour les vecteurs.

 TmatAverage doit d'abord être initialisé en appelant son constructeur create@ (on
utilisera de préférence un type de nombre réel: t_single ou t_double) et en fixant les
paramètres d'échelle suivant X.

 Ensuite, les méthodes add@ ou addEx@ permettent d'accumuler une matrice dans la
moyenne. Reset@ permet la remise à zéro de la moyenne alors que count@ indique
le nombre de matrices accumulées.

 Pendant le calcul, on peut aussi calculer les matrices MStdDev@ , MstdUp@ et MstdDw@
qui contiendront respectivement l'écart-type, la moyenne augmentée de l'écart-type
et la moyenne diminuée de l'écart-type.

 Pour activer ce calcul, il faut mettre la propriété StdOn@ à true.
}

  Toptimizer(Tobject)
{$H Toptimizer est un outil d'optimisation.

 On considère un système à plusieurs entrées et une seule sortie. Le signal de sortie (un vecteur)
est donc une fonction des vecteurs d'entrée.
 Toptimizer permet de rechercher les paramètres du modèle connaissant les entrées et la sortie.
 La méthode de recherche est celle de Marquard-Levenberg.

 Pour l'utiliser, la première étape consiste en l'écriture d'un modèle dans un fichier séparé.

 @ul @b Ecriture du modèle : @notul @notb

 La syntaxe est assez proche de celle du Pascal. Voici un exemple de modèle :

 @f6   Var
 @f6     x1,x2:Tvector;
 @f6     y1,y2,y:Tvector;
 @f6     h1,h2:TlinearFilter(10);
 @f6     a0:real;
 @f6     f0:TNL1filter;

 @f6   Model
 @f6    y1:=h1(x1);
 @f6    y2:=h2(x2);
 @f6    y:=f0(y1+y2)+a0;

  Le premier bloc contient des déclarations et le second contient le modèle proprement dit.
  L'écriture du modèle fait clairement apparaitre les entrées x1 et x2, et la sortie y.
  y1 et y2 sont des variables intermédiaires.

  h1, h2 et f0 sont des filtres alors que a0 est un paramètre réel. Il existe un
certain nombre de filtres (définis ci-dessous) . Certains filtres ont un nombre de
paramètres fixe (comme TNL1filter), d'autres ont un nombre de paramètres fixé dans la déclaration
(comme TlinearFilter).

 @ul @b Types de filtres @notul @notb
     Voici les filtres disponibles. Entre parenthèses, on indique les paramètres à indiquer dans
la déclaration.

 @ul TlinearFilter(Ncoeff) @notul
     Filtre linéaire défini par les Ncoeff points de sa réponse impulsionnelle

 @ul TlinearFilter2(Ncoeff,K) @notul
     Filtre linéaire défini par Ncoeff coefficients. K est un facteur de compression
     Le nombre de points de la réponse impulsionnelle est K*Ncoeff. La réponse impulsionnelle
est construite avec les Ncoeff coefficients mais avec un intervalle d'échantillonnage K fois
plus grand que celui du signal. Dans les calculs, on intercale des points par interpolation linéaire.

 @ul TlinearFilterP(Ncoeff,Nlin) @notul
     Filtre linéaire défini par Ncoeff coefficients d'un polynôme.
     Nlin est le nombre de points de la réponse impulsionnelle.

 @ul TNL1Filter @notul
     Filtre statique : la sortie est donnée par y:=g0*th(x)^alpha + Cte
     th est une fonction seuil qui met à zéro les parties négatives
     Les paramètres sont g0, alpha et Cte

 @ul TNL2Filter @notul
     Filtre statique : la sortie est donnée par y:=g0*abs(x)^alpha
     abs prend la valeur absolue de x
     Les paramètres sont g0 et alpha

 @ul TstaticFilter(Nval,min,max) @notul
     Filtre statique : la sortie est donnée par y:=f(x)
     La fonction f est définie par Nval points régulièrement espacés entre les abscisses min et max

 @ul TpolyFilter(Nval) @notul
     Filtre statique : la sortie est donnée par y:=f(x)
     La fonction f est définie par un polynôme ayant Nval coefficients


 @ul TsynDep @notul

 @ul TLPRfilter(mode) @notul
     Module correspondant au schéma ci-dessous:
     @(@ d:\delphe5\LPRfilter.bmp)


     La sortie attaque un circuit redresseur (x²) suivi d'un filtre passe-bas (LP). Le signal obtenu
divise le signal d'entrée.

     Les équations suivantes permettent de calculer la sortie y en fonction de l'entrée x
 @f6         w(i) = y(i-1)²
 @f6         z(i) = (1-b)*w(i) + b*z(i-1)
 @f6         y(i) = G*x(i)/(z(i)+C)

     b , G et C sont les paramètres du modèle

     b est le paramètre du filtre passe-bas. Il est lié à la constante de temps Tau du filtre par la relation
 @f6         b = exp(-1/tau)
     G est le gain du système
     C est une constante positive destinée à éviter la valeur zéro au dénominateur


 @ul THLPRfilter(mode) @notul
     Module correspondant au schéma ci-dessous:
     @(@ d:\delphe5\HLPRfilter.bmp)

     Les modules "x²" redressent leur entrée
     LP est filtre passe-bas du premier ordre
     H calcule la transformée de Hilbert de son entrée
     Le module sqrt est optionnel, suivant la valeur de mode. Il calcule simplement la racine de l'entrée.
       mode=0 , on prend la racine
       mode=1 , on ne prend pas la racine.

     Les équations suivantes permettent de calculer la sortie y en fonction de l'entrée x

 @f6         w(i) = sqrt( y(i-1)² +u(i-1)² )   ou w(i) = y(i-1)² +u(i-1)²
 @f6         z(i) = (1-i)*w(i) + b*z(i-1)
 @f6         y(i) = G*x(i)/(z(i)+C)
 @f6         u(i) = G*Hilbert(x)(i)/(z(i)+C)

     b , G et C sont les paramètres du modèle

     b est le paramètre du filtre passe-bas. Il est lié à la constante de temps Tau du filtre par la relation
 @f6         b = exp(-1/tau)
     G est le gain du système
     C est une constante positive destinée à éviter la valeur zéro au dénominateur


 @ul TlowPassFilter2(Nlin) @notul
     Filtre passe-bas du premier ordre dont la constante de temps tau est contrôlée par une entrée.
     La réponse impulsionnelle s'écrit exp(-t/tau)/tau
     Nlin est le nombre de points de la réponse impulsionnelle
     Il n'y a pas de paramètre à optimiser
     Le modèle s'écrit y:=f0(y1,y2) , y1 étant le vecteur d'entrée, y2 étant le vecteur contenant la
constante de temps.

 @ul TlowPassFilter2B  @notul

 @ul TlowPassFilter2C  @notul

 @ul TRCcell           @notul


 @ul @b Utilisation du modèle : @notul @notb

     Une fois le modèle écrit, le programme Elphy peut l'utiliser pour effectuer une simulation
ou une optimisation:

 @ul Simulation  @notul
  Voici un exemple de simulation:

  @f6   with opti do
  @f6   begin
  @f6     create('');

  @f6     loadFromFile(stModele);
  @f6     if not compile then halt;

  @f6     setVector('x1',c1);
  @f6     setVector('x2',c2);

  @f6     setParams(Vparam);

  @f6     calculateOutput('y');

  @f6     getVector('y',c3);
  @f6     getVector('y1',c5);
  @f6     getVector('y2',c6);

  @f6   end;

  On crée un objet opti de type Toptimizer. On charge le modèle avec LoadFromFile@ et
on le compile avec Compile@ .
  Ensuite, on remplit les vecteurs d'entrées avec setVector@ et on fixe les paramètres avec setParams@.
Le vecteur de paramètres Vparam doit contenir les paramètres du modèle dans l'ordre de déclaration.
 Dans l'exemple ci-dessus, il y a 24 paramètres:
   10 pour h1
   10 pour h2
   1  pour a0
   3 pour f0

 CalculateOutPut@ calcule un vecteur de sortie
 GetVector@ permet de récupérer le contenu des vecteurs de sortie.

 @ul Optimisation  @notul
  Voici un exemple d'optimisation:

 @f6   with opti do
 @f6   begin
 @f6     create('');
 @f6     maxIt:=1;

 @f6     loadFromFile(stModele);
 @f6     if not compile then halt;

 @f6     setVector('x1',c1);
 @f6     setVector('x2',c2);

 @f6     setParams(Vparam);

 @f6     cnt:=0;
 @f6     repeat
 @f6       oldChi2:=chi2;
 @f6       optimize('y',c3);
 @f6       getParams(Vparam);
 @f6       getVector('y',c4);
 @f6       c3.invalidate;
 @f6       c4.invalidate;
 @f6       Vparam.invalidate;
 @f6       update;
 @f6       inc(cnt);
 @f6       statuslineTxt('cnt='+Istr(cnt,0)+'  chi2='+Rstr(chi2,10,6));
 @f6     until (abs(chi2-oldChi2)/chi2< 0.001) or (chi2<0.00001) ;
 @f6   end;

 L'initialisation est semblable à l'initialisation de la simulation.
 Ensuite, il suffit d'appeler Optimize@ pour optimiser les paramètres du modèle.
 Dans l'exemple ci-dessus, nous avons fixé le nombre d'itérations à 1 avec maxIt@ ,
et nous avons écrit une boucle pour répéter l'opération. Ceci permet de visualiser
la progression de l'algorithme.

}

  Tmacro(Tobject)
{$H Tmacro gère un programme défini par l'utilisateur

 Le programme principal, accessible dans l'éditeur de texte avec Analysis/Programming est géré par un
objet de type Tmacro appelé PG0
 Pour travailler seulement avec PG0, il n'est pas nécessaire de connaitre les méthodes et propriétés de Tmacro.
 On utilise les commandes du menu pour compiler le fichier texte puis pour appeler les différentes commandes du fichier pg2.

 Dans le programme principal, il est possible de déclarer des objets Tmacro.
 Nous appelons couramment ces objets des programmes secondaires
 Par exemple:
@prog
   var
      pgSec1: TPG2;
@notprog
 En appelant ensuite pgSec1.create(AfileName) ,le fichier texte de nom AfileName (extension PG2) est chargé et compilé.
 Un message d'erreur est généré si le texte n'est pas correct.
 Si le fichier est déjà compilé dans un fichier à jour .pgc ou .pgc64 , cette compilation est directement chargée en mémoire.

 Le code compilé peut ensuite être exécuté avec executeCommand@
@prog
 pgSec1.executeCommand('Init');
@notprog
 Dans cet exemple, 'Init' doit apparaitre dans une ligne comme 'Program Init'

 Les programmes secondaires sont donc des modules compilés séparément que l'on peut appeler à partir du programme principal.
 Dans la version actuelle, il n'est pas possible de transmettre des paramètres au moment de l'appel.
 Toutefois, comme les objets permanents (multigraph0, RealArray0, DataFile0...) sont accessibles à partir de n'importe quel
programme, on utilise souvent RealArray0 pour transmettre des paramètres numériques d'un programme à un autre.

 Une autre méthode possible est la suivante:
 - on déclare un objet de type TDBrecord@ dans le programme principal
@prog
   var
      DB0: TDBrecord;
@notprog
 - le programme principal peut accéder aux champs de l'objet avec l'écriture habituelle
@prog
   DB0.Height:= 125;
@notprog
 - les programmes secondaires peuvent accéder à ces champs avec l'écriture
@prog
   TDBrecord('DB0').Height
@notprog
 DB0 n'existe pas dans le programme secondaire mais cette écriture permet de rechercher un objet de nom DB0 et de type TDBrecord

 


}

  Tregion(Tobject)
{$H Tregion représente une région élémentaire (rectangle, ellipse, polygone ou liste de pixels).

 Cet objet est utilisé par TregionList@ et ne possède pas de constructeur.

 Un objet Trégion permet de délimiter une zone particulière dans une matrice (Tmatrix@), une image (TbitmapPlot@)
ou une séquence d'images (TOIseq@)
 Les coordonnées d'une région sont toujours exprimées en pixels.

 Le type de région RegType@ peut avoir l'une des valeurs suivantes
     1: Rectangle
     2: Ellipse
     3: Polygone
     4: Liste de pixels.

 Les trois premiers types de région peuvent être créés manuellement en utilisant la fenêtre de sélection pour une matrice
(commande 'Show select window') ou la fenêtre de l'objet (commande 'Show') pour une image ou une liste d'images.

 Le type "Liste de pixels" ne peut être créé que par programme, par exemple au moyen de
CreateRegionFromMatrix@(TregionList.createRegionFromMatrix)

 L'extension de la région est donnée par les propriétés width@ et height@ : quel que soit le type de région, ces propriétés donnent la largeur et
la hauteur du plus petit rectangle contenant tous les pixels de la région. La position de ce rectangle
est donnée par les propriétés left@ et top@ .

 La propriété PixCount@ donne le nombre de pixels contenus dans la région. Les propriétés Xpix@ et Ypix@
donnent les coordonnées de tous les pixels de la région. Dans ces listes, les pixels sont rangés
ligne par ligne.

 Color@ est la couleur d'affichage.

 Les méthodes utiles sont Move@ et MoveAbs@ qui permettent de changer la position de la région.

}
  TregionList(Tdataplot)
{$H TregionList permet de gérer une liste de régions (Tregion@)

 C'est un descendant de TdataPlot@ , ce qui signifie que l'on peut afficher l'objet seul dans une fenêtre
et choisir les coordonnées comme on l'entend. Mais en fait, TregionList est plutôt destiné à être affiché
par dessus un autre objet (matrice, image ou séquence d'images) .

 Son comportement à l'affichage a ceci de particulier: TregionList utilise toujours les coordonnées fichier de l'objet
situé en arrière-plan s'il existe.

 Count@ donne le nombre de régions de la liste
 Region@ (de type Tregion@) permet d'accéder à chaque région de la liste
 DefColor@ est la couleur par défaut: chaque nouvelle région créée utilisera cette couleur.

 Clear@ efface toutes les régions.
 CreateRectRegion@ ajoute une région rectangulaire à la liste
 CreateEllipseRegion@ ajoute une région elliptique à la liste
 Add@ permet d'ajouter une région appartenant à une autre liste
 Copy@ permet de copier une autre liste.
}

  Timage(Tplot)
  TbitmapPlot(TdataObject)


  TstatusBar(Tobject)
{$H
  L'objet Tstatusbar permet d'ajouter une ou plusieurs barres d'état dans le bas de la fenêtre
principale de Elphy.

  Une barre d'état comprend un ou plusieurs compartiments (panels) permettant d'afficher des informations.

  Voici un exemple d'utilisation:

 @f6        var
 @f6          status1:TstatusBar;
 @f6          i:integer;
 @f6
 @f6        program 'Create'
 @f6
 @f6        with status1 do
 @f6        begin
 @f6          create(5);
 @f6          setPanelProp(1,80,2,2,'Height');
 @f6          setPanelProp(2,80,2,1,'58');
 @f6          setPanelProp(3,80,2,2,'Width');
 @f6          setPanelProp(4,80,2,1,'85');
 @f6          height:=30;
 @f6          font.size:=12;
 @f6          font.style:=fs_bold;
 @f6        end;
 @f6
 @f6        hideSystemStatusBar;
 @f6
 @f6        program 'Play'
 @f6
 @f6        Repeat
 @f6          inc(i);
 @f6
 @f6          status1.text[2]:=Istr(randomI(100));
 @f6          status2.text[4]:=Istr(randomI(1000));
 @f6
 @f6        until i>10000;


 Dans le constructeur create@ , on indique le nombre de panels souhaités.
 Ensuite, pour chaque panel, on fixe les paramètres (largeur en pixels,
alignement du texte, type de biseau et texte).
 Optionnellement, on peut changer la hauteur de la barre (height@) et le jeu de caractères utilisés (font@).
 La propriété text@ permet de modifier le texte affiché dans chaque panel.
}

  TArrowPlot (TdataPlot)
 {$H Permet d'afficher des données sous la forme d'un champ de vecteurs.

 Voici un exemple:

  @(@ d:\delphe5\arrows.bmp)

 Après avoir créé l'objet ( constructeur create@ ), il suffit d'appeler AddPoint@ pour chaque flêche que l'on veut afficher.

 Pour chaque flèche, on peut définir l'origine, la longueur de la flêche, sa couleur et les dimensions de la pointe. 
 } 

  TvectorSpk (Tvector)
{$H Objet gérant les vecteurs d'événements du type CyberKinetics (BlackRock MicroSystems).

 Actuellement, c'est un objet sans constructeur. Seul l'objet TdataFile@ contient une propriété Vspk du type TvectorSpk.

 Un objet TvectorSpk se comporte comme un vecteur d'événement mais, de plus, à chaque événement est associé un attribut
(nombre entier compris entre 0 et 255).
 Pour le système d'acquisition CyberKinetics, cet attribut est le numéro d'unité donné par le mécanisme de tri automatique.
 La propriété Uvalue@ renvoie la valeur de cet attribut.

 Pour l'affichage, chaque événement pourra être affiché avec une couleur correspondant à son attribut. Pour cela, il faut
que la propriété UseStdColors@ vaille TRUE.

 TvectorSpk contient un tableau de propriétés VU@ de type Tvector. Chaque vecteur VU[n] contient les événements
d'attribut n.

}
  TwaveList  (Tvector)
{$H Objet gérant les listes de spikes obtenues avec le système CyberKinetics (BlackRock MicroSystems).

 Actuellement, c'est un objet sans constructeur. Seul l'objet TdataFile@ contient une propriété Wspk du type TwaveList.

 L'objet TwaveList se présente comme un vecteur auquel on associe une propriété Index@ .
 Quand on change la valeur du nombre entier Index@ , on modifie le contenu du vecteur, pas sa structure
 Index doit être compris entre 1 et MaxIndex@

 Dans l'objet TdataFile@, les propriétés Vspk@(Tdatafile.Vspk) et Wspk@(Tdatafile.Wspk) correspondent étroitement: Vspk[n] contient les temps des spikes
sur l'électrode n alors que Wspk[n] contient les waveforms correspondantes.

 TwaveList contient un tableau de propriétés WU@ de type TwaveList. Chaque WaveList WU[n] contient les waveforms correspondant
à l'attribut n.

}

  TspkTable (Tobject)
{$H Objet pouvant contenir tous les attributs des spikes( numéros d'unité ) contenus dans un objet TdataFile@ .

 La propriété clé est la propriété Att@ . L'élément Att[Ep,Ch,n] représente l'attribut du n-ème spike dans l'épisode Ep sur
le canal ch . Tous les indices commencent à 1.
 EpCount@ représente la première dimension.
 ChCount@ resprésente la deuxième dimension.

 De nouvelles méthodes ont été ajoutées à TdataFile@ pour gérer les objets TspkTable:

 Nous insistons sur le fait que TspkTable ne contient que les numéros d'unité et pas les dates des spikes. On ne peut donc
l'utiliser qu'en association avec un fichier de données.

 Pour initialiser une table, on peut appeler TdataFile.initSpkTable@(TdataFile.initSpkTable) , ce qui a pour effet de dimensionner la table suivant le
contenu du fichier de données courant.

 Avec TdataFile.setSpkTable@(TdataFile.setSpkTable) , on établit le lien entre le fichier de données et la table. Tous les spikes (objets Vspk et Wspk de TdataFile@)
utiliseront ensuite le contenu de la table plutôt que les attributs rangés dans le fichier.

 La méthode TdataFile.AppendObject@(TdataFile.AppendObject) permet de ranger une table à la fin du fichier de données.

 La méthode TdataFile.loadSpkTable@(TdataFile.loadSpkTable) permet ensuite d'établir le lien entre le fichier de données et la n-ième table stockée dans le fichier.

 La méthode LoadFromNexFile@ permet de charger le contenu d'un fichier NEX ( Plexon/NeuroExplorer ).
}

  TRasterPlot (TdataPlot)
{$H TrasterPlot permet d'afficher plusieurs vecteurs d'événements sans se soucier de leur positionnement vertical.

  L'utilisation de TrasterPlot est très simple: il suffit de ranger l'objet dans une fenêtre Multigraph@Tmultigraph , puis de ranger les vecteurs
d'événements dans la même fenêtre.
  Dans la fenêtre, TrasterPlot doit être le premier de la liste pour pouvoir travailler correctement.
  Son rôle est de contrôler l'affichage des vecteurs d'événements en imposant les coordonnées.

  La propriété LineHeight@ définit l'intervalle entre les lignes (en pixels )
  La propriété Ftitle@ permet d'imposer l'affichage du nom des vecteurs dans la partie gauche de la fenêtre.
  La propriété TitleWidth@ indique la largeur de l'espace réservé à ces noms (en pixels)

  Parmi les propriétés héritées de TdataPlot@ , les propriétés utiles sont Xmin@, Xmax@, Xscale@, Xticks@, TopTicks@, SymbolSize@ et
Cpx@ . Les autres sont sans effet.


}
   ThexaPlot(TxyPlot)
{$H ThexaPlot est un descendant de TxyPlot permettant de représenter commodément un réseau de maille hexagonale.

  Un tel réseau est utilisé dans le protocol HEXAGABOR

  On considère un repère normé xOy dont les axes Ox et Oy forment un angle de 60 degrés, et on considère tous les points
d'abscisse et d'ordonnée entière situés à une distance du centre inférieure ou égale à une valeur fixée (Order@)

  Quand on crée l'objet (constructeur create@), on donne un argument qui fixe la valeur de Order.
  Dans l'exemple ci-dessous , on considère le réseau d'ordre 3

  @(@ d:\delphe5\HexaMaille.bmp)

  On vérifiera que le nombre de points est  37
  A chacun des points, on va faire correspondre un nombre rangé dans la propriété Zvalue@
  Les arguments de Zvalue sont les coordonnées du point dans le repère xOy

  A l'affichage, chaque point du réseau sera représenté par un petit hexagone coloré centré sur le point.
  La couleur correspondra à Zvalue, en tenant compte de l'échelle de couleur (voir Zmin@, Zmax@, PalColor@, PalName@, etc...)

  @(@ d:\delphe5\HexaPlot.bmp)

  Avec BuildContour@ , on peut construire les contours correspondant à un certain seuil 

}

   TserialCom(Tobject)
{  Permet de gérer un port série
}

end; { Fin des objets }

type
  Tprocedure= procedure;
  
  Tprocedure1=procedure(num:longint);
  Tprocedure2=procedure(num1,num2:longint);
  Tprocedure2I1F=procedure(num1,num2:longint; w:real);

  TsetPointColor=procedure(ind:longint;var col:longint);
  TonDragDrop=procedure(var v:Tvector;x,y:real);
  TmatSelect=procedure(var mat:Tmatrix;x,y:integer);
  TmatHint=procedure(var mat:Tmatrix;x,y:real;var stH:string);
  TVAHint=procedure(var va:TvectorArray;x,y:real;var stH:string);

  TVlistSelect=procedure(var Vlist:TVlist0;n:integer);
  TgetK=function(t, z:integer;w:real):real;
  TPlotMgClick = procedure (var mg: Tmultigraph; var plot: TPlot);
  TpopupClick = procedure (var plot: TPlot);

  TfunctionB = function: boolean;

Hpage ProcModels; {Modèles de procédures}

{$P Les modèles suivant sont utilisés dans les différents gestionnaires d'événements

 @f6  Tprocedure=procedure;
 @f6  Tprocedure1=procedure(num:longint);
 @f6  Tprocedure2=procedure(num1,num2:longint);

 @f6  TsetPointColor=procedure(ind:longint;var col:longint);
 @f6  TonDragDrop=procedure(var v:Tvector;x,y:real);
 @f6  TmatSelect=procedure(var mat:Tmatrix;x,y:integer);
 @f6  TmatHint=procedure(var mat:Tmatrix;x,y:real;var stH:string);
 @f6  TVAHint=procedure(var va:TvectorArray;x,y:real;var stH:string);

 @f6  TVlistSelect=procedure(var Vlist:TVlist0;n:integer);
 @f6  TgetK=function(t, z:integer;w:real):real;
 @f6  TPlotMgClick = procedure (var mg: Tmultigraph; var plot: TPlot);
 @f6  TpopupClick = procedure (var plot: TPlot);

}


                         { Tobject }
procedure Tobject.free;
{$H Quand un objet devient inutile, le programme peut le détruire en appelant sa
méthode free. Ceci permet de libérer de la mémoire.

 La méthode n'a aucun effet sur les objets créés manuellement.

 Les objets créés par programme sont détruits automatiquement quand on recompile ou
quand on réinitialise le programme. Un objet est aussi détruit quand on appelle une
seconde fois son constructeur create.
}
Property Tobject.SysName:string readOnly;
{$H Tous les objets possèdent un nom. Ce nom est donné au moment de la création
de l'objet soit dans le menu Objects/New si l'utilisateur a créé l'objet
" manuellement ", soit comme paramètre du constructeur create si l'objet a été créé
par le programme.

 Ce nom apparait dans l'inspecteur d'objets.

 Deux objets ne peuvent avoir le même nom.

 Lorsque dans l'appel du constructeur create, on indique une chaîne vide, on laisse
le système donner un nom par défaut à l'objet. Ce nom est formé par le nom du type
de l'objet auquel on adjoint le premier numéro disponible.
}


property Tobject.tag:longint;
{$H La propriété Tag permet d'identifier commodément un objet, en particulier
lorque l'on utilise des gestionnaires d'événement.

 Tag vaut zéro par défaut. On peut lui attribuer n'importe quelle valeur entière.

}

procedure Tobject.clone(var modele:Tobject);
procedure Tobject.clone(st:String;var modele:Tobject);
{$H Crée l'objet puis charge tous les paramètres et toutes les données de l'objet Modele.

 Modele doit être du même type que l'objet.
 Si l'objet existe déjà, il est d'abord détruit puis recréé.

 Quand l'objet existe déjà, on obtient le même résultat en utilisant CopyObject@ ,
sans les inconvénients de l'opération destruction-création.
}

procedure Tobject.copyObject(var modele:Tobject;Fdata:boolean);
{$H Charge tous les paramètres de l'objet Modele puis, si Fdata vaut True, charge toutes ses données.

 Modele doit être du même type que l'objet.

 La méthode Clone@ donnera le même résultat, même si l'objet n'a pas été créé.
}

procedure TObject.load(var obF:TobjectFile);
{$H Charge un objet à partir d'un fichier d'objets.

 ObF est du type TobjectFile@ . Le fichier doit avoir été ouvert au moyen de la méthode
OpenFile@(TobjectFile.OpenFile) .

 L'inconvénient de cette méthode est qu'une erreur d'exécution est générée si le
chargement de l'objet est impossible. Ce qui n'est pas toujours souhaitable.
 La méthode load1@ a le même effet mais n'arrête pas le programme en cas de
chargement impossible.

 Il est équivalent d'utiliser (TobjectFile.load)@(TobjectFile.load)
}
function TObject.load1(var obF:TobjectFile):boolean;
{$H Charge un objet à partir d'un fichier d'objets.

 ObF est du type TobjectFile@ . Le fichier doit avoir été ouvert au moyen de la méthode
OpenFile@(TobjectFile.OpenFile) .

 La fonction renvoie true si l'objet a été chargé correctement, false dans le cas
contraire. En particulier, la fonction renvoie false si le type de l'objet du fichier ne
correspond pas au type de la variable obF.

 Il est équivalent d'utiliser (TobjectFile.load1)@(TobjectFile.load1)
}

procedure TObject.save(var obF:TobjectFile);
{$H Sauve un objet dans un fichier d'objets.

 ObF est du type TobjectFile@ . Le fichier doit avoir été ouvert au moyen de la méthode
CreateFile@(TobjectFile.OpenFile) .

 Il est équivalent d'utiliser (TobjectFile.save)@(TobjectFile.save)
}



procedure TObject.loadObject(stF:string);
{$H Charge l'objet à partir du fichier d'objets de nom stF

 Le premier objet du fichier doit être du même type que celui de l'objet
sinon une erreur est générée.

}

procedure TObject.SaveAsObject(stF:string);
{$H Sauve l'objet dans un fichier d'objets de nom stF.

 Si le fichier existe déjà, il est effacé.
}
property Tobject.stCom:string;
{$H Commentaire associé à l'objet.

 StCom est une chaine de caractères permettant de stocker des informations dans
l'objet sous forme de texte.
}

function Tobject.getIndex(num:integer):integer;
{$H Lorsque l'object fait partie d'un tableau, cette fonction permet d'accéder aux différents indices.

 Exemple: si une variable a été déclarée x: array[1..5, 1..12] of Tvector,
 getIndex(1) renvoie le premier indice dans le tableau, getindex(2) renvoie le second indice

 La fonction se base sur le nom de l'objet pour renvoyer cette information
}


procedure DragDropObject(var w:Tobject);
procedure InstallShortcut(proc:Tprocedure;vk1,vk2:longint);
{$H Permet d'installer un raccourci clavier.

 vk1 doit être une somme des constantes définissant les
(codes clavier)@(codes clavier et souris), à savoir ss_ctrl, ss_shift ou ss_alt

 vk2 doit être le code Windows ( (Virtual key codes)@ ) correspondant à une touche du
clavier. Pour les touches correspondant à un caractère ASCII, ce code est simplement
le code ASCII du caractère (en majuscules).

 Proc est une procédure sans paramètre écrite par l'utilisateur.
 Une fois le raccourci installé, la procédure sera appelée à chaque fois que
l'utilisateur appuiera sur la ou les touches définies par vk1 et vk2.

 Exemple:

 @f6 procedure proc1;
 @f6 begin
 @f6   ....
 @f6 end;
 @f6

 @f6 procedure proc2;
 @f6 begin
 @f6   ....
 @f6 end;
 @f6

 @f6 InstallShortcut(proc1,ss_alt,ord('K');
 @f6 ALT+K entrainera l'appel de proc1
 @f6
 @f6 InstallShortcut(proc2,ss_ctrl+ss_shift,ord('X');
 @f6 CTRL+SHIFT+K entrainera l'appel de proc2

 InstallShortcut1@ est une variante de InstallShortcut .

 Essayons....
}
procedure InstallShortcut1(proc:Tprocedure2;vk1,vk2:longint);
{$H Permet d'installer un raccourci clavier.

 Le fonctionnement est le même que celui de InstallShortcut@ mais la procédure
proc fournie comme paramètre doit posséder 2 paramètres de type longint;

 Cette procédure recevra les valeurs vk1 et vk2 fournies au moment de l'installation.
 De cette façon, l'utilisateur peut écrire une seule procédure de gestion des
événements clavier pour plusieurs combinaisons de touches.

 Exemple

 @f6 procedure KB(num1,num2:longint);
 @f6 var
 @f6   k:integer;
 @f6 begin
 @f6   k:=num2-ord('1')+1;
 @f6   case k of
 @f6     1: begin
 @f6          ...
 @f6        end;
 @f6     2: begin
 @f6          ...
 @f6        end;
 @f6   end;
 @f6 end;
 @f6

 @f6 InstallShortcut1(KB,ss_alt,ord('1');
 @f6 InstallShortcut1(KB,ss_alt,ord('2');
}

procedure ResetShortcuts;
{$H Supprime tous les raccourcis mis en place avec InstallShortcut@ ou InstallShortcut1@ 
}

                         { stmData0 Tdata0=TwinObject }

procedure TwinObject.show;
{$H Provoque l'affichage de la fenêtre propre à l'objet.

 Le bouton Show de l'inspecteur d'objets appelle cette procédure.
 La fenêtre peut être cachée au moyen de Hide@ .
}
procedure TwinObject.hide;
{$H Cache la fenêtre propre à l'objet.

 La fenêtre peut être rendue visible à nouveau au moyen de Show@ .
}

procedure TwinObject.invalidate;
{$H Oblige l'objet à se réafficher.
}


property TwinObject.WinTop:integer;
{$H Ordonnée du coin en haut à gauche de la fenêtre propre à l'objet

 L'ordonnée zéro est en haut de l'écran.
}
property TwinObject.WinLeft:integer;
{$H Abscisse du coin en haut à gauche de la fenêtre propre à l'objet

}
property TwinObject.WinWidth:integer;
{$H Largeur de la fenêtre propre à l'objet

}
property TwinObject.WinHeight:integer;
{$H Hauteur de la fenêtre propre à l'objet

}

property TwinObject.BKColor:integer;
{$H Couleur de fond de la fenêtre propre à l'objet.
}

                         { stmPlot1 Tplot }

property Tplot.title:string;
{$H Titre apparaissant dans la fenêtre d'affichage}

procedure Tplot.refresh;
{$H Force l'objet à se réafficher immédiatement dans toutes les fenêtres
ou il se trouve}
procedure Tplot.invalidate;
{$H Quand un objet est invalidé, il se réaffichera dés que possible, c'est-à-dire
lorsque les calculs en cours seront terminés ou bien lorsque la mise à jour de l'objet
multigraph sera demandée au moyen de la méthode Update .
}

property Tdataplot.font:Tfont readOnly;
{$H Définit la police de caractères utilisée pour l'affichage des coordonnées.

 Voir Tfont@ .
}

procedure Tplot.resetUserPopUp;
{$H Efface les rubriques du menu popup ajoutées par l'utilisateur.

 Voir AddUserPopUpItem@
}

procedure Tplot.AddUserPopUpItem(st:string; ad:TpopupClick);
{$H Ajoute une rubrique au menu popup de l'objet.

 Le menu popup est le menu surgissant qui apparait, par exemple, quand on fait un clic droit dans une fenêtre multigraph contenant l'objet.

 st est le texte qui s'affiche dans le menu.
 ad est une procédure écrite par l'utilisateur, qui doit correspondre au modèle donné par TpopupClick@ProcModels

  @f6  TpopupClick = procedure (var plot: TPlot);
}

property TPlot.OnMgClick: TPlotMgClick;
{$H Gestionnaire d'événement appelé quand l'utilisateur clique dans une fenêtre Multigraph@(Tmultigraph)
contenant l'objet.

 Pour utiliser ce gestionnaire d'événement, il faut écrire une procédure correspondant au modèle TdataPlotMgClick@ProcModels
 Exemple:
 @f6    procedure MyProc(var mg: Tmultigraph; var plot: TPlot);

 Ensuite il faut affecter cette procédure à la propriété MgClick.
 Exemple:
 @f6    v1.MgClick:= MyProc;

 La procédure reçoit comme paramètres l'objet multigraph et l'objet plot, ce qui permet d'identifier
clairement les circonstances du clic.
}


                         { stmDplot TdataPlot }

property TdataPlot.unitX:string;
{$H Définit le nom des unités suivant l'axe horizontal. }

property TdataPlot.unitY:string;
{$H Définit le nom des unités suivant l'axe vertical. }


procedure TdataPlot.SetWorld(x1,y1,x2,y2:real);
{$H Définit le système de coordonnées dans lequel s'affiche l'objet.

 x1 et y1 sont les coordonnées du point situé en bas à gauche de la fenêtre d'affichage.
 x2 et y2 sont les coordonnées du point situé en haut à droite de la fenêtre d'affichage.

 Il revient au même d'affecter directement les propriétés Xmin@ , Ymin@ ,Xmax@ et Ymax@ .
}

procedure TdataPlot.GetWorld(var x1,y1,x2,y2:real);
{$H Permet d'obtenir le système de coordonnées dans lequel s'affiche l'objet.

 x1 et y1 sont les coordonnées du point situé en bas à gauche de la fenêtre d'affichage.
 x2 et y2 sont les coordonnées du point situé en haut à droite de la fenêtre d'affichage.

 Il revient au même d'utiliser directement les propriétés Xmin@ , Ymin@ ,Xmax@ et Ymax@ .
}


property TdataPlot.Xmin:real;
{$H L'affichage standard de l'objet se fait dans un système de coordonnées défini par
Xmin@ , Ymin@ , Xmax@ et Ymax@.

Xmin est l'abscisse des points situés sur le bord gauche de la fenêtre d'affichage.
}
property TdataPlot.Xmax:real;
{$H L'affichage standard de l'objet se fait dans un système de coordonnées défini par
Xmin@ , Ymin@ , Xmax@ et Ymax@.

Xmax est l'abscisse des points situés sur le bord droit de la fenêtre d'affichage.
}
property TdataPlot.Ymin:real;
{$H L'affichage standard de l'objet se fait dans un système de coordonnées défini par
Xmin@ , Ymin@ , Xmax@ et Ymax@.

Ymin est l'ordonnée des points situés sur le bord bas de la fenêtre d'affichage.
}
property TdataPlot.Ymax:real;
{$H L'affichage standard de l'objet se fait dans un système de coordonnées défini par
Xmin@ , Ymin@ , Xmax@ et Ymax@.

Ymax est l'ordonnée des points situés sur le bord haut de la fenêtre d'affichage.
}
property TdataPlot.Cpx:smallint;
{$H
 Définit le coefficient de couplage suivant l’axe des X.
Quand ce coefficient est nul, il n’a aucun effet. Dans le cas contraire, tous les
objets ayant le même coefficient de couplage seront considérés par le système
comme couplés suivant X, c’est à dire que toute modification du paramètre
Xmin@ ou Xmax@ de l’un de ces objets entraînera la même modification de ce
paramètre pour tous les autres objets couplés.

 Au moment où l'on modifie Cpx, les coordonnées Xmin et Xmax s'alignent sur les coordonnées des autres
objets de même Cpx (s'ils existent)
}
property TdataPlot.Cpy:smallint;
{$H
 Définit le coefficient de couplage suivant l’axe des Y.
Quand ce coefficient est nul, il n’a aucun effet. Dans le cas contraire, tous les
objets ayant le même coefficient de couplage seront considérés par le système
comme couplés suivant Y, c’est à dire que toute modification du paramètre
Ymin@ ou Ymax@ de l’un de ces objets entraînera la même modification de ce
paramètre pour tous les autres objets couplés.

 Au moment où l'on modifie Cpy, les coordonnées Ymin et Ymax s'alignent sur les coordonnées des autres
objets de même Cpy (s'ils existent)
}

property TdataPlot.Cpz:smallint;
{$H
Définit le coefficient de couplage suivant l’axe des Z.
Quand ce coefficient est nul, il n’a aucun effet. Dans le cas contraire, tous les
objets ayant le même coefficient de couplage seront considérés par le système
comme couplés suivant Z, c’est à dire que toute modification du paramètre
Zmin@ ou Zmax@ de l’un de ces objets entraînera la même modification de ce
paramètre pour tous les autres objets couplés.
}

property TdataPlot.LogX:boolean;
{$H Quand LogX est vrai, l'affichage standard est logarithmique suivant l'axe des X.

 En mode logarithmique, Xmin@ et Xmax@ doivent tous deux être positifs sinon l'objet ne s'affiche pas.
}
property TdataPlot.LogY:boolean;
{$H Quand LogY est vrai, l'affichage standard est logarithmique suivant l'axe des Y.

 En mode logarithmique, Ymin@ et Ymax@ doivent tous deux être positifs sinon l'objet ne s'affiche pas.
}
property TdataPlot.Xscale:boolean;
{$H Quand Xscale est vrai, l'affichage standard de l'objet comprend des chiffres sous
l'échelle horizontale
}
property TdataPlot.Yscale:boolean;
{$H Quand Yscale est vrai, l'affichage standard de l'objet comprend des chiffres sur
le coté gauche de l'échelle verticale.
}

property TdataPlot.Xticks:boolean;
{$H Quand Xticks est vrai, l'affichage standard de l'objet comprend une échelle horizontale
avec des graduations.
}
property TdataPlot.Yticks:boolean;
{$H Quand Yticks est vrai, l'affichage standard de l'objet comprend une échelle verticale
avec des graduations.
}

property TdataPlot.ExtTicksX:boolean;
{$H Quand ExtTicksX est vrai, les ticks de l'axe horizontal sont placés à l'extérieur du cadre.
}
property TdataPlot.ExtTicksY:boolean;
{$H Quand ExtTicksY est vrai, les ticks de l'axe vertical sont placés à l'extérieur du cadre.
}


property TdataPlot.RightTicks:boolean;
{$H Si RightTicks est vrai, l'affichage présente des ticks aussi bien à droite
qu'à gauche pour l'échelle verticale.
}
property TdataPlot.TopTicks:boolean;
{$H Si TopTicks est vrai, l'affichage présente des ticks à la fois en haut et en bas
pour l'échelle horizontale.
}

property TdataPlot.ZeroAxisX:boolean;
{$H Si ZeroAxisX est vrai, l'échelle horizontale est représentée par un axe qui passe
par l'origine.
}

property TdataPlot.ZeroAxisY:boolean;
{$H Si ZeroAxisY est vrai, l'échelle verticale est représentée par un axe qui passe
par l'origine.
}

property TdataPlot.ScaleColor:longint;
{$H Définit la couleur des échelles.
}
property TdataPlot.inverseX:boolean;
{$H Si inverseX est vrai, Xmin@ devient l'abscisse des points situés sur le bord droit
de la fenêtre d'affichage et Xmax@ devient l'abscisse des points situés sur le bord gauche
de la fenêtre d'affichage.
}
property TdataPlot.inverseY:boolean;
{$H Si inverseY est vrai, Ymin@ devient l'ordonnée des points situés sur le bord du haut
de la fenêtre d'affichage et Ymax@ devient l'ordonnée des points situés sur le bord du bas
de la fenêtre d'affichage.
}
procedure TdataPlot.AutoscaleX;
{$H Range dans Xmin@ et Xmax@ les valeurs extrêmes autorisées. Ces valeurs sont
les abscisses réelles correspondant aux indices Istart@ et Iend@ .
}
procedure TdataPlot.AutoscaleY;
{$H Pour un vecteur, la procédure recherche les valeurs minimale et maximale des
données et range ces valeurs dans Ymin@ et Ymax@.
 Pour une matrice, la procédure range dans Ymin et Ymax les valeurs réelles
correspondant aux indices Jstart@ et Jend@ .
}

procedure TdataPlot.AutoscaleY1;
{$H Pour un vecteur, la procédure recherche les valeurs minimale Vmin et maximale Vmax des
données entre Xmin@ et Xmax@ .

 Elle range ensuite la valeur Vmin-(Vmax-Vmin)/10 dans Ymin@ .
 Puis elle range la valeur Vmax+(Vmax-Vmin)/10 dans Ymax@ .

 La partie affichée occupe donc 80% de l'amplitude disponible dans la fenêtre.
}

function TdataPlot.chooseCoo:boolean;
{$H Ouvre la boite de dialogue Coordonnées de l'objet.

La fonction renvoie True si l'utilisateur a validé son choix.
}

property TdataPlot.color:longint;
{$H Color définit la couleur de tracé de l'objet. Une couleur peut être définie au
moyen des constantes de couleur@couleurs ou bien au moyen de la fonction rgb@.
 Certains modes d'affichage utilisent deux couleurs. La deuxième couleur est dans
la propriété color2@.
}

property TdataPlot.color2:longint;
{$H Color2 définit la deuxième couleur de tracé de l'objet.

 La plupart des (modes d'affichage)@mode n'utilisent qu'une seule couleur (définie par la
propriété color@). Certains modes utilisent deux couleurs: c'est le cas des modes
dessinant des traits plus des symboles. Les traits utilisent la propriété color alors que les
symboles utilisent la propriété color2.

}
property TdataPlot.Mode:integer;
{$H Définit le mode d'affichage. Il est recommandé d'utiliser les constantes
définissant les (modes d'affichage)@ pour modifier cette propriété.
}
property TdataPlot.SymbolSize:integer;
{$H Définit la taille des symboles en pixels.
}
property TdataPlot.lineWidth:integer;
{$H Définit la largeur des traits pour le mode trait uniquement
( DM_line@(Modes d'affichage) ).
}

property TdataPlot.LineStyle: integer;
{$H Type de trait quand le mode@ d'affichage est DM_line

 Par défaut, LineStyle vaut 1 et les traits sont continus.
 Il est possible d'afficher des points et/ou des tirets en utilisant les valeurs suivantes:

 @prog
 ps_Solid =     1;
 ps_Dash  =     2;
 ps_Dot   =     3;
 ps_DashDot =   4;
 ps_DashDotDot =5;
 ps_Clear =     6;
 @notprog

 Voir les (types de traits)@
}


property TdataPlot.keepAspectRatio:boolean;
{$H Propriété indiquant si l'on doit respecter les proportions à l'affichage.

 Par défaut, les objets Tmatrix@, TxyPlot@ et leurs descendants ont cette
propriété vraie. Pour les autres objets, cette propriété vaut False en général.

}

property TdataPlot.Fgrid: boolean;
{$H Permet d'associer une grille aux graduations affichées.

}

                         { stmDObj1 TdataObject }

property TdataObject.Dx:real;
{$H La correspondance entre unités réelles et unités fichier (ou unités système) est définie
par une relation du type :
     x :=Dx*i+X0
 i étant une abscisse fichier, c'est-à-dire une valeur entière donnant la position
d'un élément dans le vecteur, x étant  une abscisse réelle.

 Dx et X0@ définissent la correspondance entre les deux types d'unités.

 Exemple : Pour un vecteur d'un fichier de données Elphy, Dx représente la période d'échantillonnage.
}
property TdataObject.x0:real;
{$H La correspondance entre unités réelles et unités fichier (ou unités système) est définie
par une relation du type :
     x :=Dx*i+X0
 i étant une abscisse fichier, c'est-à-dire une valeur entière donnant la position
d'un élément dans le vecteur, x étant  une abscisse réelle.

 Dx@ et X0 définissent la correspondance entre les deux types d'unités.
}
property TdataObject.Dy:real;
{$H Quand le type des éléments de l'objet est entier (t_byte, t_short, t_word, t_smallint ou
t_longint), on associe à chaque valeur j d'un élément de vecteur une valeur réelle y donnée
par la relation:
	y = Dy*j+Y0
 Dy et Y0@ sont les paramètres d'échelle suivant Y.

 Exemple : Pour un fichier de données du type Acquis1, les valeurs rangées dans le
vecteur sont en général des nombres entiers compris entre -2048 et +2047. La connaissance
des paramètres d'échelle Dy et Y0 permet d'obtenir les grandeurs réelles correspondantes,
grandeurs exprimées en mV, pA, etc... Ces paramètres d'échelle sont rangés dans l'entête de
fichier.
}

property TdataObject.y0:real;
{$H Quand le type des éléments de l'objet est entier (t_byte, t_short, t_word, t_smallint ou
t_longint), on associe à chaque valeur j d'un élément de vecteur une valeur réelle y donnée
par la relation:
	y = Dy*j+Y0
 Dy@ et Y0 sont les paramètres d'échelle suivant Y.
}

function TdataObject.convX(i:longint):real;
{$H Convertit une abscisse fichier en abscisse réelle.

 Par exemple, si l'objet est un vecteur et si i représente l'indice d'un élément, le
résultat x est l'abscisse réelle correspondante déduite de la relation

  	x = Dx@*i + x0@

 La fonction reciproque est invConvX@ .
}
function TdataObject.invconvX(x:real):longint;
{$H Convertit une abscisse réelle en abscisse fichier.

 Par exemple, si l'objet est un vecteur et si x représente l'abscisse réelle d'un élément,
le résultat i est l'indice correspondant déduit de la relation

        i = (x-x0@) / Dx@

 La fonction réciproque est convx@ .
}

function TdataObject.convY(i:longint):real;
{$H Convertit une ordonnée fichier en ordonnée réelle.

 Si j est une ordonnée fichier, le résultat est donné par la relation

  	 Dy@*j + y0@

 Cette fonction n'a de sens que lorsque le type des éléments est entier (t_byte, t_short,
t_word, t_smallint ou t_longint) .
 La fonction reciproque est invConvY@ .
}
function TdataObject.invconvY(x:real):longint;
{$H Convertit une ordonnée réelle en ordonnée fichier.

 Si y est une ordonnée réelle, le résultat est donné par la relation

  	 (y-y0@) / Dy0@

 Cette fonction n'a de sens que lorsque le type des éléments est entier (t_byte, t_short,
t_word, t_smallint ou t_longint) .
 La fonction reciproque est ConvY@ .
}
property TdataObject.Xstart:real readOnly;
{$H Pour un vecteur, renvoie l'abscisse réelle du premier  point.

 Pour une matrice M(i,j), renvoie l'abscisse réelle correspondant à la première valeur  de i.
}
property TdataObject.Xend:real readOnly;
{$H Pour un vecteur, renvoie l'abscisse réelle du dernier  point.

 Pour une matrice M(i,j), renvoie l'abscisse réelle correspondant à la dernière valeur  de i.
}
property TdataObject.Istart:integer;
{$H Pour un vecteur, renvoie l'indice du premier  point.

 Pour une matrice M(i,j), renvoie l'indice correspondant à la première valeur  de i.

  En écriture, la propriété modifie simultanément Istart et Iend@ afin de maintenir constante
la propriété Icount@

}
property TdataObject.Iend:integer;
{$H Pour un vecteur, renvoie l'indice du dernier  point.

 Pour une matrice M(i,j), renvoie l'indice correspondant à la dernière valeur  de i.

   En écriture, la propriété modifie simultanément Istart@ et Iend afin de maintenir constante
la propriété Icount@
}

property TdataObject.Icount:longint;
{$H Pour un vecteur, renvoie le nombre d'éléments.

 Pour une matrice M(i,j), renvoie le nombre d'éléments suivant X.

 Ce nombre est égal à Iend@-Istart@+1

 En écriture, et seulement pour un vecteur, Icount modifie la taille du vecteur si cela est possible.
 Istart@ n'est pas modifié. Iend@ est modifié afin d'obtenir le nombre d'éléments souhaité. Le contenu du
vecteur est préservé et les parties nouvellement allouées sont remplies avec des zéros.
}

property TdataObject.NumType:integer readOnly;
{$H Renvoie le (type des nombres)@(types de nombre) rangés dans le vecteur ou la matrice.

 Ce type est celui qui est indiqué au moment de l'appel du constructeur create de l'objet.
}

procedure TdataObject.clear;
{$H Efface le contenu de l'objet.

 Un vecteur ou une matrice est rempli avec des zéros.
}


property TdataObject.FreadOnly:boolean;
{$H Indique si la modification des données est autorisée ou non.

 Cette propriété vaut FALSE en général. Toutefois, si l'objet appartient à un autre
objet, l'objet propriétaire peut mettre la propriété à TRUE pour protéger ses données.

 En particulier, les vecteurs faisant partie d'un objet TdataFile@ ont leur propriété
readOnly à TRUE à chaque fois qu'un fichier de données est chargé. L'utilisateur peut
changer cette propriété par programme ou dans le dialogue Propriétés du vecteur mais
cela n'est pas recommandé.
}

property TdataObject.Fexpand:boolean;
{$H Indique la possibilité d'écrire au delà de l'indice de fin Iend.

 Fexpand vaut toujours FALSE par défaut.
 Pour certains objets, en imposant Fexpand=TRUE, il devient possible d'écrire à
l'indice Iend+1.

}
property TdataObject.FimDisplay:boolean;
{$H Indique que toute modification doit entraîner un affichage immédiat.

 FimDisplay doit être affecté uniquement dans la partie InitProcess ou initProcess0.

 FimDisplay vaut toujours FALSE par défaut. La mise en place du flag est intéressante
en acquisition continue pour suivre l'évolution de données que l'on range dans un
vecteur.

}

procedure ReAfficherTrace(var t:Tplot);
/RefreshTrace
{$H Appelle la méthode refresh@ de l'objet.

 Cette procédure n'est là que pour assurer la compatibilité avec Acquis1.
 A la place de refreshTrace(t) , il est préférable d'écrire t.refresh .
}
procedure Reafficher(var t:Tplot);
/MarkForRefresh
{$H Appelle la méthode invalidate@ de l'objet.

 Cette procédure n'est là que pour assurer la compatibilité avec Acquis1.
 A la place de MarkForRefresh(t) , il est préférable d'écrire t.invalidate .
}
procedure ModifierAffichage(modifGrad:boolean);
{$H Procédure sans effet.

 Cette procédure n'est là que pour assurer la compatibilité avec Acquis1.
}
                        { stmVec1 Tvector }

procedure Tvector.create(stName:string;tp:integer;n1,n2:longint);
procedure Tvector.create(tp:integer;n1,n2:longint);
procedure Tvector.create;

{$H Constructeur de l'objet Tvector

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
 Si StName est omis ou vide, l'objet prend le nom de la variable.

 tp est le (type des nombres)@(types de nombre). Actuellement, les types supportés sont/
      t_smallint: entiers sur 2 octets
      t_longint: entiers sur 4 octets
      t_single:  réels sur 4 octets.
      t_extended: réels sur 10 octets
      t_Scomplex: Complexes formés de deux réels de type single
      t_Dcomplex: Complexes formés de deux réels de type double
      t_Complex: Complexes formés de deux réels de type extended


 n1 et n2 sont les indices de début et de fin du vecteur. n2 doit être supérieur ou
égal à n1 .

 Dans la version sans arguments, on donne les valeurs par défaut: tp=t_single, n1=0, n2=0 .
}
procedure Tvector.modify(tp:integer;n1,n2:longint);
{$H Permet de modifier la structure du vecteur sans détruire l'objet.

 Les paramètres sont les mêmes que ceux du constructeur create@ .
 Si l'objet n'est pas créé, modify appelle d'abord le constructeur create avec un nom vide.

  Après l'appel de Modify, le vecteur contient des zéros. Les paramètres
d'échelle Dx@, x0@, Dy@ et y0@ ne sont pas modifiés.
}

property TVector.Jvalue(i:longint):longint;
{$H Quand les éléments d'un vecteur (ou d'un objet dérivé) sont d'un type entier, Jvalue
renvoie la valeur fichier de l'élément de vecteur d'indice i.

Quand les éléments sont d'un type réel, Jvalue renvoie une valeur arrondie de l'élément
d'indice i.
}
property TVector.Yvalue(i:longint):real default;
{$H Yvalue renvoie la valeur réelle du vecteur correspondant à l'indice i.

Quand le type de nombre est un type réel, la valeur renvoyée (ou affectée) correspond
simplement au nombre rangé à l'indice i.

Quand le type de nombre est un type entier, la valeur renvoyée est égale au nombre
rangé à l'indice i converti en unités réelles. Réciproquement, quand on effectue une
affectation telle que
	Yvalue[i] :=x;
 la valeur x est d'abord convertie en unités fichier avant d'être rangée à l'indice i du
vecteur.
 De cette façon, on peut manipuler des données entières auquelles sont associés des
paramètres d'échelle comme si l'on avait affaire à des suites de nombres réels.
 Remarquons toutefois que l'affectation peut poser quelques problèmes puisque la conversion
effectue un arrondi.

 Yvalue est la propriété par défaut de Tvector. Ce qui signifie par exemple que l'écriture
 @f6 vec.Yvalue[10]:=0;
 peut être remplacée par
 @f6 vec[10]:=0;


}
property TVector.Rvalue(x:real):real;
{$H Rvalue se comporte comme Yvalue@ mais au lieu de donner un indice du vecteur comme
paramètre, on donne une valeur réelle. La méthode calcule d'abord l'indice i correspondant
à x en utilisant les lois de conversion puis renvoie Yvalue[i].
}



procedure TVector.getMinMax(var min,max:real);
{$H Renvoie les valeurs minimale et maximale du vecteur.

 Les variables min et max doivent être initialisées auparavant (par exemple min:=1E100
et max:=-1E100).
 Avec cette méthode, on peut rechercher commodément le minimum et le maximum
d'un groupe de vecteurs. Il suffit d'initialiser min et max une fois, puis d'appeler
successivement getMinMax pour chaque vecteur du groupe.
}

function Tvector.Mean:real;
function Tvector.Mean(x1,x2:real):real;
{$H Renvoie la valeur moyenne des points compris entre x1 et x2.

 Si les paramètres sont omis, renvoie la valeur moyenne de tout le vecteur.
}

function Tvector.CpxMean:complex;
function Tvector.CpxMean(x1,x2:real):complex;
{$H Renvoie la valeur moyenne complexe des points compris entre x1 et x2.

 Si les paramètres sont omis, renvoie la valeur moyenne de tout le vecteur.

 Si le vecteur ne contient pas des nombres complexes,
}


function Tvector.MedianValue(x1,x2:real):real;
{$H Renvoie la valeur médiane des points compris entre x1 et x2.
}


function Tvector.stdDev:real;
function Tvector.StdDev(x1,x2:real):real;
{$H Calcul de l'écart-type (standard deviation) pour tous les points du vecteur
 compris entre les abscisses x1 et x2.

 Le résultat est donné par la formule:
 y= sqrt( sum( sqr(|y[i]-ym|))/(N-1) )

 sqrt signifie racine carrée
 sum signifie somme sur tous les échantillons compris entre x1 et x2
 sqr signifie carré
 y[i] désigne le ième échantillon et ym la moyenne sur tous les échantillons
 N est le nombre d'échantillons compris entre x1 et x2

 Si le vecteur contient des nombres complexes, la formule s'applique également.
}

function Tvector.Maxi(x1,x2:real):real;
{$H Renvoie le maximum du vecteur entre x1 et x2.

  Voir aussi maxi0@ .
}

function Tvector.Mini(x1,x2:real):real;
{$H Renvoie le minimum du vecteur entre x1 et x2.

  Voir aussi mini0@ .
}

function Tvector.MaxiX(x1,x2:real):real;
{$H Renvoie la position du maximum du vecteur entre x1 et x2.

  Voir aussi maxiX0@ .
}

function Tvector.MiniX(x1,x2:real):real;
{$H Renvoie la position du minimum du vecteur entre x1 et x2.

  Voir aussi miniX0@ .
}


function Tvector.Maxi0:real;
{$H Renvoie le maximum du vecteur.

  Voir aussi maxi@ .
}

function Tvector.Mini0:real;
{$H Renvoie le minimum du vecteur .

  Voir aussi mini@ .
}

function Tvector.MaxiX0:real;
{$H Renvoie la position du maximum du vecteur.

  Voir aussi maxiX@ .
}

function Tvector.MiniX0:real;
{$H Renvoie la position du minimum du vecteur.

  Voir aussi miniX@ .
}

function Tvector.sum0:real;
{$H Renvoie la somme des éléments du vecteur.

  Pour les nombres complexes, on obtient la somme des parties réelles.
}

function Tvector.Sum:real;
function Tvector.Sum(x1,x2:real):real;
{$H Renvoie la valeur moyenne des points compris entre x1 et x2.

 Si les paramètres sont omis, renvoie la somme de tout le vecteur.
 Pour les nombres complexes, on obtient la somme des parties réelles.
}


function Tvector.SqrSum0:real;
{$H Renvoie la somme des carrés des éléments du vecteur.

 Pour les nombres complexes, on obtient le somme des carrés des modules.
}

function Tvector.Mean0:real;
{$H Renvoie la valeur moyenne du vecteur.
}

function Tvector.MedianValue0:real;
{$H Renvoie la valeur médiane .
}


function Tvector.StdDev0:real;
{$H Renvoie l'écart-type (standard deviation) du vecteur.

 Le résultat est donné par la formule:
 y= sqrt( sum( sqr(y[i]-ym))/(N-1) )

 sqrt signifie racine carrée
 sum signifie somme sur tous les points
 sqr signifie carré
 y[i] désigne le ième échantillon et ym la moyenne sur tous les échantillons
 N est le nombre de points du vecteur

}



function Tvector.DistriMean(x1,x2:real):real;
{$H Renvoie la valeur moyenne du vecteur considéré comme une distribution.
}

function Tvector.DistriStdDev(x1,x2:real):real;
{$H Renvoie l'écart-type (standard deviation) du vecteur considéré comme une distribution.
}

procedure Tvector.fill(y:real);
{$H Remplit le vecteur avec la valeur y.
}

procedure Tvector.fill1(y,x1,x2:real);
{$H Remplit le vecteur avec la valeur y entre les abscisses x1 et x2.
}

procedure Tvector.fillCpx(y:complex);
{$H Remplit le vecteur avec la valeur complexe y.
}

procedure Tvector.fillCpx1(y:complex;x1,x2:real);
{$H Remplit le vecteur avec la valeur complexe y entre les abscisses x1 et x2.
}


procedure Tvector.Vmoveto(x,y:real);
{$H Positionne un pointeur de dessin au point (x,y).

 Associée à Vlineto@, cette procédure permet de dessiner commodément une forme
dans le vecteur.
}

procedure Tvector.Vlineto(x,y:real);
{$H Trace dans le vecteur un segment de droite dont l'origine est la position précédente
du pointeur de dessin et dont l'extrémité est le point (x,y).

 Le pointeur de dessin se place ensuite aux coordonnées (x,y).

 Associée à Vmoveto, cette procédure permet de dessiner commodément une forme
dans le vecteur.
}


procedure Tvector.initEventList(t:integer;dx:real);
{$H Initialise une liste d'événements.

 Si l'objet n'est pas créé, initEventList appelle d'abord le constructeur create@ avec un nom vide.

 Après initEventList, le vecteur a les propriétés suivantes:

 le (type de nombre)@(types de nombre) est celui donné par le paramètre t
 Istart=1
 Iend=0
 x0=0
 dx prend la valeur du paramètre dx
 y0=0
 dy prend la valeur du paramètre dx

 Le mode d'affichage est DM_evt
 Ymin=-100
 Ymax=100

 Après cette initialisation, on peut ajouter des dates d'événement avec la
méthode AddToList@ .

}
procedure Tvector.initList(t:integer);
{$H Initialise une liste de valeurs.

 Si l'objet n'est pas créé, modify appelle d'abord le constructeur create@ avec un nom vide.

 Après initList, le vecteur a les propriétés suivantes:

 le (type de nombre)@(types de nombre) est celui donné par le paramètre t
 Istart@=1
 Iend@=0

 Les paramètres d'échelle sont:
     x0@=0
     dx@=1
     y0@=0
     dy@=1

 Après cette initialisation, on peut ajouter des valeurs avec la
méthode AddToList@

 InitList impose le paramètre Istart à 1. Ce qui n'est pas toujours souhaité.
Si l'on veut imposer une autre valeur (par exemple zéro), on peut écrire:

 @f6      vec.modify(t_smallint,0,-1);  (* le vecteur sera vide *)
 @f6      vec.x0=0
 @f6      vec.dx=1
 @f6      vec.y0=0
 @f6      vec.dy=1

}
procedure Tvector.addToList(x:real);
{$H Ajoute un élément de valeur x à la fin du vecteur.

 La méthode incrémente d'abord Iend puis effectue l'opération Yvalue[Iend]:=x;
}

procedure Tvector.removeFromList(index:integer);
{$H supprime l'élément d'indice index.

 Après cette opération, Iend a été décrémenté et tous les éléments d'indice supérieur
à index ont été décalés vers le bas.
}
procedure Tvector.InsertIntoList(i:integer;x:real);
{$H insére un élément de valeur x à l'indice index.

 Après cette opération, Iend a été incrémenté et tous les éléments d'indice supérieur
ou égal à index ont été décalés vers le haut.
}
procedure Tvector.resetList;
{$H Vide le vecteur considéré comme une liste.

 Après cette opération:
 Iend@=0

 ResetList ne modifie pas les paramètres d'échelle, ni le type de nombre.
}

procedure Tvector.SortEventList;
{$H Trie les éléments du vecteur afin d'obtenir une suite de nombres croissants.

}

procedure Tvector.Sort(AscendingOrder: boolean);
{$H Trie les éléments du vecteur.

 Le résultat est une suite de nombres croissants si AscendingOrder vaut True.
 C'est une suite de nombres décroissants si AscendingOrder vaut False.

}

procedure Tvector.SortWithIndex(AscendingOrder: boolean;var Vindex: Tvector);
{$H Trie les éléments du vecteur en même temps que les éléments d'un vecteur annexe (Vindex)

 Le résultat est une suite de nombres croissants si AscendingOrder vaut True.
 C'est une suite de nombres décroissants si AscendingOrder vaut False.

 Vindex doit avoir les mêmes propriétés Istart, Iend que le vecteur courant.
 Ses éléments seront ordonnés de la même façon que le vecteur courant.
 Si Vindex contenait au départ les valeurs des indices  (exemple: 1, 2, 3, 4,...), les nouvelles valeurs
permettront de retrouver l'ordre original.

}

procedure Tvector.ModifyOrder(var Vindex:Tvector);
{$H Change l'ordre des éléments du vecteur.

 Pour chaque élément, on effectue l'opération Yvalue[i]:= Yvalue[Vindex[i]];

 Vindex doit avoir les mêmes propriétés Istart, Iend que le vecteur courant.
 Si les valeurs de Vindex sont comprises entre Istart et Iend et sont toutes différentes,
on obtient une permutation des éléments du vecteur.

}

property Tvector.GetPointColor:TsetPointColor;
{$H Procédure appelée avant chaque affichage d'un point du vecteur.

 TsetPointColor est un type de procédure déclaré de la façon suivante:
 TsetPointColor=procedure(ind:longint;var col:longint);

 Il est possible d'écrire une procédure déclarée comme ci-dessus et d'affecter
cette procédure à la propriété GetPointColor;

 Le rôle de cette procédure doit se limiter à modifier la variable col en tenant
compte de l'indice ind reçu comme paramètre. Il est ainsi possible de modifier
la couleur d'affichage sur une partie du tracé. Le ralentissement de l'affichage
étant assez important, il ne faut pas abuser de cette possibilité.
}

property Tvector.OnDisplay:Tprocedure1;
{$H Procédure appelée après chaque affichage du vecteur.

 Tprocedure1 est un type de procédure déclaré de la façon suivante:
 Tprocedure1=procedure(num:longint);

 Il est possible d'écrire une procédure déclarée comme ci-dessus et d'affecter
cette procédure à la propriété OnDisplay.

 Le paramètre num transmis est le tag de l'objet Tvector .
}

property Tvector.OnImDisplay:Tprocedure1;
{$H Procédure utilisée en mode affichage immédiat

 Tprocedure1 est un type de procédure déclaré de la façon suivante:
 Tprocedure1=procedure(num:longint);

 Il est possible d'écrire une procédure déclarée comme ci-dessus et d'affecter
cette procédure à la propriété OnDisplay.

 Le paramètre num transmis est le tag de l'objet Tvector .
}


function Tvector.getFirstEvent(x:real):longint;
{$H Renvoie l'indice du premier événement de date supérieure ou égale à x .

 Le vecteur doit contenir des dates d'événements, c'est à dire une suite de nombres
croissants, sinon le résultat est imprévisible.

 Lorsqu'il n'existe aucun événement de date supérieure à x, la fonction
renvoie Iend@+1 .

 La recherche est très rapide (méthode dichotomique).
}

property Tvector.OnDragDrop:TonDragDrop;
{$H Gestionnaire d'événement pour un événement 'Lacher'.

 TondragDrop doit être une procédure déclarée de la façon suivante:

 Procedure Proc(var v:Tvector;x,y:real);

 Quand l'utilisateur effectuera un 'lacher' de la souris dans une fenêtre multigraph
contenant le vecteur v, la procédure Proc sera appelée avec pour paramètres le vecteur
v et les coordonnées réelles du 'lacher'

 Cette propriété est utilisée en liaison avec la procédure DragDropObject@ et
avec la propriété onDragDrop de Tdialog@ .
}

function CompareMseq(var vec1,vec2:Tvector):longint;
{$H Recherche le décalage existant entre les deux m-séquences contenues dans les
vecteurs vec1 et vec2.

 Les deux vecteurs doivent être de même type entier et avoir les mêmes indices de
début et de fin.

 Si le contenu de vec1 est le même que celui de vec2, la fonction renvoie zéro.

 Si vec2 contient les mêmes valeurs que vec1 mais décalées, la fonction renvoie
la valeur de ce décalage.

 Dans les autres cas, la fonction renvoie -1 .

}

procedure MseqFMT(var cc,Re,Rs,Data,fmtr:Tvector);
{$H Calcul d'une transformée de Hadamard rapide.

 En entrée:
  cc est un vecteur servant de buffer pour le calcul.
  Re est la m-séquence calculée par la méthode Generating Register.
  Rs est la m-séquence calculée par la méthode Tap Register.
  Data contient les données.

 En sortie:
  fmtr contient la corrélation de Data avec la m-séquence


 Tous les vecteurs doivent être de type t_longint.
 Tous leurs indices Istart doivent être égaux à zéro.

 Si on appele N est l'ordre de la m-séquence, les vecteurs Re, Rs, Data et Fmtr doivent
avoir un indice de fin égal à 2 exposant N -2.

 Le vecteur cc, quant à lui, doit avoir un indice de fin égal à 2 exposant N -1 .
}

procedure Tvector.saveAsText(fileName:string;TwoColumns:boolean;decimalPlaces:integer);
{$H Sauve le vecteur sous la forme d'un fichier texte.

 FileName est le nom du fichier.

 Si TwoColumns vaut True, chaque ligne du fichier contiendra un couple de valeurs (x,y)
séparées par une tabulation, sinon, chaque ligne ne contiendra que la valeur y.

 DecimalPlaces est le nombre de chiffres après la virgule.

}

procedure Tvector.LoadFromText(stName:String;ColNum,line1,line2:integer);
{$H Charge le vecteur à partir d'un fichier texte.

 stName est le nom du fichier.

 On suppose que le fichier est organisé en colonnes qui contiennent des nombres. Les séparateurs
acceptés sont les tabulations, les espaces et les points-virgules. 
 colNum est le numéro de la colonne qui sera chargée dans le vecteur.

 line1 est le numéro de la première ligne du fichier qui doit être chargée.
 line2 est le numéro de la dernière ligne du fichier qui doit être chargée.

 Si line2<line1, la procédure chargera toutes les lignes du fichier.

 L'indice Iend@ du vecteur est modifié pour tenir compte du nombre de lignes chargées
mais pas l'indice Istart@

}

procedure Tvector.saveAsSingle(fileName:string);
{$H Sauve le vecteur sous la forme d'un fichier de nombres réels de 4 octets.

 FileName est le nom du fichier.

 La taille du fichier obtenu sera (Iend@-Istart@+1)*4 .
}

procedure Tvector.saveAsDouble(fileName:string);
{$H Sauve le vecteur sous la forme d'un fichier de nombres réels de 8 octets.

 FileName est le nom du fichier.

 La taille du fichier obtenu sera (Iend@-Istart@+1)*8 .
}

procedure Tvector.SineWave(amp,Periode,phi:real);
{$H Remplit le vecteur avec une fonction sinusoïdale d'amplitude Amp, de
période Periode et de déphasage Phi .
}
property TVector.CpxMode:integer;
{$H Définit le mode d'affichage du vecteur lorsqu'il contient des nombres complexes.

 Les valeurs possibles sont:

     0: affichage de la partie réelle
     1: affichage de la partie imaginaire
     2: affichage du module
     3: affichage de l'argument

 Il est recommandé d'utiliser les (constantes de mode)@(Modes d'affichage complexes)
}

property TVector.CpxValue(i:longint):complex;
{$H Permet d'accéder aux valeurs contenues dans un vecteur complexe.

 Renvoie Yvalue@ si le type de nombre n'est pas complexe.
}
property TVector.ImValue(i:longint):real;
{$H Permet d'accéder à la partie imaginaire des valeurs contenue dans un vecteur complexe.

 Renvoie zéro si le type de nombre est réel.
}



procedure Tvector.setScaleParams(Dx1,x1,Dy1,y1:real);
{$H Fixe les paramètres d'échelle du vecteur.

 Dx1,x1,Dy1 et y1 deviennent respectivement les propriétés Dx@, x0@, Dy@ et y0@ .
}

procedure Tvector.Threshold(th:real;Fup,Fdw:boolean);
{$H Réalise une opération de seuillage sur tous les points du vecteur.

 L'algorithme est le suivant:

 @f6   for i:=Istart to Iend do
 @f6   begin
 @f6     y:=Yvalue[i]-th;
 @f6     if Fup and (y>0) then Yvalue[i]:=y
 @f6     else
 @f6     if Fdw and (y<0) then Yvalue[i]:=-y
 @f6     else Yvalue[i]:=0;
 @f6   end;

 En particulier, on peut redresser un signal, tout en supprimant sa composante continue,
en appelant:
                Threshold(Vm,true,true);
 Vm étant la valeur moyenne.

}

procedure Tvector.Threshold1(th:real);
{$H Réalise une opération de seuillage sur tous les points du vecteur.

  On remplace toutes les valeurs supérieures ou égales au seuil par des uns,
et toutes les autres par des zéros.

 L'algorithme est le suivant:

 @f6   for i:=Istart to Iend do
 @f6     if Yvalue[i]>=th
 @f6       then Yvalue[i]:=1
 @f6       else Yvalue[i]:=0;

}

procedure Tvector.Threshold2(th1,th2,val1,val2:real);
{$H Réalise une opération de seuillage sur tous les points du vecteur.

  On remplace toutes les valeurs inférieures au seuil th1 par val1.
  On remplace toutes les valeurs supérieures au seuil th2 par val2.

  L'algorithme est le suivant:

 @f6   for i:=Istart to Iend do
 @f6     if Yvalue[i]<th1 then Yvalue[i]:=val1
 @f6     else
 @f6     if Yvalue[i]>th2 then Yvalue[i]:=val2;

}


Property Tvector.UseLevel:boolean;
Property Tvector.XLevel:real;
Property Tvector.YLevel:real;

procedure Tvector.SaveBinaryData(var f:TbinaryFile; tp:integer);

procedure Tvector.LoadBinaryData(var f:TbinaryFile; ByteStep: integer);
{$H Chargement de données binaires

 Le pointeur de fichier de f doit être correctement positionné
 Le vecteur doit être correctement dimensionné et son type NumType@ doit correspondre
au type des données contenues dans le fichier.

  ByteStep est le nombre d'octets qu'il faut sauter pour passer à la donnée suivante.
  Si les données sont contigues sur le disque, on peut laisser cette valeur à zéro.

}

procedure Tvector.loadSingleData(var binF:TbinaryFile);
{$H Charge des données à partir d'un fichier binaire contenant des réels sur 4 octets (type single).

 binF est du type TbinaryFile@ . Le fichier doit avoir été ouvert au moyen de la méthode
Reset@(TbinaryFile.Reset) ou de la méthode Rewrite@(TbinaryFile.Rewrite)

 Le vecteur n'a pas besoin d'avoir été créée avec un type single pour utiliser
cette méthode. Par contre, le nombre de valeurs disponibles sur le disque doit correspondre
au nombre d'éléments du vecteur.

 Voir saveSingleData@
}

procedure Tvector.saveSingleData(var binF:TbinaryFile);
{$H Sauve les données de l'objet dans un fichier binaire au format single (réels sur 4 octets).

 binF est du type TbinaryFile@ . Le fichier doit avoir été ouvert au moyen de la méthode
Reset@(TbinaryFile.Reset) ou de la méthode Rewrite@(TbinaryFile.Rewrite)

 Le nombre d'octets écrits est (Iend-Istart+1)*4.

 Voir loadSingleData@ .
}

property Tvector.SmoothFactor: integer;
{$H Facteur de lissage

 Utilisé uniquement par l'affichage.
 Si SmoothFactor>=0 , on trouvera sur l'affichage à l'indice i une moyenne des échantillons contenus dans un
petit segment centré sur l'indice i et contenant SmoothFactor éléments.

 Remarque: il peut être très dangereux d'utiliser cette propriété sans précautions: le vecteur affiché ne correspond plus
à la réalité !
}

property Tvector.BinFactor: integer;
{$H Facteur d'extension de la largeur de classe

 Utilisé uniquement pour l'affichage des histogrammes (psths).
 Si BinFactor>=0 , on trouvera sur l'affichage à l'indice i une moyenne des échantillons contenus dans un
petit segment commençant à l'indice (i div BinFactor)*BinFactor et finissant en (i div BinFactor)*BinFactor +BinFactor-1.

 on obtient une représentation de l'histogramme avec une largeur de classe égale à BinFactor fois la largeur de classe initiale.

 Remarque: cette propriété n'affecte que l'affichage.

}


procedure Tvector.LoadFromWaveFile(stFile:string; ch:integer);
{$H Charge le vecteur à partir d'un fichier audio (.wav)

  ch est le numéro du canal (1 ou 2)

}

procedure Tvector.edit;
{$H Ouvre la fenêtre d'édition }

                        { stmPsth1 Tpsth }

procedure Tpsth.create(StName:string;tp:integer;n1,n2:longint;width:real);
procedure Tpsth.create(tp:integer;n1,n2:longint;width:real);
{$H Constructeur de l'objet Tpsth.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
 Si StName est omis ou vide, l'objet prend le nom de la variable.

 tp est le (type des nombres)@(types de nombre). Actuellement, les types supportés sont:
      t_smallint: entiers sur 2 octets
      t_longint: entiers sur 4 octets
      t_single:  réels sur 4 octets.
      t_extended: réels sur 10 octets

 n1 et n2 sont les indices de début et de fin du psth. n2 doit être supérieur ou
égal à n1 .

 Width est la largeur de classe du psth.

 A ce stade, l'objet est un vecteur ordinaire dont les facteurs d'échelle suivant X
sont:
      X0=0       et      Dx = Width

}

procedure Tpsth.modify(tp:integer;n1,n2:longint;width:real);
{$H Permet de modifier la structure du psth sans détruire l'objet.

  Les paramètres sont les mêmes que ceux du constructeur create@ .

  Après l'appel de Modify, le psth contient des zéros.
}

procedure Tpsth.add(var v:Tvector);
{$H Ajoute les événements contenus dans le vecteur v dans le psth.

 Pour chaque point d'indice i du vecteur v, on évalue la quantité
   k= floor(Yvalue[i]/BinWidth)
 L'élément d'indice k du psth, s'il existe, est alors incrémenté.

 Si l'on veut changer l'origine des dates dans le vecteur v, il faut utiliser
AddEx@ .
}
procedure Tpsth.addEx(var v:Tvector;xorg:real);
{$H Ajoute les événements contenus dans le vecteur v dans le psth.

 Pour chaque point d'indice i du vecteur v, on évalue la quantité
   k= floor( (Yvalue[i]-Xorg) / BinWidth)
 L'élément d'indice k du psth, s'il existe, est alors incrémenté.

}
procedure Tpsth.addsqr(var v:Tvector);
{$H Permet le calcul d'un histogramme "des carrés"
Ajoute les événements contenus dans le vecteur v dans le psth.

}
procedure Tpsth.reset;
{$H Remplit le vecteur avec des zéros et met sa propriété count@ à zéro}
property Tpsth.inHz:boolean;
{$H Détermine la façon dont l'échelle verticale est affichée.

 Si InHz est vrai, l'échelle verticale est exprimée en hertz. Pour cela, on tient
compte des unités horizontales et de la valeur de count@:
 Si UnitX='sec', le paramètre d'échelle dyu vaut 1/(dxu*count)
 Sinon il vaut 1/(dxu*count)*1000 . Autrement dit, on considère que l'échelle
horizontale est en millisecondes.

 Si InHz est faux, dyu est égal à 1 et l'échelle verticale indique directement
le nombre d'événements comptés dans chaque classe.
}
property Tpsth.count:longint;
{$H Pour Tpsth, count contient le nombre de fois où l'on a appelé Add@ ou AddEx@
depuis la création ou depuis le dernier reset@ .

 Pour un Tcorrelogram, count est incrémenté pour chaque événement de v1 pris
en compte.
}
property Tpsth.binWidth:real;
{$H Définit la largeur de classe de l'histogramme.}

                        { stmPsth1 Tcorrelogram }

procedure Tcorrelogram.create(stName:string;tp:integer;n1,n2:longint;width:real);
procedure Tcorrelogram.create(tp:integer;n1,n2:longint;width:real);

{$H Constructeur de l'objet Tcorrelogram

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
 Si StName est omis ou vide, l'objet prend le nom de la variable.
 
 tp est le (type des nombres)@(types de nombre). Actuellement, les types supportés sont
      t_smallint: entiers sur 2 octets
      t_longint: entiers sur 4 octets
      t_single:  réels sur 4 octets
      t_extended: réels sur 10 octets

 n1 et n2 sont les indices de début et de fin du corrélogramme. n2 doit être supérieur ou
égal à n1 .

 Width est la largeur de classe du corrélogramme.

 A ce stade, l'objet est un vecteur ordinaire dont les facteurs d'échelle suivant X
sont:
      X0=0       et      Dx = Width

}

procedure Tcorrelogram.add(var v1,v2:Tvector;x1,x2:real);
{$H Calcule le corrélogramme entre les vecteurs d'événements v1 et v2, en se limitant
aux événements compris entre les dates x1 et x2.

 On suppose que v1 contient des événements qui déclenchent (ou ne déclenchent pas) des
réponses dans le vecteur v2.
 Le calcul revient à calculer un psth dans le vecteur v2 en prenant pour origines
successives les positions des événements de v1.
 La propriété count est incrémentée pour chaque événement de v1 pris en compte.
}

procedure Tcorrelogram.add1(var v1,v2:Tvector;x1,x2:real);

                        { stmMat1 Tmatrix }

procedure Tmatrix.create(stName:string;tp:integer;i1,i2,j1,j2:longint);
procedure Tmatrix.create(tp:integer;i1,i2,j1,j2:longint);
procedure Tmatrix.create;
{$H Constructeur de l'objet Tmatrix

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
 Si StName est omis ou vide, l'objet prend le nom de la variable.

 tp est le (type des nombres)@(types de nombre). Actuellement, les types supportés sont/
      t_smallint: entiers sur 2 octets
      t_longint: entiers sur 4 octets
      t_single:  réels sur 4 octets.
      t_extended: réels sur 10 octets
      t_Scomplex: complexes formés de deux réels de type single

 i1 et i2 sont les indices de la première et de la dernière colonne de la matrice.
 i2 doit être supérieur ou égal à i1 .

 j1 et j2 sont les indices de la première et de la dernière ligne de la matrice.
 j2 doit être supérieur ou égal à j1 .

 Dans la version sans arguments, on attribue les valeurs par défaut tp=t_single, i1=1,
 i2=1, j1=1, j2=1 .
}

procedure Tmatrix.createImage(stName:string;tp:integer;nx,ny:integer);
{$H Construit l'objet Tmatrix avec des options adaptées aux images.

 nx et ny sont les dimensions de la matrice.
 La procédure appelle Tmatrix.create(stName,0,nx-1,0,ny-1).

 Les indices suivant X seront donc compris entre 0 et nx-1.
 Les indices suivant Y seront donc compris entre 0 et ny-1.


 De plus, on affecte les propriétés:

 @f6               InverseY:=true;
 @f6               KeepAspectRatio:=true;
 @f6               AspectRatio:=Jcount/Icount;
 @f6               palColor[1]:=7;
 @f6               palColor[2]:=7;


}
property Tmatrix.Ystart:real readOnly;
{$H Renvoie l'ordonnée d'un point situé sur la première ligne de la matrice.

}
property Tmatrix.Yend:real readOnly;
{$H Renvoie l'ordonnée d'un point situé sur la dernière ligne de la matrice.
}

property Tmatrix.Jstart:integer;
{$H Renvoie l'indice de la première ligne de la matrice.

 Si on modifie Jstart, Jend@ est également modifié pour que la propriété Jcount@ reste constante.
}
property Tmatrix.Jend: integer;
{$H Renvoie l'indice de la dernière ligne de la matrice.

 Si on modifie Jend, Jstart@ est également modifié pour que la propriété Jcount@ reste constante.
}
function Tmatrix.Jcount:longint;
{$H Renvoie le nombre de lignes de la matrice.
}

property TMatrix.Kvalue(i,j:longint):longint;
{$H Permet d'accéder à l'élément de la matrice de coordonnées (i,j) lorsque
le type de nombre est entier.

 Si le type de nombre est réel, la propriété est également utilisable mais la
lecture renvoie un arrondi du contenu de la matrice.
}
property TMatrix.Zvalue(i,j:longint):real default;
{$H Permet d'accéder à l'élément de la matrice de coordonnées (i,j).


 Zvalue est la propriété par défaut de Tmatrix. Ce qui signifie par exemple que l'écriture
 @f6 mat.Zvalue[i,j]:=0;
 peut être remplacée par
 @f6 mat[i,j]:=0;
}

property TMatrix.Rvalue(x,y:real):real;
{$H Permet d'accéder à l'élément de la matrice de coordonnées réelles (x,y).

 Les coordonnées réelles (x,y) sont différentes des coordonnées (i,j) si l'on
a introduit des paramètres d'échelle ( Dx@, x0@, Dy@, y0@ )

 Dans ce cas, les deux types de coordonnées sont reliés par les relations:

   X = Dx * i + x0
   Y = Dy * j + y0
}

property TMatrix.CpxValue(i,j:integer):complex;
{$H Permet d'accéder à l'élément de la matrice complexe de coordonnées (i,j).

 Si la matrice ne contient pas de nombres complexes, la lecture renvoie simplement
un nombre de partie imaginaire nulle alors que l'écriture ignore la partie imaginaire.
}

property TMatrix.MdlValue(i,j:integer):real readOnly;
{$H Renvoie le module de l'élément de coordonnées (i,j)
}

property Tmatrix.CpxMode:integer;
{$H Définit le mode d'affichage des matrices contenant des nombres complexes.

 Quand la matrice contient des nombres réels, chaque élément de matrice se représente
simplement par un pavé coloré en utilisant une échelle de couleurs.

 Quand la matrice contient des nombres complexes, chaque élément de matrice contient
deux informations qui sont:
  partie réelle + partie imaginaire
  ou bien
  Module + Argument

 On peut choisir la façon dont ces informations sont représentées en fixant CpxMode.

 Les valeurs possibles sont:

     0: la couleur d'un pavé représente la partie réelle
     1: la couleur d'un pavé représente  la partie imaginaire
     2: la couleur d'un pavé représente le module
     3: la couleur d'un pavé représente l'argument
     4: Luminance=partie réelle , chrominance=partie imaginaire
     5: Luminance=partie imaginaire , chrominance=partie réelle
     6: Luminance= module , chrominance= argument
     7: Luminance= argument , chrominance= module

 Pour les 4 derniers modes, il faut choisir une palette spéciale formée de 16 couleurs de base
dont l'intensité sera modulée, par exemple: palName@ = 'Pal2D'.

 Il est recommandé d'utiliser les (constantes de mode)@(Modes d'affichage complexes)
}
property Tmatrix.ImValue(i,j:integer):real;
{$H Permet d'accéder à la partie imaginaire de l'élément de coordonnées (i,j).

 Si la matrice n'est pas complexe, la lecture renvoie toujours zéro et l'écriture
est sans effet.
}

property Tmatrix.Dz:real;
{$H Quand le type des éléments de la matrice est entier (t_byte, t_short, t_word, t_smallint ou
t_longint), on associe à chaque valeur k d'un élément de la matrice une valeur réelle z donnée
par la relation:
	z = Dz*k+Z0
 Dz et Z0@ sont les paramètres d'échelle suivant Z.

 Toutes les affectations et lectures tiennent compte de ces paramètres d'échelle.

 Quand le type des éléments est réel ou complexe, les paramètres d'échelle suivant Z sont ignorés.
}

property Tmatrix.z0:real;
{$H Quand le type des éléments de la matrice est entier (t_byte, t_short, t_word, t_smallint ou
t_longint), on associe à chaque valeur k d'un élément de la matrice une valeur réelle z donnée
par la relation:
	z = Dz*k+Z0
 Dz@ et Z0 sont les paramètres d'échelle suivant Z.

 Toutes les affectations et lectures tiennent compte de ces paramètres d'échelle.

 Quand le type des éléments est réel ou complexe, les paramètres d'échelle suivant Z sont ignorés.
}


function Tmatrix.convZ(i:longint):real;
{$H Convertit une valeur fichier en valeur réelle.

 Si k est une valeur fichier, la valeur réelle est donné par la relation

  	 z = Dz@ * k + z0@

 Cette fonction n'a de sens que lorsque le type des éléments est entier (t_byte, t_short,
t_word, t_smallint ou t_longint) .
 La fonction reciproque est invConvZ@ .
}
function Tmatrix.invconvZ(x:real):longint;
{$H Convertit une valeur réelle en valeur fichier.

 Si z est une valeur réelle, la valeur fichier est donné par la relation

  	 k = round ( (z - z0@) / Dz@ )

 Cette fonction n'a de sens que lorsque le type des éléments est entier (t_byte, t_short,
t_word, t_smallint ou t_longint) .
 La fonction reciproque est ConvZ@ .
}
property Tmatrix.Zmin:real;
{$H Définit la limite inférieure de l'échelle de couleurs.

 De façon standard, les éléments de matrice sont représentés par des rectangles coloriés.
 Les couleurs sont choisies dans une palette de 256 couleurs (voir color@, TwoColors@, PalColor@, PalName@ ).
 Le système s'arrange pour que ces 256 couleurs représentent uniformément les valeurs
comprises entre Zmin et Zmax@ .

 Toutes les valeurs de la matrice inférieures ou égales à Zmin seront représentées par la même couleur,
celle qui se trouve à l'extrémité inférieure de la palette.
 Toutes les valeurs de la matrice supérieures ou égales à Zmax seront représentées par la même couleur,
celle qui se trouve à l'extrémité supérieure de la palette.

}
property Tmatrix.Zmax:real;
{$H Définit la limite supérieure de l'échelle de couleurs.

 De façon standard, les éléments de matrice sont représentés par des rectangles coloriés.
 Les couleurs sont choisies dans une palette de 256 couleurs (voir color@, TwoColors@, PalColor@, PalName@ ).
 Le système s'arrange pour que ces 256 couleurs représentent uniformément les valeurs
comprises entre Zmin@ et Zmax .

 Toutes les valeurs de la matrice inférieures ou égales à Zmin seront représentées par la même couleur,
celle qui se trouve à l'extrémité inférieure de la palette.
 Toutes les valeurs de la matrice supérieures ou égales à Zmax seront représentées par la même couleur,
celle qui se trouve à l'extrémité supérieure de la palette.

}

property Tmatrix.Cmin:real;
{$H Définit la limite inférieure de l'échelle de couleurs pour les représentations complexes.

 Quand la matrice contient des nombres complexes, la propriété CpxMode@ définit le mode d'affichage.
 Si CpxMode vaut CM_XY, CM_YX, CM_MDLARG ou CM_ARGMDL, la couleur d'un pavé affiché dépend de deux
 paramètres: le premier paramètre représente la luminance, le second représente la chrominance.
 Les valeurs extrêmes de l'échelle de chrominance sont fixées par Cmin et Cmax@

}
property Tmatrix.Cmax:real;
{$H Définit la limite supérieure de l'échelle de couleurs pour les représentations complexes.

 Quand la matrice contient des nombres complexes, la propriété CpxMode@ définit le mode d'affichage.
 Si CpxMode vaut CM_XY, CM_YX, CM_MDLARG ou CM_ARGMDL, la couleur d'un pavé affiché dépend de deux
 paramètres: le premier paramètre représente la luminance, le second représente la chrominance.
 Les valeurs extrêmes de l'échelle de chrominance sont fixées par Cmin@ et Cmax

}

property Tmatrix.gamma:real;
{$H Facteur de correction pour la palette de couleurs.

 Pour représenter la matrice au moyen d'une palette de couleurs, on découpe l'intervalle (Zmin@ - Zmax@) en
256 segments et on attribue une couleur de la palette à chacun de ces segments.

 Par défaut, gamma vaut 1 et l'intervalle Zmin@ - Zmax@ est découpé en 256 segments de même longueur (variation linéaire).

 En augmentant ou en diminuant gamma (entre 0.1 et 10) , on obtient des segments de longueurs croissantes
ou décroissantes, on favorise ainsi les faibles ou les fortes valeurs de z.


}

property Tmatrix.LogZ: boolean;
{$H Quand LogZ est vrai, l'affichage standard est logarithmique suivant l'axe des Z.

 En mode logarithmique, Zmin@ et Zmax@ doivent tous deux être positifs sinon l'objet l'affichage normal est utilisé.
}


property Tmatrix.theta:real;
{$H Orientation de la matrice.

 Par défaut, Theta est nul et les lignes de la matrice sont affichées horizontalement.

 En augmentant Theta, on fait tourner la matrice autour de son centre, dans le sens
trigonométrique.

 Theta est exprimé en degrés.
}
property Tmatrix.aspectRatio:real;
{$H Rapport d'aspect de la matrice.

 C'est le rapport Hauteur/Largeur de la matrice à l'affichage, dans le
cas où KeepAspectRatio@ vaut True.
 Il est ignoré si KeepAspectRatio@ vaut False.

 Notez qu'il s'agit de l'inverse de la définition usuelle d'un rapport d'aspect pour une image.


 Au moment de la création de l'objet, ce rapport est égal à Jcount@/Icount@

 Cette propriété est liée à la propriété PixelRatio@ par la relation:

 @f6       AspectRatio = PixelRatio * Jcount / Icount
}

property Tmatrix.PixelRatio:real;
{$H Rapport d'aspect des pixels de la matrice.

 C'est le rapport Hauteur/Largeur des pixels à l'affichage, dans le
cas où KeepAspectRatio@ vaut True.
 Il est ignoré si KeepAspectRatio@ vaut False.

 Ce rapport vaut 1 par défaut.

 Voir aussi AspectRatio@
}




property Tmatrix.twoColors:boolean;
{$H Lorsque la palette est monochrome (PalName@='' ou PalName@='Monochrome'),
il est possible d'utiliser deux couleurs différentes pour les valeurs positives
et les valeurs négatives.

 Par défaut, twoColors vaut False. Dans ce cas, les valeurs comprises entre Zmin@
et Zmax@ seront représentées par des couleurs s'étendant du noir jusqu'à la couleur
saturée définie par palColor@[1] .

 Si twoColors vaut True,les valeurs comprises entre 0 et Zmax@ seront représentées par
des couleurs s'étendant du noir jusqu'à la couleur saturée définie par palColor@[1]
alors que les valeurs comprises entre 0 et Zmin@ seront représentées par
des couleurs s'étendant du noir jusqu'à la couleur saturée définie par palColor@[2]

 Si la palette n'est pas monochrome, twoColors est ignoré.
}
property Tmatrix.PalColor(n:integer):integer;
{$H Définit la ou les couleurs utilisées par la palette monochrome.

 Lorsque TwoColors vaut False, PalColor[1] définit la couleur utilisée par la
palette monochrome, PalColor[2] est alors ignoré.

 Lorsque TwoColors vaut True, PalColor[1] définit la couleur utilisée par la
palette monochrome pour les valeurs positives alors que PalColor[2] définit la couleur
utilisée par la palette monochrome pour les valeurs négatives.

 PalColor[n] peut prendre des valeurs de 1 à 7 qui correspondent aux couleurs suivantes:
   1 : Red
   2 : Green
   3 : Blue
   4 : Red + Green
   5 : Red + Blue
   6 : Green + Blue
   7 : Red + Green +Blue

 Par exemple, quand PalColor[1]=6, les couleurs utilisées sont rgb(0,i,i) où
i prend toutes les valeurs comprises entre 0 et 255.
}
property Tmatrix.PalName:string;
{$H PalName est le nom de la palette utilisée pour représenter la matrice.

 Si PalName='', on considère que la palette est monochrome.

 Une palette est un jeu de 256 couleurs rangées dans un fichier d'extension 'PL1'.
 Ce fichier doit être rangé dans le répertoire du programme Elphy pour être reconnu
par le système. Les palettes disponibles apparaissent dans la liste Palette du
dialogue Coordinates/Colors.

 PalName est le nom du fichier sans extension et sans chemin d'accès.

 Il est très facile de créer une palette. Voici un exemple:

 @f6 var
 @f6   i:integer;
 @f6   pal:array[0..255] of longint;

 @f6 program 'Create palette'
 @f6 for i:=0 to 63 do
 @f6   begin
 @f6     pal[i]:=rgb(0,i*4,255);
 @f6     pal[64+i]:=rgb(0,255,252-i*4);
 @f6     pal[128+i]:=rgb(i*4,255,0);
 @f6     pal[192+i]:=rgb(255,252-i*4,0);
 @f6   end;

 @f6 rewrite(1,'c:\dac2\MyPal1.pl1');
 @f6 blockwrite(1,pal);
 @f6 close(1);

}

property Tmatrix.DisplayMode:integer;
{$H Définit le mode d'affichage de la matrice.

 0 correspond au mode normal.
 1 correspond à un lissage de rang 3
 2 correspond à un lissage de rang 3 qui ignore les cases nulles

}
property Tmatrix.AngularMode:integer;
{$H Définit le mode d'affichage angulaire de la matrice.

 Les valeurs possibles sont
   0: aucun affichage angulaire
   1: on affiche des segments orientés suivant les valeurs de la matrice
   2: on affiche des segments orientés suivant les arguments des nombres complexes contenus dans la matrice.

 Voir aussi AngLineWidth@
}
property Tmatrix.AngLineWidth:integer;
{$H Définit la largeur de trait pour l'affichage angulaire.
}

property Tmatrix.Full2DPalette:boolean;
{$H Indique qu'en mode d'affichage complexe, on utilise toutes les couleurs de la palette.
}

property Tmatrix.onControl:boolean;
{$H Permet l'affichage de la matrice sur l'écran de contrôle du stimulateur visuel.
}

procedure Tmatrix.fill(x:real);
{$H Remplit la matrice avec la valeur x .
}
procedure Tmatrix.autoScaleZ;
{$H Cherche le minimum et le maximum des éléments de la matrice
et range les valeurs trouvées dans Zmin@ et Zmax@
}
procedure Tmatrix.autoScaleC;
{$H Pour les matrices de nombres complexes, cherche le minimum et le maximum de la
seconde composante des éléments de la matrice et range les valeurs trouvées
dans Cmin@ et Cmax@ .
}

procedure Tmatrix.autoScaleXYZ;
{$H appelle successivement AutoscaleX@ , AutoscaleY@ et AutoscaleZ@ .
}

procedure Tmatrix.autoScaleZmax(Vmin:real);
{$H Cherche le maximum des éléments de la matrice
puis range la valeur trouvée dans Zmax@.

 Zmin@ prend la valeur du paramètre Vmin à condition que Zmax>=Vmin,
sinon Zmin devient égal à Zmax.
}

procedure Tmatrix.autoScaleZsym;
{$H Cherche le minimum min et le maximum max des éléments de la matrice
puis affecte Zmin@ et Zmax@ de la façon suivante:

 Si abs(min)>abs(max) alors Zmin:=-abs(min) et Zmax:=+abs(min)
 Sinon Zmin:=-abs(max) et Zmax:=+abs(max)

 Le but recherché est de placer le zéro au milieu de l'échelle d'affichage.
}


procedure Tmatrix.inc(i,j:longint);
{$H Ajoute 1 à l'élément de coordonnées (i,j) .
}
procedure Tmatrix.dec(x,y:longint);
{$H Retrnache 1 à l'élément de coordonnées (i,j) .
}

procedure TMatrix.getMinMaxI(var Vmin,Vmax:longint);
{$H Renvoie les valeurs minimale et maximale de la matrice.

 Les variables min et max doivent être initialisées auparavant (par exemple
Vmin:=2000000000 et Vmax:=-2000000000).
 Avec cette méthode, on peut rechercher commodément le minimum et le maximum
d'un groupe de matrices. Il suffit d'initialiser Vmin et Vmax une fois, puis d'appeler
successivement getMinMax pour chaque matrice du groupe.
}

procedure Tmatrix.getMinMax(var Vmin,Vmax:real);
procedure Tmatrix.getMinMax(var Vmin,Vmax:real;var Imini,Jmini,Imaxi,Jmaxi:integer);

{$H Renvoie les valeurs minimale et maximale de la matrice.

 Les variables min et max doivent être initialisées auparavant (par exemple Vmin:=1E100
et Vmax:=-1E100).
 Avec cette méthode, on peut rechercher commodément le minimum et le maximum
d'un groupe de matrices. Il suffit d'initialiser Vmin et Vmax une fois, puis d'appeler
successivement getMinMax pour chaque matrice du groupe.

  Dans la deuxième variante, la méthode renvoie aussi les positions du minimum et du maximum
}
procedure Tmatrix.getMinMaxWithTH(Th1,Th2:real;var Vmin,Vmax:real);
{$H Recherche les valeurs minimale et maximale de la matrice en ne considérant que
les valeurs de la matrices comprises entre th1 et th2.

 Les variables min et max doivent être initialisées auparavant (par exemple Vmin:=1E100
et Vmax:=-1E100).
 Avec cette méthode, on peut rechercher commodément le minimum et le maximum
d'un groupe de matrices. Il suffit d'initialiser Vmin et Vmax une fois, puis d'appeler
successivement getMinMax pour chaque matrice du groupe.
}

procedure Tmatrix.modify(t:integer;i1,i2,j1,j2:longint);
{$H Permet de modifier la structure de la matrice sans la détruire.

 Les paramètres sont les mêmes que ceux du constructeur Create@.
}

procedure Tmatrix.setPosition(x,y,dx,dy,theta:real);
{$H Fixe les paramètres de position sur l'écran de contrôle du stimulateur visuel.

 x et y sont les coordonnées du centre.
 dx et dy sont les dimensions.
 Theta est l'orientation.

 Pour afficher la matrice sur un champ récepteur, il suffit d'écrire par exemple:

 @f6 with RFsys[1] do
 @f6   mat.setPosition(x,y,dx,dy,theta);

 Ce qui transmet les paramètres de position du champ récepteur à la matrice.
}

property Tmatrix.UsePosition:boolean;
{$H Indique que la matrice doit utiliser ses paramètres de position (fixés par exemple avec setPosition@ )
pour l'affichage.
}

function Tmatrix.ConnectedPixels(seuil1,seuil2:real):integer;
{$H  On considère que deux pixels (c'est à dire deux éléments de la matrice) sont connectés
s'ils contiennent tous deux des valeurs z telles que (z<seuil1) ou (z>seuil2).

 La fonction renvoie la taille du plus grand groupe de pixels connectés entre eux.
}

procedure Tmatrix.BuildCnxMap(Threshold:real);
procedure Tmatrix.BuildCnxMap(Threshold:real;mode:integer);
{$H Construit une matrice de connectivité.

 Deux éléments (i1,j1) et (i2,j2) sont considérés comme reliés entre eux s'ils
contiennent une valeur supérieure au seuil Threshold et si abs(i1-i2)<=1 et abs(j1-j2)<=1 .

 Les éléments non significatifs sont remplacés par zéro.

 Si mode=0 (valeur par défaut), les éléments significatifs sont remplacés par le nombre de
pixels connectés.
 Si mode=1 ,les éléments significatifs sont remplacés par la valeur moyenne des pixels connectés.

 Voir aussi AgFilter@



}
procedure Tmatrix.AgFilter(th:real;nbAg:integer);
procedure Tmatrix.AgFilter(th:real;nbAg:integer;AbsMode: boolean);

{$H Filtrage par connectivité.

 Les éléments non significatifs de la matrice sont remplacés par des zéros.
 Le paramètre optionnel AbsMode vaut false par défaut.

 Pour chaque pixel, on teste la condition
   COND = (not AbsMode AND (Zvalue>th)) OR (AbsMode AND (abs(Zvalue)>th))

 Les éléments significatifs sont les éléments vérifiant COND qui font partie d'un agrégat
ayant au moins nbAg éléments.

 Lorsque nbAg<0 , nbAg prend pour valeur le nombre d'éléments du plus grand agrégat.

 Deux éléments (i1,j1) et (i2,j2) sont considérés comme faisant partie du même agrégat s'ils
vérifient la condition COND et si abs(i1-i2)<=1 et abs(j1-j2)<=1 .

 Voir aussi BuildCnxMap@
}


property Tmatrix.useWF:boolean;
{$H Active le mode Waterfall.

 Ce mode WaterFall n'a d'autre but que de permettre la superposition d'un objet
TvectorArray sur une matrice.

 En choisissant les mêmes valeurs pour les paramètres dxWF@, dyWF@, Mtop@, Mleft@,
Mbottom@ et Mright@ pour la matrice et l'objet TvectorArray, on pourra superposer
exactement les deux objets.
}

property Tmatrix.dxWF:real;
{$H Décalage des traces selon X en mode waterfall

 Ce mode WaterFall n'a d'autre but que de permettre la superposition d'un objet
TvectorArray sur une matrice.

 dxWF est exprimé en pourcentage de la dimension horizontale d'un petit cadre de la
grille et peut être positif ou négatif.
 Quand dxWF est différent de zéro, l'affichage est décalé selon X à chaque ligne de la
grille afin de donner un effet de cascade.

}
property Tmatrix.dyWF:real;
{$H Décalage des traces selon Y en mode waterfall

 Ce mode WaterFall n'a d'autre but que de permettre la superposition d'un objet
TvectorArray sur une matrice.

 dyWF est exprimé en pourcentage de la dimension verticale d'un petit cadre de la
grille et peut être positif ou négatif.
 Quand dyWF est différent de zéro, l'affichage est décalé selon Y à chaque colonne de la
grille afin de donner un effet de cascade.

}
property Tmatrix.Mleft:real;
{$H Définit la Marge gauche pour l'affichage de la matrice.

 Cette marge n'est utile que lorsque l'on veut superposer un objet TvectorArray
sur une matrice.

 Mleft est exprimé en pourcentage de la dimension horizontale de la fenêtre d'affichage.
}
property Tmatrix.Mright:real;
{$H Définit la Marge droite pour l'affichage de la matrice.

 Cette marge n'est utile que lorsque l'on veut superposer un objet TvectorArray
sur une matrice.

 Mright est exprimé en pourcentage de la dimension horizontale de la fenêtre d'affichage.
}


property Tmatrix.Mtop:real;
{$H Définit la marge haute pour l'affichage de la matrice.

 Cette marge n'est utile que lorsque l'on veut superposer un objet TvectorArray
sur une matrice.

 Mtop est exprimé en pourcentage de la dimension verticale de la fenêtre d'affichage.
}

property Tmatrix.Mbottom:real;
{$H Définit la marge basse pour l'affichage de la matrice.

 Cette marge n'est utile que lorsque l'on veut superposer un objet TvectorArray
sur une matrice.

 Mbottom est exprimé en pourcentage de la dimension verticale de la fenêtre d'affichage.
}

property Tmatrix.selColor:longint;
{$H Définit la couleur de sélection.

 Il s'agit de la couleur utilisée pour entourer les cellules sélectionnées
dans une matrice. Voir SelPix@ .
}
property Tmatrix.selPix(i,j:longint):boolean;
{$H Indique les cellules sélectionnées dans une matrice.

 Les cellules sélectionnées apparaissent entourées par un trait de couleur
selColor@ .
}

property Tmatrix.MarkColor:longint;
{$H Définit la couleur de marquage.

 Il s'agit de la couleur utilisée pour marquer avec une croix les cellules
dans une matrice. Voir MarkPix@ .
}
property Tmatrix.MarkPix(i,j:longint):boolean;
{$H Indique les cellules marquée dans une matrice.

 Les cellules marquées sont marquées avec une croix de couleur MarkColor@ .
}

property Tmatrix.SelectON:boolean;
{$H Active ou désactive la possibilité de sélection d'une case de la matrice avec la souris.
}

property Tmatrix.MarkON:boolean;
{$H Active ou désactive la possibilité de marquage d'une case de la matrice avec la souris.
}



procedure Tmatrix.ClearSelPix;
{$H Efface toutes les selections.
}
procedure Tmatrix.ClearMarkPix;
{$H Efface toutes les marques.
}
property Tmatrix.SingleSel:boolean;
{$H Interdit ou autorise les sélections multiples.

 Si SingleSel vaut TRUE, toute nouvelle sélection supprime toutes les sélections précédentes. De
cette façon, une seule case de la matrice est sélectionnée à  la fois.
}
property Tmatrix.SingleMark:boolean;
{$H Interdit ou autorise les marques multiples.

 Si SingleMark vaut TRUE, toute nouvelle marque supprime toutes les marques précédentes. De
cette façon, une seule case de la matrice est marquée à  la fois.
}

property Tmatrix.OnSelect:TmatSelect;
{$H Gestionnaire d'événement appelé quand l'utilisateur clique sur une case de la matrice
en mode Select.

  OnSelect doit recevoir une procédure conforme à la déclaration suivante:
  TmatSelect=procedure( var mat:Tmatrix;x,y:integer);

 @f6   Exemple:
 @f6   procedure myOnselect(var mat:Tmatrix;x,y:integer);
 @f6   begin
 @f6
 @f6   end;

 Mat est la matrice qui a généré l'événement. Le gestionnaire peut donc servir à plusieurs
objets.
 x et y sont les coordonnées du point cliqué dans la matrice.
}

property Tmatrix.OnMark:TmatSelect;
{$H Gestionnaire d'événement appelé quand l'utilisateur clique sur une case de la matrice
en mode Mark.

  OnMark doit recevoir une procédure conforme à la déclaration suivante:
  TmatSelect=procedure( var mat:Tmatrix;x,y:integer);

 @f6   Exemple:
 @f6   procedure myOnMark(var mat:Tmatrix;x,y:integer);
 @f6   begin
 @f6
 @f6   end;

 Mat est la matrice qui a généré l'événement. Le gestionnaire peut donc servir à plusieurs
objets.
 x et y sont les coordonnées du point cliqué dans la matrice.
}

property Tmatrix.OnHint:TmatHint;
{$H Gestionnaire d'événement appelé quand l'utilisateur clique sur une case de la matrice
tout en appuyant sur la touche Control .

  OnHint doit recevoir une procédure conforme à la déclaration suivante:
  TmatHint=procedure( var mat:Tmatrix;x,y:real;var stH:string);

  Par défaut, quand on clique sur une case de la matrice tout en appuyant sur la touche Control,
on obtient une indication contenant les coordonnées de la case et le contenu de la case.

  Avec le gestionnaire OnHint , on peut afficher une indication complémentaire. Cette
indication doit être renvoyée dans la variable stH.
  Mat est la matrice qui a généré l'événement.
  x et y sont les coordonnées du point cliqué dans la matrice. Ce sont des nombres réels.

}

Property Tmatrix.Contour:TcontourPlot readOnly;
{$H ContourPlot associé à la matrice.

 Quand une matrice est créée, l'objet contour, de type TcontourPlot@ , n'est pas
créé automatiquement mais le seul fait d'utiliser cette propriété le créera si
nécessaire.
}



Property Tmatrix.D3_mode:integer;
Property Tmatrix.D3_D0:real;
Property Tmatrix.D3_fov:real;
Property Tmatrix.D3_ThetaX:real;
Property Tmatrix.D3_ThetaY:real;
Property Tmatrix.D3_ThetaZ:real;

Function Tmatrix.sum:real;
Function Tmatrix.sum(i1,i2,j1,j2:integer):real;
{$H Renvoie la somme (réelle) des éléments de la matrice dont les coordonnnées (i,j) satisfont les conditions:

 @f6  i1 <= i <= i2
 @f6  j1 <= j <= j2

}

Function Tmatrix.SqrSum:real;
Function Tmatrix.SqrSum(i1,i2,j1,j2:integer):real;
{Renvoie la somme des carrés des éléments de la matrice.

 Pour les nombres complexes, on obtient le somme des carrés des modules.

 Dans la première variante, on considère tous les éléments de la matrice;
 Dans la seconde variante, on considère les éléments (i,j) qui satisfont les conditions:

 @f6  i1 <= i <= i2
 @f6  j1 <= j <= j2

}

Function Tmatrix.mean:real;
Function Tmatrix.mean(i1,i2,j1,j2:integer):real;
{$H Renvoie la moyenne (réelle) des éléments de la matrice dont les coordonnnées (i,j) satisfont les conditions:

 @f6  i1 <= i <= i2
 @f6  j1 <= j <= j2

}

Function Tmatrix.CpxMean:complex;
Function Tmatrix.CpxMean(i1,i2,j1,j2:integer):complex;
{$H Renvoie la moyenne complexe des éléments de la matrice dont les coordonnnées (i,j) satisfont les conditions:

 @f6  i1 <= i <= i2
 @f6  j1 <= j <= j2

}


Function Tmatrix.stdDev:real;
Function Tmatrix.stdDev(i1,i2,j1,j2:integer):real;
{$H Renvoie la standard deviation (réelle) des éléments de la matrice dont les coordonnnées (i,j) satisfont les conditions:

 @f6  i1 <= i <= i2
 @f6  j1 <= j <= j2

 La fonction convient aussi quand la matrice contient des nombres complexes.

}
Function Tmatrix.mean0:real;
{$H Identique à mean@
}
Function Tmatrix.stdDev0:real;
{$H Identique à stdDev@
}
Function Tmatrix.sum0:real;

procedure Tmatrix.ColtoVec(n:integer;vec:Tvector);
{$H Transfert les éléments de la colonne n de la matrice dans le vecteur vec.

 La structure du vecteur est modifiée pour que ses indices de début et de fin deviennent
égaux à Jstart@ et Jend@, et pour que son type de nombre soit égal à NumType.
}

procedure Tmatrix.LinetoVec(n:integer;vec:Tvector);
{$H Transfert les éléments de la ligne n de la matrice dans le vecteur vec.

 La structure du vecteur est modifiée pour que ses indices de début et de fin deviennent
égaux à Istart@ et Iend@, et pour que son type de nombre soit égal à NumType.
}

procedure Tmatrix.VecToCol(vec:Tvector;n:integer);
{$H Transfert les éléments du vecteur vec dans la colonne n de la matrice.

 La structure de la matrice n'est pas modifiée.
 Il faut impérativement que les conditions suivantes soient vérifiées:
 @f6 vec.Istart = Jstart
 @f6 vec.Iend = Jend

}

procedure Tmatrix.VecToLine(vec:Tvector;n:integer);
{$H Transfert les éléments du vecteur vec dans la ligne n de la matrice.

 La structure de la matrice n'est pas modifiée.
 Il faut impérativement que les conditions suivantes soient vérifiées:
 @f6 vec.Istart = Istart
 @f6 vec.Iend = Iend

}

procedure Tmatrix.ShowContour;
{$H Affiche le contour@ par dessus la matrice dans les objets multigraph@ .

 Les coordonnées du contour sont d'abord rendues égales à celles de la matrice.
 Les coefficients de couplage cpx et cpy du contour sont ensuite rendus égaux à ceux de
la matrice.

 Puis un message est envoyé à tous les objets multigraph pour que ces objets rangent le contour
dans les fenêtres qui contiennent la matrice.
}

procedure TMatrix.CenterOfGravity(var xG, yG: real);
{$H Calcule les coordonnées du centre de gravité de la matrice.
}

property Tmatrix.Transparent:boolean;
{$H Si Transparent vaut TRUE, les pixels contenant la valeur TransparentValue@ ne sont pas affichés.
}

Property Tmatrix.TransparentValue:real;
{$H Si Transparent@ vaut TRUE, les pixels contenant la valeur TransparentValue ne sont pas affichés.
}

procedure addMatrix(mat,mat1,mat2:Tmatrix);
{$H Fait la somme de mat1 et mat2 et range le résultat dans mat

 OBSOLETE: utiliser Madd@
}

procedure subMatrix(mat,mat1,mat2:Tmatrix);
{$H Fait la différence de mat1 et mat2 et range le résultat dans mat

 OBSOLETE: utiliser Msub@
}

procedure MultiplyMatrix(mat,mat1,mat2:Tmatrix);
{$H Fait la multiplication point par point de mat1 et mat2 et range le résultat dans mat

 OBSOLETE: utiliser Mmul@
}

procedure DivideMatrix(mat,mat1,mat2:Tmatrix);
{$H Fait la division point par point de mat1 et mat2 et range le résultat dans mat

 OBSOLETE: utiliser Mdiv@
}


procedure incrementMatrix(mat,mat1:Tmatrix;cte:real);
{$H OBSOLETE : utiliser Madd@
}

procedure KMultiplyMatrix(mat,mat1:Tmatrix;cte:real);
{$H OBSOLETE: utiliser MaddNum@
}

procedure ZscoreMap(var src,dest:Tmatrix;Zmean,Zstd,Zthreshold:real;Fabove,Fzero:boolean);
{$H Construit une carte en Zscore.

 src est la matrice source
 dest est la matrice destination. Elle peut être égale à src.

 Zmean est la valeur moyenne de référence.
 Zstd est la standard deviation de référence.
 Zthreshold est le seuil en unités de Zstd

 En pseudo-code, l'algorithme est le suivant:

 On définit d'abord deux seuils th1 et th2 :

 @f6  if Fabove
 @f6     then th1:=-1E100
 @f6     else th1:=Vmean-Vstd*Zthreshold;
 @f6   Th2:=Vmean+Vstd*Zthreshold;

 Puis, pour chaque élément z de la matrice, on calcule la nouvelle valeur:

 @f6   if (z<=th1) or (z>=th2) then
 @f6     begin
 @f6        z:=(z-Vmean)/Vstd;
 @f6        if Fzero then
 @f6          begin
 @f6            if z>0
 @f6              then z:=z-Zthreshold
 @f6              else z:=z+Zthreshold;
 @f6          end;
 @f6     end
 @f6   else z:=0;

 Si Fabove est vrai, toutes les valeurs en dessous de la moyenne sont considérées
comme non significatives.

 Si Fzero est vrai, on retranche le seuil aux valeurs calculées, ce qui permet une
meilleure utilisation de l'échelle des couleurs après un autoscale.

 Si on veut construire la carte en Zscore sans seuillage au sens habitule, on appellera la méthode
avec Zthreshold=0, Fabove:=false, Fzero=false.
}

procedure Tmatrix.copyMat(var mat:Tmatrix);
{$H Copie les données de la matrice Mat

  Mat doit avoir les mêmes valeurs NumType@, Istart@, Iend@, Jstart@, Jend@ que l'objet.
}

procedure Tmatrix.Threshold(th:real;Fup,Fdw:boolean);
{$H Réalise une opération de seuillage sur tous les points de la matrice.

 L'algorithme est le suivant:

 @f6   for i:=Istart to Iend do
 @f6   for j:=Jstart to Jend do
 @f6   begin
 @f6     y:=Zvalue[i,j]-th;
 @f6     if Fup and (y>0) then Zvalue[i,j]:=y
 @f6     else
 @f6     if Fdw and (y<0) then Zvalue[i,j]:=-y
 @f6     else Zvalue[i,j]:=0;
 @f6   end;

}

procedure Tmatrix.Threshold1(th:real);
{$H Réalise une opération de seuillage sur tous les points de la matrice.

  On remplace toutes les valeurs supérieures ou égales au seuil par des uns,
et toutes les autres par des zéros.

 L'algorithme est le suivant:

 @f6   for i:=Istart to Iend do
 @f6   for j:=Jstart to Jend do
 @f6     if Zvalue[i,j]>=th
 @f6       then Zvalue[i,j]:=1
 @f6       else Zvalue[i,j]:=0;

}
procedure Tmatrix.Threshold2(th1,th2,val1,val2:real);
{$H Réalise une opération de seuillage sur tous les points de la matrice.

  On remplace toutes les valeurs inférieures au seuil th1 par val1.
  On remplace toutes les valeurs supérieures au seuil th2 par val2.

  L'algorithme est le suivant:

 @f6   for i:=Istart to Iend do
 @f6   for j:=Jstart to Jend do
 @f6     if Yvalue[i,j]<th1 then Yvalue[i,j]:=val1
 @f6     else
 @f6     if Yvalue[i,j]>th2 then Yvalue[i,j]:=val2;

}

function Tmatrix.loadFromBMP(stF:string):boolean;
{$H Charge un fichier BMP dans la matrice.

 Le fichier doit contenir un bitmap 8 bits.
 Le type de nombre n'est pas changé
 Les dimensions du bitmap deviennent celles de la matrice.
 Les pixels deviennent des nombres compris entre 0 et 255.
}

function Tmatrix.saveAsBMP(stF:string):boolean;
{$H Sauve la matrice sous forme d'un fichier BMP.

 stF est le nom du fichier.

 Le bitmap sauvé a une profondeur de pixel de 8 bits.
 Les valeurs contenues dans la matrice doivent être comprises entre 0 et 255.
}

procedure Tmatrix.edit;
{$H Ouvre la fenêtre d'édition de la matrice.
}

function Tmatrix.loadFromSTK(stF:string;num:integer):boolean;
{$H Charge une image à partir d'un fichier STK.

  num est le numéro de l'image dans la pile (le premier numéro est zéro).

  La matrice résultante est toujours de type single. 
}

procedure TMatrix.setMapScale(Xextent, Yextent, Iorg, Jorg: real);
{$H Fixe les paramètres d'échelle dans le cas où la matrice est une "carte" .

 La méthode réalise les actions suivantes:

    dx:=Xextent/Icount
    dy:=Yextent/Jcount
    x0:=-Iorg*dx;
    y0:=-Jorg*dy;
    AspectRatio:=Yextent/Xextent;

 Xextent et Yextent sont les dimensions réelles de la carte (en cm, degrés visuels, etc...)
 Iorg et Jorg sont les coordonnées fichier du point que l'on souhaite prendre comme origine.
 Si l'on souhaite placer le point (Istart,Jstart) à l'origine, on écrira
     with mat do setMapScale(Xextent,Yextent,Istart,Jstart);
 Si l'on souhaite placer l'origine au centre de la carte, on écrira
     with mat do setMapScale(Xextent,Yextent,(Istart+Iend)/2,(Jstart+Jend)/2);


}

procedure Tmatrix.ShowDesignWindow;

procedure MatToSectors(var mat:Tmatrix;var vec:Tvector;xa,ya,xb,yb:real;thresh:real;nb:integer);
{$H Calcule la distribution angulaire des éléments de matrice situés au dessus d'un seuil.

 On partitionne le plan en nb secteurs de sommet (xa,ya). Le premier secteur (numéroté 0 ) est tel que son axe soit
dirigé suivant le segment A(xa,ya) - B(xb,yb) .
 Les autres secteurs sont obtenus en tournant l'axe d'un angle pi/nb autour du point A dans le sens trigonométrique.

 Dans chaque secteur, on compte le nombre d'éléments de matrice dont la valeur est supérieure au seuil Thresh.
 Le vecteur vec est modifié de sorte que Istart=0 et Iend=nb-1

}


procedure Tmatrix.loadSingleData(var binF:TbinaryFile);
procedure Tmatrix.loadSingleData(var binF:TbinaryFile; FbyLine: boolean);

{$H Charge des données à partir d'un fichier binaire contenant des réels sur 4 octets (type single).

 binF est du type TbinaryFile@ . Le fichier doit avoir été ouvert au moyen de la méthode
Reset@(TbinaryFile.Reset) ou de la méthode Rewrite@(TbinaryFile.Rewrite)

 La matrice n'a pas besoin d'avoir été créée avec un type single pour utiliser
cette méthode. Par contre, le nombre de valeurs disponibles sur le disque doit correspondre
au nombre d'éléments de la matrice.

 Fbyline vaut false par défaut.
 Si Fbyline vaut True, les données sont chargées ligne par ligne.


 Voir saveSingleData@
}

procedure Tmatrix.saveSingleData(var binF:TbinaryFile);
procedure Tmatrix.saveSingleData(var binF:TbinaryFile; FByLine:boolean);

{$H Sauve les données de la matrice dans un fichier binaire au format single (réels sur 4 octets).

 binF est du type TbinaryFile@ . Le fichier doit avoir été ouvert au moyen de la méthode
Reset@(TbinaryFile.Reset) ou de la méthode Rewrite@(TbinaryFile.Rewrite)

 Le nombre d'octets écrits est (Iend-Istart+1)*(Jend-Jstart+1)*4.

 Fbyline vaut false par défaut.
 Si Fbyline vaut True, les données sont sauvées ligne par ligne

 Voir loadSingleData@ .
}

procedure Tmatrix.Distri(var vec:Tvector);
{$H Calcule un histogramme donnant la distribution des valeurs contenues dans la matrice.

 Le vecteur vec doit auparavant être convenablement paramètré, en fixant notamment:

 - ses indices de début et de fin
 - son type qui doit être de préférence t_smallint ou t_longint
 - sa propriété Dx@ qui représente la largeur de classe de l'histogramme.

}

procedure TMatrix.loadFromText(fileName: string);
{$H Charge un fichier texte dans la matrice

 Chaque ligne du fichier doit contenir des nombres séparés par tabulations, des virgules ou des point-virgules.

 La structure de la matrice est modifiée s'ajuster au nombre de lignes et au nombre de colonnes

}
procedure TMatrix.saveAsText(fileName: string; decimalPlaces: integer);
{$H Sauve les données de la matrice dans un fichier texte.

 decimalPlaces est le nombre de décimales. Si ce paramètre vaut -1, on utilise la notation scientifique.

 Le caractère séparateur utilisé est la tabulation.
}

procedure TMatrix.Circle(xC, yC, Rc, value: real;Ffill:boolean);
{$H Construit un cercle dans la matrice.

  La matrice est considérée comme un bitmap monochrome.
  xc et yc sont les coordonnées du centre du cercle.
  Rc est le rayon du cercle.
  value est la valeur de remplissage.
  Si Ffill est vrai, l'intérieur du cercle est rempli avec value. Sinon, on dessine
un cercle d'épaisseur égale à 1 pixel.

}
procedure TMatrix.Polygons(var plot:TXYplot; val1,val2:real;Ffill:boolean);
{$H Reproduit les tracés de l'objet plot dans la matrice

 La matrice est considérée comme un bitmap monochrome.

 Si Ffill vaut True, chaque polyline de plot est d'abord fermée si elle ne l'est pas.
Le polygone obtenu est ensuite dessiné dans la matrice. Val1 est la couleur du tracé. Val2 est la couleur de remplissage.

 Si Ffill vaut false, les polylines ne sont pas fermées automatiquement. Elles sont dessinées avec la couleur val1.
 Val2 est considéré comme la largeur de trait.

 On utilise les paramètres d'échelle de la matrice.
}

function getPalNameList: string;
{$H Renvoie la liste des palettes disponibles dans le système.

 Les noms des palettes sont utilisés par la propriété PalName@(Tmatrix.PalName) de Tmatrix@

 La liste est une chaine de caractères qui contient les noms séparés par le caractère '|' .


}


                        { stmJP Tjpsth }
procedure TJpsth.create(stName:string;t:integer;i1,i2,j1,j2:longint;Lclasse:real);
procedure TJpsth.create(t:integer;i1,i2,j1,j2:longint;Lclasse:real);

Procedure TJpsth.Add(vec1,vec2:Tvector);

property TJpsth.BinWidth:real;
property TJpsth.Count:longint;

                        { stmJP T2Dcorre }

procedure T2Dcorre.Create(stName:string;t:integer;i1,i2,j1,j2:longint;binWidthX,binWidthY:real);
procedure T2Dcorre.Create(t:integer;i1,i2,j1,j2:longint;binWidthX,binWidthY:real);

Procedure T2Dcorre.Add(vec1,vec2:Tvector;x1,x2:real);

property T2Dcorre.BinWidthX:real;
property T2Dcorre.BinWidthY:real;



                        { stmGraph Tgraph }

procedure Tgraph.create(stName:string;var Xvec,Yvec:Tvector;iStart,iEnd:longint);
procedure Tgraph.create(var Xvec,Yvec:Tvector;iStart,iEnd:longint);
procedure Tgraph.create;

procedure Tgraph.modify(var Xvec,Yvec:Tvector;iStart,iEnd:longint);
procedure Tgraph.setErrorData(var ErrorVec:Tvector);


property Tgraph.autoLimit:boolean;

property Tgraph.OwnedVectors:boolean;
property Tgraph.VecX:Tvector readOnly;
property Tgraph.VecY:Tvector readOnly;
property Tgraph.VecSigma:Tvector readOnly;

                        { multG1 TmultiGraph }

function Multigraph0:Tmultigraph;

procedure TmultiGraph.create(stName:string;nx,ny:integer);
procedure TmultiGraph.create(nx,ny:integer);
procedure TmultiGraph.create;

{$H Constructeur de l'objet Multigraph.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
 L'objet est initialisé avec une grille contenant nx*ny fenêtres.
 nx est le nombre de fenêtres dans le sens horizontal.
 ny est le nombre de fenêtres dans le sens vertical.

 Si nx et ny sont omis, la page ne contient pas de fenêtres. 
}


procedure TmultiGraph.initGrid(PageNum,nx,ny:integer);
{$H Initialise une grille  dans la page@ de numéro pageNum contenant
nx*ny fenêtres.
 nx est le nombre de fenêtres dans le sens horizontal.
 ny est le nombre de fenêtres dans le sens vertical.

 Toutes les fenêtres existant auparavant sont détruites.
 Ensuite, on peut ranger des objets dans les fenêtres en utilisant addObjectOnGrid@
au lieu de addObject@.

}
procedure TmultiGraph.addObjectOnGrid(pageNum,i,j:integer;plot:Tplot);
{$H Range l'objet Plot dans la fenêtre de coordonnées grille (i,j) dans la page@
de numéro PageNum.

 Cette procédure n'a d'effet que si l'on a appelé InitGrid@ auparavant. Elle remplace
avantageusement AddObject@ quand on souhaite référencer les fenêtres au moyen de
deux coordonnées.

 i est la position horizontale de la fenêtre. Elle doit être comprise entre 1 et le
nombre de fenêtres dans le sens horizontal.
 j est la position verticale de la fenêtre. Elle doit être comprise entre 1 et le
nombre de fenêtres dans le sens vertical.
 La fenêtre située en haut à gauche dans la grille a pour coordonnées (1,1).

 Plot doit être un descendant de Tplot (exemple: Tvector ou Tmatrix)

 }
procedure TmultiGraph.addObject(page,w:integer;u:Tplot);
{$H Range l'objet Plot dans la fenêtre de numéro w dans la page@ de numéro PageNum.

 w est le numéro de création de la fenêtre. Il est compris entre 1 et le
nombre de fenêtres.

 Plot doit être un descendant de Tplot (exemple: Tvector ou Tmatrix)

 La procédure a le même effet qu'un glisser-déposer de l'inspecteur d'objet vers
une fenêtre multigraph.

  Voir aussi AddObjectEx@ .
 }

procedure TmultiGraph.addObjectEx(page,w:integer;u:Tobject);
procedure TmultiGraph.addObjectEx(page,w:integer;u:Tobject; mode:integer);

{$H Fonctionne comme addObject@ mais ne vérifie pas le type de l'objet à la compilation.

  u peut donc être un objet de n'importe quel type.
  A l'exécution, une erreur sera générée si l'objet u ne peut pas être rangé dans une fenêtre.

  Actuellement addObjectEx peut être utilisé avec Tdialog@ , TDBgrid@ , TstmMemo@

  Le paramètre mode est utilisé pour les objects qui ont deux modes d'incrustation: par exemple Tmemo@
peut simplement afficher du texte dans la fenêtre (mode=1) ou bien peut permettre la saisie de texte (mode=2).
}

procedure TmultiGraph.addDialog(page,w:integer;u:Tdialog);
procedure TmultiGraph.addCursor(page,w:integer;u:Tcursor);

procedure TmultiGraph.ClearObjects(pageNum,w:integer);
{$H Enlève tous les objets de la fenêtre de numéro w dans la page@ de numéro pageNum.
}

property TmultiGraph.color:longint;
{$H Color est la couleur de fond d'une page.
}
property TmultiGraph.caption:string;
{$H Caption est la chaine de caractère qui apparait dans la barre de titre d'une
fenêtre (au sens du système Windows).

 Pour multigraph0, modifier cette propriété n'aura qu'un effet temporaire. Par contre,
on peut changer de façon permanente la barre de titre d'un autre objet multigraph.
}
property TmultiGraph.screenNum:integer;
/Page
{$H En lecture, Page renvoie le numéro de la page actuellement visible.

 L'affectation de la propriété Page permet de changer la page visible.

 Les pages sont numérotées à partir de 1.
}

procedure Tmultigraph.selectScreen(i:integer);
{$H Méthode assurant la compatibilité avec Acquis1.

 Il est préférable d'utiliser la propriété Page@ .
}
procedure TmultiGraph.refresh;
{$H Force le réaffichage complet et immédiat de la page courante.

 En général, il n'est pas nécessaire d'appeler Refresh car la mise à jour de
multigraph est automatique.
 Cela peut être utile si vous avez dessiné directement dans les fenêtres multigraph.
 Dans ce cas, Refresh a pour effet de faire disparaitre ces dessins.
}
procedure TmultiGraph.update;
{$H Entraine la mise à jour immédiate de la page courante.

 L'utilité de update est liée au fonctionnement de l'affichage sous Windows.
 La plupart des procédures qui modifient un objet
(vecteur, matrice,etc..) se contentent d'invalider l'objet. Ce qui signifie que le
système Elphy note simplement que l'affichage de cet objet a besoin d'être actualisé
mais ne fait rien d'autre dans l'immédiat.
 Pendant le déroulement d'un programme utilisateur, le système tient à jour la
liste des objets invalidés puis, quand le programme se termine ou quand le programme
entre dans une phase d'attente, tous les objets invalidés sont réaffichés d'un seul
coup. Ceci a un inconvénient lorsque le programme effectue un calcul assez long
(plusieurs secondes ou minutes): on ne voit pas l'évolution des résultats.

 La méthode update remédie à ce problème. Il ne faut pas en abuser car elle
entraîne un ralentissement de l'exécution.
}

procedure TmultiGraph.updatePages;
{$H Met à jour immédiatement toutes les pages.


}


procedure TmultiGraph.Droite(a,b:real);
/DisplayLinearFunc
{$H Affiche une droite d'équation y=a*x+b

 La droite s'affiche dans la fenêtre courante( voir setWindow@), dans le système
de coordonnées courant (voir setWorld@), avec la couleur courante (voir penColor@).
}
procedure TmultiGraph.Line(x1,y1,x2,y2:real);
{$H Trace un segment de droite entre les points de coordonnées (x1,y1) et (x2,y2).

 Le segment s'affiche dans la fenêtre courante( voir setWindow@), dans le système
de coordonnées courant (voir setWorld@), avec la couleur courante (voir penColor@).
}
procedure TmultiGraph.lineTo(x,y:real);
{$H Trace un segment de droite commençant à la position d'écriture courante et
finissant au point de coordonnées x,y .

 Le point d'écriture courante est déterminé par le dernier appel à moveto@ ou lineTo.

 Le segment s'affiche dans la fenêtre courante( voir setWindow@), dans le système
de coordonnées courant (voir setWorld@), avec la couleur courante (voir penColor@).
}
procedure TmultiGraph.moveto(x,y:real);
{$H Fixe la position d'écriture au point de coordonnées (x,y).

 Ce point sera en particulier utilisé par lineto@ .
}
procedure TmultiGraph.LineVer(x0:real);
{$H Trace une droite verticale d'équation x=x0 .

 La droite s'affiche dans la fenêtre courante( voir setWindow@), dans le système
de coordonnées courant (voir setWorld@), avec la couleur courante (voir penColor@).
}
procedure TmultiGraph.LineHor(y0:real);
{$H Trace une droite horizontale d'équation y=y0 .

 La droite s'affiche dans la fenêtre courante( voir setWindow@), dans le système
de coordonnées courant (voir setWorld@), avec la couleur courante (voir penColor@).
}
procedure TmultiGraph.VSrectangle(x,y,dx,dy,theta:real);
{$H Trace un rectangle dans la fenêtre courante en utilisant les conventions
du stimulateur visuel.
}

procedure TmultiGraph.setWindow(num:integer);
{$H Choisit la fenêtre multigraph destinée à recevoir les futures opérations
d'écriture.

 num est le numéro de la fenêtre dans la page courante. Ce numéro doit être compris
entre 1 et le nombre de fenêtres.

 On peut aussi choisir une fenêtre contenant un objet déterminé avec selectWindow@ .

 Quand le premier objet contenu dans la fenêtre est un descendant de TdataObject,
c'est en fait le rectangle intérieur (celui sur lequel s'appuient les graduations)
qui est sélectionné.
}
function TmultiGraph.getWindow:integer;
{$H Renvoie le numéro de la fenêtre courante.

 Ce numéro est celui de la fenêtre qui a été choisie avec setWindow@ ou selectWindow0.
}
procedure TmultiGraph.getWindowPos(page,win:integer;var x1,y1,x2,y2:integer);
{$H Renvoie les coordonnées de la fenêtre de numéro win dans la page de numéro page.

  x1 et y1 sont les coordonnées du coin en haut à gauche de la fenêtre.
  x2 et y2 sont les coordonnées du coin en bas à droite de la fenêtre.
}

procedure TmultiGraph.selectWindow(plot:Tplot);
{$H Choisit la fenêtre multigraph destinée à recevoir les futures opérations
d'écriture en se basant sur un objet contenu dans la fenêtre.

 Plot est un descendant de Tplot(ex: Tvector ou Tmatrix). Si plusieurs fenêtres
contiennent l'objet plot, c'est la première fenêtre qui est retenue.
 On peut aussi choisir une fenêtre en se basant sur son numéro avec setWindow@ .
}
procedure TmultiGraph.setWindowEx(x1,y1,x2,y2:integer);
{$H Définit la fenêtre destinée à recevoir les futures opérations d'écriture en
fixant ses coordonnées en pixels.

 x1 et y1 sont les coordonnées du point en haut à gauche de la fenêtre.
 x2 et y2 sont les coordonnées du point en bas à droite de la fenêtre.

 Contrairement à setWindow@ , on ne tient pas compte des fenêtres existantes. Il
devient donc possible d'écrire n'importe où sur l'écran multigraph. Ce qui n'est pas
recommandé.
 Il peut parfois être intéressant de définir des sous-fenêtres dans une fenêtre
existante. Dans ce cas, on récupère les coordonnées d'une fenêtre existante
avec getWindowEx@ puis on calcule les coordonnées des sous-fenêtres.
}
procedure TmultiGraph.getWindowEx(var x1,y1,x2,y2:integer);
{$H Renvoie les coordonnées en pixels de la fenêtre courante.

 La fenêtre courante a pu être mise en place avec setWindow@, selectWindow@ ou
setWindowEx@ .

 Le point situé en haut à gauche d'une page est l'origine des coordonnées.
}

procedure TmultiGraph.setWorld(x1,y1,x2,y2:real);
{$H Fixe le système de coordonnées pour les futures opérations d'écriture.

 x1 et y1 sont les coordonnées réelles du point en bas à gauche dans la fenêtre
courante.
 x2 et y2 sont les coordonnées réelles du point en haut à droite dans la fenêtre
courante.

 Toutes les opérations de dessin (moveto@ , lineto@ , lineto@ , etc..) utilisent
ces coordonnées réelles et non pas les coordonnées en pixels.
}

procedure TmultiGraph.setXWorld(x1,y1,x2:real;Fup:boolean);
{$H Fixe le système de coordonnées pour les futures opérations d'écriture.

 La méthode fonctionne comme SetWorld mais la valeur de y2 est calculée
automatiquement afin d'obtenir des échelles qui conservent le rapport d'aspect.

  Avec Fup=True , l'axe des y est dirigé vers le haut. Sinon, il est dirigé vers le bas.
}


procedure TmultiGraph.selectWorld(plot:TdataPlot);
{$H Sélectionne le système de coordonnées de l'objet plot.

 Cette méthode est équivalente à l'instruction:
 with plot do setWorld@(Xmin,Ymin,Xmax,Ymax);

}

procedure TmultiGraph.getWorld(var x1,y1,x2,y2:real);
{$H Renvoie le système de coordonnées courant.

 Ce système de coordonnées a pu être mis en place par setWorld@ ou selectWorld@.

}
procedure TmultiGraph.clearWindow(All:boolean);
{$H Efface le contenu de la fenêtre courante.

 Si le paramètre All vaut False et si la fenêtre courante contient un descendant
de TdataPlot, alors les graduations sont conservées.
 Si le paramètre All vaut True, la totalité de la fenêtre est effacée.
}
procedure TmultiGraph.DrawBorder;
{$H Trace un rectangle sur les limites de la fenêtre courante.
}
procedure TmultiGraph.DrawBorderOut;
{$H Trace un rectangle qui entoure la fenêtre courante.

 Le rectangle tracé se trouve un pixel au delà de celui qui serait tracé avec
drawBorder@ .
}

procedure TmultiGraph.OutText(x,y:integer;st:string);
{$H Ecrit la chaîne st au point de coordonnées x et y .

 x et y sont exprimés en pixels. L'origine étant en haut à gauche de la page
multigraph.

 Le jeu de caractères utilisé est défini par la propriété Font@.

 Si Transparent@ vaut false, la propriété PenColor définit la couleur d'arrière-plan,
sinon, le fond est inchangé.

 Si l'on veut se positionner par rapport à une fenêtre,il faut utiliser OutTextW@ .
}
procedure TmultiGraph.OutTextW(x,y:integer;st:string);
{$H Ecrit la chaîne st au point de coordonnées x et y .

 x et y sont exprimés en pixels. L'origine étant le point situé en haut à gauche
dans la fenêtre courante.

 Pour se positionner dans la page,  il faut utiliser outText@.
}

procedure TmultiGraph.SetClippingON;
{$H Rétablit l'interdiction d'écriture en dehors de la fenêtre courante.

 Le clipping est activé à chaque fois que l'on sélectionne une fenêtre avec
setWindow@, selectWindow@, etc...
 Si l'on veut désactiver ce clipping, il faut appeler setClippingOff@.
}
procedure TmultiGraph.SetClippingOff;
{$H Autorise l'écriture en dehors de la fenêtre courante.

 Le clipping (interdiction d'écriture en dehors de la fenêtre courante) est activé
à chaque fois que l'on sélectionne une fenêtre avec setWindow@, selectWindow@, etc...
 On appelle setClippingOff@ pour désactiver ce clipping.
}


procedure TmultiGraph.Graduations(stX,stY:string;echX,echY:boolean);
/ShowScale
{$H Dessine des graduations autour de la fenêtre courante.

 stX et stY sont respectivement les unités suivant les axes des X et des Y.
 Si echX vaut true, des nombres sont affichés sous l'axe des X.
 Si echY vaut true, des nombres sont affichés à gauche de l'axe des Y.

 Les coordonnées utilisées sont celles du système de coordonnées courant (celui
qui a été imposé au moyen de SetWorld@ ou selectWorld@).

 La police de caractères utilisée est celle définie par Font@ .

}
procedure TmultiGraph.setcolor(num:longint);
{$H Définit la couleur courante de tracé

 num est une couleur du système Windows qui peut être construite avec la fonction
rgb@ .
 On peut aussi utiliser les (constantes de couleur)@couleurs.

 Il est équivalent d'utiliser la propriété penColor@ .
}
procedure TmultiGraph.setWriteMode(mode:integer);
{$H Sélectionne le mode d'écriture.

 Assure la compatibilité avec Acquis1. Utilisez de préférence la propriété
PenMode@ qui est plus générale.

 Actuellement:
      0 = mode copy (défaut)
      1 = mode XOR
}
procedure TmultiGraph.AfficherSymbole(x,y:real;numSymb,taille:integer);
/DisplaySymbol
{$H Affiche un symbole au point de coordonnées (x,y)

 L'affichage a lieu dans la fenêtre courante en tenant compte du sytème de
coordonnées courant.

 Les symboles sont les mêmes que ceux qui sont utilisés dans l'affichage des
vecteurs ( Points, traits, carrés, etc..). NumSymb correspond au numéro d'ordre
dans la liste proposée dans une boîte de dialogue Coordonnées.
 On peut utiliser les constantes donnant les (modes d'affichage)@ .

 Taille est la taille des symboles en pixels.
}

procedure TmultiGraph.clearScreen;
/clear
{$H Efface la totalité de la page courante.
}
procedure TmultiGraph.resetScreen;
{$H Equivalent à refresh.

 Assure la compatibilité avec Acquis1.
}
function Tmultigraph.GetWin(p:Tplot):integer;
{$H Renvoie le numéro de la fenêtre qui contient l'objet plot dans la page courante.

 Si la page ne contient pas l'objet, la fonction renvoie zéro.
}

function Tmultigraph.winCount(pageNum:integer):longint;
{$H Renvoie le nombre de fenêtres de la page de numéro pageNum
}

procedure TmultiGraph.DisplayObject(plot:Tplot);
{$H Affiche l'objet Plot dans la fenêtre courante, avec le système de coordonnées
courant, en utilisant tous les paramètres de tracé fixés dans le programme
(penColor@, penWidth@, logX@, logY@, etc...

 Cette méthode n'utilise aucun paramètre d'affichage propre à l'objet plot.
}
procedure TmultiGraph.setLogMode(logX,logY:boolean);
{$H Fixe les modes logarithmiques en X et Y.

 Il est équivalent de modifier directement les propriétés logX@ et logY@ .

 Ces propriétés ont une effet sur les méthodes DisplayObject@ et ShowScale@
 Si logX vaut True, l'affichage sera logarithmique selon X .
 Si logY vaut True, l'affichage sera logarithmique selon Y .

}

procedure TmultiGraph.setVectorMode(mode,size:integer);
{$H Définit le mode d'affichage ainsi que la taille des symboles pour un futur appel
de displayObject@ .

 Il est recommandé d'utiliser les constantes définissant les (modes d'affichage)@
pour fixer le mode.

 Il est équivalent de modifier les propriétés VectorMode@ et SymboleSize@ .

}

property TmultiGraph.Pencolor:longint;
{$H Définit la couleur de tracé.

 Une couleur du système Windows peut être construite avec la fonction rgb@ .
 On peut aussi utiliser les (constantes de couleur)@couleurs.

}
property TmultiGraph.PenMode:integer;
{$H Définit le mode de tracé.

 Il s'agit des modes d'écriture Windows. Les valeurs possibles sont données par
les (constantes de mode de crayon)@(modes de crayon) .
 Ce mode s'applique aux tracés de lignes uniquement.

}
property TmultiGraph.PenWidth:integer;
{$H Définit la largeur de trait.

 La valeur par défaut est l'unité.
}
property TmultiGraph.VectorMode:integer;
{$H Définit le mode de tracé des vecteurs.

 Il est recommandé d'utiliser les constantes définissant les (modes d'affichage)@
pour fixer le mode.

 Cette propriété est utilisée par displayObject@ .
}

property TmultiGraph.symbolSize:integer;
{$H Définit la taille des symboles.

 Cette propriété est utilisée par displayObject@ .
}
property TmultiGraph.LogX:boolean;
{$H Définit le mode logarithmique suivant l'axe des X.

 La valeur par défaut est False.
 Cette propriété est utilisée par displayObject@ .
}
property TmultiGraph.LogY:boolean;
{$H Définit le mode logarithmique suivant l'axe des Y.

 La valeur par défaut est False.
 Cette propriété est utilisée par displayObject@ .
}
property TmultiGraph.Font:Tfont readOnly;
{$H Définit la police de caractères utilisée par outText@ , outTextW
ou encore showScale@ .
}
property TmultiGraph.transparent:boolean;
{$H Définit le mode d'affichage transparent dans outText@ ou outTextW .

 Si transparent vaut true, le texte s'affiche sans effacer l'arrière plan.
 Si transparent vaut false, le fond des caractères est rempli avec la couleur de
fond de la page.

}

procedure TmultiGraph.AfficherTrace(var S:Tvector);
/DisplayTrace
{$H Equivalent à DisplayObject@ .

 Assure la compatibilité avec Acquis1 .
}


property TmultiGraph.PageWidth:integer;
{$H Largeur de la page en pixels
}

property TmultiGraph.PageHeight:integer;
{$H Hauteur de la page en pixels
}
property TmultiGraph.PageLeft:integer readOnly;
{$H Renvoie la position horizontale de la page sur l'écran en pixels
}

property TmultiGraph.PageTop:integer readOnly;
{$H Renvoie la position verticale de la page sur l'écran en pixels
}



function TmultiGraph.DefineWindow(page,x1,y1,x2,y2:integer):integer;
{$H Crée un nouvelle fenêtre multigraph.

  Page est le numéro de la page devant contenir la fenêtre.
  x1 et y1 sont les coordonnées du coin en haut à gauche de la fenêtre.
  x2 et y2 sont les coordonnées du coin en bas à droite de la fenêtre.

  La fonction renvoie zéro si la fenêtre ne peut être créée (coordonnées
incorrectes) et renvoie le numéro de la fenêtre dans le cas contraire.

  Les coordonnées sont exprimées en pixels. Si l'utilisateur redimensionne la fenêtre
Elphy, ces coordonnées changeront puisque les dimensions des fenêtres sont
proportionnelles aux dimensions de la page. Il est donc important de calculer des
dimensions en se basant sur les dimensions actuelles de la page (pageWidth@ et
pageHeight@ ).
}
function TmultiGraph.DefineGrid(page,x1,y1,x2,y2,nx,ny:integer):integer;
{$H Définit une grille de fenêtres.

  Page est le numéro de la page devant contenir la fenêtre.
  x1 et y1 sont les coordonnées du coin en haut à gauche de la grille.
  x2 et y2 sont les coordonnées du coin en bas à droite de la grille.

  nx et ny sont les nombres de fenêtres dans les sens horizontal et vertical. Il
y a donc nx*ny fenêtres créées.

  La fonction renvoie zéro si la fenêtre ne peut être créée (coordonnées
incorrectes) et renvoie le numéro de la première fenêtre de la grille dans le
cas contraire. Les numéros des autres fenêtres prennent des valeurs consécutives
quand on se déplace ligne par ligne.

}
procedure TmultiGraph.DestroyAllWindows(pageNum:integer);
{$H Supprime toutes les fenêtre de la page de numéro PageNum}

Procedure TmultiGraph.SavePage(st:string);
{$H Sauve la page courante dans un fichier de nom st.

 Le fichier créé est au format BMP .
}

Procedure TmultiGraph.SavePageAsPNG(st:string);
{$H Sauve la page courante dans un fichier de nom st .

 Le fichier créé est au format PNG .
}

Procedure TmultiGraph.SavePageAsJPEG(st:string;quality:integer);
{$H Sauve la page courante dans un fichier de nom st.

 Le fichier créé est au format JPEG .
 Quality est un nombre compris entre 1 et 100 qui affecte le taux de compression
de l'image.
 Pour quality=100 , l'image est parfaitement conservée mais le taux de compression
est minimal.
}

procedure TmultiGraph.PrintCurrentPage;
{$H Imprime la page courante.

 La méthode utilise les paramètres introduits dans le menu Impression.
}
procedure TmultiGraph.divideWindow(page,Win,nx,ny:integer);
{$H Divise une fenêtre existante en plusieurs fenêtres formant une grille.

 Page est le numéro de la page
 Win est le numéro de la fenêtre.
 nx et ny sont les nombres de fenêtres souhaités dans les sens horizontal et
vertical.
}
function TmultiGraph.newWindow(pageNum,x,y:integer):integer;
{$H Crée une nouvelle fenêtre dans la page de numéro PageNum.

 x et y sont les coordonnées en pixels d'un point de la page. Ce point ne doit
appartenir à aucune fenêtre existante. La méthode crée la fenêtre la plus grande
possible contenant ce point. Tout se passe comme si l'on activait la commande
New Window avec un clic droit de la souris au point (x,y).
}
procedure TmultiGraph.destroyWindows(page,win,count:integer);
{$H Détruit plusieurs fenêtres de numéros consécutifs.

 Page est le numéro de la page.
 win est le numéro de la première fenêtre à détruire.
 count est le nombre de fenêtres à détruire. Si l'on indique une valeur
supérieure au nombre de fenêtres, seules les fenêtres existantes seront
détruites.
}

function Tmultigraph.PageCount:integer;


                        { stmOdat2  Tplotarray }

property TplotArray.Imin:integer readOnly;
{$H Indice de début de la grille selon l'axe horizontal.

 La valeur de Imin a été fixée pendant l'appel de create ou de modify.
}
property TplotArray.Imax:integer readOnly;
{$H Indice de fin de la grille selon l'axe horizontal.

 La valeur de Imax a été fixée pendant l'appel de create ou de modify.
}
property TplotArray.Jmin:integer readOnly;
{$H Indice de début de la grille selon l'axe vertical.

 La valeur de Jmin a été fixée pendant l'appel de create ou de modify.
}
property TplotArray.Jmax:integer readOnly;
{$H Indice de fin de la grille selon l'axe vertical.

 La valeur de Jmax a été fixée pendant l'appel de create ou de modify.
}

property TplotArray.IdispMin:integer;
{$H Indice du premier élément de la grille affiché selon l'axe horizontal.
}
property TplotArray.IdispMax:integer;
{$H Indice du dernier élément de la grille affiché selon l'axe horizontal.
}
property TplotArray.JdispMin:integer;
{$H Indice du premier élément de la grille affiché selon l'axe vertical.
}
property TplotArray.JdispMax:integer;
{$H Indice du dernier élément de la grille affiché selon l'axe vertical.
}
property TplotArray.JdispInvert: boolean;
{$H Inverse l'affichage de la grille dans la direction verticale.

 Par défaut, l'objet obj[1,1] de la grille se trouve en haut à gauche.
 En donnant la valeur True à JdispInvert , il se trouvera en bas à gauche

 Affecter cette propriété a un effet immédiat: en lui donnant la valeur True, on impose JdispMin:= Jmax@ et JdispMax:=Jmin@.
 Elle agira de la même façon à chaque fois que modify@(TvectorArray.modify) sera appelé.
 Il est toujours possible de retourner l'affichage en donnant à JdispMin une
valeur supérieure à celle de JdispMax.
}

procedure TplotArray.setGrid(x1,y1,x2,y2:integer);
{$H Fixe les coordonnées de la grille d'affichage.

 Permet de modifier en une seule fois les propriétés IdispMin@, IdispMax@,
JdispMin@ et JdispMax@ .
}

procedure TplotArray.autoscaleI;
{$H Donne à IdispMin@ et IdispMax les valeurs limites de la grille Imin@ et Imax@
}
procedure TplotArray.autoscaleJ;
{$H Donne à JdispMin@ et JdispMax les valeurs limites de la grille Jmin@ et Jmax@
}

property TplotArray.Overlap:boolean;
{$H Autorise le recouvrement des traces à l'affichage.

 Si Overlap vaut False, chaque vecteur s'affiche dans sa petite fenêtre sans
déborder sur les autres.
 Si Overlap vaut True, la trace peut s'afficher au delà des limites supérieure et
inférieure de la petite fenêtre.

 Toutefois, l'affichage ne se fait jamais en dehors du grand cadre réservé à l'objet.

}
property TplotArray.dxWF:real;
{$H Décalage des traces selon X en mode waterfall

 dxWF est exprimé en pourcentage de la dimension horizontale de la fenêtre
d'affichage et peut être positif ou négatif.
 Quand dxWF est différent de zéro, l'affichage est décalé selon X à chaque ligne de la
grille afin de donner un effet de cascade.

}
property TplotArray.dyWF:real;
{$H Décalage des traces selon Y en mode waterfall

 dyWF est exprimé en pourcentage de la dimension verticale de la fenêtre
d'affichage et peut être positif ou négatif.
 Quand dyWF est différent de zéro, l'affichage est décalé selon Y à chaque colonne de la
grille afin de donner un effet de cascade.
}
property TplotArray.Mleft:real;
{$H Définit la Marge gauche pour l'affichage de la grille.

 Mleft est exprimé en pourcentage de la dimension horizontale de la fenêtre d'affichage.
}
property TplotArray.Mright:real;
{$H Définit la Marge droite pour l'affichage de la grille.

 Mright est exprimé en pourcentage de la dimension horizontale de la fenêtre d'affichage.
}


property TplotArray.Mtop:real;
{$H Définit la marge haute pour l'affichage de la grille.

 Mtop est exprimé en pourcentage de la dimension verticale de la fenêtre d'affichage.
}

property TplotArray.Mbottom:real;
{$H Définit la marge basse pour l'affichage de la grille.

 Mbottom est exprimé en pourcentage de la dimension verticale de la fenêtre d'affichage.
}

property TplotArray.dxInt:real;
{$H Intervalles entre les traces selon X

 dxInt est exprimé en pourcentage de la dimension horizontale de la fenêtre
d'affichage.

}
property TplotArray.dyInt:real;
{$H Intervalles entre les traces selon Y

 dyInt est exprimé en pourcentage de la dimension verticale de la fenêtre
d'affichage.
}
                        { stmOdat2  Tvectorarray }

procedure TVectorArray.create(stName:string;i1,i2,j1,j2:integer);
procedure TVectorArray.create(i1,i2,j1,j2:integer);
procedure TVectorArray.create(i1,i2:integer);


{$H Constructeur de l'objet TvectorArray.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 i1 et i2 sont les valeurs extrêmes du premier indice.
 j1 et j2 sont les valeurs extrêmes du second indice.

 i2 doit être supérieur ou égal à i1 .
 j2 doit être supérieur ou égal à j1 .

 L'objet est équivalent à la déclaration
 @f6 Array[i1..i2,j1..j2] of Tvector;

 A ce stade, les vecteurs n'existent pas encore. Il faut appeler initObjects@
pour créer effectivement ces vecteurs.
}

procedure TVectorArray.modify(i1,i2,j1,j2:integer);
procedure TVectorArray.modify(i1,i2:integer);

{$H Modifie les dimensions du tableau de vecteurs.
}
procedure TVectorArray.initObjects(tp,n1,n2:longint);
{$H Initialise les vecteurs du tableau.

 Tous les vecteurs sont créés avec les propriétés suivantes:

 tp : (Type de nombre)@(types de nombres)
 n1 : Indice de début Istart
 n2 : Indice de fin Iend
}

property TVectorArray.V(i,j:integer):Tvector readOnly default;
property TVectorArray.V(i:integer):Tvector readOnly default;

{$H Permet d'accéder à un vecteur du tableau.

 i et j sont les indices du vecteur dans le tableau.

 Il est possible de modifier toutes les propriétés d'affichage d'un vecteur.
Toutefois, ces modifications risquent d'être temporaires, l'objet VectorArray
pouvant modifier ces propriétés.
}

procedure TvectorArray.BuildMap(var m:Tmatrix;x1,x2:real;mode:integer);
{$H Construit une matrice à partir des données contenues dans les vecteurs de l'objet.

 En sortie, les indices limites de la matrice sont ceux de la grille de l'objet.
 Le type des nombres de la matrice reste inchangé .

 Chaque valeur m.Zvalue[i,j] est calculée en fonction des données du vecteur V[i,j].

 Selon la valeur de Mode, le calcul est le suivant:

      0: Zvalue[i,j] = somme des éléments compris entre les abscisses réelles x1 et x2
      1: Zvalue[i,j] = somme des carrés des modules des éléments compris entre les abscisses réelles
x1 et x2
      2: Zvalue[i,j] = somme des modules des éléments compris entre les abscisses réelles
x1 et x2
      3: Zvalue[i,j] = valeur moyenne de l'argument des éléments compris entre les abscisses
réelles x1 et x2
      4: Zvalue[i,j] = valeur moyenne des éléments compris entre les abscisses réelles x1 et x2

 Les vecteurs peuvent contenir des nombres complexes.

 Voir BuildZscoreMap@ .
}

procedure TvectorArray.BuildZscoreMap(var m:Tmatrix;x1,x2:real;mode:integer);
{$H Construit une matrice à partir des données contenues dans les vecteurs de l'objet.

 La méthode appelle d'abord BuildMap@ avec les mêmes paramètres puis en remplaçant x1 et x2
par -x2 et -x1 . On calcule alors la moyenne m et la  déviation standard sigma sur tous les
éléments de cette seconde matrice.

 On remplace ensuite chaque élément y de la première matrice par (y-m)/sigma .


}

procedure TvectorArray.BuildXTMap(var m: Tmatrix;t1,t2,dtau,dxt:real;mode:integer;FY,FZscore:boolean;Xref:real;FrefSym:boolean;Zth:real;mode1,AgTh:integer);
{$H Calcul d'une carte XT (PSTHS)

 m est la matrice destination. Elle est initialisée de la façon suivante:
     - son type est inchangé
     - on calcule  nb:=round((t2-t1-dtau)/dxt);
       si FY=true,  on fixe m.Istart:=0;   m.Iend:=nb-1;    m.Jstart:=Imin;     m.Jend:=Imax;
       si FY=false, on fixe m.Istart:=0;   m.Iend:=nb-1;    m.Jstart:=Jmin;     m.Jend:=Jmax;
     - dx:=dxt;

 t1 et t2 déterminent la zone de calcul. En général, on choisira Xstart et Xend du VectorArray
 dtau est la largeur de la fenêtre d'intégration
 dxt est l'incrément temporel

 mode est le mode de calcul d'une carte XY élémentaire: on appelle BuildMap@ pour chaque
intervalle [t1+i*dxt,t1+i*dxt+dtau] avec le paramètre mode

 FY fixe la direction de projection. Si FY=true, la direction de projection est selon Y, sinon
elle est selon X.

 FZscore doit valoir true si le calcul doit être fait sur des cartes XY en Zscore
 Xref détermine la zone de référence pour les cartes en Zscore: en Zscore, on calcule une carte XY
entre Xref et Xref+dtau puis on calcule la moyenne et l'écart-type pour toutes les cases de cette
carte. Les valeurs trouvées permettent de calculer ensuite les cartes XY en Zscore.

 FrefSym indique le mode symétrique: si sa valeur est TRUE (et si FZscore=True), la zone de référence sera le
symétrique de la zone de calcul .Pour chaque carte XY calculée entre t et t+dtau, la carte de référence
est calculée entre -t-dtau et -t.

 Zth est le seuil de connectivité (voir mode1)
 AgTh est le seuil d'agrégation   (voir mode1)

 mode1 détermine le mode de calcul de la carte XT. Les valeurs possibles sont:
     1: Somme des colonnes
     2: Maximum d'une colonne
     3: Somme des valeurs d'agrégat d'une colonne
     4: Maximum des valeurs d'agrégat d'une colonne
     5: Somme des colonnes après avoir supprimé les pixels dont la valeur d'agrégat
est inférieure au seuil AgTh
     6: Maximum des colonnes après avoir supprimé les pixels dont la valeur d'agrégat
est inférieure au seuil AgTh

 Pour calculer les valeurs d'agrégat, on procède comme suit: dans une matrice XY, on
remplace d'abord les valeurs supérieures à Zth par des 1, les autres par des zéros.
On considère ensuite que les pixels de valeur 1 font partie d'agrégats ayant 1,2,3...n éléments.
Deux pixels de valeur 1 font partie du même agrégat si l'on peut passer de l'un à l'autre
en sautant de proche voisin de valeur 1 en proche voisin de valeur 1 (un pixel a 8 proches voisins) .
On remplace alors chaque 1 par la valeur d'agrégat n.

Remarques:



}
procedure TvectorArray.BuildXTMap1(var m: Tmatrix;x1,x2,dtau,dxt:real;mode:integer;FY,FZscore,FrefSym:boolean;Zth:real;var vecM,vecStd:Tvector;mode1,AgTh:integer);

procedure TvectorArray.BuildXTIntMaps(var mat1,mat2:Tmatrix;x1,x2,dtau,dxt,seuilP,seuilM:real;FY,FZscore:boolean;Xref:real;FrefSym:boolean;Zth:real;mode,AgTh:integer);
procedure TvectorArray.BuildXTIntMaps1(var mat1,mat2:Tmatrix;x1,x2,dtau,dxt,seuilP,seuilM:real;FY:boolean;FZscore,FrefSym:boolean;Zth:real;var vecM,vecStd:Tvector;mode,AgTh:integer);


procedure TvectorArray.MeanStdDev(x1, x2: real; var vm, vstd: real);
{$H Calcul de la moyenne et de la déviation standard de tous les points contenus dans tous les
vecteurs entre les abscisses réelles x1 et x2.

 La moyenne est renvoyée dans vm.
 La déviation standard est renvoyée dans vstd.
}

procedure TvectorArray.BuildIntMaps(var mat1,mat2:Tmatrix;tau1,tau2,ThUp,ThDw:real;Norm:boolean);
{$H Calcul de deux matrices suivant l'algorithme suivant:

 Les dimensions de mat1 et mat2 sont rendues égales aux propriétés Imin@, Imax@, Jmin@, Jmax@.

 Puis, pour chaque vecteur v[i,j], on calcule:

 @f6      IntSup:= v[i,j].IntAbove (tau1,tau2,seuilP,LAbove);
 @f6      IntInf:= v[i,j].IntBelow (tau1,tau2,seuilM,LBelow);

 @f6      if not Norm then
 @f6        begin
 @f6         mat1.Zvalue[i,j] := IntSUP;
 @f6         mat2.Zvalue[i,j] := IntINF;
 @f6       end
 @f6     else
 @f6       begin
 @f6         if Labove>0 then mat1.Zvalue[i,j] := intSUP/LAbove;
 @f6         if LBelow>0 then mat2.Zvalue[i,j] := IntINF/LBelow;
 @f6       end;

 Voir aussi IntAbove@(Tvector.intAbove) , IntBelow@(Tvector.intBelow)
}

procedure TvectorArray.BuildZscoreIntMaps(var mat1,mat2:Tmatrix;tau1,tau2,ThUp,ThDw:real);

procedure TvectorArray.IntMapStats(var VMean1,Vmean2,VStd1,Vstd2:Tvector;seuilP,seuilM,tmax,TauMax:real;Norm:boolean);


procedure TvectorArray.OptStats(x1,x2,dxm:real;var VMean,VStd:real);
{$H Calcul de la valeur moyenne et de la déviation standard destinées au calcul
d'une carte optimale avec OptMatrix@ .

 Le but du calcul est d'obtenir un seuil de significativité pour le calcul d'une carte optimale.

 Pour chaque vecteur (i,j), on calcule la moyenne Vm sur un segment de longueur dxm en essayant toutes
les positions possibles pour ce segment entre x1 et x2. On retient la position qui donne la
plus grande valeur de Vm.

 Cette valeur est rangée dans un tableau mat[i,j] .

 Ensuite, on calcule la moyenne et la déviation standard sur l'ensemble des valeurs
de ce tableau.

 dxm doit être inférieur x2-x1. La première position testée est [x1,x1+dxm], la
dernière est [x2-dxm,x2] .

}

procedure TvectorArray.OptMatrix(x1,x2,dxm:real;Vmean,Vstd:real; var Mopt,Mlat: Tmatrix);
{$H Calcul d'une carte optimale.

 Pour chaque vecteur, on calcule la moyenne Vm sur un segment de longueur dxm en essayant toutes
les positions possibles pour ce segment entre x1 et x2. On retient la position qui donne la
plus grande valeur de Vm.

 On range (Vm-Vmean)/Vstd  dans Mopt à condition que cette valeur soit positive, sinon on range zéro.
 La position (début du segment) est rangée dans Mlat.

 Vmean et Vstd peuvent être calculées au moyen de OptStats@ .

 Mopt et Mlat sont auparavant redimensionnées afin que leurs indices deviennent égaux
à Imin@, Imax@, Jmin@, Jmax@ .
 dxm doit être inférieur x2-x1. La première position testée est [x1,x1+dxm], la
dernière est [x2-dxm,x2] .




}


procedure TvectorArray.Threshold(th:real;Fup,Fdw:boolean);




procedure TvectorArray.MedianVector(var vec:Tvector);
procedure TvectorArray.SubVector(var vec:Tvector);
procedure TvectorArray.AddNum(num:complex);

property TvectorArray.OnHint:TvaHint;
{$H Gestionnaire d'événement appelé quand l'utilisateur clique sur un vecteur du tableau
avec le bouton droit de la souris tout en appuyant sur la touche Control .

  OnHint doit recevoir une procédure conforme à la déclaration suivante:
  TvaHint=procedure( var va:TvectorArray;x,y:real;var stH:string);

  Par défaut, quand on clique avec le bouton droit sur une case du tableau tout en appuyant sur la touche Control,
on obtient une indication contenant les coordonnées de la case et le contenu de la case.

  Avec le gestionnaire OnHint , on peut afficher une indication complémentaire. Cette
indication doit être renvoyée dans la variable stH.
  Va est l'objet qui a généré l'événement.
  x et y sont les coordonnées du point cliqué dans le tableau. Ce sont des nombres réels.

}
property TVectorArray.CpxMode:integer;
{$H Définit le mode d'affichage des vecteurs lorsqu'ils contiennent des nombres complexes.

 Les valeurs possibles sont:

     0: affichage de la partie réelle
     1: affichage de la partie imaginaire
     2: affichage du module
     3: affichage de l'argument

 Il est recommandé d'utiliser les (constantes de mode)@(Modes d'affichage complexes)
}


                        { stmpstA1  TpsthArray }

procedure TpsthArray.create(stName:string;i1,i2,j1,j2:integer);
procedure TpsthArray.create(i1,i2,j1,j2:integer);
procedure TpsthArray.create(i1,i2:integer);

{$H Constructeur de l'objet TpsthArray.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 i1 et i2 sont les valeurs extrêmes du premier indice.
 j1 et j2 sont les valeurs extrêmes du second indice.

 i2 doit être supérieur ou égal à i1 .
 j2 doit être supérieur ou égal à j1 .

 L'objet est équivalent à la déclaration
 @f6 Array[i1..i2,j1..j2] of Tpsth;

 A ce stade, les psths n'existent pas encore. Il faut appeler initObjects@
pour créer effectivement ces psths.
}

procedure TPsthArray.modify(i1,i2,j1,j2:integer);
procedure TPsthArray.modify(i1,i2: integer);
{$H Modifie les dimensions du tableau de psths.
}
procedure TpsthArray.initObjects(tp,n1,n2:integer;binWidth:real);
{$H Initialise les psths du tableau.

 Tous les psths sont créés avec les propriétés suivantes:

 tp : (Type de nombre)@(types de nombres)
 n1 : Indice de début Istart
 n2 : Indice de fin Iend
 binWidth: largeur de classe
}

property TpsthArray.V(i,j:integer):Tpsth readOnly default;
property TpsthArray.V(i:integer):Tpsth readOnly default;
{$H Permet d'accéder à un psth du tableau.

 i et j sont les indices du psth dans le tableau.
}

                        { stmpstA1  TCorrelogramArray }

procedure TCorrelogramArray.create(stName:string;i1,i2,j1,j2:integer);
procedure TCorrelogramArray.create(i1,i2,j1,j2:integer);
procedure TCorrelogramArray.create(i1,i2:integer);

{$H Constructeur de l'objet TCorrelogramArray.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 i1 et i2 sont les valeurs extrêmes du premier indice.
 j1 et j2 sont les valeurs extrêmes du second indice.

 i2 doit être supérieur ou égal à i1 .
 j2 doit être supérieur ou égal à j1 .

 L'objet est équivalent à la déclaration
 @f6 Array[i1..i2,j1..j2] of TCorrelogram;

 A ce stade, les Correlograms n'existent pas encore. Il faut appeler initObjects@
pour créer effectivement ces Correlograms.
}

procedure TCorrelogramArray.modify(i1,i2,j1,j2:integer);
procedure TCorrelogramArray.modify(i1,i2:integer);
{$H Modifie les dimensions du tableau de Correlograms.
}
procedure TCorrelogramArray.initObjects(tp,n1,n2:longint;binWidth:real);
{$H Initialise les Correlograms du tableau.

 Tous les Correlograms sont créés avec les propriétés suivantes:

 tp : (Type de nombre)@(types de nombres)
 n1 : Indice de début Istart
 n2 : Indice de fin Iend
 binWidth: largeur de classe
}

property TCorrelogramArray.V(i,j:integer):Tcorrelogram readOnly default;
property TCorrelogramArray.V(i:integer):Tcorrelogram readOnly default;
{$H Permet d'accéder à un Correlogram du tableau.

 i et j sont les indices du Correlogram dans le tableau.
}



                        { stmAveA1  TAverageArray }

procedure TAverageArray.create(stName:string;i1,i2,j1,j2:integer);
procedure TAverageArray.create(i1,i2,j1,j2:integer);
procedure TAverageArray.create(i1,i2:integer);

{$H Constructeur de l'objet TAverageArray.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 i1 et i2 sont les valeurs extrêmes du premier indice.
 j1 et j2 sont les valeurs extrêmes du second indice.

 i2 doit être supérieur ou égal à i1 .
 j2 doit être supérieur ou égal à j1 .

 L'objet est équivalent à la déclaration
 @f6 Array[i1..i2,j1..j2] of Taverage;

 A ce stade, les objets Taverage n'existent pas encore. Il faut appeler initObjects@
pour créer effectivement ces objets.
}

procedure TAverageArray.modify(i1,i2,j1,j2:integer);
procedure TAverageArray.modify(i1,i2:integer);

{$H Modifie les dimensions du tableau de moyennes.
}
procedure TAverageArray.initObjects(tp,n1,n2:longint);
{$H Initialise les objets Taverage du tableau.

 Tous les objets sont créés avec les propriétés suivantes:

 tp : (Type de nombre)@
 n1 : Indice de début Istart
 n2 : Indice de fin Iend
}

property TAverageArray.V(i,j:integer):Taverage readOnly default;
property TAverageArray.V(i:integer):Taverage readOnly default;
{$H Permet d'accéder à un des objets du tableau.

 i et j sont les indices de l'objet dans le tableau.

}

property TaverageArray.stdOn:boolean;

property TaverageArray.Vsqrs:TvectorArray readOnly;
property TaverageArray.VstdDev:TvectorArray readOnly;
property TaverageArray.VstdUp:TvectorArray readOnly;
property TaverageArray.VstdDw:TvectorArray readOnly;

procedure TaverageArray.UpdateStdDev;

                        { stmmatA1  TmatrixArray }

procedure TmatrixArray.create(stName:string;i1,i2,j1,j2:integer);
procedure TmatrixArray.create(i1,i2,j1,j2:integer);

{$H Constructeur de l'objet TmatrixArray.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 i1 et i2 sont les valeurs extrêmes du premier indice.
 j1 et j2 sont les valeurs extrêmes du second indice.

 i2 doit être supérieur ou égal à i1 .
 j2 doit être supérieur ou égal à j1 .

 L'objet est équivalent à la déclaration
 @f6 Array[i1..i2,j1..j2] of Tmatrix;

 A ce stade, les matrices n'existent pas encore. Il faut appeler initMatrix@
pour créer effectivement ces matrices.
}

procedure TmatrixArray.modify(i1,i2,j1,j2:integer);
{$H Modifie les dimensions du tableau de matrices.
}
procedure TmatrixArray.initObjects(tp,i1,i2,j1,j2:longint);
{$H Initialise les matrices du tableau.

 Toutes les matrices sont créées avec les propriétés suivantes:

 tp : (Type de nombre)@(types de nombres)
 i1 : Indice de début Istart
 i2 : Indice de fin Iend
 j1 : Indice de début Jstart
 j2 : Indice de fin Jend
}

property TmatrixArray.M(i,j:integer):Tmatrix readOnly;
{$H Permet d'accéder à une matrice du tableau.

 i et j sont les indices de la matrice dans le tableau.
}


property TmatrixArray.Jstart:longint readOnly;
property TmatrixArray.Jend:longint readOnly;
property TmatrixArray.Ystart:real readOnly;
property TmatrixArray.Yend:real readOnly;

property TmatrixArray.Dz:real;
property TmatrixArray.z0:real;
function TmatrixArray.convZ(i:longint):real;
function TmatrixArray.invconvZ(x:real):longint;

property TmatrixArray.Zmin:real;
property TmatrixArray.Zmax:real;

property TmatrixArray.theta:real;

property TmatrixArray.AspectRatio:real;
property TmatrixArray.PixelRatio:real;

property TmatrixArray.gamma:real;
property TmatrixArray.TwoColors:boolean;
property TmatrixArray.PalColor(n:integer):integer;
property TmatrixArray.PalName:string;
property TmatrixArray.DisplayMode:integer;

procedure TmatrixArray.autoscaleZ;
procedure TmatrixArray.autoscaleZsym;

procedure TmatrixArray.getMinMaxI(var Vmin,Vmax:longint);
procedure TmatrixArray.getMinMax(var Vmin,Vmax:real);

procedure TmatrixArray.buildMap(var mat: Tmatrix; i1,i2,j1,j2:integer;mode:integer);
 {$H Construit une matrice à partir des données contenues dans les matrices de l'objet TmatrixArray.

 En sortie, les indices limites de la matrice sont ceux de la grille de l'objet.
 Le type des nombres de la matrice reste inchangé .

 Chaque valeur m.Zvalue[i,j] est calculée en fonction des données de la matrice M[i,j].

 Selon la valeur de Mode, le résultat du calcul est le suivant:

      0: Zvalue[i,j] = somme des éléments tels que (i1<=i<=i2) et (j1<=j<=j2)
      1: Zvalue[i,j] = somme des modules des éléments tels que (i1<=i<=i2) et (j1<=j<=j2)
      2: Zvalue[i,j] = somme des carrés des modules des éléments tels que (i1<=i<=i2) et (j1<=j<=j2)


 Les matrices peuvent contenir des nombres complexes.

}
procedure TmatrixArray.buildMap1(var mat: Tmatrix; i1,i2,j1,j2:integer;Zmean,ZstdDev:real;mode:integer;Fabove:boolean);


procedure TmatrixArray.buildVectorArray(var va: TvectorArray; i1,i2:integer);



                        { stmDf0 TdataFile }

function dataFile0:TdataFile;

{channels}
procedure TdataFile.create(stName:string);
procedure TdataFile.create;
{$H Constructeur de l'objet

 Rappelons qu'il existe un objet permanent appelé datafile0.
 Cet objet bénéficie d'un (with implicite)@ .
}

property Tdatafile.v(num:integer):Tvector ReadOnly;
{$H Vecteur contenant les données du canal analogique num.

 Num doit être compris entre 1 et ChannelCount@
 Quand le fichier est structuré en épisodes, le vecteur contient l'épisode fixé par la propriété EpNum@ .

 Pour Num compris entre 1 et 6, on peut écrire directement v1@, v2@, v3@, v4@, v5@ ou v6@
}

Property Tdatafile.v1:Tvector ReadOnly;
{$H Identique à v[1]

  voir v@
}
Property Tdatafile.v2:Tvector ReadOnly;
{$H Identique à v[2]

  voir v@
}
Property Tdatafile.v3:Tvector ReadOnly;
{$H Identique à v[3]

  voir v@
}
Property Tdatafile.v4:Tvector ReadOnly;
{$H Identique à v[4]

  voir v@
}
Property Tdatafile.v5:Tvector ReadOnly;
{$H Identique à v[5]

  voir v@
}
Property Tdatafile.v6:Tvector ReadOnly;
{$H Identique à v[6]

  voir v@
}

{Averages}
property Tdatafile.m(num:integer):Taverage ReadOnly;
{$H Vecteur contenant le résultat des opérations "moyenne" effectuées sur plusieurs vecteurs v[num] .

 Num doit être compris entre 1 et ChannelCount@

 Quand le fichier est structuré en épisodes, le menu pricipal de Elphy contient une rubrique "Averages" qui permet de moyenner
point par point les vecteurs correspondant à plusieurs épisodes.

 Pour Num compris entre 1 et 6, on peut écrire directement m1@, m2@, m3@, m4@, m5@ ou m6@
}

Property Tdatafile.m1:Taverage ReadOnly;
{$H Identique à m[1]

  voir m@
}
Property Tdatafile.m2:Taverage ReadOnly;
{$H Identique à m[2]

  voir m@
}
Property Tdatafile.m3:Taverage ReadOnly;
{$H Identique à m[3]

  voir m@
}
Property Tdatafile.m4:Taverage ReadOnly;
{$H Identique à m[4]

  voir m@
}
Property Tdatafile.m5:Taverage ReadOnly;
{$H Identique à m[5]

  voir m@
}
Property Tdatafile.m6:Taverage ReadOnly;
{$H Identique à m[6]

  voir m@
}

property Tdatafile.Vspk(num:integer):TvectorSpk ReadOnly;
{$H Vecteur contenant les spikes détectés sur l'électrode n du système BlackRock/Cyberkinetics

 n doit être compris entre 1 et VspkCount@ .

 L'objet TvectorSpk@ est un vecteur ordinaire travaillant en mode événements mais chaque événement
est affiché avec une couleur dépendant de son attribut (unité)
}
property Tdatafile.Wspk(num:integer):TwaveList ReadOnly;
{$H Objet contenant les waveforms des spikes détectés sur l'électrode n du système BlackRock/Cyberkinetics

 n doit être compris entre 1 et VspkCount@ .

 L'objet TwaveList@ se comporte comme un vecteur contenant une seule waveform. Cette waveform étant celle
qui correspond à la valeur de la propriété index@(Twavelist.index) .
}

property Tdatafile.VspkCount:integer ReadOnly;
{$H Renvoie le nombre de voies "VSpk" du fichier de données.

 Actuellement, ces voies sont créées uniquement par le système BlackRock-Cyberkinetics.

 Voir aussi MaxVspkCount@ .
}
property Tdatafile.MaxVspkCount:integer ReadOnly;
{$H Renvoie le nombre de voies "VSpk" de la configuration actuelle.

 Actuellement, ces voies sont utilisées uniquement par le système BlackRock-Cyberkinetics.

 Voir aussi VspkCount@ .
}


{Vtags}

property Tdatafile.Vtag(i:integer):Tvector ReadOnly;
{$H Vecteur contenant la voie d'acquisition digitale numéro i

 i est le numéro logique . Il commence à 1
 Les vecteurs Vtag se présentent comme des vecteurs analogiques mais ils ne contiennent
que des valeurs 0 ou 1

}
Property Tdatafile.Vtag1:Tvector ReadOnly;
{$H Identique à Vtag[1]

 voir Vtag@
}
Property Tdatafile.Vtag2:Tvector ReadOnly;
{$H Identique à Vtag[1]

 voir Vtag@
}
{Mtags}
property Tdatafile.Mtag:TMtag ReadOnly;
{$H Objet de type TMtag@ contenant soit les tags manuels de Elphy, soit les tags
des fichiers Pclamp ou ABF.
}


property TdataFile.AverageType:integer;


property TdataFile.nbSeq:longint readOnly;
/Epcount
{$H Indique le nombre d'épisodes du fichier de données.
}
property TdataFile.nbvoie:integer readOnly;
/ChannelCount
{$H Indique le nombre de canaux du fichier de données
}

property TdataFile.MaxChannelCount:integer readOnly;
{$H Indique le nombre de canaux ordinaires de la configuration actuelle.
}

procedure TdataFile.afficherNumSeq;
/DisplayEpNum
{$H Obsolète
}

procedure TdataFile.setNumSeq(i:longint);
/setEpNum
{$H Obsolète

 Utiliser de préférence la propriété NumSeq@
}

property TdataFile.NumSeq:longint;
/EpNum
{$H Numéro de l'épisode courant

 Il n'y a qu'un seul épisode en mémoire à un instant donné.
 Les données de cet épisode sont dans les vecteurs V1@, V2@,..., Vtag1@, Vtag2,...

 Quand on modifie la valeur de EpNum, on modifie immédiatement le contenu de tous ces vecteurs

 EpNum est compris entre 1 et EpCount@;
}

function TdataFile.NbPtSeq:longint;
/PointsPerEp
{$H Renvoie le nombre de points nominal (échantillons) par canal dans l'épisode courant

 Il est préférable de s'appuyer sur les propriétés des vecteurs v1@, v2@,...,Vtag1@, Vtag2@...
pour connaitre le nombre de points. Voir Istart@(Tvector.Istart), Iend@(Tvector.Iend), Icount@(Tvector.Icount).
}
function TdataFile.NomData:String;
/dataName
{$H Renvoie le nom du fichier courant

 Voir aussi dataPath@ , dataExt@

 Le nom complet est dataPath@ + dataName@ + dataExt@
}

function TdataFile.CheminData:String;
/dataPath
{$H Renvoie le path du fichier courant

 Voir aussi dataName@ , dataExt@

 Le nom complet est dataPath@ + dataName@ + dataExt@
}
function TdataFile.ExtData:String;
/dataExt
{$H Renvoie l'extension du fichier courant

 Voir aussi dataPath@ , dataName@

 Le nom complet est dataPath@ + dataName@ + dataExt@
}



procedure TdataFile.NouveauFichier(st:String);
procedure TdataFile.NouveauFichier(st:String;var errorCode:integer);
/newFile
{$H Chargement d'une fichier de données.

 La méthode a le même effet que la commande File/Load data file dans le menu principal.

 Si le paramètre ErrorCode est présent, aucun message d'erreur n'apparait en cas d'impossibilité
de chargement du fichier mais la valeur renvoyée par errorCode est différente de zéro.
}

procedure TdataFile.ClearAverage;
{$H Mise à zéro des moyennes.

 La méthode clear de chacun des objets m1@, m2@,... est appelée. C'est à dire que
leur contenu est effacé et leur propriété count est mise à zéro.

 Il est nécessaire d'appeler cette méthode avant d'appeler AddToAverage@ ou AddToAverage1@.

}
procedure TdataFile.AddToAverage;
{$H Ajoute le contenu de l'épisode courant au tampon moyenne.

 Tous les canaux sont moyennés simultanément. Comme les épisodes sont marqués, il
n'est pas possible d'accumuler deux fois le même épisode.

 Si la propriété StdON@ vaut true, les deviations standard sont également calculées.
}
procedure TdataFile.AddToAverage1(x:real);
{$H Ajoute le contenu d'un segment d'origine x au tampon moyenne.

 Cette méthode s'emploie avec les fichiers continus.
 Tous les canaux sont moyennés simultanément.

 Si l'on appelle i
 Le point du fichier d'abscisse x est ajouté au point d'indice 0 des objets moyenne.

}



property TdataFile.StdON:boolean;
{$H Si StdON vaut True, la déviation standard ainsi que les objets associés seront
calculés en même temps que les moyennes.

 Il faut que les objets moyennes soient vides pour modifier la propriété StdON.

 En affectant StdON, on modifie simultanément la propriété StdON de tous les
objets m1@, m2@,...
}
procedure TdataFile.InitAverages(tp,i1,i2:integer);
{$H Initialise les objets moyennes.

   tp est le (type de nombre)@ . Il faut obligatoirement choisir un type réel (T_single,
T_double ou T_extended).
   i1 deviendra l'indice de début Istart@(Tvector.Istart).
   i2 deviendra l'indice de fin Iend@(Tvector.Iend).

    La méthode modify@(Taverage.modify) de chaque objet moyenne (m1@, m2@...) est
appelée avec les paramètres tp, i1, i2 .

  Cette méthode n'a d'effet que si le fichier est continu. Pour les fichiers d'épisodes,
les objets moyennes ont obligatoirement les mêmes indices de début et de fin que
les vecteurs v1@, v2@.. On peut toutefois modifier le type de nombre avec AverageType@.

  i1 peut éventuellement être négatif. De cette façon, l'appel de la méthode AddToAverage1@ (x0)
ajoutera un certain nombre de points situés avant x0
}

procedure TdataFile.GetEpInfo(var x;dep:longint);
procedure TdataFile.SetEpInfo(var x;dep:longint);
procedure TdataFile.ReadEpInfo(var x);
procedure TdataFile.WriteEpInfo(var x);
procedure TdataFile.ResetEpInfo;

procedure TdataFile.GetFileInfo(var x;dep:longint);
procedure TdataFile.SetFileInfo(var x;dep:longint);
procedure TdataFile.ReadFileInfo(var x);
procedure TdataFile.WriteFileInfo(var x);
procedure TdataFile.ReadFileInfoExt(var x);
procedure TdataFile.WriteFileInfoExt(var x);
procedure TdataFile.ResetFileInfo;

function TdataFile.EpInfoSize:integer;
function TdataFile.FileInfoSize:integer;

property TdataFile.Comment:Tmemo readOnly;

function TdataFile.getSm2Info(ObjName,st:string;var w):boolean;
function TdataFile.getSM2RF(var x,y,dx,dy,theta:real):boolean;


function TdataFile.SearchAndload(st:string;numOc:integer;var ob:Tobject):boolean;
{$H Cherche dans le fichier un objet de nom St et essaie de le charger dans Ob.
 La fonction ne fonctionne que pour les fichiers de format Elphy.

 Num est le numéro de l'occurence de st. En effet, le fichier peut contenir plusieurs objets
de même nom. Si on souhaite charger la première occurence, on choisira num=1 . Si on
souhaite charger la seconde, on choisira num=2, etc...

 Si st est laissée vide , on considère que st est égale au nom de ob (ob.sysName).

 La fonction renvoie True si l'objet a pu être chargé, False dans le cas contraire.
}
function TdataFile.SearchTypeAndload(numOc:integer;var ob:Tobject):boolean;
{$H Cherche dans le fichier un objet dont le type est celui ob et essaie de le charger
dans ob.
 La fonction ne fonctionne que pour les fichiers de format Elphy.

 NumOc est le numéro de l'occurence de ob. En effet, le fichier peut contenir plusieurs objets
ayant le type de ob.
 ob doit avoir été créé auparavant.

 La fonction renvoie True si l'objet a pu être chargé, False dans le cas contraire.

}

procedure TdataFile.appendOI(src:string);
{$H Transforme les fichiers Optical Imaging en objets Elphy et les ajoute à la fin du fichier.

  src doit être un nom de fichier d'extension RSH ou nom générique de fichiers d'extension RSH

  Le fichier chargé dans TdataFile doit être au format Elphy.



  Dans un répertoire Optical Imaging , on trouve plusieurs groupes de fichiers.
  Un groupe a l'allure suivante:
    Ger0216-0.rsh           fichier texte Header
    Ger0216-0.rsm           image de référence (1 seule frame)
    Ger0216-0(0).rsd        premier bloc 256 frames
    Ger0216-0(1).rsd        second
    Ger0216-0(2).rsd        etc...
    Ger0216-0(3).rsd

  Voici un exemple de fichier rsh :

 @f6  //UltimaExpMan 20040830
 @f6  //x=128/y=100/lskp=20/rskp=8/blk=256
 @f6  //cmp=0/bit=16/mon=14/sft=0/prc=0
 @f6  page_frames=1024
 @f6  page_number=0
 @f6  sample_time=  1.0msec
 @f6  sample_mode=SDIF
 @f6  reset_mode=0
 @f6  gain_mode=0
 @f6  average=1
 @f6  trigger_src=Ext
 @f6  trigger_pos=pre_trg
 @f6  interval=1.0sec
 @f6  pls_delay=  0.0msec
 @f6  pls_width=  1.0msec
 @f6  pls_interval=  1.0msec
 @f6  pls_number=1
 @f6  pls2_delay=  0.0msec
 @f6  pls2_width=  0.0msec
 @f6  pls2_interval=  0.0msec
 @f6  pls2_number=0
 @f6  stim_mode=0
 @f6  dout_value=0
 @f6  sync_mode=1
 @f6  dual_cam=0
 @f6  plsfile=
 @f6  name=4*Ger0216-0(0)
 @f6  cmnt=
 @f6  Data-File-List
 @f6  Ger0216-0.rsm
 @f6  Ger0216-0(0).rsd
 @f6  Ger0216-0(1).rsd
 @f6  Ger0216-0(2).rsd
 @f6  Ger0216-0(3).rsd

  A la fin du fichier rsh , on trouve la liste des fichiers data  (extension rsm ou rsd)

  La méthode analyse le fichier RSH, récupère la liste des fichiers de données et
crée dans le fichier Elphy un bloc de données qui pourra être ensuite être traité
comme un objet TOIseq@

  voir aussi AppendOIblocks@  ,  (TobjectFile.appendOI)@(TobjectFile.appendOI) .


}
procedure TdataFile.AppendObject(var ob:Tobject);
{$H Sauve l'objet ob à la fin du fichier de données.

 Le fichier chargé dans Tdatafile doit être au format Elphy.

 Attention, tous les objets ne peuvent pas être sauvés avec cette méthode.
 Actuellement, seuls les vecteurs et matrices sont sauvés convenablement.
}

procedure TdataFile.BuildOIvecFile(stF: String);
{$H Crée un nouveau fichier de nom stF à partir des données contenues dans les objets TOISeq
du fichier chargé dans TdataFile.

 Dans TdataFile, les objets TOIseq sont rangés les uns après les autres.
 Dans chaque OIseq, on trouve FrameCount@(TOISeq.FrameCount)  images rangées les unes après les autres.
 Chaque image est un tableau de Nx@(TOIseq.Nx) * Ny@(TOIseq.Ny) nombres entiers sur deux octets.

 Si on s'intéresse à l'évolution temporelle de chaque pixel dans chaque OIseq, il sera plus commode et plus efficace
de disposer d'un fichier qui contient une succession de vecteurs plutôt qu'une succession d'images.

 BuildOIvecFile construit un fichier de nombres réels de type single organisé de la façon suivante:

 @f6 OIseq 1, pixel (0,0) FrameCount valeurs
 @f6 OIseq 1, pixel (1,0) FrameCount valeurs
 @f6 ...
 @f6 OIseq 1, pixel (Nx-1,0) FrameCount valeurs
 @f6 OIseq 1, pixel (0,1) FrameCount valeurs
 @f6 ...
 @f6 Puis
 @f6 OIseq 2, pixel (0,0) FrameCount valeurs
 @f6 etc...

 Il n'y a pas d'autre information. La taille du fichier créé est Nx*Ny*FrameCount*OIseqCount*4 .

 Par la suite, on peut associer le fichier créé au fichier de données chargé en utilisant setOIvecFile@
}


procedure TdataFile.setOIvecFile(stF: String);
{$H Associe le fichier de vecteurs de nom stF au fichier de données chargé.

 Le fichier de nom stF a été créé au moyen de BuildOIvecFile@ afin d'accélérer
}

function TdataFile.CyberTime(Ep:integer):real;
{$H Renvoie la date du début de l'épisode Ep exprimée en secondes.

 Ep est compris entre 1 et epCount@
 La fonction est active avec les fichiers de données obtenus avec le système BlackRock-CyberKinetics
 Pendant l'acquisition, pour chaque épisode, on a rangé dans le fichier la valeur de l'horloge de ce système.

 Cette horloge a une résolution de 1/30000 seconde.

}
function TdataFile.CorrectedCyberTime(Ep:integer):real;
{$H Renvoie la date du début de l'épisode Ep exprimée en secondes.

 Ep est compris entre 1 et epCount@

 En général, la fonction renvoie le même résultat que CyberTime@ mais elle s'efforce aussi de
corriger certaines anomalies.
 Si le fichier de données a été obtenu à partir d'une acquisition unique, les valeurs de CyberTime
forment une série croissante et le temps de fin d'un épisode ne peut pas se trouver aprés le début de
l'épisode suivant.
 Par contre, si le fichier de données a été reconstruit en concaténant plusieurs fichiers de données,
la chronologie n'est peut-être plus respectée. Le rôle de CorrectedCyberTime est de fournir
une liste de temps cohérents: on s'arrange pour éviter les chevauchements en introduisant des
décalages arbitraires. 

}

function TdataFile.Vcounts(num,ep:integer):integer;
{$H Renvoie le nombre d'échantillons du vecteur v[num] dans l'épisode ep
}

function TdataFile.VtagCounts(num,ep:integer):integer;
{$H Renvoie le nombre d'échantillons du vecteur Vtag[num] dans l'épisode ep
}

function TdataFile.VspkCounts(num,ep:integer):integer;
{$H Renvoie le nombre d'éléments du vecteur Vspk[num] dans l'épisode ep
}
function TdataFile.dataFileSize:int64;
function TdataFile.dataFileAge: TdateTime;


property TdataFile.OnChange: Tprocedure1;
{$H  Permet d'installer un gestionnaire d'événement appelé au chargement d'un nouveau fichier.

 Tprocedure1 est déclaré de la façon suivante:
 Tprocedure1=procedure(num:longint);

 Le paramètre num transmis est le tag de l'objet TdataFile .
}

property TdataFile.OnChangeEpisode: Tprocedure1;
{$H  Permet d'installer un gestionnaire d'événement appelé au chargement d'un épisode.

 Tprocedure1 est déclaré de la façon suivante:
 Tprocedure1=procedure(num:longint);

 Le paramètre num transmis est le tag de l'objet TdataFile .

 La procédure est appelée quand la propriété EpNum@ change ou quand on charge
un nouveau fichier.
}

function TdataFile.ElphyTime(ep:integer): TdateTime;
{$H Renvoie la date et l'heure du début d'enregistrement d'un épisode dans un fichier Elphy

 Cette information provient de l'horloge du PC. Elle a été rangée dans le fichier au moment
de l'enregistrement.
 Si le fichier n'est pas au format Elphy, la valeur renvoyée est 0.
 voir TdateTime@
}

function TdataFile.EpPCTime(ep:integer): longword;
{$H Renvoie le temps du PC au début de l'enregistrement d'un épisode dans un fichier Elphy

 Cette information provient de l'horloge du PC. C'est le temps en millisecondes de l'arrivée du premier échantillon dans le buffer d'acquisition.
 
 Si le fichier n'est pas au format Elphy, la valeur renvoyée est 0.
}


procedure TdataFile.CopyBlockTo(var f: TobjectFile; num: integer);
{$H Copie un bloc du fichier de données dans un fichier d'objets

 Num est le numéro de bloc compris entre 1 et ObjCount@

 Ne s'applique qu'aux fichiers de données Elphy

 Les fichiers de données Elphy ont la même structure que les fichiers d'objets (TobjectFile@),
certaines méthodes se retrouvent donc dans les deux objets.

 Voir TobjectFile.copy@(TobjectFile.copy)

}
property TdataFile.ClassNames(num:integer):String readOnly;
{$H Renvoie le nom de la classe de l'objet de numéro Num

 Ne s'applique qu'aux fichiers de données Elphy

 Les fichiers de données Elphy ont la même structure que les fichiers d'objets (TobjectFile@),
certaines méthodes se retrouvent donc dans les deux objets.

 Voir TobjectFile.ClassNames@(TobjectFile.ClassNames)

}

function TdataFile.Objcount:integer;
{$H Renvoie le nombre de blocs du fichier

 Ne s'applique qu'aux fichiers de données Elphy

 Les fichiers de données Elphy ont la même structure que les fichiers d'objets (TobjectFile@),
certaines méthodes se retrouvent donc dans les deux objets.

 Voir TobjectFile.ObjCount@(TobjectFile.ObjCount)

}
Procedure TdataFile.FreeFileStream;
{$H Ferme temporairement le fichier de données.

 Quand un fichier de données est ouvert dans Elphy, un autre processus ne peut pas accéder au fichier de données.
 FreeFileStream ferme le lien entre Elphy et le fichier mais sans rien perdre de l'initialisation des données.
 Ce lien sera rétablit automatiquement dés que ce sera nécessaire.

 Avec FreeFileStream, on permet à une autre application d'accéder aux données du fichier. On permet aussi
au programme PG2 d'accéder aux données d'une manière inhabituelle, par exemple en ouvrant le fichier
sous une forme binaire (TbinaryFile@)

  FreeFileStream est risqué dans la mesure où il faut s'arranger pour que l'autre application ou l'autre programme
ferme le fichier avant que TdataFile reprenne la main.

}


{ module Rarray1 }

function realArray0:TrealArray;

procedure TrealArray.create(stName:string;ColCount,LineCount:longint);
procedure TrealArray.create(ColCount,LineCount:longint);

procedure TrealArray.modify(ColCount,LineCount:longint);

property TrealArray.t(i,j:longint):real default;

property TrealArray.t1(i:longint):real;
property TrealArray.t2(i:longint):real;
property TrealArray.t3(i:longint):real;
property TrealArray.t4(i:longint):real;
property TrealArray.t5(i:longint):real;
property TrealArray.t6(i:longint):real;
property TrealArray.t7(i:longint):real;
property TrealArray.t8(i:longint):real;
property TrealArray.t9(i:longint):real;
property TrealArray.t10(i:longint):real;
property TrealArray.t11(i:longint):real;
property TrealArray.t12(i:longint):real;

property TrealArray.tN(i:longint):Tvector ReadOnly;

Property TrealArray.tN1:Tvector ReadOnly;
Property TrealArray.tN2:Tvector ReadOnly;
Property TrealArray.tN3:Tvector ReadOnly;
Property TrealArray.tN4:Tvector ReadOnly;
Property TrealArray.tN5:Tvector ReadOnly;
Property TrealArray.tN6:Tvector ReadOnly;
Property TrealArray.tN7:Tvector ReadOnly;
Property TrealArray.tN8:Tvector ReadOnly;
Property TrealArray.tN9:Tvector ReadOnly;
Property TrealArray.tN10:Tvector ReadOnly;
Property TrealArray.tN11:Tvector ReadOnly;
Property TrealArray.tN12:Tvector ReadOnly;

property TrealArray.columnName(i:integer):string;

procedure TrealArray.NomTab(num:integer;st:string);
/SetColumnName
procedure TrealArray.SauverTableau(st:string;lig1,lig2,col1,col2:longint;sauverNom:boolean;charsep:string);
/SSsave
function TrealArray.ChargerTableau(st:string;ChargerNom:boolean;lig1,col1:longint;var lig,col:longint;CharSep:string):boolean;
/SSload
procedure TrealArray.ImprimerTableau(lig1,lig2,col1,col2:longint);
/SSPrint
function TrealArray.NbColTableau:longint;
/SSColumnCount
function TrealArray.NbLigneTableau:longint;
/SSLineCount
procedure TrealArray.FillTableau(lig1,lig2,col1,col2:longint;x:real);
/SSFill

procedure TrealArray.SSrefresh;
procedure TrealArray.SSclear;
property TrealArray.SSindex(column:longint):longint;

procedure TrealArray.StringToLine(st:string;lineNum:integer);


{ module ObjFile1 }
procedure TobjectFile.createFile(fileName:string);
{$H Crée un nouveau fichier d'objets.

 CreateFile est un constructeur de l'objet Tobjectfile.
 Il crée un nouveau fichier de nom fileName. Si le fichier fileName existait
déjà, ce fichier est détruit.

}
procedure TobjectFile.OpenFile(fileName:string);
{$H Ouvre un fichier d'objets existant.

 OpenFile construit d'abord un objet Tobjectfile puis ouvre le fichier filename.
}

procedure TobjectFile.close;
{$H Ferme le fichier ouvert avec createFile@ ou OpenFile@ puis détruit
l'objet TobjectFile.
}

function TobjectFile.Maincount:longint;
{$H Renvoie le nombre d'objets primaires contenus dans le fichier.

 Les objets primaires sont ceux qui sont directement attachés à la racine de l'arbre
des objets dans la fenêtre de commande de TobjectFile.

 On ne tient donc pas compte des objets appartenant à ces objets primaires.
 Voir ObjCount@

}
function TobjectFile.count:longint;
{$H Equivalent de MainCount@

 La méthode est obsolète.  Elle a été remplacée par MainCount@ et ObjCount@ afin de
faire la distinction entre les deux méthodes de comptage des objets.
}


function TobjectFile.ObjCount:longint;
{$H Renvoie le nombre total d'objets contenus dans le fichier.

 On compte aussi bien les objets
 C'est donc le nombre total de blocs existant dans le fichier (excepté le bloc header)
 Voir MainCount@
}

procedure TobjectFile.seek(num:longint);
{$H Place le pointeur de lecture du fichier sur l'objet primaire de numéro num.

 Les objets primaires sont ceux qui sont directement attachés à la racine de l'arbre
des objets dans la fenêtre de commande de TobjectFile.

 C'est cet objet qui sera chargé par un appel à la méthode load@(TdataObject.load)
d'un objet de type TdataObject@ .

 Les numéros sont compris entre 1 et Maincount@ .
}


procedure TObjectFile.save(var ob:Tobject);

procedure TObjectFile.load(var ob:Tobject);
procedure TObjectFile.load(var ob:Tobject; SkipDisplayParams: boolean);
procedure TObjectFile.load(var ob:Tobject; SkipDisplayParams, KeepCoo: boolean);
{$H Charge l'objet ob à partir du fichier d'objets.

 Le fichier doit avoir été ouvert au moyen de la méthode OpenFile@(TobjectFile.OpenFile) .

 L'inconvénient de cette méthode est qu'une erreur d'exécution est générée si le
chargement de l'objet est impossible. Ce qui n'est pas toujours souhaitable.
 La méthode load1@ a le même effet mais n'arrête pas le programme en cas de
chargement impossible.

 Si SkipDisplayParams vaut True, on ne charge pas les paramètres d'affichage.

 Si KeepCoo vaut true (avec SkipDisplayParams=false) , on ne cherche pas à aligner les coordonnées
sur celles des objets ayant les mêmes coefficients de couplage.

}
function TObjectFile.load1(var ob:Tobject):boolean;
function TObjectFile.load1(var ob:Tobject; SkipDisplayParams: boolean):boolean;
function TObjectFile.load1(var ob:Tobject; SkipDisplayParams, KeepCoo: boolean):boolean;
{$H Charge l'objet ob à partir du fichier d'objets.

 Le fichier doit avoir été ouvert au moyen de la méthode OpenFile@(TobjectFile.OpenFile) .

 La fonction renvoie True si l'objet a pu être chargé, False dans le cas contraire.

 Le pointeur de fichier est incrémenté après un appel à load1, que l'objet
ait été chargé ou non.

 Si SkipDisplayParams vaut True, on ne charge pas les paramètres d'affichage.

 Si KeepCoo vaut true (avec SkipDisplayParams=false) , on ne cherche pas à aligner les coordonnées
sur celles des objets ayant les mêmes coefficients de couplage.

}
property TobjectFile.position:integer;
{$H Position du pointeur de lecture.

 Le pointeur de lecture est un nombre compris entre 1 et le nombre d'objets
primaires contenus dans le fichier ( MainCount@ ) . Il indique le prochain objet
qui sera chargé avec Load@ ou Load1@ .

 Affecter la propriété position est équivalent à appeler seek@ .
}

function TObjectFile.SearchAndload(st:string;Num:integer;var ob:Tobject):boolean;
function TObjectFile.SearchAndload(st:string;Num:integer;var ob:Tobject;SkipDisplayParams: boolean):boolean;
function TObjectFile.SearchAndload(st:string;Num:integer;var ob:Tobject;SkipDisplayParams,KeepCoo: boolean):boolean;

{$H Cherche dans le fichier un objet de nom St et essaie de le charger dans Ob.

 Num est le numéro de l'occurence de st. En effet, le fichier peut contenir plusieurs objets
de même nom. Si on souhaite charger la première occurence, on choisira num=1 . Si on
souhaite charger la seconde, on choisira num=2, etc...

 Si Num est négatif, on commence la recherche par la fin du fichier et abs(Num)
est le numéro de l'occurence cherchée.

 Si st est laissée vide , on considère que st est égale au nom de ob (ob.sysName).

 La fonction renvoie True si l'objet a pu être chargé, False dans le cas contraire.

 Si SkipDisplayParams vaut True, on ne charge pas les paramètres d'affichage.

 Si KeepCoo vaut true (avec SkipDisplayParams=false) , on ne cherche pas à aligner les coordonnées
sur celles des objets ayant les mêmes coefficients de couplage.

}

function TobjectFile.SearchTypeAndload(numOc:integer;var ob:Tobject):boolean;
function TobjectFile.SearchTypeAndload(numOc:integer;var ob:Tobject; SkipDisplayParams: boolean):boolean;
function TobjectFile.SearchTypeAndload(numOc:integer;var ob:Tobject; SkipDisplayParams, KeepCoo: boolean):boolean;
{$H Cherche dans le fichier un objet dont le type est celui ob et essaie de le charger
dans ob.

 NumOc est le numéro de l'occurence de ob. En effet, le fichier peut contenir plusieurs objets
ayant le type de ob.
 ob doit avoir été créé auparavant.

 Si NumOc est négatif, on commence la recherche par la fin du fichier et abs(NumOc)
est le numéro de l'occurence cherchée.

 La fonction renvoie True si l'objet a pu être chargé, False dans le cas contraire.

 Si SkipDisplayParams vaut True, on ne charge pas les paramètres d'affichage.

 Si KeepCoo vaut true (avec SkipDisplayParams=false) , on ne cherche pas à aligner les coordonnées
sur celles des objets ayant les mêmes coefficients de couplage.

}

function AppendObjectFile(st1,st2:string):boolean;
{$H Copie tous les objets du fichier de nom st2 à la fin du fichier de nom st1 .

 La fonction renvoie TRUE si l'opération s'est déroulée correctement.
 La fonction peut s'appliquer aux fichiers de données au format ELPHY.
}

procedure TobjectFile.AppendOI(Src: String);
procedure TobjectFile.AppendOI(Src: String; tp:integer);

{$H Convertit les fichiers générés par MICAM Ultima ou OPTICAL IMAGING INC. en blocs TOIseq@ et ajoute ces blocs à
la fin d'un fichier de données.

 Si tp=1 (valeur par défaut), les fichiers sources  doivent être des fichiers MICAM Ultima (extension RSH)
 Un fichier RSH contient une liste de fichiers d'images (extension RSD ou RSM)

 Si tp=2 , les fichiers sources doivent être des fichiers OPTICAL Imaging (extension BLK).

 src doit être un fichier d'extension RSH (resp BLK) ou encore un nom générique de fichier RSH (resp BLK).
 Exemple:  Cell18.RSH ou Cell*.RSH

 En général, l'étoile du nom générique désignera une liste de chiffres formant un numéro.
 Les fichiers seront triés dans l'ordre des numéros croissants.

 Le fichier dest doit être un fichier de données au format Elphy .
 Aucune vérification n'est effectuée sur ce fichier destination.


 Dans un répertoire MICAM Ultima, on trouve plusieurs groupes de fichiers.
 Un groupe a l'allure suivante:
    Ger0216-0.rsh           fichier texte Header
    Ger0216-0.rsm           image de référence (1 seule frame)
    Ger0216-0(0).rsd        premier bloc 256 frames
    Ger0216-0(1).rsd        second
    Ger0216-0(2).rsd        etc...
    Ger0216-0(3).rsd

  Voici un exemple de fichier rsh :

 @f6  //UltimaExpMan 20040830
 @f6  //x=128/y=100/lskp=20/rskp=8/blk=256
 @f6  //cmp=0/bit=16/mon=14/sft=0/prc=0
 @f6  page_frames=1024
 @f6  page_number=0
 @f6  sample_time=  1.0msec
 @f6  sample_mode=SDIF
 @f6  reset_mode=0
 @f6  gain_mode=0
 @f6  average=1
 @f6  trigger_src=Ext
 @f6  trigger_pos=pre_trg
 @f6  interval=1.0sec
 @f6  pls_delay=  0.0msec
 @f6  pls_width=  1.0msec
 @f6  pls_interval=  1.0msec
 @f6  pls_number=1
 @f6  pls2_delay=  0.0msec
 @f6  pls2_width=  0.0msec
 @f6  pls2_interval=  0.0msec
 @f6  pls2_number=0
 @f6  stim_mode=0
 @f6  dout_value=0
 @f6  sync_mode=1
 @f6  dual_cam=0
 @f6  plsfile=
 @f6  name=4*Ger0216-0(0)
 @f6  cmnt=
 @f6  Data-File-List
 @f6  Ger0216-0.rsm
 @f6  Ger0216-0(0).rsd
 @f6  Ger0216-0(1).rsd
 @f6  Ger0216-0(2).rsd
 @f6  Ger0216-0(3).rsd

  A la fin du fichier rsh , on trouve la liste des fichiers data  (extension rsm ou rsd)

  La méthode analyse le fichier RSH, récupère la liste des fichiers de données et
crée un objet TOIseq@ qu'il range à la fin du fichier d'objets

  Voir aussi (TdataFile.AppendOI)@(TdataFile.AppendOI) ,AppendOIblocks@

}

property TobjectFile.ClassNames(n:integer): string readonly;
{$H Liste des types d'objets (les classes) contenus dans le fichier.

 n est l'indice de l'objet. Sa valeur est comprise entre 1 et ObjCount@
}

property TobjectFile.ObjNames(n:integer): string readonly;
{$H Liste des noms des objets  contenus dans le fichier.

 n est l'indice de l'objet. Sa valeur est comprise entre 1 et ObjCount@
}

property TobjectFile.ObjOffsets(n:integer): int64 readonly;
{$H Liste des offsets des objets  contenus dans le fichier.

 n est l'indice de l'objet. Sa valeur est comprise entre 1 et ObjCount@
 Les offsets sont exprimés en octets et commencent à zéro
}

property TobjectFile.ObjSizes(n:integer): integer readonly;
{$H Liste des tailles des objets  contenus dans le fichier.

 n est l'indice de l'objet. Sa valeur est comprise entre 1 et ObjCount@
 Les tailles sont exprimées en octets. Ces tailles correspondent aux différences
entre offsets d'objets consécutifs dans le fichier.
}

procedure TobjectFile.copy(var f2: TobjectFile; num:integer);
{$H Copie un objet contenu dans un autre fichier d'objets.

 num est l'indice de l'objet dans le fichier f2. C'est un nombre compris entre 1 et f2.ObjCount@ObjCount.
 Cet objet sera placé à la fin du fichier actuel.
 La copie ne préoccupe pas de la nature de l'objet copié. On se base uniquement sur les informations
contenues dans les propriétés ObjOffsets@ et ObjSizes de f2

 La propriété Position@ ne joue aucun rôle dans cette copie.
}



{Module BinFile1}

procedure TBinaryFile.reset(fileName:string);
{$H Ouvre un fichier existant de nom fileName.
 Cette méthode est aussi un constructeur de l'objet.
}

procedure TBinaryFile.rewrite(fileName:string);
{$H Crée un nouveau fichier de nom fileName.
 Cette méthode est aussi un constructeur de l'objet.
}

procedure TBinaryFile.close;
{$H Ferme le fichier et détruit l'objet.
}

procedure TBinaryFile.seek(x:int64);
{$H Place le pointeur de lecture/écriture sur l'octet du fichier d'indice x.
 Les indices commencent à zéro.
 Les opérations ultérieures de lecture ou écriture se feront à partir de cet octet.
}
function TBinaryFile.filePos:int64;
{$H Renvoie la position du pointeur de lecture/écriture
}
function TBinaryFile.fileSize:int64;
{$H Renvoie la taille du fichier
}

procedure TBinaryFile.write(var x);
{$H Range la variable x dans le fichier.
 Le pointeur de lecture/écriture est incrémenté dune valeur égale à la taille de
la variable.
}
procedure TBinaryFile.read(var x);
{$H Lit suffisamment d'octet dans le fichier pour remplir la variable x.
Après la lecture, le pointeur de lecture/écriture se trouve incrémenté dune
valeur égale à la taille de la variable.
}

procedure TBinaryFile.BlockWrite(var x;offset,nb:integer);
{$H Range une partie de la variable x dans le fichier.
 Si on appelle Ad l'adresse de la variable, les octets compris entre les adresses
Ad+offset et Ad+offset+nb-1 sont rangés dans le fichier.

}
procedure TBinaryFile.BlockRead(var x;offset,nb:integer);
{$H Lit suffisamment d'octets dans le fichier pour remplir la partie de la variable x
dont les adresses sont comprises entre Ad+offset et Ad+offset+nb-1, Ad étant l'adresse
de la variable x.
}

procedure TBinaryFile.CopyFrom(var binF: TbinaryFile; nb:int64);
procedure TbinaryFile.CopyFrom(var binF:TbinaryFile;BlockSize, MaxSize:int64; var VMask:Tvector; tp:integer;var index:integer);

{$H  Copy nb octets à partir du fichier binF

 On suppose que la position de lecture de binF a été correctement choisie avec seek@

 La seconde variante permet de copier efficacement les données analogiques d'un fichier Elphy multiplexé:
 BlockSize est la taille du bloc de données à traiter (en bytes)
 MaxSize permet de limiter la taille écrite dans le fichier destination. En général, on donnera la valeur zéro à maxSize.

 Vmask est un vecteur qui permet d'indiquer la structure d'un agrégat. Sa longueur (Icount) doit être égale à la taille d'un agrégat.
Les valeurs successives de Vmask correspondent au numéro du canal . Quand on ne veut pas sauver le canal, on remplace la valeur par zéro.
Dans le cas le plus simple, un agrégat correspondant à un fichier de cinq canaux contiendra par exemple (1,2,3,4,5) mais comme Elphy autorise le
sous-échantillonnage sur certaines voies, la structure de l'agrégat peut être nettement plus compliquée. Dans notre exemple, si la voie 5 a été
décimée avec un facteur 3, on aura (1,2,3,4,5,1,2,3,4,1,2,3,4)

 tp est le type des données (voir (Types numériques)@(types de nombre) ). Ce type est conservé pendant la copie.
 index est une variable entière qui doit être initialisée à zéro quand on commence le traitement d'un fichier continu ou bien quand
on commence le traitement d'un épisode. Dans les autre cas, cete valeur ne doit pas être modifiée.



}
procedure TbinaryFile.CopyWithDownSampling1(var binF:TbinaryFile;EpSize:int64; ChCount, tp, DSfactor: integer);
{$H Copie les données du fichier binF en effectuant un sous-échantillonnage.

 binF est un fichier binaire contenant des données de type smallint ou single.
 Ce fichier contient ChCount canaux multiplexés.
 tp est le type des données (voir (Types numériques)@(types de nombre) )
 DSfactor est le facteur de sous-échantillonnage souhaité.

 Les données contenues dans un bloc commençant à la position courante de binF et de taille EpSIze sont
sous-échantillonnées et rangées à la fin du fichier .
  Chaque groupe de DSfactor échantillons est remplacé par sa moyenne.
  On supprime le multiplexage: le nouveau bloc contient tous les échantillons du premier canal, puis tous les échantillons
du second canal, etc...



}

procedure TbinaryFile.CopyEpisodeWithDownSampling1(var binF:TbinaryFile;var Voffset, VSize, VMask:Tvector; tp:integer; DSfactor: integer);


procedure ElphyFileToAnalogBinaryFile(stSrc,stDest: String; var Vchan: Tvector; DW: integer;mux:boolean; var VstartPos:Tvector);
{$H Copie certaines voies analogiques d'un fichier Elphy dans un fichier binaire.

 stSrc est le nom du fichier source
 stDest est le nom du fichier destination

 Vchan doit contenir la liste des numéros des canaux à copier

 DW est le facteur de sous- échantillonnage. Si DW>1 ,chaque groupe de DW échantillons est remplacé par sa moyenne

 Si mux vaut TRUE, le fichier créé est multiplexé. Sinon, les vecteurs correspondant à chaque canal et chaque épisode
sont rangés les uns après les autres sur le disque.
 Le mode multiplexé convient bien aux fichiers continus. Le mode non multiplexé convient aux fichiers organisés en épisodes.

 Au retour, VstartPos contiendra soit les indices des débuts d'épisode si l'on est en mode multiplexé, soit les indices des débuts
de chaque vecteur si l'on est en mode non multiplexé.

}

{Module TextFile1}

procedure TtextFile.reset(fileName:string);
{$H Ouvre un fichier existant de nom fileName.
 Cette méthode est aussi un constructeur de l'objet.
}

procedure TtextFile.rewrite(fileName:string);
{$H Crée un nouveau fichier de nom fileName.
 Cette méthode est aussi un constructeur de l'objet.
}

procedure TtextFile.close;
{$H Ferme le fichier et détruit l'objet.
}

function TtextFile.fileSize:int64;
{$H Renvoie la taille du fichier
}

function TtextFile.eof:boolean;
{$H Indique si la fin du fichier est atteinte
}

function TtextFile.Readln:string;
{$H Lit une ligne du fichier
}

procedure TtextFile.writeln(st:string);
{$H Ecrit la chaine st dans le fichier en ajoutant les caractères de fin de ligne (CR+LF).
}


{ modules Standac1  et stmU1}

function Abs(x:integer):integer;
function Abs(x:real):real;
{$CAT TRIGO Routines trigonométriques}
{$CAT MATH Routines mathématiques}
{$CAT Files Routines de gestion de fichiers}
{$CAT RSystem Routines système}
{$CAT Dialmod Dialogue modal}
{$CAT RString Gestion de chaînes de caractères}
{$CAT Conv routines de conversion}

{$C Math Valeur absolue d'un réel}
{$H Renvoie la valeur absolue de x}

function AbsI(x:longint):longint;
{$C Math Valeur absolue d'un entier}
{$H Renvoie la valeur absolue de x}

function Sin(x:real):real;
{$C TRIGO Sinus}
{$H Renvoie le sinus de x.}

function Cos(x:real):real;
{$C TRIGO Cosinus}
{$H Renvoie le cosinus de x}

function Tan(x:real):real;
{$C TRIGO Tangente}
{$H Renvoie la tangente de x.}

function ArcSin(x:real):real;
{$C TRIGO Arcsinus}
{$H Renvoie l'arcsinus  de x}

function ArcCos(x:real):real;
{$C TRIGO Arccosinus}
{$H Renvoie l'arccosinus  de x}

function ArcTan(x:real):real;
{$C TRIGO Arctangente}
{$H Renvoie l'arctangente  de x}

function SinC(x:real):real;
{$C TRIGO Sinus cardinal}
{$H Renvoie la valeur de sin(x)/x

 Pour x=0, la valeur renvoyée est 1
}


function Chr(i:integer):string;
{$C Rstring Renvoie le caractère de code i }
{$H Convertit le nombre i en une chaine de un caractère dont le code ASCII est i.
}
function Copy(st:string;p,l:integer):string;
{$C RString Extrait une sous-chaine d'une chaine de caractères}
{$H Renvoie une sous-chaîne de la chaîne st.
 Cette sous-chaîne commence au pième caractère de st et contient l caractères
( à condition que ces caractères existent)
}

procedure Delay(m:integer);
{$H Attend pendant un durée approximative de m millisecondes.
}

procedure Delete(var st:string;p,n:integer);
procedure Delete(var st:shortstring;p,n:integer);
{$C RString supprime une sous-chaine dans une chaine de caractères}
{$H Supprime n caractères dans la chaîne st en commençant au caractère d'indice p.
}
function Exp(x:real):real;
{$C Math Exponentielle }
{$H Renvoie l'exponentielle de x.
}
function Frac(x:real):real;
{$C Math Partie fractionnaire }
{$H Renvoie la partie fractionnaire de x.

 Exemple Frac(6.56) renvoie 0.56;
}

procedure Insert(source:string;var st:string;p:integer);
procedure Insert(source:string;var st:shortstring;p:integer);
{$C RString Insère une chaine de caractères dans une autre}
{$H Insère la sous-chaîne source dans la chaîne st à l'indice p.

}
function Length(st:string):integer;
{$C RString renvoie la longueur d'une chaine }
{$H Renvoie la longueur de la chaîne st.
}
function Ln(x:real):real;
{$C Math Logarithme népérien }
{$H Renvoie le logarithme népérien de x.
}

function Pi:real;
{$C Math Nombre PI }
{$H Renvoie le nombre PI
}
function Pos(s,st:string):integer;
{$C RString Renvoie la position d'une sous-chaine}
{$H Renvoie la position de la sous-chaîne s dans la chaine st.

 Si la sous-chaîne n'existe pas, la fonction renvoie 0.
}
function Random:real;
function Random(n:integer):integer ;
{$C Math Nombre aléatoire }
{$H La première variante renvoie un nombre aléatoire réel compris entre 0 et 1.
    La seconde variante renvoie un nombre aléatoire entier compris entre 0 et n-1.
 Pour initialiser le générateur de nombres aléatoires, il faut appeler
Randomize@ ou setRandSeed@ .
}

function RandomI(n:longint):longint;
{$C Math Nombre aléatoire entier}
{$H Renvoie un nombre aléatoire entier compris entre 0 et n-1.

 Pour initialiser le générateur de nombres aléatoires, il faut appeler
Randomize@ ou setRandSeed@ .
}
procedure Randomize;
{$C Math Initialise le générateur de nombres aléatoires}
{$H Initialise le générateur de nombres aléatoires en lui donnant un
état aléatoire.

 Pour lui donner un état déterminé, il faut utiliser setRandSeed@ .

}
procedure setRandSeed(n:longint);
{$C Math Initialise le générateur de nombres aléatoires}
{$H Initialise le générateur de nombres aléatoires en le plaçant dans un
état déterminé dépendant du nombre n.

 Après l'appel de setRandSeed avec une valeur donnée, la séquence pseudo-aléatoire
générée sera toujours la même.
}
function Round(x:real): int64;
{$C Math Valeur entière la plus proche}
{$H Renvoie la valeur entière la plus proche de x.

 Voir aussi trunc@, floor@.
}


function SqrC(x:complex):complex;
{$C Math Carré d'un nombre complexe}
{$H Renvoie le carré de x.
}

function Sqr(x:real):real;
{$C Math Carré d'un nombre réel}
{$H Renvoie le carré de x.
}
function SqrI(x:longint):longint;
{$C Math Carré d'un nombre entier}
{$H Renvoie le carré de x.
}
function Sqrt(x:real):real;
{$C Math Racine carrée d'un nombre réel}
{$H Renvoie la racine carrée de x.
}
function SqrtC(x:complex):complex;
{$C Math Racine carrée d'un nombre complexe}
{$H Renvoie la racine carrée de x.
}

function Power(x,y:real):real;
{$C Math x exposant y }
{$H Renvoie la valeur de x élevé à la puissance y
 x et y sont des réels quelconques
}

function Trunc(x:real): int64;
{$C Math Partie entière}
{$H Renvoie la partie entière de x.

 @f6 Exemple: trunc(2.67) renvoie 2
 @f6          trunc(-2.67) renvoie -2

 Voir aussi round@, floor@.
}

procedure InitChrono;
{$H Initialise un chronomètre.

 La fonction Chrono@ renverra le temps écoulé depuis cette initialisation.

 Les deux fonctions (initchrono et chrono) permettent surtout d'évaluer la durée
d'un calcul.
}
function Chrono:string;
{$H Renvoie une chaîne indiquant le temps écoulé depuis l'appel de InitChrono@.

}
procedure SupSpace(var st:string);
procedure SupSpace(var st:shortstring);
/deleteSpaces
{$C RString suppression des espaces}
{$H Supprime les espaces de la chaîne st.
}

function ValInt(st:string):longint;
{$C CONV Convertit une chaine en valeur entière}
{$H Convertit le contenu de la chaîne st en une valeur entière.

 Si la chaîne ne représente pas un nombre entier, la fonction renvoie 0.
}
function ValReal(st:string):real;
{$C CONV Convertit une chaine en valeur réel}
{$H Convertit le contenu de la chaîne st en une valeur réelle.

 Si la chaîne ne représente pas un nombre réel, la fonction renvoie 0.
}
function Sizeof(var x):longint;
{$H Renvoie la taille de la variable x.
}

function floor(x:real): int64;
{$C Math Valeur entière inférieure la plus proche}
{$H Renvoie la valeur entière inférieure à x qui est la plus proche de x.

 @f6 Exemple: floor(2.67) renvoie 2
 @f6          floor(-2.67) renvoie -3

 Voir aussi trunc@, round@, ceil@.
}

function ceil(x:real): int64;
{$C Math Valeur entière supérieure la plus proche}
{$H Renvoie la valeur entière supérieure à x qui est la plus proche de x.

 @f6 Exemple: ceil(2.67) renvoie 3
 @f6          floor(-2.67) renvoie -2

 Voir aussi trunc@, round@, floor@.
}


function TimeGetTime:longint;
{$C RSystem Temps système }
{$H  Renvoie le temps système en millisecondes.
}

procedure PlaySound(st:string; flags: longword);
{$H Appelle la fonction SndPlaySound de l'API Windows

  st peut être le nom d'un fichier d'extension wav ou bien peut désigner l'un des sons du système:

  'SystemAsterisk'
  'SystemExclamation'
  'SystemExit'
  'SystemHand'
  'SystemQuestion'
  'SystemStart'

  flags peut être une combinaison des codes suivants:

  SND_SYNC            = $0000;  // play synchronously (default)
  SND_ASYNC           = $0001;  // play asynchronously
  SND_NODEFAULT       = $0002;  // don't use default sound
  SND_MEMORY          = $0004;  // lpszSoundName points to a memory file
  SND_LOOP            = $0008;  // loop the sound until next sndPlaySound
  SND_NOSTOP          = $0010;  // don't stop any currently playing sound

  Pour arrêter un son déclenché de façon asynchrone, il faut appeler PlaySound
avec une chaîne vide pour paramètre.

}

function createDir(st:string):boolean;
{$C Files Création d'un répertoire }

procedure SplitFileName( st:string; var path,name,ext:string);
procedure SplitFileName( st:string; var path,name,ext:shortstring);
{$C Files Décompose un nom de fichier}
{$H Décompose le nom de fichier st.
 La chaine st est décomposée en trois parties telles que
         st=path + name + ext
 Path est le chemin d'accès, formé de tous les caractères qui précèdent le nom proprement dit.
 name est le nom de fichier
 ext est l'extension (qui inclut le point séparateur
}

procedure SplitFileNameEx( st:string;  var path,name:string;var num:integer;var ext:string);
procedure SplitFileNameEx( st:string;  var path,name:shortstring;var num:integer;var ext:shortstring);
{$C Files Décompose un nom de fichier}
{$H Décompose le nom de fichier st.
 La chaine st est décomposée en quatre parties telles que
         st=path + name + StNum + ext
 Path est le chemin d'accès, formé de tous les caractères qui précèdent le nom proprement dit.
 Le nom de fichier est décomposé en une partie littérale Num et une partie numérique stNum
 Exemple: data32 donne name = data et stNum = 32
 La chaine stNum est convertie en une valeur numérique Num.
 Ext est l'extension (qui inclut le point séparateur
}

function NextFileEx(st:string):String;
{$C Files Trouve le fichier ayant le numéro suivant }
{$H  Renvoie le fichier ayant le numéro suivant
  St doit être un nom de fichier complet (chemin d'accès+nom+extension) avec un nom se terminant
par une partie numérique, par exemple Data56 .
  La chaine renvoyée sera le nom complet du fichier ayant le numéro supérieur le plus proche
de celui de st.
  Si ce fichier n'existe pas, la fonction renvoie une chaine vide.

 Exemple: si le répertoire C:\Manip contient les fichiers data24.dat, data28.dat et data29.dat
 NextFileEx('c:\Manip\data24.dat') renvoie 'c:\Manip\data28.dat'
}
function PreviousFileEx(st:string):String;
{$C Files Trouve le fichier ayant le numéro précédent }
{$H  Renvoie le fichier ayant le numéro précédent
  St doit être un nom de fichier complet (chemin d'accès+nom+extension) avec un nom se terminant
par une partie numérique, par exemple Data56 .
  La chaine renvoyée sera le nom complet du fichier ayant le numéro inférieur le plus proche
de celui de st.
  Si ce fichier n'existe pas, la fonction renvoie une chaine vide.

 Exemple: si le répertoire C:\Manip contient les fichiers data24.dat, data28.dat et data29.dat
 PreviousFileEx('c:\Manip\data28.dat') renvoie 'c:\Manip\data24.dat'
}

Hpage TdateTime; { Type TdateTime }

{$P TdateTime représente une valeur date+heure
 Le type TdateTime est implémenté dans Elphy sous la forme d'une structure sur 8 octets.
 On obtient une valeur de ce type par exemple quand on appelle FirstFile@ ou NextFile@

 Les procédures DecodeDateTime@ et EncodeDateTime@ permettent de décoder ou  encoder cette valeur.
}

procedure DecodeDateTime(Value: TdateTime;var Year,Month,Day,Hour,Minute,Second,MilliSecond:smallint..longword);
{$H Décode une valeur de type TdateTime@.

 Voir aussi EncodeDateTime@, FirstFile@ , NextFile@
}

function EncodeDateTime(Year, Month, Day, Hour, Minute, Second, MilliSecond:integer ):TdateTime;
{$H Encode une valeur de type TdateTime@.

 Voir aussi DecodeDateTime@, FirstFile@ , NextFile@

}

function Now:TdateTime;
{$H Renvoie la date et l'heure sous la forme d'une valeur TdateTime@

 La procédure DecodeDateTime@ permet de décoder cette valeur.

}

{ module StmU1 }

function Istr(i:integer):string;
function Istr(i,n:integer):string;
{$C CONV convertit un entier en chaine de caractères }
{$H Convertit la valeur entière i en une chaîne de caractères.

 Quand n est supérieur au nombre de digits, le  nombre est précédé par autant d'espaces qu'il est nécessaire
pour obtenir n caractères.
 n vaut zéro par défaut. Dans ce cas, aucun espace ne précède les caractères formant le nombre.
}

function HexaStr(i:integer):string;
function HexaStr(i,n:integer):string;
{$C CONV convertit un entier en chaine hexadécimale }
{$H Convertit la valeur entière i en une chaîne de caractères hexadécimale

 Quand n est supérieur au nombre de digits, le  nombre est précédé par autant de zéros qu'il est nécessaire
pour obtenir n caractères.
 n vaut zéro par défaut.

 Exemple: @prog HexaStr(18) donne la chaine '12'; @notprog
}



function Bstr(w:boolean):string;
{$C CONV convertit un booléen en chaine de caractères }
{$H Convertit la valeur booléenne w en une chaîne de caractères.

 Le résultat est 'TRUE' ou 'FALSE' .
}
function Rstr(x:real;n,m:integer):string;
function Rstr(x:real):string;

{$C CONV convertit un réel en chaine de caractères }
{$H Convertit la valeur réelle x en une chaîne de caractères.

 n est la largeur de champ
 m est le nombre de décimales

 Quand n=0, ou bien quand n et m sont omis, la chaîne renvoyée contient le nombre en notation scientifique avec le maximum de chiffres significatifs.
 
}
procedure InitSaisie;
/InitDialogBox
{$C DIALMOD  Initialise le dialogue .}
{$H Initialise un dialogue modal.

 La structure typique d'une routine effectuant une saisie de paramètres sera
la suivante:

 @f6 InitDialogBox;
 @f6 DBgetInteger('Longueur',long,6);
 @f6 DBgetReal('Position',x,10,3);
 @f6 DBgetString('Nom',XName,20);
 @f6 ...

 @f6 ShowDialogBox;

 On commence toujours avec InitDialogBox et on termine avec ShowDialogBox@ .
 Entre les deux, on place une liste de procédures qui permettent chacune la saisie
d'une variable. Le nom de ces procédures rappelle le type de la variable saisie.
 En voici la liste:

          DBgetInteger@
          DBgetReal@
          DBgetString@
          DBgetBoolean@
          DBgetStringList@
          DBsetText@
          DBgetColor@
          DBgetCommand

 On peut également changer le contenu de la barre de titre avec DBsetCaption@ .

 Quand la fenêtre se ferme après que l'utilisateur ait appuyé sur le bouton OK,
le contenu des variables est mis à jour. Il en de même s'il a appuyé un bouton
créé avec DBgetCommand@ .
 Par contre, si l'utilisateur a appuyé sur le bouton Cancel, le contenu des variables
est inchangé.

 Pour créer un dialogue modal, on peut utiliser aussi un objet Tdialog@ .
}

procedure SaisieInteger(titre:string;var x:byte..longword;n:integer);
/DBgetInteger
{$C DIALMOD  Saisie d'un entier }
{$H Saisie d'une variable entière dans un dialogue modal.

 Titre apparait à gauche de la variable dans le dialogue.
 x est la variable à saisir. Son type peut être n'importe quel (type entier)@(types entiers);
 n est une largeur de champ approximative exprimée en nombre de caractères

 Voir l'exemple de InitDialogBox@ .
}
procedure SaisieLongint(titre:string;var x:longint;n:integer);
/DBgetLongint
{$C DIALMOD  Saisie d'un entier }
{$H Saisie d'une variable de type longint dans un dialogue modal.

 Cette procédure est désormais inutile. Il faut utiliser DBgetInteger@ .

 Titre apparait à gauche de la variable dans le dialogue.
 x est la variable à saisir.
 n est une largeur de champ approximative exprimée en nombre de caractères

 Voir l'exemple de InitDialogBox@ .
}

procedure SaisieReal(titre:string;var x:single..extended;n,m:integer);
/DBgetReal
{$C DIALMOD  Saisie d'un réel }
{$H Saisie d'une variable de type Real dans un dialogue modal.

 Titre apparait à gauche de la variable dans le dialogue.
 x est la variable à saisir.Son type peut être n'importe quel (type réel)@(types réels);
 n est une largeur de champ approximative exprimée en nombre de caractères
 m est le nombre de décimales affichées.

 Voir l'exemple de InitDialogBox@ .
}

procedure SaisieString(titre:string;var x:string;n:integer);
procedure SaisieString(titre:string;var x:shortstring;n:integer);
/DBgetString
{$C DIALMOD  Saisie d'une chaîne de caractères }
{$H Saisie d'une variable de type string dans un dialogue modal.

 Titre apparait à gauche de la variable dans le dialogue.
 x est la variable à saisir.
 n est une largeur de champ approximative exprimée en nombre de caractères

 Voir l'exemple de InitDialogBox@ .
}

procedure SaisieBoolean(titre:string;var x:boolean);
/DBgetBoolean
{$C DIALMOD  Saisie d'un booléean }
{$H Saisie d'une variable de type Boolean dans un dialogue modal.

 Les variables booléennes appraissent sous la forme de cases à cocher.
 Titre apparait à gauche de la case à cocher.
 x est la variable à saisir.

 Voir l'exemple de InitDialogBox@ .
}

procedure SaisieScalaire(titre,option:string;var x:byte..longWord);
/DBgetStringList
{$C DIALMOD  Saisie d'une valeur dans une liste  }
{$H Saisie d'une variable de type integer dans un dialogue modal, sous la forme
d'un choix à faire dans une liste d'options (comboBox).

 Titre apparait à gauche de la combobox
 Option est une chaine contenant les options possibles. Dans cette chaine, les options
sont des sous-chaînes séparées par des barres verticales (|).
 x est la variable contenant le numéro courant de l'option. Les numéros commencent
à 1.

 Exemple:
 @f6 DBgetStringList('Votre choix:','Choix 1|Choix 2|Choix 3',ww);


 Voir aussi l'exemple de InitDialogBox@ .
}

procedure SaisieText(titre:string);
/DBsetText
{$C DIALMOD  Insertion d'une ligne de texte  }
{$H Permet d'insérer une ligne de texte dans un dialogue modal.

 Titre est la ligne de texte.

 Voir l'exemple de InitDialogBox@ .
}

procedure SaisieCouleur(titre:string;var x:longint);
/DBgetColor
{$C DIALMOD  Saisie d'une couleur  }
{$H Permet de choisir une couleur dans un dialogue modal.

 Les couleurs sont stockées sous la forme d'entiers sur 4 octets.

 Titre apparait sur un bouton qu'il faut enfoncer pour ouvrir un dialogue
standard de saisie de couleur.
 A coté du bouton se trouve un rectangle colorié avec la couleur correspondant
au contenu de la variable. Cette couleur se met à jour dés que l'utilisateur
modifie son choix.

 Voir l'exemple de InitDialogBox@ .
}

procedure SaisieCaption(titre:string);
/DBsetCaption
{$C DIALMOD  Modification de la barre de titre }
{$H Permet de la barre de titre d' un dialogue modal.

 Voir l'exemple de InitDialogBox@ .
}


procedure SaisieCommande(titre:string;var x:boolean);
/DBgetCommand
{$C DIALMOD  Introduction d'un bouton de commande }
{$H Permet d'introduire un bouton supplémentaire dans un dialogue modal.

 Titre apparait sur le bouton.

 x est une variable booléenne qui sera automatiquement initialisée à false à
l'ouverture du dialogue.
 Si l'utilisateur appuie sur le bouton, le dialogue se ferme et la valeur de la
variable vaut True.

 Il est préférable d'utiliser DBgetCommand1@ qui est plus pratique.

 Voir l'exemple de InitDialogBox@ .
}

procedure SaisieCommande1(titre:string;Res:integer);
/DBgetCommand1
{$C DIALMOD  Introduction d'un bouton de commande }
{$H Permet d'introduire un bouton supplémentaire dans un dialogue modal.

 Titre apparait sur le bouton.

 Si l'utilisateur appuie sur le bouton, le dialogue se ferme et la valeur renvoyée
par la fonction ShowDialogBox sera égale à Res.

 Res peut prendre n'importe quelle valeur entière différente de zéro mais il faut
éviter les valeurs comprises entre 1, 2 et 100 (voir ShowDialogBox@)

 Voir l'exemple de InitDialogBox@ .
}


function Saisie:longint;
/ShowDialogBox
{$C DIALMOD  Exécution de la saisie }
{$H Ouvre le dialogue modal préparé avec InitDialogBox@ et le jeu d'instructions commençant
par DB.

 La valeur renvoyée par la fonction dépend du choix fait par l'utilisateur:

 Si l'utilisateur a appuyé sur le bouton OK, la valeur renvoyée est 1
(Constante MR_OK@).
 Si l'utilisateur a appuyé sur le bouton Cancel, la valeur renvoyée est 2
(Constante MR_Cancel@).
 Si l'utilisateur a appuyé sur un  bouton créé avec DBgetCommand, la valeur renvoyée est 100.

 Voir l'exemple de InitDialogBox@ .
}

function Saisie1(x0,y0:integer):longint;
/ShowDialogBoxXY
{$C DIALMOD  Exécution de la saisie }
{$H Ouvre le dialogue modal préparé avec InitDialogBox@ et le jeu d'instructions commençant
par DB.
 x0 et y0 sont les coordonnées du dialogue exprimées en pixels.

 La valeur renvoyée par la fonction dépend du choix fait par l'utilisateur:

 Si l'utilisateur a appuyé sur le bouton OK, la valeur renvoyée est 1
(Constante MR_OK@).
 Si l'utilisateur a appuyé sur le bouton Cancel, la valeur renvoyée est 2
(Constante MR_Cancel@).
 Si l'utilisateur a appuyé sur un  bouton créé avec DBgetCommand, la valeur renvoyée est 100.

 Voir l'exemple de InitDialogBox@ .
}


procedure MessageCentral(st:string);
/messageBox
{$H Affiche un message au centre de l'écran.

 st est la chaîne de caractères affichée.
 L'utilisateur doit cliquer sur le bouton OK pour continuer.
}
function QuestionCentrale(st:string):boolean;
/QueryBox
{$H Affiche le message st au centre de l'écran.

 L'utilisateur doit cliquer sur l'un des boutons Yes ou No.
 La fonction renvoie True dans le premier cas et False autrement.
}

procedure Pause;
{$H Interrompt le déroulement du programme en affichant une petite fenêtre.

 L'utilisateur doit fermer cette fenêtre pour continuer. L'instruction est surtout
utile pour la mise au point.
}
procedure Halt;
{$H Arrête immédiatement l'exécution d'un programme.

 L'arrêt se fait sans message d'aucune sorte.
}
function Clavier:integer;
/KeyBoard
{$H La fonction attend que l'utilisateur frappe une touche du clavier et renvoie
un code correspondant à la touche enfoncée.

 Ce code est le Virtual Key Code de Windows.
}

procedure StatusLineTxt(st:string);
{Permet d'afficher du texte en bas de l'écran dans la fenêtre status }

function NewFileName(st:string):string;
{$C Files Renvoie un nom de fichier disponible pour l'acquisition }
{$H Renvoie le premier nom de fichier disponible compatible avec st.

 st doit être un nom générique de fichier analogue à celui que l'on indique
dans le dialogue Acquisition/Paramètres.

}

function Rgb(red,green,blue:integer):longint;
{$H Construit un code couleur à partir des trois composantes Rouge, Verte et Bleue.

 Les paramètres red, green et blue ont des valeurs comprises entre 0 et 255.

 Par exemple rgb(0,0,0) correspond au noir et rgb(255,255,255) correspond au blanc.

}

function AllocatedMemory: int64;
{$H Renvoie la taille en octets de la mémoire utilisée par le programme.}


function WinExec(stCmd:String;cmd:integer):integer;

function GetStringOption(st:String;n:integer):String;
{$H Renvoie la nième option de la chaîne st.

 St doit contenir plusieurs sous-chaînes (options) séparées par des barres verticales.
 Les options sont numérotées à partir de 1.

 Exemple: GetStringOption('Un|Deux|Trois',2) renvoie la chaîne 'Deux' .

}

procedure Rotation(x1,y1:real;var x2,y2:real;x0,y0:real;Theta:real);
{$H Calcule le point image (x2,y2) du point (x1,y1) dans la rotation de centre (x0,y0)
et d'angle Theta.

 L'angle doit être exprimé en radians.
}


{ Module txtAc1 }

procedure OpenText(numF:integer;st:string;lect:boolean);
{$H Ouvre un fichier texte.

 numF est un numéro compris entre 1 et 20. Il permet d'identifier le fichier
pour les opérations ultérieures.
 st est le nom du fichier

 si lect vaut True, le fichier est ouvert en lecture, sinon il est ouvert en
écriture.

 Si le fichier était déjà ouvert, le fichier est d'abord fermé.
 Si l'on ouvre le fichier en lecture (lect=true), les appels successifs à readlnText@
permettront de lire le fichier.
 Si l'on ouvre le fichier en écriture (lect=false), on crée un nouveau fichier vide.
Les appels successifs à writeText@ ou writelnText@ permettront d'écrire dans le fichier.

 On ferme le fichier avec CloseText@
 EofText@ permet de vérifier que la fin du fichier est atteinte.

 Pour ajouter du texte à la fin d'un fichier existant, il faut ouvrir le fichier
avec AppendText@.
}
procedure AppendText(numF:integer;st:string);
{$H Ouvre en écriture un fichier texte existant.

 numF est un numéro compris entre 1 et 20. Il permet d'identifier le fichier
pour les opérations ultérieures.
 st est le nom du fichier.

 Les appels successifs à writeText@ ou writelnText@ permettront d'ajouter du texte
à la fin du fichier.

 Voir aussi openText@
}


procedure WriteText(numF:integer;st:string);
{$H Ecriture de la chaîne st dans le fichier texte de numéro numF.

 numF est le numéro attribué au fichier au moment de son ouverture avec openText@
ou appendText@.

 Voir aussi WritelnText@ .
}
procedure WritelnText(numF:integer;st:string);
{$H Ecriture de la chaîne st dans le fichier texte de numéro numF.

 numF est le numéro attribué au fichier au moment de son ouverture avec openText@
ou appendText@.

 La chaîne est suivie dans le fichier des caractères CR et LF marquant la fin de ligne.

 Voir aussi WriteText@ .
}
procedure ReadlnText(numF:integer;var st:string);
procedure ReadlnText(numF:integer;var st:shortstring);

{$H Lecture d'une ligne dans le fichier texte de numéro numF.

 numF est le numéro attribué au fichier au moment de son ouverture avec openText@ .

 Au retour, la chaîne st contient les caractères lus dans le fichier.
}
procedure CloseText(numF:integer);
{$H Fermeture du fichier de numéro numF.

 numF est le numéro attribué au fichier au moment de son ouverture .
}
function EofText(numF:integer):boolean;
{$H Vérifie si la fin du fichier est atteinte.

 numF est le numéro attribué au fichier au moment de son ouverture .
}

{ module BinAc1 }

procedure Reset(numF:integer;st:string);
{$H Ouverture d'un fichier binaire existant.

 numF est un numéro compris entre 1 et 20. Il permet d'identifier le fichier
pour les opérations ultérieures.
 st est le nom du fichier

}
procedure Rewrite(numF:integer;st:string);
{$H Création d'un fichier binaire.

 numF est un numéro compris entre 1 et 20. Il permet d'identifier le fichier
pour les opérations ultérieures.
 st est le nom du fichier

}
procedure Blockread(numF:integer;var x;var res:integer);
{$H Lecture d'une variable x dans un fichier binaire.

 Le fichier doit avoir été ouvert au moyen de reset@ ou rewrite@ avec le numéro
de fichier numF. C'est la taille de la variable x qui détermine le nombre d'octets
à lire sur le disque. Aucun contrôle n'est effectué sur le type des données lues.

 Au retour, la variable res contiendra le nombre d'octets effectivement lus sur
le disque. Ce nombre sera inférieur à la taille de x si la fin du fichier a été
atteinte trop tôt.

 Voir aussi Reset@, Rewrite@, BlockWrite@, Close@, Seek@
}
procedure Blockwrite(numF:integer;var x);
{$H Ecriture d'une variable x dans un fichier binaire.

 Le fichier doit avoir été ouvert au moyen de reset@ ou rewrite@ avec le numéro
de fichier numF. C'est la taille de la variable x qui d‚termine le nombre d'octets
à écrire sur le disque. Aucun contrôle n'est effectué sur le type des données écrites.

Voir aussi     Reset@, Rewrite@, BlockRead@, Close@, Seek@
}

procedure Close(numF:integer);
{$H Fermeture du fichier binaire de numéro NumF.
}
procedure Seek(numF:integer;n:longint);
{$H Positionne le pointeur de fichier d'un fichier binaire.

 NumF est le numéro de fichier attribué à l'ouverture du fichier.
 n est le numéro de l'octet du fichier qui doit être pointé.

 Voir aussi Close@, Reset@, Rewrite@, BlockRead@, BlockWrite@
}

function fileSize(numF:integer):longint;
{$H Renvoie la taille d'un fichier binaire.

 NumF est le numéro de fichier attribué à l'ouverture du fichier.
}

procedure BlockreadReal(numF:integer;var x;var res:integer);
{$H Lecture d'une variable x dans un fichier binaire.

 x doit être de type REAL ou bien doit être un tableau d'éléments de type REAL.

  Les données doivent avoir été écrites sur le disque au moyen de BlockWriteReal@.
Ces données subissent un changement de type avant d'être rangées dans x.

 Le fichier doit avoir été ouvert au moyen de reset@ ou rewrite@ avec le numéro
de fichier numF.
 C'est la taille de la variable x qui d‚termine le nombre d'éléments à lire sur
le disque. Aucun contrôle n'est effectué sur le type des données lues.

 Au retour, la variable res contiendra le nombre de valeurs réelles effectivement
lues sur le disque. Ce nombre sera inférieur au nombre d'éléments de x si la fin
du fichier a été atteinte trop tôt.

}
procedure BlockwriteReal(numF:integer;var x);
{$H Ecriture d'une variable réelle ou d'un tableau de nombres réels x dans un fichier binaire.

 Cette proc‚dure joue le même rôle que BlockWrite@ mais les nombres réels subissent un
changement de type avant d'être stockés sur le disque.

 Dans Acquis1 et les premières versions de Elphy, les nombres réels étaient toujours stockés
sur 10 octets (type REAL=Extended).
 Pour des raisons de compatibilité avec d'autres logiciels ou d'encombrement, on pouvait
souhaiter ranger ces nombres dans un fichier sous un autre format (type Single 4 octets),
c'est ce que permettait cette procédure.

 Aujourd'hui, la procédure a peu d'intérêt dans la mesure ou on peut utiliser tous les
types réels.

 Le fichier doit avoir été ouvert au moyen de reset@ ou rewrite@ avec le numéro de fichier
numF.
 C'est la taille de la variable x qui détermine le nombre d'éléments réels à écrire sur le
disque. Aucun contrôle n'est effectué sur le type des données écrites.

Voir aussi     BlockReadReal@
}


{ module stmObj }

function assigned(t:Tobject):boolean;

{ module DrcSeq1 }
procedure Randseq(seed,scotome,expansion:integer;
                  var nbdivX,nbdivY:integer;
                  var tb;
                  var nbplace:integer);

function Parity(n:longint):boolean;

{module stmexe10}

procedure transferer(var dest,source: Tvector);
/TransferTrace
{$H Copie du contenu du vecteur source dans le vecteur dest .

 La structure du vecteur dest est d'abord modifiée pour correspondre à celle du
vecteur source. Les propriétés affectées sont Istart, Iend, NumType, Dx, x0 ainsi que
Dy et y0 quand le type de nombre est entier.

 Ensuite les données de source sont copiées dans dest.

 Il est préférable d'utiliser Vcopy@ , dont les arguments ont un ordre plus "logique" .


}

procedure Transferer1(var dest,source:Tvector;x1,x2,xd:real);
/TransferTrace1
{$H Copie une partie du contenu du vecteur source dans le vecteur dest .

 La structure du vecteur dest n'est pas modifiée, contrairement à ce qui se passe avec TransferTrace@ .

 Toutefois, la propriété dest.dx devient égale à source.dx .

 Les données de source comprises entre les abscisses réelles x1 et x2 sont copiées dans dest
à partir de l'abscisse réelle xd .

}

procedure Opposer(var dest,source:Tvector);
/oppositeVector
procedure AdditionnerSeq(var dest,U1,U2:Tvector);
/addVector
procedure SoustraireSeq(var dest,U1,U2:Tvector);
/subVector
procedure AugmenterSeq(var dest,source:Tvector;x:real);
/IncrementVector
procedure RotationOrigine(var t:Tvector;x0:real);
/RotateVector
procedure RotateVector1(var source,dest:Tvector;x0:real);



procedure multiplyVector(var dest,U1,U2:Tvector);

procedure divideVector(var dest,U1,U2:Tvector);
procedure divideVector1(var dest,U1,U2:Tvector;value:real);

procedure KmultiplyVector(var dest,source:Tvector;x:real);

procedure TransfertUnites(var source,dest:Tvector);
/TransferUnits
{$H Copie les paramètres d'échelle x0@, dx@, y0@, dy@ de source dans dest }


function PremierMaximum(var source:Tvector;x1,x2,l,h:real;tout:boolean):real;
/FirstMax
{$H
  Renvoie la position du premier maximum local situé entre les abscisses x1 et x2.
  Un point d'abscisse x est considéré comme un maximum local si:
  - les points d'abscisses comprises entre x-l et x+l ont une ordonnée inférieure ou
égale à celle du point d'abscisse x.
  - sur l'intervalle [x-l,x[, il existe au moins un point d'abscisse x0 tel que
y(x)-y(x0)>h.
  - sur l'intervalle ]x,x+l], il existe au moins un point d'abscisse x0 tel que
y(x)-y(x0)>h.

  Si tt est vrai, on teste tous les points compris entre x1 et x2. Sinon, on se limite
aux points compris entre x1+l et x2-l .

 Voir aussi     FirstMax1@, LastMax@, FirstMin@, LastMin@, ModifySearchMode@

 Exemple: le programme suivant relève les positions des 3 premiers maxima locaux et
les range dans x1, x2 et x3 :

 @f6                 L:=20;
 @f6                 H:=10;
 @f6                 x1:=FirstMax(v1,Xstart,Xend,L,H);
 @f6                 x2:=FirstMax(v1,x1,Xend,L,H);
 @f6                 x3:=FirstMax(v1,x2,Xend,L,H);

}

function PremierMinimum(var source:Tvector;x1,x2,l,h:real;tout:boolean):real;
/FirstMin
{$H
 Renvoie la position du premier minimum local situé entre les abscisses x1 et x2.

 Un point d'abscisse x est considéré comme un minimum local si:

  - les points d'abscisses comprises entre x-l et x+l ont une ordonnée supérieure
ou égale à celle du point d'abscisse x.

  - sur l'intervalle [x-l,x[, il existe au moins un point d'abscisse x0 tel que
y(x0)-y(x)>h.
  - sur l'intervalle ]x,x+l], il existe au moins un point d'abscisse x0 tel que
y(x0)-y(x)>h.

 Si tt est vrai, on teste tous les points compris entre x1 et x2. Sinon, on se
limite aux points compris entre x1+l et x2-l .

 Voir aussi     FirstMin1@, LastMin@, FirstMax@, LastMax@, ModifySearchMode@ .

}
function DernierMaximum(var source:Tvector;x1,x2,l,h:real;tout:boolean):real;
/LastMax
{$H
 Renvoie la position du dernier maximum local situé entre les abscisses x1 et x2.

 Un point d'abscisse x est considéré comme un maximum local si:

 - les points d'abscisses comprises entre x-l et x+l ont une ordonnée inférieure ou
égale à celle du point d'abscisse x.

 - sur l'intervalle [x-l,x[, il existe au moins un point d'abscisse x0 tel que
y(x)-y(x0)>h.

 - sur l'intervalle ]x,x+l], il existe au moins un point d'abscisse x0 tel que
y(x)-y(x0)>h.

 Si tt est vrai, on teste tous les points compris entre x1 et x2. Sinon, on se
limite aux points compris entre x1+l et x2-l.

 Voir aussi     LastMax@ ,FirstMin@, LastMin@, ModifySearchMode@

}
function DernierMinimum(var source:Tvector;x1,x2,l,h:real;tout:boolean):real;
/LastMin
{$H Renvoie la position du dernier minimum local situé entre les abscisses x1 et x2.

 Un point d'abscisse x est considéré comme un minimum local si:

 - les points d'abscisses comprises entre x-l et x+l ont une ordonnée supérieure
ou égale à celle du point d'abscisse x.

 - sur l'intervalle [x-l,x[, il existe au moins un point d'abscisse x0 tel que
y(x0)-y(x)>h.

 - sur l'intervalle ]x,x+l], il existe au moins un point d'abscisse x0 tel que
y(x0)-y(x)>h.

 Si tt est vrai, on teste tous les points compris entre x1 et x2. Sinon, on se
limite aux points compris entre x1+l et x2-l.

 Voir aussi  LastMin@, FirstMax@, LastMax@, ModifySearchMode@

}

function premiereMarche(var source:Tvector;x1,x2,l,h:real;positive:boolean):real;
/FirstStep
{$H
  Renvoie la position x de la première marche située entre les  abscisses x1 et x2.

  Le point d'abscisse x est tel y(x+l)-y(x)>=h si le paramètre Positive est vrai.
  Il est tel que (y(x)-y(x+l)>=h dans le cas contraire.
}

function DerniereMarche(var source:Tvector;x1,x2,l,h:real;positive:boolean):real;
/LastStep
{$H Renvoie la position x de la dernière marche située entre les abscisses x1 et x2.

 Le point d'abscisse x est tel y(x+l)-y(x)>=h si le paramètre Positive est vrai.
 Il est tel que (y(x)-y(x+l)>=h dans le cas contraire.

 Voir aussi  FirstStep@, FirstMin@, FirstMax@, LastMax@, LastMin@
}
function PremierMaximum1(var source:Tvector;x1,x2,l,h:real;var xp1,xp2:real):real;
/FirstMax1
{$H Renvoie la position du premier maximum local situé entre les abscisses x1 et x2.

 Un point (x,y) est considéré comme un maximum local si:

 - il existe un point (x1p,y1p) tel que:
 (i)  x-l<x1p<x
 (ii) y1p<y-h
 (iii) pour tout point (xi,yi) tel que x1p<xi<x, on a yi<y

 - il existe un point (x2p,y2p) tel que:
 (i) x<x2p<x+l
 (ii) y2p<y-h
 (iii) pour tout point (xi,yi) tel que x<xi<x2p, on a yi<y

 La fonction renvoie aussi les abscisses x1p et x2p.

 Voir aussi     FirstMax@

}
function DernierMaximum1(var source:Tvector;x1,x2,ll,hh:real;var xp1,xp2:real):real;
/LastMax1
{$H
 Renvoie la position du dernier maximum local situé entre les abscisses x1 et x2.

 Un point (x,y) est considéré comme un maximum local si:

 - il existe un point (x1p,y1p) que:
   (i) x-l<x1p<x
   (ii) y1p<y-h
   (iii) pour tout point (xi,yi) tel que x1p<xi<x, on a yi<y

 - il existe un point (x2p,y2p) que:
   (i) x<x2p<x+l
   (ii) y2p<y-h
   (iii) pour tout point (xi,yi) tel que x<xi<x2p, on a yi<y

 La fonction renvoie aussi les abscisses x1p et x2p.

 Voir aussi     LastMax@
}

function PremierMinimum1(var source:Tvector;x1,x2,ll,hh:real;var xp1,xp2:real):real;
/FirstMin1
{$H Renvoie la position du premier minimum local situé entre les abscisses x1 et x2.

 Un point (x,y) est considéré comme un minimum local si:

 - il existe un point (x1p,y1p) que:
  (i) x-l<x1p<x
  (ii) y1p>y+h
  (iii) pour tout point (xi,yi) tel que x1p<xi<x, on a yi>y

 - il existe un point (x2p,y2p) que:
  (i) x<x2p<x+l
  (ii) y2p>y+h
  (iii) pour tout point (xi,yi) tel que x<xi<x2p, on a yi>y

 La fonction renvoie aussi les abscisses x1p et x2p.

 Voir aussi     FirstMin@
}
function DernierMinimum1(var source:Tvector;x1,x2,ll,hh:real;var xp1,xp2:real):real;
/LastMin1
{$H Renvoie la position du dernier minimum local situé entre les abscisses x1 et x2.

 Un point (x,y) est considéré comme un minimum local si:

 - il existe un point (x1p,y1p) que:
  (i) x-l<x1p<x
  (ii) y1p>y+h
  (iii) pour tout point (xi,yi) tel que x1p<xi<x, on a yi>y

 - il existe un point (x2p,y2p) que:
  (i) x<x2p<x+l
  (ii) y2p>y+h
  (iii) pour tout point (xi,yi) tel que x<xi<x2p, on a yi>y

  La fonction renvoie aussi les abscisses x1p et x2p.

  Voir aussi  LastMin@

}
Function NextExtrema(var source:Tvector;x2,ll,hh:real;var xp1,xp2:real;var up:boolean):real;
{$H Dans Acquis1, cette fonction était une amélioration des fonctions FirstMax1 et FirstMin1.

 Dans Elphy, il est préférable d'utiliser un objet Tdetect@ pour obtenir les mêmes
résultats.

 Voici l'exemple tiré de la documentation de Acquis1:

 @f6   x:=FirstMax1(v1,Xstart,Xend,ll,hh,xp1,xp2);
 @f6   repeat
 @f6     x:=NextExtrema(v1,Xend,ll,hh,xp1,xp2,up);
 @f6     if x<Xend then
 @f6       begin
 @f6         (* Analyse de l'extrema *)
 @f6        end;
 @f6    until (x>=Xend);

}

function PremierDepassement(var source:Tvector;x1,x2,y0:real;UP:boolean):real;
/FirstCrossing
{$H Renvoie la position x du premier dépassement du seuil y0 situé entre les abscisses
x1 et x2.

 Le point d'abscisse x correspond à un franchissement du seuil du bas vers le haut si UP
vaut TRUE, et correspond à un franchissement du seuil du haut vers le bas si UP vaut FALSE.

 Si le seuil n'est jamais franchi, la fonction renvoie la valeur x2

 Voir aussi     LastCrossing@, FirstStep@, FirstMin@,
                LastStep@, LastMax@, LastMin@
}

function DernierDepassement(var source:Tvector;x1,x2,y0:real;positif:boolean):real;
/LastCrossing
{$H Renvoie la position x du dernier dépassement du seuil y0 situé entre les abscisses
x1 et x2.

 Le point d'abscisse x correspond à un franchissement du seuil du bas vers le haut si UP
vaut TRUE, et correspond à un franchissement du seuil du haut vers le bas si UP vaut FALSE.

 Si le seuil n'est jamais franchi, la fonction renvoie la valeur x1

 Voir aussi     FirstCrossing@, FirstStep@, FirstMin@,
                LastStep@, LastMax@, LastMin@
}


procedure SetModeRecherche(etendu:boolean);
/ModifySearchMode
{$H Modifie la condition de recherche des fonctions @FirstMax, @FirstMin, @LastMax
et @LastMin.

 Si Etendu est faux (valeur par défaut), les minima et maxima sont recherchés comme il est
indiqué dans les descriptions des fonctions.

 Si Etendu est vrai, le paramètre l sera considéré comme une valeur minimale l0 et les
définitions deviennent:

  - il existe un nombre l>l0 tel que...etc...

}


function MAXI(var source:Tvector;x1,x2:real):real;
{$H Calcul de l'ordonnée maximale du vecteur source entre les deux abscisses réelles
x1 et x2.

 Voir aussi Mini@, MaxiX@, MiniX@, MaxiR@, MiniR@

 @f6 Exemple        t[1,EpNum]:=maxi(v1,100,200);

}
function MINI(var source:Tvector;x1,x2:real):real;
{$H Calcul de l'ordonnée minimale du vecteur source entre les deux abscisses réelles
x1 et x2.

 Voir aussi Maxi@, MaxiX@, MiniX@, MaxiR@, MiniR@

 @f6 Exemple        t[1,EpNum]:=mini(v1,100,200);

}
function MAXIX(var source:Tvector;x1,x2:real):real;
{$H Calcul de la position du maximum du vecteur source entre les deux abscisses réelles
x1 et x2.

 Voir aussi Maxi@, Mini@, MiniX@, MaxiR@, MiniR@
}
function MINIX(var source:Tvector;x1,x2:real):real;
{$H Calcul de la position du minimum du vecteur source entre les deux abscisses réelles
x1 et x2.

 Voir aussi Maxi@, Mini@, MaxiX@, MaxiR@, MiniR@
}
function MAXIR(var source:Tvector;x1,x2,x1r,x2r:real):real;
{$H  Calcul du maximum relatif du vecteur source entre les deux abscisses réelles x1 et x2.
 La fonction recherche le maximum de la source entre x1 et x2, puis calcule l'ordonnée
moyenne entre les abscisses x1r et x2r.
 La valeur renvoyée est la différence entre le maximum trouvé et l'ordonnée moyenne.

 Voir aussi     Maxi@, Mini@, MaxiX@, MiniX@, MiniR@

 @f6 Exemple        t1:=maxiR(v1,100,200,10,20);
 @f6 (* Cette ligne est équivalente à t1:=maxi(v1,100,200)-Mean(v1,10,20); *)
}

function MINIR(var source:Tvector;x1,x2,x1r,x2r:real):real;
{$H  Calcul du minimum relatif du vecteur source entre les deux abscisses réelles x1 et x2.
 La fonction recherche le minimum de la source entre x1 et x2, puis calcule l'ordonnée
moyenne entre les abscisses x1r et x2r.
 La valeur renvoyée est la différence entre le minimum trouvé et l'ordonnée moyenne.

 Voir aussi     Maxi@, Mini@, MaxiX@, MaxiX@, MaxiR@

 @f6 Exemple        t1:=miniR(v1,100,200,10,20);
 @f6 (* Cette ligne est équivalente à t1:=mini(v1,100,200)-Mean(v1,10,20); *)
}

function MOYENNE(var source:Tvector;x1,x2:real):real;
/Mean
{$H Renvoie la moyenne du vecteur source entre les abscisses x1 et x2.

 Voir aussi StdDev@ .
}
function ECARTTYPE(var source:Tvector;x1,x2:real):real;
/StdDev
{$H Calcul de l'écart-type (standard deviation) pour tous les points du vecteur
source compris entre les abscisses x1 et x2.

 Le résultat est donné par la formule:
 y= sqrt( sum( sqr(y[i]-ym))/(N-1) )

 sqrt signifie racine carrée
 sum signifie somme sur tous les échantillons compris entre x1 et x2
 sqr signifie carré
 y[i] désigne le ième échantillon et ym la moyenne sur tous les échantillons
 N est le nombre d'échantillons compris entre x1 et x2

 Remarque: dans Acquis1, Ecart-type était traduit par Standard Error ce qui
était une erreur
}
function PA1(var source:Tvector;x1,x2,x1r,x2r,N1:real):real;
/PulseWidth1

{$H  Mesure d'une largeur d'impulsion.

 x1 et x2 déterminent la zone d'analyse. On calcule d'abord un niveau de référence Yref
en moyennant les points situés entre x1r et x2r puis on recherche le maximum Ymax entre
x1 et x2.
 On mesure ensuite la largeur de l'impulsion pour une ordonnée égale à
 Yref+N1*(Ymax-Yref)/100.

 Voir aussi     PulseWidth2@

 @f6 Exemple:       t1[EpNum]:=PulseWidth1(V1,100,1000,10,20,20);
 @f6                (* Calcul de largeur à  20% de l'amplitude *)
}
function PA2(var source:Tvector;y1,x1,x2:real):real;
/PulseWidth2
{$H Mesure d'une largeur d'impulsion sur le vecteur source.

 x1 et x2 déterminent la zone d'analyse. La largeur de l'impulsion est mesurée pour
une ordonnée égale à y1.

 Voir aussi     PulseWidth1@

 @f6 Exemple:       t1[EpNum]:=PulseWidth2(V1,500,100,1000);
}
function TM1(var source:Tvector;x1,x2:real;Up:boolean;var x1r,x2r:real):real;
/RiseTime1
{$H Calcul d'un temps de montée (ou de descente ) sur le vecteur source.

 x1 et x2 déterminent la zone d'analyse. Up doit valoir TRUE si la courbe est ascendante
et FALSE dans le cas contraire.
 La fonction cherche d'abord le maximum et le minimum dans la zone d'analyse puis cherche
les points correspondant au maximum diminué de la différence d'amplitude multipliée par
0.1, et au minimum augmenté de la différence d'amplitude multipliée par 0.1.
 Les abscisses de ces deux points sont renvoyées dans x1r et x2r. La fonction renvoie la
différence entre ces deux abscisses.

 Voir aussi     RiseTime2@

}
function TM2(var source:Tvector;x10,x20,x1,x2,Np:real;Up:boolean;var x1r,x2r:real):real;
/RiseTime2
{$H Calcul d'un temps de montée (ou de descente ) sur le vecteur source.

 x1 et x2 déterminent la zone d'analyse.
 UP doit valoir TRUE si la courbe est ascendante et FALSE dans le cas contraire.
 La fonction cherche d'abord le maximum Ymax ou le minimum Ymin dans la zone d'analyse,
suivant la valeur de la variable UP, puis calcule la moyenne Y0 des ordonnées des points
situés entre les abscisses x1ref et x2ref. Cette moyenne Y0 représente donc le niveau de
base avant le signal.
 On cherche ensuite les points correspondant au maximum diminué de la différence
(Ymax-Y0) multipliée par Np, et au niveau Y0 augmenté de la différence (Ymax-Y0) multipliée
par Np.
 Les abscisses de ces deux points sont renvoyées dans x1r et x2r. La fonction renvoie la
différence entre ces deux abscisses.
}

function Shape1(var s:Tvector;p1:longint;var pu:Tvector;nb:longint):real;
{$H Fonction spéciale David Desmaison}

{ module stmExe11 }
procedure Lissage(var source,dest:Tvector;N:integer;x1,x2:real);
procedure Lissage(var source,dest:Tvector;N:integer);
/Smooth
{$H Effectue un lissage du vecteur source entre les abscisses x1 et x2.

 Le résultat est rangé dans le vecteur dest.

 L'opération de lissage consiste à calculer pour chaque indice i une moyenne
sur N points de la source pris entre les abscisses i-N div 2 et i-N div 2+N-1.
 En choisissant une valeur de N impaire,le point résultant est placé exactement
au milieu du segment moyenné.

 Pour les points du début (resp. de la fin) du vecteur, comme il n'y a pas
suffisamment de points pour faire une moyenne, on range simplement la moyenne des
N premiers (resp. des N derniers) points du vecteur.
}

procedure Integrer(var source,dest:Tvector;Cte:integer;x1,x2:real);
procedure Integrer(var source,dest:Tvector;Cte:integer);
/Integrate
{$H L'opération d'intégration consiste à redresser le signal source puis à
effectuer un lissage sur le signal obtenu.

 Le signal source doit être centré autour de zéro (sinon voir integrate1@). Le
redressement consiste à rendre positives les parties négatives. On effectue
ensuite un moyenne glissante sur Cte points. Le résultat est rangé dans dest.

 Le calcul est effectué entre les bornes x1 et x2.

}
procedure Integrer1(var source,dest:Tvector;CtI,CtM:integer;x1,x2:real);
procedure Integrer1(var source,dest:Tvector;CtI,CtM:integer);
/Integrate1

{$H Integrate1 est une amélioration de la procédure integrate@.

 La procédure Integrate ne fonctionne pas si le signal ne fluctue pas autour de zéro.
 D'où l'idée de ramener le signal autour de zéro de façon automatique.

 On effectue une moyenne glissante sur CtM points et cette moyenne est d'abord
retranchée au vecteur source.

 Ensuite, on effectue l'opération d'intégration avec un paramètre Cti qui doit
être petit devant CtM.

}
procedure LissageGauss(var source,dest:Tvector;sig,x1,x2:real);
procedure LissageGauss(var source,dest:Tvector;sig:real);

/GaussSmooth

{$H Effectue un lissage gaussien du vecteur source entre les abscisses x1 et x2
et range le résultat dans dest.

 L'opération consiste à calculer pour chaque point d'abscisse x une moyenne pondérée

exp(-0.5*sqr((x-x0)/sig))

}

procedure EnveloppeS(var source,dest:Tvector;Length,x1,x2:real);
procedure EnveloppeS(var source,dest:Tvector;Length:real);

/UpperEnvelope
{$H  Calcul d'un vecteur représentant l'enveloppe supérieure du vecteur source
entre les abscisses x1 et x2.

  On peut comprendre le mécanisme de calcul de la façon suivante:
  Imaginons un segment rigide dont la longueur est Length. On place une extrémité
de ce segment sur la courbe source à l'abscisse x1 puis on plaque le segment contre
la courbe tout en restant au dessus de la courbe. On obtient un point de contact
d'abscisse xc. Le segment de droite compris entre x1 et xc représente la première
partie de l'enveloppe. On répète l'opération en prenant xc pour origine et on
continue jusqu'à ce que l'abscisse x2 soit atteinte.
  L'enveloppe est donc formée d'une succession de segments. Plus la longueur d'analyse
Length est faible, plus l'enveloppe épouse les contours de la courbe initiale.

}

procedure EnveloppeI(var source,dest:Tvector;Length,x1,x2:real);
procedure EnveloppeI(var source,dest:Tvector;Length:real);
/LowerEnvelope
{$H  Calcul d'un vecteur représentant l'enveloppe inférieure du vecteur source
entre les abscisses x1 et x2.

  On peut comprendre le mécanisme de calcul de la façon suivante:
  Imaginons un segment rigide dont la longueur est Length. On place une extrémité
de ce segment sur la courbe source à l'abscisse x1 puis on plaque le segment contre
la courbe tout en restant en dessous de la courbe. On obtient un point de contact
d'abscisse xc. Le segment de droite compris entre x1 et xc représente la première
partie de l'enveloppe. On répète l'opération en prenant xc pour origine et on
continue jusqu'à ce que l'abscisse x2 soit atteinte.
  L'enveloppe est donc formée d'une succession de segments. Plus la longueur d'analyse
Length est faible, plus l'enveloppe épouse les contours de la courbe initiale.
}

procedure SupSpike(var source,dest:Tvector;Threshold,Lmax,x1,x2:real);
procedure SupSpike(var source,dest:Tvector;Threshold,Lmax:real);
/RemoveSpike
{$H  Supprime certaines impulsions indésirables du vecteur Source.

 Le résultat est rangé dans Dest.

 Une impulsion est éliminée si son abscisse est située entre x1 et x2, et elle
est caractérisée de la façon suivante:

    - elle commence lorsque la différence entre les ordonnées de deux points
consécutifs de la source dépasse le seuil Threshold.

    - elle est prise en compte seulement si on détecte un nouveau dépassement du
seuil différentiel avec un signe contraire sur la longueur Lmax.

    Autrement dit, on n'élimine que des impulsions de largeur inférieure à Lmax.
    L'impulsion est remplacée par un segment de droite commençant au point de
détection et finissant soit au point de la courbe d'abscisse Lmax, soit au point
de la courbe situé après l'impulsion.
}

procedure CorrectSpike(var source,Dest:Tvector;threshold,Linhib:real);
{$H Suppression des spikes du vecteur source en les remplaçant par des fonctions Alpha.

  Les spikes sont d'abord détectés en utilisant le seuil absolu Threshold ( de bas en haut)
et la longueur d'inhibition Linhib.
  Le résultat est rangé dans le vecteur Dest.
  Dest peut être égal à Source.

  Si l'on veut utiliser une autre méthode de détection, on peut utiliser CorrectSpike2@
}

procedure CorrectSpike2(var source:Tvector;Xdet:real);
{$H Suppression d'un spike du vecteur source en le remplaçant par une fonction Alpha.

 Xdet est la position du spike.

 Voir aussi CorrectSpike@
}



procedure Pente(var source:Tvector;x1,x2:real;var a,b,R:real);
/Slope
{$H  Calcul de la droite s'ajustant au mieux sur points du vecteur source compris
entre x1 et x1.

 Une régression linéaire est effectuée sur les données de la source comprises entre
les abscisses x1 et x2.
 Les valeurs renvoyées sont
  - la pente a
  - l'ordonnée à l'origine b
  - le coefficient de régression linéaire R

 Voir aussi  MaxSlope@, MinSlope@

}
procedure PenteMax(var source:Tvector;Nb:integer;x1,x2:real;var a,b,R:real);
/MaxSlope
{$H Calcul de la droite de pente maximale s'ajustant au mieux sur un vecteur dans
dans une région donnée.

 Une régression linéaire est effectuée sur tous les groupes de Nb points consécutifs de la
source compris entre les abscisses x1 et x2. La régression retenue est celle qui donne la
pente maximale.
 Les valeurs renvoyées sont
  - la pente a
  - l'ordonnée à l'origine b
  - le coefficient de régression linéaire R

 Cette procédure remplace avantageusement la procédure Slope@ lorsque la source présente un
point d'inflexion et que ce point d'inflexion n'a pas un position constante d'une séquence
à l'autre.

 La date du point d'inflexion est donnée par la fonction SlopeDate@.
 Nb doit évidemment être inférieur au nombre de points situés entre x1 et x2. On peut le
calculer à partir d'une durée comme dans l'exemple qui suit.

 Exemple:
 @f6    delta:=10;
 @f6    MaxSlope(v1,round(delta/v1.dx),0,100,a,b,R);


 Voir aussi     Slope@, MinSlope@, SlopeDate@
}

procedure PenteMin(var source:Tvector;Nb:integer;x1,x2:real;var a,b,R:real);
/MinSlope
{$H Calcul de la droite de pente minimale s'ajustant au mieux sur un vecteur dans
dans une région donnée.

 Une régression linéaire est effectuée sur tous les groupes de Nb points consécutifs de la
source compris entre les abscisses x1 et x2. La régression retenue est celle qui donne la
pente minimale.
 Les valeurs renvoyées sont
  - la pente a
  - l'ordonnée à l'origine b
  - le coefficient de régression linéaire R

 Cette procédure remplace avantageusement la procédure Slope@ lorsque la source présente un
point d'inflexion et que ce point d'inflexion n'a pas un position constante d'une séquence
à l'autre.

 La date du point d'inflexion est donnée par la fonction SlopeDate@.
 Nb doit évidemment être inférieur au nombre de points situés entre x1 et x2. On peut le
calculer à partir d'une durée comme dans l'exemple qui suit.

 Exemple:
 @f6    delta:=10;
 @f6    MinSlope(v1,round(delta/v1.dx),0,100,a,b,R);

 Voir aussi     Slope@, MaxSlope@, SlopeDate@
}

function datePente:real;
/SlopeDate
{$H  Renvoie la position du point d'inflexion après l'utilisation
               de la procédure MaxSlope@ ou de la procédure MinSlope@.
}

function Integrale(var source:Tvector;x1,x2,x1r,x2r:real):real;
/Integral
{$H  Calcul de l'intégrale de la fonction (y(x)-B) entre les abscisses x1 et x2.

 y représente l'ordonnée du vecteur à l'abscisse x.

 Le niveau de référence B est obtenu en calculant la moyenne des ordonnées des points
compris entre x1r et x2r.

 Voir aussi  Integral1@, Energy@, Energy1@, IntAbs@
}
function Energie(var source:Tvector;x1,x2,x1r,x2r:real):real;
/Energy
{$H  Calcul de l'intégrale de la fonction sqr(y(x)-B) entre les abscisses x1 et x2.

 y représente l'ordonnée du vecteur à l'abscisse x.

 Le niveau de référence B est obtenu en calculant la moyenne des ordonnées des points
compris entre x1r et x2r.

 Voir aussi  Integral1@, Energy@, Energy1@, IntAbs@
}
function Integrale1(var source:Tvector;x1,x2,Y0:real):real;
/Integral1
{$H  Calcul de l'intégrale de la fonction (y(x)-y0) entre les abscisses x1 et x2.

 y représente l'ordonnée du vecteur à l'abscisse x.

 Voir aussi  Integral@, Energy@, Energy1@, IntAbs@
}
function Energie1(var source:Tvector;x1,x2,Y0:real):real;
/Energy1
{$H Calcul de l'intégrale de la fonction sqr(y(x)-y0) entre x1 et x2.

 y représente l'ordonnée du vecteur à l'abscisse x.

 Voir aussi Integral@, Integral1@, Energy@, Energy2@,IntAbs@
}
function Energie2(var source:Tvector;x1,x2,Y0:real;up:boolean):real;
/Energy2
{$H Calcul de l'intégrale de la fonction sqr(y(x)-y0) entre x1 et x2, en se limitant:

     - aux régions ou y(x)>y si above=true
     - aux régions ou y(x)<y si above=false

  y représente l'ordonnée de la séquence.

 Voir aussi     Integral@, Integral1@, Energy@, Energy1@, IntAbs@

}
function IntAbs(var source:Tvector;x1,x2:real):real;
{$H Calcul de l'intégrale  de la fonction abs(y(x)) entre x1 et x2.

 abs(y(x)) représente la valeur absolue de l'ordonnée du vecteur source à l'abscisse x.

 Voir aussi     Intabs1@, Integral@, Integral1@, Energy@, Energy1@
}
function IntAbs1(var source:Tvector;x1,x2,y0:real):real;
{$H  Calcul de l'intégrale de abs(y[x]-y0) entre x1 et x2.

 abs(y(x)-y0) représente la valeur absolue de l'ordonnée du vecteur source à l'abscisse x,
relativement au niveau de base y0.

 Voir aussi     IntAbs@, Integral@, Integral1@, Energy@, Energy1@


}
function IntAbove(var source:Tvector;x1c,x2c,y0:real;var len:real):real;
{$H Calcul de l'intégrale de yvalue[x]-y0 entre x1 et x2 en ne considérant que les
points du vecteur situés au dessus du seuil y0.

 Au retour, len contient la longueur d'intégration effective. Cette longueur est égale
au nombre points situés au dessus du seuil multiplié par Dx@(Tvector.dx).

}
function IntBelow(var source:Tvector;x1c,x2c,y0:real;var len:real):real;
{$H Calcul de l'intégrale de y0-yvalue[x] entre x1 et x2 en ne considérant que les
points du vecteur situés en dessous du seuil y0.

 Au retour, len contient la longueur d'intégration effective. Cette longueur est égale
au nombre points situés en dessous du seuil multiplié par Dx@(Tvector.dx).

}

procedure Derivee(var source,dest:Tvector;N:integer;fmul:real);
/derivative
{$H Calcule la dérivée de source et la range dans le vecteur dest.

 Utiliser de préférence DerivativeEx@
}

procedure DeriveeEx(var source,dest:Tvector;N:integer;x1,x2:real);
/derivativeEx
{$H Calcule la dérivée du vecteur source et la range dans le vecteur dest.

 Le type de nombre de Dest doit être un type réel sinon les résultats seront
imprévisibles.

 La dérivée au point d'indice i est calculée en effectuant une régression linéaire
sur les points compris entre les indices i-N et i+N.

 Le calcul est effectué pour les points compris entre les abscisses réelles x1 et x2.
}

procedure Derivative1(var source,destD,destReg:Tvector;N:integer;x1,x2:real);
{$H Calcule la dérivée du vecteur source et la range dans le vecteur destD. On
calcule également le coefficient de corrélation R et on le range dans destReg.

 Le type de nombre de Dest doit être un type réel sinon les résultats seront
imprévisibles.

 La dérivée au point d'indice i est calculée en effectuant une régression linéaire
sur les points compris entre les indices i-N et i+N.

 Le calcul est effectué pour les points compris entre les abscisses réelles x1 et x2.
}

procedure Distri(var source,dest:Tvector;x1,x2:real);
{$H Calcule un histogramme donnant la distribution des valeurs contenues dans le
vecteur source.

 Les valeurs utiles sont prises entre x1 et x2 .

 Le vecteur destination Dest doit auparavant être convenablement paramètré, en fixant
notamment:

 - ses indices de début et de fin
 - son type qui doit être de préférence t_smallint ou t_longint
 - sa propriété Dx@ qui représente la largeur de classe de l'histogramme.

 Voir aussi Distri1@ .
}

procedure Distri1(var source,dest:Tvector;x1,x2:real);
{$H Calcule un histogramme donnant la distribution des valeurs contenues dans le
vecteur source.

  La procédure fonctionne comme Distri@ mais:
  - si une valeur de source est inférieure à dest.Xstart, on incrémente la première classe de dest.
  - si une valeur de source est supérieure à dest.Xend, on incrémente la dernière classe de dest.

  De cette façon, la somme des éléments du vecteur dest est toujours égale au nombre de
valeurs contenues dans source.
}


procedure EventFreq(var source,dest:Tvector;x1,x2,dt:real);
{$H Calcule l'évolution de la fréquence instantanée dans un vecteur d'événements.

 Source est un vecteur qui contient des dates d'événements.
 Dest est le vecteur destination. Ses paramètres NumType et dx doivent être fixés
auparavant.
 x1 et x2 sont les dates entre lesquelles la fréquence doit être calculée.
 dt est la durée sur laquelle chaque fréquence est calculée. On suppose que tous
les temps sont exprimés en secondes.

 En sortie, on obtient un vecteur Dest dont chaque point représente une fréquence
instantanée. L'ordonnée en un point d'abscisse x est obtenue en comptant le nombre
d'événements compris entre x-dt/2 et x+dt/2 et en divisant ce nombre par dt.

 Voir aussi EventFreq1@.
}

procedure EventFreq1(var source,dest:Tvector;dt:real);
{$H Calcule l'évolution de la fréquence instantanée dans un vecteur d'événements.

 Source est un vecteur qui contient des dates d'événements.
 Dest est le vecteur destination. Tous ses paramètres (Istart, Iend, NumType, Dx, x0 )  doivent être fixés
auparavant, ils ne seront pas modifiés par la procédure.
 dt est la durée sur laquelle chaque fréquence est calculée. On suppose que tous
les temps sont exprimés en secondes.

 En sortie, on obtient un vecteur Dest dont chaque point représente une fréquence
instantanée. L'ordonnée en un point d'abscisse x est obtenue en comptant le nombre
d'événements compris entre x et x+dt et en divisant ce nombre par dt.

 Voir aussi EventFreq@.
}


procedure BootStrap(var vx,vy,vn:Tvector;var va,vb:Tvector;nbIt:longint);
{$H Implémente une procédure de BootStrap.

 Les vecteurs Vx et Vy doivent contenir en entrée des couples de valeurs (x,y).
Vx et Vy doivent donc avoir les mêmes indices Istart et Iend.

 Le vecteur Vn doit contenir en entrée des nombres d'éléments par groupe. S'il n'y a
pas de groupes, le premier élément de Vn doit être simplement égal au nombre de données
(nombre d'éléments de Vx ou Vy) et les autres éléments de Vn doivent être nuls.
 Si les données forment des groupes, le premier élément n1 de Vn indique que les
n1 premières données forment le premier groupe, le second élément n2 de Vn indique que
les n2 données suivantes forment le second groupe, etc...

 nbIt est le nombre d'itérations.

 Le principe de calcul est le suivant:

 Soit N le nombre de données, Ng le nombre de groupes (nombre d'éléments non nuls de Vn)
et soient n1, n2, n3... les nombres de données par groupe.
 A chaque itération, on tire au hasard:
   - un couple (x,y) dans le premier groupe
   - un couple (x,y) dans le second groupe
   ...
   - puis N-Ng couples (x,y) parmi les N données

 Ensuite, on effectue une régression linéaire sur les N couples (x,y) obtenus et on
range les résultats a et b (respectivement pente et ordonnée à l'origine) dans les
vecteurs Va et Vb.

 En sortie, Va et Vb sont indicés de 1 à nbIt.

}

{ module stmExeAc }

function GetUnitX(var source:Tvector):String;
{$H renvoie la chaîne définissant les unités suivant X pour le vecteur source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la méthode unitX@(TdataPlot_unitX) de Tvector@ .
}
function GetUnitY(var source:Tvector):String;
{$H renvoie la chaîne définissant les unités suivant Y pour le vecteur source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la méthode unitY@(TdataPlot_unitY) de Tvector@ .
}
function XdebutMem(var t:Tvector):real;
/XstartMem
{$H renvoie l'abscisse de début du vecteur source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la méthode Xstart@(TdataObject_Xstart) de Tvector@ .
}

function XfinMem(var t:Tvector):real;
/XendMem
{$H renvoie l'abscisse de fin du vecteur source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la méthode Xend@(TdataObject_Xend) de Tvector@ .
}
function getV(var source:Tvector;x:real):real;
{$H renvoie l'ordonnée réelle correspondant à l'abscisse x dans le vecteur source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la propriété Rvalue@(Tvector_Rvalue) de Tvector@ .
}
function GetVI(var source:Tvector;i:longint):integer;
{$H renvoie l'ordonnée fichier correspondant à l'indice i dans le vecteur source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la propriété Jvalue@(Tvector_Jvalue) de Tvector@ .
}

procedure SetV(var source:Tvector;x,y:real);
{$H Range la valeur réelle y à l'abscisse x dans le vecteur source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la propriété Rvalue@(Tvector_Rvalue) de Tvector@ .
}
procedure SetVI(var source:Tvector;i:longint;j:integer);
{$H Range la valeur fichier j à l'indice i dans le vecteur source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la propriété Jvalue@(Tvector_Jvalue) de Tvector@ .
}

function ConvX(var source:TdataObject;i:longint):real;
{$H Convertit un indice i en abscisse réelle pour l'objet source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la méthode convx@TdataObject_convx de TdataObject@ .
}
function ConvY(var source:TdataObject;j:integer):real;
{$H Convertit une ordonnée fichier j en ordonnée réelle pour l'objet source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la méthode convy@TdataObject_convy de TdataObject@ .
}
function InvConvX(var source:TdataObject;x:real):longint;
{$H Convertit une abscisse réelle en indice fichier pour l'objet source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la méthode invconvx@TdataObject_invconvx de TdataObject@ .
}
function InvConvY(var source:TdataObject;y:real):longint;
{$H Convertit une ordonnée réelle y en ordonnée fichier pour l'objet source.

 Cette fonction existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la méthode invconvy@TdataObject_invconvY de TdataObject@ .
}

procedure SetScaleX(var source:TdataObject;Dx,x0:real;ux:string);
/ScalingFactorX
{$H Fixe les paramètres d'échelle suivant X pour l'objet source.

 Cette procédure existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence les propriétés Dx@TdataObject_Dx , X0@TdataObject_X0 et
unitX@TdataObject_unitX  de TdataObject@ .
}
procedure SetScaleY(var source:TdataObject;Dy,y0:real;uy:string);
/ScalingFactorY
{$H Fixe les paramètres d'échelle suivant Y pour l'objet source.

 Cette procédure existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence les propriétés Dy@TdataObject_Dy , Y0@TdataObject_Y0 et
unitY@TdataObject_unitY  de TdataObject@ .
}
procedure SetWorldT(var source:TdataPlot;x1,y1,x2,y2:real);
{$H Fixe les coordonnées d'affichage pour l'objet source.

 Cette procédure existe seulement pour assurer la compatibilité avec Acquis1.

 Il faut utiliser de préférence la méthode setWorld@TdataPlot_setWorld ou les propriétés
Xmin@TdataObject_Xmin ,Xmax@TdataObject_Xmax ,Ymin@TdataObject_Ymin ,Ymax@TdataObject_Ymax
de TdataPlot@ .
}
procedure SetStyleT(var t:TdataPlot;mode,taille:integer;logX,logY,grille:boolean;color:integer);

procedure GetWorldT(var t:TdataPlot;var x1,y1,x2,y2:real);

function GetColorT(var t:TdataPlot):longint;



{ module stmExeFi }

function premierFichier(st:string):string;
function premierFichier(st:string;exploreDir:boolean;var time:TdateTime;var size:longword;var att:integer):string;
/FirstFile
{$C Files Initialise une liste de fichiers }
{$H Associée à NextFile@ , cette fonction permet d'obtenir la liste de tous les
fichiers correspondant au nom générique st.

 Par exemple, en appelant FirstFile('c:\*.dat'), la fonction renvoie le nom du premier
fichier d'extension .dat dans le répertoire c:\ . Ensuite les appels successifs à nextFile@
renverront les noms des autres fichiers. Quand la liste est épuisée, NextFile renvoie
une chaîne vide.

 Si ExploreDir est FALSE (valeur par défaut), les sous répertoires sont ignorés. Sinon, ils sont explorés,
mais à condition que leur nom corresponde au nom générique fourni. Si on veut une exploration systématique
de tous les répertoires, il faut que le nom générique se termine par *.*

 Time est la date de création du fichier sous la forme d'une structure TdateTime@

 Time peut être décodé avec DecodeDateTime@.

 Size est la taille du fichier

 Att contient les attributs du fichier. C'est un entier dont chaque bit représente un attribut:

 @f6         Bit0 = ReadOnly
 @f6         Bit1 = Hidden
 @f6         Bit2 = SysFile
 @f6         Bit3 = VolumeID
 @f6         Bit4 = Directory
 @f6         Bit5 = Archive

}

function FichierSuivant:string;
function FichierSuivant(var time:TdateTime;var size:longword;var att:integer):string;
/NextFile
{$C Files Renvoie le nom suivant dans une liste de fichiers }
{$H Associée à FirstFile@ , cette fonction permet d'obtenir la liste de tous les
fichiers correspondant à un nom générique.

 Par exemple, en appelant FirstFile('c:\*.dat'), la fonction renvoie le nom du premier
fichier d'extension .dat dans le répertoire c:\ . Ensuite les appels successifs à nextFile
renverront les noms des autres fichiers. Quand la liste est épuisée, NextFile renvoie
une chaîne vide.

 Time est la date de création du fichier sous la forme d'une structure TdateTime@
 Time peut être décodé avec DecodeDateTime@.

 Size est la taille du fichier

 Att contient les attributs du fichier. C'est un entier dont chaque bit représente un attribut:

}
function FichierExiste(st:string):boolean;
/FileExists
{$C Files Vérifie l'existence d'un fichier }
{$H Permet de vérifier l'existence d'un fichier de nom st.

 st est un nom de fichier avec ou sans chemin d'accès.
}

function DirectoryExists(st:string):boolean;
{$C Files Vérifie l'existence d'un dossier }
{$H Permet de vérifier l'existence d'un dossier.
}

function RenameFile(OldName, NewName: string): Boolean;
{$C Files Vérifie l'existence d'un dossier }
{$H Change le nom d'un fichier.

 Renvoie true si le nom a pu être changé, false dans le cas contraire.

 Attention! Cette fonction déplace le fichier si le chemin d'accès de NewName est différent de celui de OldName.
}

function RemoveDir(Dir: string): Boolean;
{$C Files Supprime un répertoire }
{$H Supprime un répertoire vide.

 Renvoie true si le répertoire a été supprimé, false dans le cas contraire.
}

function DeleteFile(FileName: String): Boolean;
{$C Files Supprime un fichier }
{$H Supprime le fichier de nom FileName

 Si le fichier n'existe pas ou si la suppression n'est pas possible, la fonction renvoie false.

 Un fichier ne doit pas être ouvert pour que la suppression soit possible.
}

function CopyFile(src,dest:string): boolean;
{$C Files Copie un fichier }
{$H Copy le fichier de nom src dans un fichier de nom dest

 La fonction renvoie true si la copie s'est bien effectuée.

}

function ChoixFichier(var stgen:string;var stFile:string;var stHis:string):boolean;
function ChoixFichier(var stgen:string;var stFile:shortstring;var stHis:shortstring):boolean;
/ChooseFileDialog
{$C Files Ouvre un dialogue permettant la sélection d'un fichier }
{$H Permet à l'utilisateur de choisir un fichier dans une boite de dialogue standard.

 Cette fonction permet d'assurer la compatibilité avec Acquis1 mais il est préférable
d'utiliser ChooseFile@ .

 Seul le paramètre stFile est nécessaire. En entrée, il peut contenir un nom générique
du genre '*.*' ou 'c:\data\*.dat'. Dans ce cas, la boite de dialogue est remplie avec
la liste des fichiers correspondants. Il peut contenir aussi un simple nom de fichier et
dans ce cas, la boite de dialogue sera remplie avec la liste des fichiers du même répertoire
et ayant la même extension.

 La fonction renvoie true si l'utilisateur a validé son choix. Dans ce cas stFile contient
le nom du fichier choisi.
}
function SauverFichier(var stFile:string;extension:string):boolean;
function SauverFichier(var stFile:shortstring;extension:string):boolean;

/SaveFileDialog
{$C Files Ouvre un dialogue de saisie d'un nom de fichier pour la sauvegarde }
{$H Permet à l'utilisateur de donner un nom de fichier pour sauvegarde dans une boite de
dialogue standard.

 stFile peut contenir une chaîne vide , un nom générique (exemple: 'c:\*.dat') ou encore
un nom de fichier.

 Extension contient l'extension ajoutée au nom de fichier lorsque l'utilisateur a introduit
un nom sans extension. Extension peut contenir ou ne pas contenir le point séparateur.
 Exemple:   '.dat' ou 'dat' .

 La fonction renvoie true si l'utilisateur a validé son choix. Dans ce cas stFile contient
le nom du fichier choisi.
}

function ChooseFile(var stFile:string):boolean;
function ChooseFile(var stFile:shortstring):boolean;
function ChooseFile(var stFile:string;title:string):boolean;
function ChooseFile(var stFile:shortstring;title:string):boolean;
{$C Files Ouvre un dialogue permettant la sélection d'un fichier existant}

{$H Permet à l'utilisateur de choisir un fichier dans une boite de dialogue standard.

   En entrée, le paramètre stFile peut contenir un nom générique (exemple: 'c:\data\*.dat'.
Dans ce cas, la boite de dialogue est remplie avec la liste des fichiers correspondants. Il
peut contenir aussi un simple nom de fichier et dans ce cas, la boite de dialogue sera
remplie avec la liste des fichiers du même répertoire et ayant la même extension.

  Title est le titre de la boîte de dialogue.

 La fonction renvoie true si l'utilisateur a validé son choix. Dans ce cas stFile contient
le nom du fichier choisi.

 Voir aussi ChooseDirectory@
}

function ChooseDirectory(caption,root:string;var dir:string):boolean;
{$C Files Ouvre un dialogue permettant la sélection d'un dossier}
{$H Permet à l'utilisateur de choisir un répertoire dans une boite de dialogue standard.

 Caption est une légende apparaissant dans le dialogue.
 Root est la racine de la recherche. Il faut laisser cette chaine vide pour explorer tous les répertoires disponibles.
 Dir contiendra le répertoire sélectionné au retour de la fonction.

 La fonction renvoie TRUE quand l'utilisateur a cliqué sur OK.

 Voie aussi ChooseFile@
}

function extractFilePath(st:string):string;
{$C Files Renvoie le chemin d'accès à un fichier}
{$H St étant un nom de fichier complet , la fonction renvoie la partie de st qui
précède le nom du fichier.
 Le résultat inclut le backslash s'il existe.
}
function extractFileName(st:string):string;
{$C Files Renvoie le nom d'un fichier}
{$H St étant un nom de fichier complet , la fonction renvoie la partie de st qui
représente le nom du fichier.
 L'extension ne fait pas partie du résultat.
}
function extractFileExt(st:string):string;
{$C Files Renvoie l'extension d'un fichier}
{$H St étant un nom de fichier complet , la fonction renvoie la partie de st qui
représente l'extension du fichier.
 Le point séparateur fait partie du résultat.
}

function ElphyPath:string;
{$C Files Renvoie le chemin d'accès à Elphy}
{$H Renvoie le chemin d'accès à Elphy}

function StartPath:string;
{$C Files Renvoie le chemin d'accès au répertoire initial}
{$H renvoie le chemin d'accès au répertoire initial}

{ module stmAc1 }

function acquis1:Tacquis1;

property Tacquis1.c(i:integer):Tvector readOnly;

Property Tacquis1.c1:Tvector readOnly;
Property Tacquis1.c2:Tvector readOnly;
Property Tacquis1.c3:Tvector readOnly;
Property Tacquis1.c4:Tvector readOnly;
Property Tacquis1.c5:Tvector readOnly;
Property Tacquis1.c6:Tvector readOnly;
Property Tacquis1.c7:Tvector readOnly;
Property Tacquis1.c8:Tvector readOnly;
Property Tacquis1.c9:Tvector readOnly;
Property Tacquis1.c10:Tvector readOnly;
Property Tacquis1.c11:Tvector readOnly;
Property Tacquis1.c12:Tvector readOnly;

property Tacquis1.g(i:integer):Tgraph readOnly;

Property Tacquis1.g1:Tgraph readOnly;
Property Tacquis1.g2:Tgraph readOnly;
Property Tacquis1.g3:Tgraph readOnly;
Property Tacquis1.g4:Tgraph readOnly;
Property Tacquis1.g5:Tgraph readOnly;
Property Tacquis1.g6:Tgraph readOnly;
Property Tacquis1.g7:Tgraph readOnly;
Property Tacquis1.g8:Tgraph readOnly;
Property Tacquis1.g9:Tgraph readOnly;
Property Tacquis1.g10:Tgraph readOnly;
Property Tacquis1.g11:Tgraph readOnly;
Property Tacquis1.g12:Tgraph readOnly;

procedure Tacquis1.SetGraph(num:integer;var s1,s2:Tvector;Ideb,Ifin:longint);
procedure Tacquis1.SetGraph1(num:integer;var s1,s2,s3:Tvector;Ideb,Ifin:longint);



{module stmFevt}
procedure ResetEvtFile(numF:integer;st:string;numS:longint);
procedure RewriteEvtFile(numF:integer;st:string;dxF,dureeF:real;ux:string);
procedure CloseEvtFile(numF:integer);

function FgetEvt(numF,v:integer;i:longint):real;
function FgetEvtL(numF,v:integer;i:longint):longint;
procedure FgetEvtX(numF:integer;i:longint;
                   var d:longint;var x:word);

procedure FsetEvt(numF,v:integer;d:real);
procedure FsetEvtL(numF,v:integer;i:longint);
procedure FsetEvtX(numF:integer;i:longint;mask:integer);

function FconvEvt(numF:integer;i:longint):real;
function Fnbevt(numF,voie:integer):longint;
/FevtCount

                        { stmFunc1 Tfunction }

procedure Tfunction.create(stName:string;stTxt:string);
procedure Tfunction.create(stTxt:string);
{$H Constructeur de l'objet Tfunction.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
 stTxt est la chaîne de caractères définissant la fonction. Elle devient
sa propriété text@ .
}

procedure Tfunction.create1(stName:string;F:TanyProcedure);
procedure Tfunction.create1(F:TanyProcedure);

{$H Constructeur de l'objet Tfunction.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 F est une fonction réelle à paramètres réels déclarée dans le programme.
 F deviendra la propriété PgFunction@ de l'objet.

}

property Tfunction.Text:string;
{$H Définition de la fonction.

 La fonction est définie par une suite de déclarations du genre:
 A=a1*x+b1
 B=a2*sin(omega*x)
 RES=(A-B)*(A+B)

 A et B sont des résultats intermédiaires permettant une écriture plus aisée de
la fonction.
 RES désigne toujours le résultat de la fonction.
 a1, b1, a2, b2, omega sont des paramètres.
 Par défaut, x désigne l'argument mais ceci peut être changé au moyen de
la propriété argument@ .

 Pour introduire l'exemple précédent, vous pouvez écrire:
 @f6 Text:= 'A=a1*x+b1' +chr(10)+
 @f6        'B=a2*sin(omega*x)' +chr(10)+
 @f6        'RES=(A-B)*(A+B)';

 chr(10) signale un changement de ligne.
 chr(10) peut être remplacé par la constante CRLF.

 En plus des symboles habituels ( + , - , * , / ), vous pouvez utilisez le symbole ^
pour l'opération exposant. Exemple: x^3 pour x à la puissance 3.

 Les fonctions suivantes sont utilisables:

      SIN                   sinus
      COS                   cosinus
      TAN ou TG             tangente
      COTAN ou COT ou COTG  cotangente

      ATAN, ARCTAN ou ARCTG arc tangente
      ARCSIN                arc sinus
      ARCCOS                arc cosinus

      EXP                   exponentielle
      LN ou LOG             logarithme népérien

      SQR                   carré
      SQRT                  racine carrée

      SH                    sinus hyperbolique
      CH                    cosinus hyperbolique
      TH                    tangente hyperbolique

      ERF                   fonction d'erreur

      ABS:                  valeur absolue           

}

property Tfunction.argument:string;
{$H Argument de la fonction

 Sa valeur par défaut est 'x'

}
property Tfunction.PgFunction:TanyProcedure;
{$H Définit la fonction en indiquant l'adresse d'une fonction écrite dans le programme.

 Le résultat de la fonction doit être de type REAL et tous ses paramètres doivent être
de type REAL.
 Le  nombre total de paramètres doit être supérieur à 1. Le premier paramètre
sera considéré comme "l'argument" X  de la fonction. Les autres seront
considérés comme les "paramètres" de la fonction.

 Le contrôle de la validité de la fonction n'est pas actuellement effectué au moment de
la compilation mais au moment de l'exécution.


 @f6   Exemple:
 @f6
 @f6   Function myFunc(x,a,b:real):real;
 @f6   begin
 @f6     myFunc:=a*sqr(x)+b*x;
 @f6   end;

 @f6   Function.PgFunction:=myFunc;

}

property Tfunction.param(st:string):real;
{$H Paramètres de la fonction.

 On accède à la valeur numérique d'un paramètre en donnant son nom.
 Exemple: l'instruction Param['a']:=5; permet de modifier la valeur du paramètre a .
}

function Tfunction.indexof(st:string):integer;
{$H Renvoie la position d'un argument.

 Cette fonction a peu d'intérêt actuellement.
}
function Tfunction.paramCount:integer;
{$H Renvoie le nombre de paramètres de la fonction.
}
procedure Tfunction.setGraphParam(x1,x2:real;i1,i2:longint);
{$H Permet de modifier la structure du vecteur qui représente la fonction.

 A l'affichage et pour de nombreux calculs, la fonction se comportera comme un
 vecteur de propriétés:
           Xstart=x1
           Xend=x2
           Istart=i1
           Iend=i2

 Quand la fonction sera affichée, son graphe sera limité entre x1 et x2, et
 le nombre de points affiché entre ces deux limites sera i2-i1+1.

}
procedure Tfunction.matchVector(var v:Tvector);
{$H Appelle la méthode setGraphParam en utilisant les propriétés du vecteur v
de la façon suivante:
           setGraphParam(v.Xstart,v.Xend,v.Istart,v.Iend);

  Après avoir appelé matchVector, la fonction a la même structure (extension et
resolution) que le vecteur v.

 Il faut appeler cette méthode avant d'effectuer une opération du genre: addition
d'une fonction à un vecteur.
}

property Tfunction.Xorigin:real;
{$H Indique l'abscisse prise comme origine pour l'affichage de la fonction .

 Par défaut, cette valeur vaut zéro. Il peut être commode de modifier cette valeur afin
de faire subir au graphe une translation suivant l'axe des X.

 Pour les objets TcurveFitting@, il peut être important de choisir une bonne valeur
afin de résoudre quelques problèmes de convergence.
 Par exemple, si l'on fait des ajustements d'exponentielles, il est
recommandé de donner à ce paramètre une valeur égale à (ou proche de) XstartFit.
}

property Tfunction.StandardModel:integer;
{$H L'affectation de standardModel permet de sélectionner un des modèles standard.
 Les modèles disponibles sont les suivants:

                 1:  f(x)= a1*exp(a2*x)
                 2:  f(x)= a1*exp(a2*x)+a3*exp(a4*x)
                 3:  f(x)= a1*exp(a2*x)+a3*exp(a4*x)+a5*exp(a6*x)
                 4:  f(x)= a1*exp(a2*x)+a3
                 5:  f(x)= a1*exp(a2*x)+a3*exp(a4*x)+a5
                 6:  f(x)= a1*exp(a2*x)+a3*exp(a4*x)+a5*exp(a6*x)+a7
                 7:  f(x)= a1/(1+exp((x-a2)/a3))
                 8:  f(x)= a1/( 1+(x/a2)^a3 )
                 9:  f(x)= a1+a2*x
                 10: f(x)= a1+a2*x+a3*x^2
                 11: f(x)= a1+a2*x+a3*x^2+a4*x^3
                 12: f(x)= a1+a2*x+...+a5*x^4
                 13: f(x)= a1+a2*x+...+a6*x^5
                 14: f(x)= a1+a2*x+...+a7*x^6
                 15: f(x)= a1+a2*x+...+a8*x^7
                 16: f(x)= a1+a2*x+...+a9*x^8
                 17: f(x)= a1+a2*x+...+a10*x^9
                 18: f(x)= a1*exp(-0.5*( (x-a2)/a3)^2)    1 gaussienne
                 19: f(x)= a1*exp(-0.5*( (x-a2)/a3)^2)+...2 gaussiennes
                 20: f(x)= a1*exp(-0.5*( (x-a2)/a3)^2)+...3 gaussiennes
                 21: f(x)= a1*exp(-x/a2)
                 22: f(x)= a1*exp(-x/a2)+a3*exp(-x/a4)
                 23: f(x)= a1*exp(-x/a2)+a3*exp(-x/a4)+a5*exp(-x/a6)
                 24: f(x)= a1*exp(-x/a2)+a3
                 25: f(x)= a1*exp(-x/a2)+a3*exp(-x/a4)+a5
                 26: f(x)= a1*exp(-x/a2)+a3*exp(-x/a4)+a5*exp(-x/a6)+a7

 On peut utiliser les constantes désignant les modèles plutôt que les numéros
ci-dessus. Voir (Modèles de fonctions standard)@


}

                        { stmFit1 TcurveFitting }

procedure TcurveFitting.create(stName:string);
procedure TcurveFitting.create;

{$H Constructeur de l'objet TcurveFitting

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
}

procedure TcurveFitting.reset;
{$H Donne des valeurs par défaut aux paramètres de l'objet.

 En particulier, les vecteurs source vaudront NIL après l'appel de reset.

}
function TcurveFitting.execute:boolean;
{$H Exécute l'ajustement.

 La fonction renvoie false si une erreur s'est produite pendant le calcul, true
dans le cas contraire.
}

property TcurveFitting.initialize:boolean;
{$H Si Initialize vaut True et si la fonction choisie correspond à un modèle
standard, les paramètres de la fonction seront initialisés avant le lancement
de l'itération, ce qui rend en général la convergence très probable et assez rapide.

 Dans le cas contraire, les paramètres actuels de la fonction seront pris comme point
de départ de l'itération.
}

procedure TcurveFitting.setXdata(var v:Tvector);
{$H Indique le vecteur contenant les données indépendantes

 Si ce vecteur n'a pas été affecté, on considère que setYdata@ indique à la fois
les données suivant X et Y.
}

procedure TcurveFitting.setYdata(var v:Tvector);
{$H Indique le vecteur contenant les données dépendantes.

 Lorsque setXdata@ n'a pas été appelé, les abscisses réelles des points du vecteur
constituent les données indépendantes.
}
procedure TcurveFitting.setErrorData(var v:Tvector);
{$H Indique le vecteur conenant les incertitudes sur chaque point.

 Ces données ne sont prises en compte que si le mode@ est égal à wm_sigma@ .
}
property TcurveFitting.XstartFit:real;
{$H Indique l'abscisse de début du fit.

 XstartFit et XendFit@ sont les abscisses réelles entre lesquelles doivent se
trouver les données X pour être prises en compte.

 Le fait d'affecter XstartFit ou XendFit a pour conséquence que les propriétés
IstartFit@ et IendFit@ seront ignorées.
}
property TcurveFitting.XendFit:real;
{$H Indique l'abscisse de fin du fit.

 XstartFit@ et XendFit sont les abscisses réelles entre lesquelles doivent se
trouver les données X pour être prises en compte.

 Le fait d'affecter XstartFit ou XendFit a pour conséquence que les propriétés
IstartFit@ et IendFit@ seront ignorées.
}

property TcurveFitting.YstartFit:real;
{$H Indique l'ordonnée minimale des données prises en compte.

 YstartFit et YendFit@ sont les ordonnées entre lesquelles doivent se
trouver les données Y pour être prises en compte.

 Si YendFit<=YstartFit , ces deux paramètres sont ignorés.
}
property TcurveFitting.YendFit:real;
{$H Indique l'ordonnée maximale des données prises en compte.

 YstartFit@ et YendFit sont les ordonnées entre lesquelles doivent se
trouver les données Y pour être prises en compte.

 Si YendFit<=YstartFit , ces deux paramètres sont ignorés.

}
property TcurveFitting.IstartFit:longint;
{$H Indique l'indice de début du fit.

 IstartFit et IendFit@ sont les indices entre lesquels doivent se
trouver les données X ou Y pour être prises en compte.

 Le fait d'affecter IstartFit ou IendFit a pour conséquence que les propriétés
XstartFit@ et XendFit@ seront ignorées.

}
property TcurveFitting.IendFit:longint;
{$H Indique l'indice de fin du fit.

 IstartFit@ et IendFit sont les indices entre lesquels doivent se
trouver les données X ou Y pour être prises en compte.

 Le fait d'affecter IstartFit ou IendFit a pour conséquence que les propriétés
XstartFit@ et XendFit@ seront ignorées.

}

function TcurveFitting.userModel:boolean;
{$H Renvoie True si le modèle utilisé a été fixé par l'utilisateur, et False
quand le modèle est une fonction standard}

property TcurveFitting.mode:integer;
{$H Le mode permet de changer le poids statistique affecté aux données.

 Par défaut, mode=wm_equal (1), ce qui signifie que toutes les données ont le même
poids. Dans les autres modes, le poids est donné par les relations:
 ( voir (Modes d'ajustement)@ ):

 @f6 wm_equal:    weight=1
 @f6 wm_sigma:    weight=1/sigma[i]²
 @f6 wm_invY2:    weight=1/y[i]²
 @f6 wm_invY:     weight=1/|y[i]|
 @f6 wm_Y2:       weight=y[i]²
 @f6 wm_Y:        weight=|y[i]|
 @f6 wm_X:        weight=x[i]
 @f6 wm_invX2:    weight=1/x[i]²
 @f6 wm_invX:     weight=1/|x[i]|

 Sigma représente la déviation standard pour la donnée d'indice i. Quand on choisit
le mode wm_sigma, il faut appeler setErrorData pour indiquer un vecteur contenant
des barres d'erreur.
}

property TcurveFitting.MaxData:longint;
{$H Indique le maximum de données à utiliser effectivement.

 Si les vecteurs source contiennent un grand nombre de points entre XstartFit et XendFit,
le calcul d'ajustement risque d'être inutilement long. On peut donc décider de ne prendre
en considération qu'un certain nombre de points régulièrement espacés entre les deux limites.

 Ce nombre est maxData et est égal à 1000000 par défaut. C'est à dire que par défaut,
toutes les données sont prises en compte.
 Avant février 2007, maxData était fixé arbitrairement à 100 .

 Si le nombre de données est inférieur à maxData, tous les points sont pris en compte.
}

function TcurveFitting.DataCount:longint;
{$H Renvoie le nombre de points utilisés pour le calcul.

 Ce nombre  est égal au nombre de points compris entre XstartFit et XendFit si ce nombre
est inférieur à maxData@ . Sinon, il est égal à maxData@ .
}

property TcurveFitting.Clamp(st:string):boolean;
{$H Permet de fixer la valeur d'un paramètre de la fonction.

 st est le nom du paramètre.
 Par défaut, toutes les propriétés Clamp valent FALSE.
 En indiquant Clamp=TRUE pour un paramètre, on empêche le paramètre d'évoluer
pendant l'itération.

}

function TcurveFitting.fitReg:real;
{$H Renvoie un coefficient de régression donné par la formule

  R=sqrt( sum( (f(xi)-ym)²)/sum( (yi-ym)²) )
}

function TcurveFitting.fitReg2:real;
{$H Renvoie un coefficient de régression donné par la formule suivante

  R=sqrt( 1- sum( (f(xi)-yi)²)/sum( (yi-ym)²) )

}

property TcurveFitting.maxIT:longint;
{$H Indique le nombre maximum d'itérations
}

property TcurveFitting.Threshold:longint;
{$H Indique le seuil d'arrêt de l'itération.

 Par défaut, sa valeur est 12. On peut augmenter ce nombre jusqu'à 20 environ
pour obliger le programme à poursuivre sa recherche encore plus loin.

 On peut également jouer sur le nombre maximum d'itérations ( voir MaxIT@ ).
}
procedure TcurveFitting.compressParam(v:real);
{$H Comprime les résultats dans le cas d'ajustement d'exponentielles.

 Si la fonction à ajuster est une somme de deux exponentielles alors que les données
sont bien décrites par un seule exponentielle, les résultats contiennent des
exponentielles (presque) identiques. Il est alors logique de remplacer les deux
exponentielles par une seule en gardant la même constante de temps et en prenant
une amplitude qui est la somme des amplitudes des deux exponentielles.

 C'est le rôle de la procédure CompressParam. Le paramètre v indique avec quelle
précision deux constantes de temps sont considérées comme égale.
 Exemple: v=0.01 signifie que les résultats peuvent être compressés si les deux constantes
 de temps sont égales à un pour cent près.

}

function TcurveFitting.SXX:real;
{$H Après un fit, renvoie la somme des carrés des termes (x-moyenne(x)), la somme
étant effectuée sur toutes les données utilisées pour le calcul.
}
function TcurveFitting.SYY:real;
{$H Après un fit, renvoie la somme des carrés des termes (y-moyenne(y)), la somme
étant effectuée sur toutes les données utilisées pour le calcul.
}
function TcurveFitting.SXY:real;
{$H Après un fit, renvoie la somme des produits (x-moyenne(x))*(y-moyenne(y)), la somme
étant effectuée sur toutes les données utilisées pour le calcul.
}
function TcurveFitting.MeanX:real;
{$H Après un fit, renvoie la valeur moyenne de la variable indépendante x.
}
function TcurveFitting.MeanY:real;
{$H Après un fit, renvoie la valeur moyenne de la variable dépendante y.
}
function TcurveFitting.ResidualVariance:real;
{$H Après un fit, renvoie la quantité
 1/(DataCount-2)*(SYY-sqr(SXY)/SXX);
}
function TcurveFitting.Chi2:real;
{$H Après un fit, renvoie le chi carré, c'est à dire la quantité

  sum(sqr(yi-f(xi)))/dataCount
}
property TcurveFitting.paramSig(st:string):real readOnly;
{$H Après un fit, indique l'incertitude sur le paramètre de nom st
}


                        { stmMF1 TmatFunction }

procedure TmatFunction.create(stName:string;stTxt:string);
procedure TmatFunction.create(stTxt:string);

{$H Constructeur de l'objet TmatFunction.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
 StTxt est une chaîne de caractères définissant la fonction. Elle devient
sa propriété text@ .

 Il est possible de définir la fonction dans le programme plutôt qu'au moyen d'une
chaîne de caractères. Pour cela, il faut utiliser le constructeur create1@ .
}

procedure TmatFunction.create1(stName:string;F:TanyProcedure);
procedure TmatFunction.create1(F:TanyProcedure);
{$H Constructeur de l'objet TmatFunction.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 F est une fonction réelle de variables réelles déclarée dans le programme.
 F deviendra la propriété PgFunction@ de l'objet.
}

property TmatFunction.PgFunction:TanyProcedure;
{$H Définit la fonction en indiquant l'adresse d'une fonction écrite dans le programme.

 Le résultat de la fonction doit être de type REAL et tous ses paramètres doivent être
de type REAL.
 Le  nombre total de paramètres doit être supérieur à 2. Les deux premiers paramètres
seront considérés commes les "arguments" X et Y de la fonction. Les autres seront
considérés comme les "paramètres" de la fonction.

 Le contrôle de la validité de la fonction n'est pas actuellement effectué au moment de
la compilation mais au moment de l'exécution.


 @f6   Exemple:
 @f6
 @f6   Function myFunc(x,y,a,b:real):real;
 @f6   begin
 @f6     myFunc:=sqr(x-a)+sqr(x-b);
 @f6   end;

 @f6   matFunction.PgFunction:=myFunc;


}

property TmatFunction.Text:string;
{$H Définition de la fonction au moyen d'une chaîne de caractères.

 La fonction est définie par une suite de déclarations du genre:
 A=a1*x+b1
 B=a2*sin(omega*y)
 RES=(A-B)*(A+B)

 A et B sont des résultats intermédiaires permettant une écriture plus aisée de
la fonction.
 RES désigne toujours le résultat de la fonction.
 a1, b1, a2, b2, omega sont des paramètres.
 Par défaut, x et y désignent les arguments mais ceci peut être changé au moyen de
la propriété argument@ .

 Pour introduire l'exemple précédent, vous pouvez écrire:
 @f6 Text:= 'A=a1*x+b1' +chr(10)+
 @f6        'B=a2*sin(omega*y)' +chr(10)+
 @f6        'RES=(A-B)*(A+B)';

 chr(10) signale un changement de ligne.

 En plus des symboles habituels ( + , - , * , / ), vous pouvez utilisez le symbole ^
pour l'opération exposant. Exemple: x^3 pour x à la puissance 3.

 Les fonctions suivantes sont utilisables:

      ABS:                valeur absolue
      ARCTAN ou ARCTG     arc tangente
      COS                 cosinus
      EXP                 exponentielle
      FRAC                partie fractionnaire
      INT                 partie entière
      LN ou LOG           logarithme népérien
      SIN                 sinus
      SQR                 carré
      SQRT                racine carrée
      TG ou TAN           tangente
      COTG ou COTAN       cotangente
      ARCSIN              arc sinus
      ARCCOS              arc cosinus
      ARCCOTG             arc cotangente
      SH                  sinus hyperbolique
      CH                  cosinus hyperbolique
      TH                  tangente hyperbolique
      COTH                cotangente hyperbolique
}
property TmatFunction.argument(i:integer):string;
{$H Arguments de la fonction

 i peut valoir 1 ou 2
 Les valeurs par défaut sont
          Argument[1]='x'
          Argument[2]='y'


}
property TmatFunction.param(st:string):real;
{$H Paramètres de la fonction.

 On accède à la valeur numérique d'un paramètre en donnant son nom.
 Exemple: l'instruction Param['a']:=5; permet de modifier la valeur du paramètre a .
}

function TmatFunction.indexof(st:string):integer;
{$H Renvoie la position d'un argument.

 Cette fonction a peu d'intérêt actuellement.
}
function TmatFunction.paramCount:integer;
{$H Renvoie le nombre de paramètres de la fonction.
}
procedure TmatFunction.setGraphParam(x1,x2,y1,y2:real;i1,i2,j1,j2:longint);
{$H Permet de modifier la structure de la matrice qui représente la fonction.

 A l'affichage et pour de nombreux calculs, la fonction se comportera comme une
 matrice de propriétés:
           Xstart=x1
           Xend=x2
           Ystart=y1
           Yend=y2

           Istart=i1
           Iend=i2
           Jstart=j1
           Jend=j2


}
procedure TmatFunction.matchMatrix(var m:Tmatrix);
{$H Appelle la méthode setGraphParam en utilisant les propriétés de la matrice m
de la façon suivante:
           setGraphParam(m.Xstart,m.Xend,m.Ystart,m.Yend,m.Istart,m.Iend,m.Jstart,m.Jend);

  Après avoir appelé matchMatrix, la fonction a la même structure (extension et
resolution) que la matrice m.

}
property TmatFunction.StandardModel:integer;
{$H L'affectation de standardModel permet de sélectionner un des modèles standard.

 0 modèle standard pour l'instant

}

                        { stmMFit1 TmatFitting }

procedure TmatFitting.create(stName:string);
procedure TmatFitting.create;
{$H Constructeur de l'objet TmatFitting

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
}

procedure TmatFitting.reset;
{$H Donne des valeurs par défaut aux paramètres de l'objet.

 En particulier, les vecteurs source seront vides après l'appel de reset.

}
procedure TmatFitting.execute;
{$H Exécute l'ajustement }

property TmatFitting.initialize:boolean;
{$H Si Initialize vaut True et si la fonction choisie correspond à un modèle
standard, les paramètres de la fonction seront initialisés avant le lancement
de l'itération, ce qui rend en général la convergence très probable et assez rapide.

 Dans le cas contraire, les paramètres actuels de la fonction seront pris comme point
de départ de l'itération.
}

procedure TmatFitting.setdata(var m:Tmatrix);
{$H Indique la matrice contenant les données.

}

procedure TmatFitting.setErrorData(var m:Tmatrix);
{$H Indique la matrice contenant les incertitudes sur chaque point.

 Ces données ne sont prises en compte que si le mode@ est égal à wm_sigma@ .
}
property TmatFitting.UseSelection:boolean;
{$H Indique si les données sont les éléments sélectionnés de la matrice source.}

function TmatFitting.userModel:boolean;
{$H Renvoie True si le modèle utilisé a été fixé par l'utilisateur, et False
quand le modèle est une fonction standard}

property TmatFitting.mode:integer;
{$H Le mode permet de changer le poids statistique affecté aux données.

 Par défaut, mode=wm_equal (1), ce qui signifie que toutes les données ont le même
poids. Dans les autres modes, le poids est donné par les relations:
 ( voir (Modes d'ajustement)@ ):

 @f6 wm_equal:    weight=1
 @f6 wm_sigma:    weight=1/sigma[i]²
 @f6 wm_invY2:    weight=1/y[i]²
 @f6 wm_invY:     weight=1/|y[i]|
 @f6 wm_Y2:       weight=y[i]²
 @f6 wm_Y:        weight=|y[i]|

 Sigma représente la déviation standard pour la donnée d'indice i. Quand on choisit
le mode wm_sigma, il faut appeler setErrorData pour indiquer un vecteur contenant
des barres d'erreur.
}

property TmatFitting.Clamp(st:string):boolean;
{$H Permet de fixer la valeur d'un paramètre de la fonction.

 st est le nom du paramètre.
 Par défaut, toutes les propriétés Clamp valent FALSE.
 En indiquant Clamp=TRUE pour un paramètre, on empêche le paramètre d'évoluer
pendant l'itération.
}

property TmatFitting.maxIT:longint;
{$H Indique le nombre maximum d'itérations
}

property TmatFitting.Threshold:longint;
{$H Indique le seuil d'arrêt de l'itération.

 Par défaut, sa valeur est 12. On peut augmenter ce nombre jusqu'à 20 environ
pour obliger le programme à poursuivre sa recherche encore plus loin.

 On peut également jouer sur le nombre maximum d'itérations ( voir MaxIT@ ).
}

property TmatFitting.paramSig(st:string):real readOnly;
{$H Après un fit, indique l'incertitude sur le paramètre de nom st
}


Hpage VariantesA; { Les méthodes "A "de Tdialog }

{$P
 Un certains nombre de méthodes de Tdialog@ se terminent par la lettre A et sont devenues obsolètes.
 Elles ont été créées à une époque où les déclarations multiples d'une même méthode n'étaient pas possibles dans le langage Elphy.

 Aujourd'hui, une méthode peut avoir plusieurs jeux de paramètres et le compilateur est capable d'identifier la variante appelée
dans le programme, en regardant le nombre et le type des paramètres.

 Il est donc préférable d'utiliser
         getInteger@(Tdialog.getInteger) plutôt que getIntegerA@(Tdialog.getIntegerA)
         getReal@(Tdialog.getReal) plutôt que getRealA@(Tdialog.getRealA)
         etc...

 D'une façon générale, les variantes A possédaient un paramètre suppémentaire id par rapport à la variante sans A,
ce paramètre étant l'identificateur attribué au contrôle.

}

                        {  stmDlg  Tdialog  }



procedure Tdialog.create(stName:string);
procedure Tdialog.create;
{$H Constructeur de l'objet Tdialog.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
}

function Tdialog.getInteger(titre:string;var x:byte..longword;n:integer):integer;
function Tdialog.getInteger(titre:string;var x:byte..longword;n:integer;id:integer):integer;
{$H Met en place un contrôle d'édition associé à une variable de
(type entier)@(types entiers) .

 Titre est une chaine de caractères qui s'affichera à gauche du contrôle.
 x est la variable associée.
 n est approximativement le nombre de chiffres que pourra contenir le contrôle.

 id est la valeur qui sera transmise au gestionnaire d'événement OnEvent s'il existe.
 Si id est absent ou nul, sa valeur sera fixée automatiquement par le dialogue.
 La valeur de id est renvoyée par la fonction.
}

function Tdialog.getIntegerA(titre:string;var x:byte..longword;n:integer;id:integer):integer;
{$H identique à la seconde variante de getInteger@

 Obsolète voir (Variantes A)@VariantesA
}


function Tdialog.getLongint(titre:string;var x:longint;n:integer):integer;
{$H Met en place un contrôle d'édition associé à une variable de type
longint.
 Titre est une chaine de caractères qui s'affichera à gauche du contrôle.
 x est la variable associée.
 n est approximativement le nombre de chiffres que pourra contenir le contrôle.

 La fonction renvoie le numéro d'ordre du controle dans le dialogue. Les controles
sont numérotés de 1 à N dans l'ordre de leur création.
}
function Tdialog.getReal(titre:string;var x:single..extended;n,m:integer):integer;
function Tdialog.getReal(titre:string;var x:single..extended;n,m:integer;id:integer):integer;
{$H Met en place un contrôle d'édition associé à une variable de (type réel)@(types réels).
 Titre est une chaine de caractères qui s'affichera à gauche du contrôle.
 x est la variable associée.
 n est approximativement le nombre de chiffres que pourra contenir le contrôle.
 m est le nombre de décimales affichées.

 La fonction renvoie le numéro d'ordre du controle dans le dialogue. Les controles
sont numérotés de 1 à N dans l'ordre de leur création.

 id est la valeur qui sera transmise au gestionnaire d'événement OnEvent.
 Si id est absent ou nul, sa valeur sera fixée automatiquement par le dialogue.
 La valeur de id est renvoyée par la fonction.
}
function Tdialog.getRealA(titre:string;var x:single..extended;n,m:integer;id:integer):integer;
{$H Identique à la seconde variante de GetReal@

 Obsolète voir (Variantes A)@VariantesA
}

function Tdialog.getString(titre:string;var x:string;n:integer):integer;
function Tdialog.getString(titre:string;var x:shortstring;n:integer):integer;
function Tdialog.getString(titre:string;var x:string;n:integer;id:integer):integer;
function Tdialog.getString(titre:string;var x:shortstring;n:integer;id:integer):integer;

{$H Met en place un contrôle d'édition associé à une variable de type string ou shortstring.

 Titre est une chaine de caractères qui s'affichera à gauche du contrôle.
 x est la variable associée.
 n est approximativement le nombre de caractères que pourra contenir le contrôle.

 id est la valeur qui sera transmise au gestionnaire d'événement OnEvent.
 Si id est absent ou nul, sa valeur sera fixée automatiquement par le dialogue.
 La valeur de id est renvoyée par la fonction.

}
function Tdialog.getStringA(titre:string;var x:string;n:integer;id:integer):integer;
function Tdialog.getStringA(titre:string;var x:shortstring;n:integer;id:integer):integer;
{$H Identique à getString

 Obsolète voir (Variantes A)@VariantesA
}

function Tdialog.getBoolean(titre:string;var x:boolean):integer;
function Tdialog.getBoolean(titre:string;var x:boolean;id:integer):integer;
{$H Met en place une case à cocher associée à une variable de type boolean.
 Titre est une chaine de caractères qui s'affichera à gauche du contrôle.
 x est la variable associée.

 La fonction renvoie le numéro d'ordre du controle dans le dialogue. Les controles
sont numérotés de 1 à N dans l'ordre de leur création.

 id est la valeur qui sera transmise au gestionnaire d'événement OnEvent.
 Si id est absent ou nul, sa valeur sera fixée automatiquement par le dialogue.
 La valeur de id est renvoyée par la fonction.
}

function Tdialog.getBooleanA(titre:string;var x:boolean;id:integer):integer;
{$H Identique à getBoolean@

 Obsolète voir (Variantes A)@VariantesA
}

function Tdialog.getMemo(titre:string;var x:string;n,Nline,flags:integer):integer;
function Tdialog.getMemo(titre:string;var x:string;n,Nline,flags:integer; id:integer):integer;
{$H Met en place un contrôle d'édition sur plusieurs lignes associé à une variable de type string.
 Titre est une chaine de caractères qui s'affichera à gauche du contrôle.
 x est la variable associée.
 n est approximativement la largeur du contrôle en nombre de caractères.
 Nline est approximativement la hauteur du contrôle en nombre de caractères.

 flags est sans action pour l'instant.

 La fonction renvoie le numéro d'ordre du controle dans le dialogue. Les controles
sont numérotés de 1 à N dans l'ordre de leur création.

 id est la valeur qui sera transmise au gestionnaire d'événement OnEvent s'il existe.
 Quand id est absent, on considère que id est égal au numéro d'ordre du controle dans le dialogue.
}

function Tdialog.getDateTime(mode: integer; titre:string;var x:TdateTime;n:integer):integer;
function Tdialog.getDateTime(mode: integer; titre:string;var x:TdateTime;n:integer; id:integer):integer;

{$H Met en place un contrôle d'édition associé à une variable de type TdateTime.

 Mode peut prendre l'une des valeurs entières 1, 2 ou 3.
 Si mode=1, seule la date est saisie
 Si mode=2, seule l'heure est saisie
 Si mode=3, la date et l'heure sont saisies

 Titre est une chaine de caractères qui s'affichera à gauche du contrôle.
 x est la variable associée.
 n est approximativement le nombre de caractères que pourra contenir le contrôle.
 id est nombre qui identifie le contrôle. Quand il est omis, la fonction renvoie automatiquement la valeur de l'identificateur.
 Cette valeur est utilisée par le gestionnaire d'événement s'il existe (voir OnEvent@ ).


 Pour modifier la variable , l'utilisateur doit cliquer sur un bouton situé à la droite du
contrôle d'édition. Ce qui fait apparaitre un dialogue dans lequel la saisie est facilitée

 La modification directe dans le contrôle d'édition est interdite.

 Le format général d'affichage
   yyyy-mm-dd hh:mn:ss:mil

 @f6 yyyy est l'année sur 4 caractères
 @f6 mm est le mois sur 2 caractères
 @f6 dd est le jour sur 2 caractères

 @f6 hh est l'heure sur 2 caractères
 @f6 mn contient les minutes sur 2 caractères
 @f6 ss contient les secondes sur 2 caractères
 @f6 mil contient les millisecondes sur 2 caractères

 Toutefois, suivant le mode, la date ou bien l'heure n'apparait pas.
}


function Tdialog.getStringList(title, names:string; var x: byte..longWord):integer;
function Tdialog.getStringList(title,names,values:string; var x: byte..longWord):integer;
function Tdialog.getStringList(title,names:string; var x: byte..longWord; id: integer):integer;
function Tdialog.getStringList(title,names,values:string; var x:byte..longWord; id: integer):integer;

{$H Met en place un controle contenant une liste d'options.

 Title est une chaine de caractères qui s'affichera à gauche du contrôle.
 x est la variable associée.

 Names est une chaîne qui contient la liste d'options. Les options sont séparées par le caractère | .
Exemple: 'Choix Un | Choix deux | Choix Trois'

 Values est une liste de nombres entiers optionnelle sous la forme d'une chaîne de caractères. Les
nombres doivent apparaitre dans la chaîne séparés par  le caractère | . Exemple: '23 | 12 | 56'

 La variable x contiendra en sortie soit le numéro de l'option dans la liste, soit la valeur correspondante qui
figure dans Values.

 id est la valeur qui sera transmise au gestionnaire d'événement OnEvent.
 Si id est absent ou nul, sa valeur sera fixée automatiquement par le dialogue.
 La valeur de id est renvoyée par la fonction.

 On peut aussi créer un contrôle identique avec getStringList1@ .
}

function Tdialog.getStringList1(title:string;var options:Tmemo; var x:byte..longWord):integer;
function Tdialog.getStringList1(title:string;var options:Tmemo; var x:byte..longWord;id:integer):integer;
{$H Met en place un controle contenant une liste d'options.

  Par rapport à GetStringList@ , la seule différence est que la liste d'options est contenue dans un objet Tmemo@ .

 Titre est une chaine de caractères qui s'affichera à gauche du contrôle.
 x est la variable associée.

 Options est un objet Tmemo@ qui contient la liste d'options.
Chaque ligne du memo représente une option .

 La variable x contiendra en sortie le numéro de l'option dans la liste.

 id est la valeur qui sera transmise au gestionnaire d'événement OnEvent.
 Si id est absent ou nul, sa valeur sera fixée automatiquement par le dialogue.
 La valeur de id est renvoyée par la fonction.

 On peut aussi créer un contrôle identique avec getStringList@ .
}

function Tdialog.getStringListA(titre,option:string;var x:byte..longWord;id:integer):integer;
{$H Identique à la troisième variante de GetStringList@

 Obsolète voir (Variantes A)@VariantesA
}

function Tdialog.getStringList1A(titre:string;var option:Tmemo; var x:byte..longWord;id:integer):integer;
{$H Identique à la deuxième variante de GetStringList1@

 Obsolète voir (Variantes A)@VariantesA
}


procedure Tdialog.ModifyStringList(AnId: integer; title, names:string);
procedure Tdialog.ModifyStringList(AnId: integer; title, names,values:string);
{$H Modifie un contrôle installé avec GetStringList.

}


function Tdialog.setText(titre:string):integer;
function Tdialog.setText(titre:string; id:integer):integer;
function Tdialog.setText(titre:string; id:integer; FontName:String;FontSize,FontColor,FontStyle:integer):integer;
{$H Introduit une ligne de texte dans le dialogue.

 id est le numéro qui sera transmis au gestionnaire d'événement OnEvent s'il existe.
 Si id est absent ou est nul, le numéro sera attribué automatiquement.

 FontName, FontSize,FontColor et FontStyle permettent de définir le jeu de caractères utilisé (voir Tfont@)
}

function Tdialog.getColor(title:string;var x:longint):integer;
function Tdialog.getColor(title:string;var x:longint;id:integer):integer;
{$H Crée un contrôle formé d'un bouton associé à un rectangle coloré.

  Quand l'utilisateur clique sur le bouton, il peut choisir une couleur au moyen d'un dialogue
de saisie de couleur standard. La couleur est stockée sous la forme d'un nombre entier x.

 id est le numéro qui sera transmis au gestionnaire d'événement OnEvent s'il existe.
 Si id est absent ou est nul, le numéro sera attribué automatiquement.
}

function Tdialog.getColorA(titre:string;var x:longint;id:integer):integer;
{$H Identique à getColor@

 Obsolète voir (Variantes A)@VariantesA
}


function Tdialog.getCommand(titre:string;Mresult:integer):integer;
function Tdialog.getCommand(titre:string;Mresult:integer;id:integer):integer;
{$H Crée un bouton dans le dialogue.

 Titre est le libellé du bouton
 Mresult est utilisé quand le dialogue est ouvert d'une façon modale. Quand Mresult
est différent de zéro, le dialogue se ferme quand on clique sur le bouton et la valeur
de Mresult est renvoyée par ShowModal.

 Quand le dialogue n'est pas modal, id est la valeur qui sera transmise au
gestionnaire d'événement OnEvent (identificateur du contrôle).

 Si id est absent ou est nul, l'identificateur est fixé automatiquement par le dialogue
}

function Tdialog.getCommandA(titre:string;Mresult:integer;id:integer):integer;
{$H identique à la seconde variante de getCommand@

 Obsolète voir (Variantes A)@VariantesA
}







function Tdialog.setTextA(text:string;id:integer):integer;
{$H Identique à setText@

 Obsolète voir (Variantes A)@VariantesA
}

procedure Tdialog.modifyText(id:integer;titre:String);
procedure Tdialog.modifyText( id:integer;titre:string; FontName:String;FontSize,FontColor,FontStyle:integer);
{$H Modifie le texte du controle dont l'identificateur est id.

 id est le numéro qui a été fourni à setText@ ou bien qui a été attribué automatiquement.
}


procedure Tdialog.modifyTextA(id:integer;titre:String);
{$H identique à modifyText@

 Obsolète voir (Variantes A)@VariantesA
}

procedure Tdialog.AddScrollBar(min1,max1,dx1,dx2:real);
procedure Tdialog.ModifyScrollBarA(id:integer; min1,max1,dx1,dx2:real);

procedure Tdialog.AddCheckBox;
procedure Tdialog.SetCheckBox(id: integer);
procedure Tdialog.setReadOnly;
property Tdialog.checked(num:integer): boolean;
property Tdialog.checkedA(id:integer): boolean;

property Tdialog.Enabled(num:integer): boolean;
property Tdialog.EnabledA(id:integer): boolean;

procedure Tdialog.AddText(nbCar:integer);

procedure Tdialog.setButtons(bb:integer);
{$H Choisit les boutons standard.

 Un dialogue peut comporter de un à trois boutons standard.
 Ces boutons comportent l'inscription OK, Cancel, Abort, Retry, Ignore, Yes ou No

 On choisit ces boutons en utilisant une combinaison des constantes (types de bouton)@
 Par exemple, pour afficher OK et cancel, on appelle
 @f6 setButtons(Bt_OK + Bt_Cancel)

 Lorsque le dialogue est modal, le fait de cliquer sur un bouton standard ferme le
dialogue et la fonction showModal renvoie un code caractéristique du bouton ( (Modal result)@ )

 Quand le dialogue est non modal, ces boutons ne sont pas utilisés.
 Il est préférable de les faire disparaitre avec @prog SetButtons(0) @notprog
}

property Tdialog.Caption:string;
{$H Permet de choisir le texte apparaissant dans la barre de titre de la fenêtre dialogue.
}

function Tdialog.showModal:integer;
{$H Fait apparaitre le dialogue en mode modal.

 En mode modal, l'utilisateur doit fermer le dialogue pour travailler en dehors du dialogue.
}

procedure Tdialog.close;
{$H Force la fermeture du dialogue
}
procedure Tdialog.update;
procedure Tdialog.update(num: integer);
{$H Met à jour un contrôle ou tous les contrôles du dialogue.

 Le contenu des variables associées sont rangés dans les contrôles.

 Quand le paramètre num est omis, tous les contrôles sont mis à jour.
 Sinon, seul le contrôle dont l'identificateur est num est concerné.

 Voir @updateVar
}

procedure Tdialog.updatevar;
procedure Tdialog.updatevar(num:integer);
{$H Met à jour une variable ou toutes les variables associées aux contrôles du dialogue .

 Les variables reçoivent le contenu des contrôles associés.

 Quand le paramètre num est omis, toutes les variables sont mises à jour.
 Sinon, seul le contrôle dont l'identificateur est num est concerné.

 Voir @update
}

property Tdialog.onchange(num:integer):Tprocedure;
{$H Gestionnaire d'événement appelé à chaque fois qu'un événement survient sur le
contrôle du dialogue de numéro num (clic sur un bouton, modification d'une valeur,..)

 Procedure est une procédure sans paramètres.

 On peut donc affecter un gestionnaire d'événement à chaque contrôle indépendamment.
 On peut aussi affecter un gestionnaire d'événement à tous les contrôles en même
temps en utilisant OnEvent@ .
}

property Tdialog.onEvent:Tprocedure1;
{$H Gestionnaire d'événement appelé à chaque fois qu'un événement survient sur un
des contrôles du dialogue (clic sur un bouton, modification d'une valeur,..)

 Tprocedure1 est une procédure ayant un seul paramètre de type longint.

 Le paramètre transmis est le numéro qui a été affecté au contrôle au moment de
sa création.
}
property Tdialog.onDragDrop(num:integer):Tprocedure;

function Tdialog.setListBox(titre,options:String;nbLine,nbCol,nbchar:integer;var x; id:integer):integer;
function Tdialog.setListBox(titre:String;var options:Tmemo;nbLine,nbCol,nbchar:integer;var x:integer; id:integer):integer;
function Tdialog.setListBox(titre:String;var options:Tmemo;nbLine,nbCol,nbchar:integer;var x; id:integer):integer;
function Tdialog.setListBox(titre,options:String;nbLine,nbCol:integer;var x; id:integer):integer;
function Tdialog.setListBox(titre:String;var options:Tmemo;nbLine,nbCol:integer;var x:integer; id:integer):integer;
function Tdialog.setListBox(titre:String;var options:Tmemo;nbLine,nbCol:integer;var x; id:integer):integer;

{$H Ajoute un contrôle du type ListBox dans le dialogue.

 Titre apparait à gauche de la liste.

 Options est soit une chaîne qui contient la liste d'options, soit un objet Tmemo@ .
 Quand Options est une chaîne, les options sont séparées par le caractère | .
    Exemple: 'Choix Un | Choix deux | Choix Trois'

 Nbline et Nbcol sont respectivement le nombre de lignes et de colonnes visibles.
 Si NbCol=1, une barre de défilement verticale apparait à droite de la fenêtre, sinon
une barre de défilement horizontale apparait en bas de la fenêtre.

 x doit être un tableau de booléens ou bien un nombre entier.
 Quand x est un tableau de booléens, le nombre d'éléments de ce tableau doit être supérieur ou
égal au nombre d'options. Dans ce cas, il est possible de sélectionner plusieurs options.
En sortie de dialogue, le tableau de booléens reflète l'état de la sélection.

 Quand x est un nombre entier, on ne peut sélectionner qu'une rubrique et en sortie de dialogue,
x contient le numéro de la rubrique sélectionnée. Les numéros commencent à 1.

 id est la valeur qui sera transmise au gestionnaire d'événement OnEvent s'il existe.


}


function Tdialog.setListBox1(titre:String;var options:Tmemo;nbLine,nbCol:integer;var x; id:integer):integer;
{$H Identique à setListBox }

function Tdialog.setCheckListBox(titre,options:String;nbLine,nbCol,nbchar:integer;var x; id:integer):integer;
function Tdialog.setCheckListBox(titre:String;var options:Tmemo;nbLine,nbCol,nbchar:integer;var x; id:integer):integer;
function Tdialog.setCheckListBox(titre,options:String;nbLine,nbCol:integer;var x; id:integer):integer;
function Tdialog.setCheckListBox(titre:String;var options:Tmemo;nbLine,nbCol:integer;var x; id:integer):integer;



procedure Tdialog.dividePanel(num,nb:integer;vertical:boolean);
procedure Tdialog.dividePanel(stName:string;nb:integer;vertical:boolean);

{$H Divise le panel de numéro num ou de nom stName en nb panneaux .

 Si vertical vaut TRUE, la division se fait dans le sens vertical, sinon elle se fait dans le sens
horizontal.

 Voir aussi SelectPanel@ , SplitPanel@
}

procedure Tdialog.selectPanel(num:integer);
procedure Tdialog.selectPanel(stName:string);

{$H Sélectionne le panneau de numéro num  ou de nom stName.

 Les prochains controles introduit seront rangés dans ce panneau.

 Les panels sont numérotés dans l'ordre de leur de création. Au départ, un dialogue ne comprend qu'un seul panel
de numéro 0 . Ensuite, si l'on utilise dividePanel@ ou SplitPanel@ , on crée des panels de numéros 1, 2, 3, etc...
Cette méthode convient pour un petit nombre de panels mais est peu pratique quand le nombre de panels est élévé.
Il est alors préférable d'utiliser les noms des panels pour les désigner:

 Le nom du premier panel est '1'
 Si ce panel est divisé en N panels, les nouveaux panels ont pour noms '1.1' , '1.2' , '1.3' , etc...
 Si le panel est '1.1' est lui même divisé, les nouveaux panels ont pour noms '1.1.1' , '1.1.2' , '1.1.3' , etc...

 Voir aussi DividePanel@ , SplitPanel@
}

procedure Tdialog.setPanelProp(Fborder: boolean;Fbevel:integer);
procedure Tdialog.setPanelProp(Fborder: boolean;Fbevel:integer; Mleft,Mtop,Mright,Mbottom:integer);

{$H Modifie les propriétés du panel courant

 Si Fborder vaut true, la bordure sera visible.

 Fbevel peut prendre les valeurs suivantes:
   0: aucun biseau
   1: biseau relevé
   2: biseau vers le bas

 Mleft est le nombre de pixels laissés à la gauche de chaque contrôle. Ce nombre vaut 10 par défaut.
 Mtop est le nombre de pixels laissés en haut du premier contrôle. Ce nombre vaut 10 par défaut.

 Mright le nombre de pixels laissés après le contrôle le plus large. Ce nombre vaut 5 par défaut.
 Mbottom est le nombre de pixels laissés en bas du dernier contrôle. Ce nombre vaut 2 par défaut.


}
procedure Tdialog.setLineSpacing(n:integer);
{$H Définit l'intervalle en pixels entre deux lignes

  La valeur par défaut est 2
}

procedure Tdialog.DispatchMessages;

procedure Tdialog.SplitPanel(num:integer;st:string);
procedure Tdialog.SplitPanel(stName:string;st:string);
procedure Tdialog.SplitPanel(num:integer;nbTabs:integer);
procedure Tdialog.SplitPanel(stName:string;nbTabs:integer);


{$H Décompose le panel de numéro num ou de nom stName en plusieurs volets superposés.

 Un seul de ces volets est visible à la fois.
 Avec les deux premières variantes, l'utilisateur peut sélectionner le volet visible au moyen d'un onglet.
 Avec les deux autres, le volet doit être sélectionné par le programme au moyen de SelectPanelTab@

 num est le numéro du panel qu'il faut décomposer.
 stName est le nom du panel qu'il faut décomposer.

 nbTabs est le nombre de volets souhaités.

 La chaine st doit contenir les noms apparaissant dans les onglets. Ces noms doivent être séparés par
le caractère '|' .

 Voici un exemple d'utilisation:

 @f6 With dialog do
 @f6 begin
 @f6   ...
 @f6   SplitPanel(0,'Un|Deux|Trois'); (* Décompose le panel 0 en trois volets *)

 @f6   SelectPanel(1);
 @f6   (* ajouter ici les controles du premier volet *)

 @f6   SelectPanel(2);
 @f6   (* ajouter ici les controles du deuxième volet *)

 @f6   SelectPanel(3);
 @f6   (* ajouter ici les controles du troisième volet *)

 @f6   ...
 @f6 end;

 Le programme suivant est équivalent:

 @f6 With dialog do
 @f6 begin
 @f6   ...
 @f6   SplitPanel('1','Un|Deux|Trois'); (* Décompose le panel 0 en trois volets *)

 @f6   SelectPanel('1.1');
 @f6   (* ajouter ici les controles du premier volet *)

 @f6   SelectPanel('1.2');
 @f6   (* ajouter ici les controles du deuxième volet *)

 @f6   SelectPanel('1.3');
 @f6   (* ajouter ici les controles du troisième volet *)

 @f6   ...
 @f6 end;


 Voir aussi SelectPanel@ , DividePanel@

}

procedure Tdialog.SelectPanelTab(num:integer;value:integer);
procedure Tdialog.SelectPanelTab(stName:string;value:integer);
{$H Sélectionne un volet dans un panel qui a été décomposé au moyen de SplitPanel@ .

 Num est le numéro du panel décomposé.
 stName est le nom du panel décomposé.

 Value est le numéro du volet ( Les numéros commencent à 1 ).
}

procedure Tdialog.setCursor(var cursor:Tcursor);


Hpage Utilisation_des_panels; { Tdialog: utilisation des panels }

{$P

 Par défaut, un dialogue ne comprend qu'un seul cadre (appelé panel) qui est dimensionné automatiquement
en fonction des controles qu'il contient. De plus, à l'intérieur du cadre, tous les controles sont placés
les uns sous les autres et leurs éléments sont alignés automatiquement: par exemple, les champs de saisie sont
alignés à gauche, le boutons ont les mêmes dimensions, etc...

 Il est possible d'améliorer la présentation du dialogue en utilisant plusieurs panels.

 Avec DividePanel@(Tdialog.dividePanel) , on divise un panel en plusieurs panels. La division se fait dans le sens
vertical ou horizontal.

 Avec SplitPanel@(Tdialog.SplitPanel) , on décompose un panel en plusieurs panels superposés que l'utilisateur peut sélectionner
au moyen d'un onglet.

 Avec SelectPanel@(Tdialog.SelectPanel) , on sélectionne un panel particulier qui recevra les controles créés.

 Pour désigner un panel, deux méthodes sont disponibles: par numéro et par nom.

 Les panels sont numérotés dans l'ordre de leur de création. Au départ, un dialogue ne comprend qu'un seul panel
de numéro 0 . Ensuite, si l'on utilise dividePanel@(Tdialog.dividePanel) ou SplitPanel@(Tdialog.SplitPanel) , on crée
des panels de numéros 1, 2, 3, etc...
 Cette méthode convient pour un petit nombre de panels mais est peu pratique quand le nombre de panels est élévé.
Il est alors préférable d'utiliser les noms des panels pour les désigner:

 Le nom du premier panel est '1'
 Si ce panel est divisé en N panels, les nouveaux panels ont pour noms '1.1' , '1.2' , '1.3' , etc...
 Si le panel est '1.1' est lui même divisé, les nouveaux panels ont pour noms '1.1.1' , '1.1.2' , '1.1.3' , etc...

 Le dimensionnement de chaque panel et la disposition des controles à l'intérieur de
chaque panel est toujours automatique.
 Par défauts, les bords des panels ne sont pas visibles mais on peut changer cela avec SetPanelProp@(Tdialog.SetPanelProp).

}

function Tdialog.getObject(title:String;var x:variant;n:integer;ClassId:string):integer;
function Tdialog.getObject(title:String;var x:variant;n:integer;ClassId:string;id:integer):integer;

property Tdialog.font:Tfont readonly;

property Tdialog.LineHeight: integer;
{$H Modifie la hauteur de l'espace occupé par un contrôle.

  Par défaut, l'intervalle entre deux contrôles dans le sens vertical est fixé automatiquement
et lineHeight vaut zéro.

  En donnant une valeur positive à lineHeight, on impose cet intervalle. Ceci est intéressant
quand on veut aligner les contrôles situés dans deux panels juxtaposés.
  Cette valeur s'applique uniquement au panel courant et est exprimée en pixels.
Les contrôles du type Memo ou ListBox ne sont pas concernés par cette propriété.


}

procedure Tdialog.AddGroupBox(stTitle: string);
{$H Ajoute un cadre avec un titre dans le panel courant

 stTitle est le titre.
}

                        { stmCor1 }

procedure CrossCorre(var source1,source2,dest:Tvector;x1c,x2c,Xmin,Xmax:real);
{$H Réalise la cross-corrélation entre les vecteurs source1 et source2.
 dest est le vecteur destination.
 x1c et x2c déterminent la région des vecteurs sources à considérer
 Xmin et Xmax déterminent l'extension du vecteur destination.

 Avant le calcul, il est préférable d'imposer un (type de nombre)@(types de nombre) réel
pour la destination.

 Le calcul tient compte pour chaque abscisse, de la longueur d'intégration effective. Ce qui
permet de supprimer les effets de bord.
}
procedure AutoCorre(var source,dest:Tvector;x1c,x2c,Xmin,Xmax:real);
{$H Calcul de l'auto-corrélation du vecteur source.
 dest est le vecteur destination.
 x1c et x2c déterminent la région du vecteur source à considérer
 Xmin et Xmax déterminent l'extension du vecteur destination.

 Avant le calcul, il est préférable d'imposer un (type de nombre)@(types de nombre)
réel pour la destination. Les paramètres d'échelle (dx,x0) et l'extension (Istart,Iend) du
vecteur destination sont ajustés automatiquement.

 Le calcul tient compte pour chaque abscisse, de la longueur d'intégration effective. Ce qui
permet de supprimer les effets de bord.

}


procedure ProdMatrix(var m:Tmatrix;var v1,v2:Tvector);
{$H Calcul d'une matrice produit.

 Il ne s'agit pas d'un produit de matrices à proprement parler.
 Le calcul effectue l'opération:
       m.Zvalue[i,j]:=v1.Yvalue[i] * v2.Yvalue[j]
 pour chaque élément de la matrice.

 Le (type de nombre)@(types de nombre) de la matrice n'est pas modifié par l'opération
mais son extension (Istart, Iend, Jstart, Jend) est ajustée automatiquement.
}

                            {stmUplot TuserPlot}

procedure TuserPlot.create(stName:string);
procedure TuserPlot.create;
property TuserPlot.onPaint:Tprocedure;

                            {stmDet1 Tdetect}

procedure TDetect.create(stName:string);
procedure TDetect.create;
{$H Constructeur de Tdetect

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

}
procedure Tdetect.installSource(var v:Tvector);
{$H Permet de spécifier le vecteur dans lequel on recherche des événements.
}
property Tdetect.Xstart:real;
{$H Permet de spécifier l'abscisse de début de la recherche dans le vecteur source.

 Par défaut, sa valeur est égale à la propriété Xstart du vecteur source.
}
property Tdetect.Xend:real;
{$H Permet de spécifier l'abscisse de fin de la recherche dans le vecteur source.

 Par défaut, sa valeur est égale à la propriété Xend du vecteur source.
}
property Tdetect.Mode:integer;
{$H Permet de spécifier le mode de recherche.

 Les valeurs possibles sont données par les constantes (modes de détection)@ . Pour chaque
mode, les paramètres Height@ et Length@ ont une signification différente.

   SM_max@(modes de détection) : recherche des maxima locaux. Un point (x,y) est considéré
comme un maximum local si:

                - il existe un point (x1p,y1p) tel que:
                    y1p<y-height
                    pour tout point (xi,yi) tel que x1p<xi<x, on a yi<y

                - il existe un point (x2p,y2p) que:
                    x<x2p<x+length
                    y2p<y-height
                    pour tout point (xi,yi) tel que x<xi<x2p, on a yi<y


   SM_min@(modes de détection) : recherche des minima locaux.Un point (x,y) est
considéré comme un minimum local si:
                - il existe un point (x1p,y1p) tel que:
                    y1p>y+h
                    pour tout point (xi,yi) tel que x1p<xi<x, on a yi>y

                - il existe un point (x2p,y2p) tel que:
                    y2p>y+h
                    pour tout point (xi,yi) tel que x<xi<x2p, on a yi>y

   SM_minMax@(modes de détection) : recherche des maxima et minima locaux. On recherche simultanément
les minima et maxima comme définis ci-dessus. On obtient obligatoirement une alternance
de minima et maxima.

   SM_stepUp@(modes de détection) : recherche de marches positives.
   Soit dl la quantité dl=round(Length/source.dx).
   Pour chaque point, on calcule la quantité w(i)=y(i)-y(i-dl)

   Il y a deux situations possibles:
   - Option1@ vaut True: Un point est un événement si w(i)>=height ET w(i-1)<height . Cette
double condition empêche la détection multiple du même événement.

   - Option1@ vaut false: Un point est un événement si w(i)>=height. En général, il n'est pas
recommandé de travailler dans ces conditions sauf si l'on veut jouer sur la longueur
d'inhibition.
   (height est supposé positif)

   SM_stepDw@(modes de détection) : recherche de marches négatives.
   Comme ci-dessus, un point est un événement si w(i)<=height ET w(i-1)>height

   SM_stepUpDw@(modes de détection) : recherche de marches positives et négatives. On
   recherche simultanément les marches positives et négatives comme définies précédemment.

   SM_crossUp@(modes de détection) : recherche de franchissement d'un seuil absolu du
bas vers le haut. Height représente le seuil et peut être positif ou négatif. Length
n'est pas utilisé.

   SM_crossDw@(modes de détection) : recherche de franchissement d'un seuil absolu du
haut vers le bas. Height représente le seuil et peut être positif ou négatif. Length
n'est pas utilisé.

   SM_crossUpDw@(modes de détection) : recherche simultanée des franchissement d'un seuil
absolu du haut vers le bas et du bas vers le haut.

   SM_slopeUp@(modes de détection) : recherche de variations de pente positive.
   Soit dl la quantité dl=round(Length/source.dx).
   Pour chaque point d'indice i, on calcule la quantité w(i)=y(i)-y(i-dl) puis
la quantité dw=w(i)-w(i-1).
   Un point est un événement si dw>=height

   SM_slopeDw@(modes de détection) : recherche de variations de pente négative.
   Comme ci-dessus, Un point est un événement si dw<=height

   SM_slopeUpDw@(modes de détection) : recherche simultanée des variations de pente
positives et négatives.

}
property Tdetect.height:real;
{$H La signification du paramètre Height dépend du mode@ de détection.
}
property Tdetect.length:real;
{$H La signification du paramètre Length dépend du mode@ de détection.
}
property Tdetect.InhibLength:real;
{$H Si cette propriété a une valeur différente de zéro, la détection sera interdite
pendant une durée InhibLength après la détection d'un événement.
}


property Tdetect.Option1:boolean;
{$H Cette option est utilisée uniquement par le mode@ smSteps
}

procedure Tdetect.Execute;
{$H Lance la recherche des événements.
}

property Tdetect.Vevent:Tvector readonly;
{$H Vecteur contenant les événements détectés.
}

property Tdetect.Vaux(i:integer):Tvector readonly;
{$H Vaux est un tableau de 3 vecteurs qui contiennent des informations sur les événements
détectés. Ces informations dépendent du mode@ utilisé.

 SM_max@(modes de détection), SM_min@(modes de détection), SM_minMax@(modes de détection) :
 Vaux[1] contient l'amplitude du signal sur l'extrémum.
 Vaux[2] contient la différence entre l'amplitude du signal sur l'extrémum actuel et
l'amplitude du signal sur l'extrémum précédent.
 Vaux[3] contient la différence entre la position de l'extrémum actuel et la position de
l'extrémum précédent.

 SM_stepUp@(modes de détection), SM_stepDw@(modes de détection), SM_stepUpDw@(modes de détection) :
 Vaux[1] contient la valeur de la différence w=y(i)-y(i-dl)
 Si Option1@ vaut true, Vaux[2] contient la hauteur totale de l'événement sinon
Vaux[2] est égal à Vaux[1]
 Si Option1@ vaut true, Vaux[3] contient la longueur totale de l'événement sinon
Vaux[3] est égal à length@

 SM_crossUp@(modes de détection), SM_crossDw@(modes de détection), SM_crossUpDw@(modes de détection) :
 Aucune information

 SM_slopeUp@(modes de détection), SM_slopeDw@(modes de détection), SM_slopeUpDw@(modes de détection) :
 Aucune information

}

property Tdetect.count:longint readOnly;
{$H Renvoie le nombre de détection.

 Est égal à Vevent.Iend .
}

property Tdetect.onDetect:Tprocedure1;
{$H Gestionnaire d'événement appelé à la fin de l'exécution de l'opération de
détection.

 Tprocedure1 est une procédure ayant un seul paramètre de type longint.

 Le paramètre transmis est le tag de l'objet.
}
                            {stmAlpha TAlphaDetect}

procedure TAlphaDetect.create(stName:string);

procedure TAlphaDetect.installVectors(source,Falpha,Dalpha:Tvector);
procedure TAlphaDetect.installVectorsAux(Vx0,Vamp,Vtau,Vlamda:Tvector);

property TAlphaDetect.UpperThreshold:real;
property TAlphaDetect.LowerThreshold:real;
property TAlphaDetect.DtDiff:real;
property TAlphaDetect.XstartA:real;
property TAlphaDetect.XendA:real;

property TAlphaDetect.DtSmooth:real;

function TAlphaDetect.tau:real;
function TAlphaDetect.Amp:real;
function TAlphaDetect.Lambda:real;
function TAlphaDetect.x0:real;

procedure TAlphaDetect.Init;
procedure TAlphaDetect.Next;
procedure TAlphaDetect.execute;

function  TAlphaDetect.terminated:boolean;

property TAlphaDetect.b_exc:real;
property TAlphaDetect.b_inh:real;
property TAlphaDetect.a_max:real;
property TAlphaDetect.a_min:real;
property TAlphaDetect.backStep:real;


                            { TrevCorAnalysis revcor2 }

procedure TrevCorAnalysis.create(stName:string);
{$H Constructeur de l'objet Tpsth.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
}

procedure TrevCorAnalysis.installSource(var v:Tvector);
{$H Installation du vecteur contenant les données à analyser.

 L'appel de cette méthode est toujours nécessaire.

 Le vecteur v doit contenir des dates d'événements. Ce vecteur pourra être par
exemple le vecteur Vevent@(Tdetect.Vevent) de l'objet Tdetect@ .
 }
procedure TrevCorAnalysis.installEvtFile(st:string);
{$H Installation du fichier Evt.

 L'appel de cette méthode est nécessaire lorsque les informations de stimulation
(tops synchro) ont été rangés dans un fichier EVT (ancienne méthode).

 Sinon il faut utiliser InstallStimSeq@ et InstallTimes@ .
}
procedure TrevCorAnalysis.installStimSeq(seed,nbDivX,nbDivY,expansion,scotome:longint);
{$H Installation des paramètres décrivant la séquence de stimulation

 Les paramètres sont ceux qui ont été fournis par le programme de stimulation et qui
en principe ont été rangés dans le fichier de données brutes.

 Seed est la valeur d'initialisation de la séquence pseudo-aléatoire. Dans le fichier
de données, on a en fait rangé une valeur de base et cette valeur a été incrémentée à
chaque séquence de corrélation. La Nème séquence de corrélation a utilisé la valeur
seed+N .

 NbDivX et NbDivY sont les nombres de divisions suivant chaque axe de la grille de base.
 La grille réelle utilisée dépend des paramètres expansion et scotome de base.

 Expansion est un facteur multiplicatif (exprimé en pourcentage) appliqué aux dimensions
de la grille de base. 100 signifie que la grille réelle est égale à la grille de base.
200 signifie que les dimensions ont été multipliées par 2, etc..

 Scotome définit une zone au centre de la grille exclue de la stimulation. La valeur
zéro signifie qu'il n'y a pas de scotome, 100 signifierait que toute la grille est
exclue.
}
procedure TrevCorAnalysis.installTimes(var vecEvt:Tvector;dx:real);
{$H Installation du vecteur contenant les dates de stimulation.

 Ce vecteur est un vecteur d'événements contenant les tops synchro de la séquence
de corrélation.

}

procedure TrevCorAnalysis.installFP(var vec:Tvector);
{$H Installation du vecteur contenant les coefficients de pondération.

 Ce vecteur doit contenir autant de valeurs que le vecteur d'événements fourni
à InstallTimes@ .
}

property TrevCorAnalysis.Tmaxi:real;
{$H Définit la date limite pour le calcul des psths.

 Il est nécessaire de fixer cette valeur car les unités utilisée sont différentes
pour les fichiers continus ou en séquences. On choisira en général 200 (ms) pour les
fichiers de séquences et 0.2 (sec) pour les fichiers continus.

 Tmaxi doit être positif. Les psths sont calculés entre -Tmaxi et +Tmaxi.
 La largeur de classe de ces psths est Dt0@, le nombre de classes est donc
round(2*Tmaxi/Dt0) .
}
property TrevCorAnalysis.Dt0:real;
{$H Définit la largeur de classe des Psths.

 Il est nécessaire de fixer cette valeur car les unités utilisée sont différentes
pour les fichiers continus ou en séquences. On choisira en général 1 (ms) pour les
fichiers de séquences et 0.001 (sec) pour les fichiers continus.

}

property TrevCorAnalysis.t:real;
{$H Indique la limite inférieure de la fenêtre d'intégration pour le calcul des
matrices brutes (m1@ et m2@)

 La limite supérieure est t + Dt@ .


}
property TrevCorAnalysis.Dt:real;
{$H Indique la largeur de la fenêtre d'intégration pour le calcul des
matrices brutes (m1@ et m2@) ou optimales (mopt1@ et mopt2@).

 Les limites de la fenêtre sont t@ et  t@ + Dt@ .
}

property TrevCorAnalysis.Zthreshold:real;
{$H Indique la valeur utilisée pour le seuillage des matrices optimales

 La valeur par défaut est 2.57 .

 Ce seuillage est effectif si UseThreshold@ est vrai .
}
property TrevCorAnalysis.UseThreshold:boolean;
{$H Indique s'il faut seuiller ou non les matrices optimales.
}

procedure TrevCorAnalysis.clearPsth;
{$H Mise à zéro des psths
}

procedure TrevCorAnalysis.calculatePsth;
{$H Calcule les psths.

 Cette étape est nécessaire avant de calculer des matrices.
 Il faut penser à appeler clearPsth@ avant le calcul.

 Le résultat se trouve dans psths@
}
procedure TrevCorAnalysis.calculateMatrix;
{$H Calcule les matrices brutes m1@ et m2@ ainsi que les matrices antérogrades
mAnte1@ et mAnte2@.

 Il faut avoir calculé les psths (calculatePsth@) avant de lancer ce calcul.
}
procedure TrevCorAnalysis.calculateOptMatrix;
{$H Calcule les matrices optimales mopt1@ et mopt2@ ainsi que les matrices de
latences mLat11@ et mLat2@.

 Il faut avoir calculé les psths (calculatePsth@) avant de lancer ce calcul.
}


Property TrevCorAnalysis.m1:Tmatrix readonly;
{$H Matrice brute pour la luminance 1.

 Cette matrice est calculée avec calculateMatrix@ .

}
Property TrevCorAnalysis.m2:Tmatrix readonly;
{$H Matrice brute pour la luminance 2.

 Cette matrice est calculée avec calculateMatrix@ .
}
Property TrevCorAnalysis.mopt1:Tmatrix readonly;
{$H Matrice optimale pour la luminance 1.

 Cette matrice est calculée avec calculateOptMatrix@ .
}
Property TrevCorAnalysis.mopt2:Tmatrix readonly;
{$H Matrice optimale pour la luminance 2.

 Cette matrice est calculée avec calculateOptMatrix@ .
}
Property TrevCorAnalysis.mlat1:Tmatrix readonly;
{$H Matrice des latences pour la luminance 1.

 Cette matrice est calculée avec calculateOptMatrix@ .

}
Property TrevCorAnalysis.mlat2:Tmatrix readonly;
{$H Matrice des latences pour la luminance 2.

 Cette matrice est calculée avec calculateOptMatrix@ .

}
Property TrevCorAnalysis.mante1:Tmatrix readonly;
{$H Matrice antérograde pour la luminance 1.

 Cette matrice est calculée avec calculateMatrix@ .

}
Property TrevCorAnalysis.mante2:Tmatrix readonly;
{$H Matrice antérograde pour la luminance 2.

 Cette matrice est calculée avec calculateMatrix@ .

}

Property TrevCorAnalysis.psths(num:integer):TvectorArray readonly;
{$H Structure contenant les psths calculé par calculatePsth@.

 num peut valoir 1 ou 2. Ce qui correspond aux deux luminances possibles pour les
stimulus.

 Psths[1] et Psths[2] sont de type TvectorArray@ . Il peuvent être affichés dans une
fenêtre multigraph.

}

property TrevCorAnalysis.mat(num:integer):Tmatrix readonly;
{$H mat permet de désigner commodément l'une des 8 matrices calculées par
l'objet TrevCorAnalysis.

 mat[1] désigne m1
 mat[2] désigne m2
 mat[3] désigne mopt1
 mat[4] désigne mopt2
 mat[5] désigne mlat1
 mat[6] désigne mlat2
 mat[7] désigne mante1
 mat[8] désigne mante2

}


function TrevCorAnalysis.pixelsAbove(num:integer):longint;
function TrevCorAnalysis.ZAbove(num:integer):real;
function TrevCorAnalysis.Nmean:real;
function TrevCorAnalysis.Nstd:real;

procedure TrevCorAnalysis.getStimsXYZ(x,y,z:integer;var v:Tvector);
{$H Renvoie la liste des dates des stimulus correspondant à un triplet (x,y,z).

 x doit être compris entre 1 et Nx@.
 y doit être compris entre 1 et Ny@.
 z doit être compris entre 1 et 2.

 En sortie, v est un vecteur d'événements contenant les dates des stimulus.
}
function TrevCorAnalysis.getTimeXYZ(x,y,z:integer):real;
{$H Renvoie la date du stimulus correspondant à un triplet (x,y,z).

 x doit être compris entre 1 et Nx@.
 y doit être compris entre 1 et Ny@.
 z doit être compris entre 1 et 2.
}



property TrevCorAnalysis.PosCount:longint readonly;
{$H Renvoie le nombre de triplets (x,y,z) effectivement utilisés dans une
séquence de corrélation.

}
property TrevCorAnalysis.Nx:longint readonly;
{$H Renvoie la dimension X de la grille de stimulation en tenant compte
du facteur d' expansion@ éventuel.
}
property TrevCorAnalysis.Ny:longint readonly;
{$H Renvoie la dimension Y de la grille de stimulation en tenant compte
du facteur d' expansion@ éventuel.
}
property TrevCorAnalysis.Codes(i:longint):longint readonly;
{$H Renvoie le code associé à la ième stimulation de la séquence.

 Le code associé à un triplet (x,y,z) est donné par
          (z-1)+2*(y-1+ny*(x-1))

 Les valeurs possibles de x sont comprises entre 1 et Nx@.
 Les valeurs possibles de y sont comprises entre 1 et Ny@.
 Les valeurs possibles de z sont comprises entre 1 et 2.

 Le code est compris entre 0 et 2*Nx*Nz-1 .
}

property TrevCorAnalysis.Xpos(i:longint):longint readOnly;
{$H Renvoie la position X de la ième stimulation de la séquence.

 Les valeurs possibles de x sont comprises entre 1 et Nx@.
}

property TrevCorAnalysis.Ypos(i:longint):longint readOnly;
{$H Renvoie la position Y de la ième stimulation de la séquence.

 Les valeurs possibles de y sont comprises entre 1 et Ny@.
}

property TrevCorAnalysis.Zpos(i:longint):longint readOnly;
{$H Renvoie la valeur Z de la ième stimulation de la séquence.

 Les valeurs possibles de Z sont 1 ou 2.
}


function TrevCorAnalysis.encode(x,y,z:longint):longint;
{$H Donne le code associé à un triplet (x,y,z) .

 Ce code est donné par (z-1)+2*(y-1+Ny*(x-1))

 Le code est compris entre 0 et 2*Nx*Nz-1 .
}
procedure TrevCorAnalysis.decode(code:longint;var x,y,z:longint);
{$H Décode le code associé à un triplet pour donner chacune des
composantes x, y et z .

 Voir encode@ .
}

procedure TrevCorAnalysis.initPstw(var vec1,vec2:TaverageArray;var source:Tvector;x1,x2:real);
{$H Initialise les Pstws (post-stimulus waveforms)

 v1 et v2 sont deux objets de type TaverageArray@ . Ces objets doivent simplement avoir
été créés en appelant leur constructeur create avec des paramètres quelconques,
mais n'ont pas besoin d'être initialisés avec initObjects.

 source est le vecteur contenant le signal qui sera moyenné.
 x1 et x2 définissent l'extension des moyennes du tableau.

 Cette procédure est équivalente à la suite d'instructions suivante:

 vec1.modify(1,Nx@,1,Ny@);
 vec1.initObject(t_single,x1/source.dxu,x2/source/dxu);
 vec2.modify(1,Nx@,1,Ny@);
 vec2.initObject(t_single,x1/source.dxu,x2/source/dxu);

 Après InitPstw, on peut appeler une ou plusieurs fois calculatePstw@ .
}
procedure TrevCorAnalysis.calculatePstw;
{$H Calcul des Pstws (post-stimulus waveforms)

 Auparavant, il faut avoir appelé InitPstw@ pour initialiser deux tableaux de
moyennes vec1 et vec2.

 Il faut également avoir initialisé la séquence de corrélation avec installStimSeq@ et
installTimes@ .

 Pour chaque stimulus (x,y,z,t) de la séquence, la portion du signal source comprise entre
t+x1 et t+x2 (voir initPstw@ ) est accumulée dans la moyenne (x,y) du tableau vec1
si z=1 ou dans la moyenne (x,y) du tableau vec2 si z=2 .

}

procedure TrevCorAnalysis.initPstac(var cor1,cor2:TcorrelogramArray;i1,i2:longint;binWidth,x1,x2:real);
procedure TrevCorAnalysis.calculatePstac;

function FindRevCorSeed(var seed:integer;nbDivX,nbDivY,expansion,scotome:integer;var Vcode:Tvector):boolean;
{$H Trouve le seed correspondant à une séquence de corrélation

 nbDivX et nbDivY sont les nombre de divisions de la grille suivant X et Y en
l'absence de facteur d'expansion.
 expansion est un facteur d'expansion appliqué à la grille. Il est exprimé en
pourcentage. 100 correspond donc à une grille non modifiée.
 scotome définit une zone centrale exclue de la stimulation. Ce paramètres est
exprimé en pourcentage. 0 correspond donc à une grille non modifiée.
 Vcode doit contenir les codes de la séquence (on peut utiliser encode@ pour les
obtenir).

 La fonction renvoie TRUE si une valeur possible a été trouvée. Dans ce cas, seed
contient la valeur cherchée.

}


procedure TrevCorAnalysis.initPsdMat(var m1,m2:TmatrixArray;var source:Tvector;x1,x2,dx1:real;Nfft0,Nb,WinDowMode:integer;Mode:integer);
procedure TrevCorAnalysis.CalculatePsdMat;
procedure TrevCorAnalysis.NormPsdMat;

procedure TrevCorAnalysis.InitResponses(var source:Tvector;var va1,va2:TvectorArray;x1,x2:real;tp:integer);
{$H Initialise deux objets TvectorArray dans le but d'utiliser la méthode Responses@ .

 Les dimensions de la grille de va1 et va2 sont ajustées pour correspondre à la grille de
stimulation.
 Les vecteurs de va1 et va2 sont initialisés de la façon suivante:
   - le type des données est tp.
   - les paramètres d'échelles sont ceux du vecteur source.
   - les indices Istart et Iend sont respectivement round(x1/source.dx) et round(x2/source.dy)

 Ensuite, quand on appelle responses@ , il faut utiliser les mêmes paramètres.  
}

procedure TrevCorAnalysis.Responses(var source:Tvector;var va1,va2:TvectorArray;x1,x2:real;mode:integer);
{$H Calcule les réponses pour chaque pixel de la grille de stimulation.

 En entrée, source contient des données correspondant à une séquence de corrélation. Il peut
s'agir des données brutes ou bien de données transformées. Source peut contenir des nombres
complexes.

 En sortie, va1 et va2 contiennent les réponses synchronisées sur chaque stimulus de la grille.
 va1 et va2 correspondent aux deux luminances utilisées.
  Les vecteurs ont pour abscisses limites x1 et x2. Leur origine étant calée sur le stimulus.


}

procedure TrevCorAnalysis.Responses1( var seqs,evts:TVlist;var seeds:Tvector;
                                      var va1,va2:TvectorArray;
                                      x1,x2,dx1:real;mode:integer);

procedure TrevcorAnalysis.getMatXYZ(var mat1,mat2: Tmatrix);
{$H Calcule deux matrices contenant les dates des stimulus pour une séquence de stimulation.

 En sortie, les matrices ont pour dimensions (1..nx@ , 1..ny@)
 mat1 contient les dates des stimulus de type 1 (Zpos@=1)
 mat2 contient les dates des stimulus de type 2 (Zpos@=2)

 Les dates sont exprimées en coordonnées fichier. Ce sont donc les indices des points
du vecteur source pour lesquels une barre s'est allumée.
 Pour obtenir la date d'allumage du pixel (x,y) pour une barre de type 1 (respectivement de type 2),
il suffit d'utiliser la relation :
              t:= Vsource.convx(mat1.Jvalue[x,y])

}

procedure TrevCorAnalysis.getCodes(var vec:Tvector;num:integer);
{$H Renvoie un vecteur permettant de retrouver tous les codes d'une stimulation
survenue num tops synchro avant ou après une stimulation donnée.

 Le vecteur vec obtenu est indicé de 0 à nx*ny*2-1

 Les codes sont des nombres compris entre 0 et nx*ny*2-1 et correspondent à des triplets (x,y,z).
 Ils sont gérés par les méthodes decode@ et encode@ .

 Les valeurs de Num positives correspondent à des stimulations postérieures à la stimulation donnée.
 Les valeurs de Num négatives correspondent à des stimulations antérieures à la stimulation donnée.
 La valeur num=0 n'a pas d'intérêt.

 Exemple: on appelle getCodes avec Num=-1
 Le vecteur vec permet de répondre à la question: quel est le stimulus (x1,y1,z1) qui a immédiatement précédé
l'allumage du pixel (x,y,z). En effet, il suffit d'écrire:

 @f6  code:=encode(x,y,z);
 @f6  if code>=0 then
 @f6  begin
 @f6    CodePrecedent:=vec.Jvalue[code];
 @f6    decode(codePrecedent,x1,y1,z1);
 @f6  end;

 Quand le code cherché n'existe pas (dans l'exemple ci-dessus, le premier stimulus n'a pas de précédent),
le code rangé dans le vecteur vaut -1 .
}

{******************************************************************************}


procedure SelectEvents(var source,dest,Csource,Cdest:Tvector;Cmin,Cmax:real);
{$H Sélectionne des événements dans un vecteur.

 Source est un vecteur d'événements (suite de dates croissantes).
 Csource est un vecteur contenant des valeurs associées à chaque événement du
vecteur Source. Il doit donc y avoir autant de valeurs dans Csource que dans source.

 Le vecteur dest sera rempli avec les événements du vecteur source satisfaisant
aux conditions:
     Csource.Yvalue[i]>=Cmin
     Csource.Yvalue[i]<Cmax

 Le vecteur Cdest sera rempli avec les valeurs du vecteur Csource satisfaisant aux
mêmes conditions.

 Pour effectuer la sélection directement dans les vecteurs source, il faut utiliser
SelectEvents1@ .
}
procedure SelectEvents1(var source,Csource:Tvector;Cmin,Cmax:real);
{$H Sélectionne des événements dans un vecteur.

 Source est un vecteur d'événements (suite de dates croissantes).
 Csource est un vecteur contenant des valeurs associées à chaque événement du
vecteur Source. Il doit donc y avoir autant de valeurs dans Csource que dans source.

 En sortie de procédure, les deux vecteurs ne contiendront que les événements du
satisfaisant aux conditions:
     Csource.Yvalue[i]>=Cmin
     Csource.Yvalue[i]<Cmax

 Pour envoyer la sélection dans des vecteurs différents des vecteurs sources, il                
faut utiliser SelectEvents@ .
}


                            { TwaveFile stmWav1 }

procedure TwaveFile.createFile(fileName:string);
procedure TwaveFile.createFile(fileName:string; SamplePerSec: Integer);
{$H Création du fichier.

 FileName est le nom du fichier.
 SamplePerSec est la fréquence d'échantillonnage souhaitée. Par défaut, sa valeur 11025.
 Toutes les fréquences ne sont pas autorisées. Les valeurs les plus courantes sont 11025 , 22050 et 44100

}
procedure TwaveFile.saveVector(var v:Tvector);
{$H Sauve les données du vecteur v dans le fichier.

 On suppose que l'échelle des temps est en secondes. Le vecteur est ré-échantillonné
pour que sa fréquence corresponde à celle qui a été donnée dans CreateFile@

}
procedure TwaveFile.save2Vectors(var v1,v2:Tvector);
{$H Sauve les données des vecteur v1 et v2 dans le fichier.

 On suppose que l'échelle des temps est en secondes. Les vecteurs sont ré-échantillonnés
pour que leur fréquence corresponde à celle qui a été donnée dans CreateFile@


}

procedure TwaveFile.OpenFile(fileName:string);
{$H Ouvre un fichier audio existant.

 fileName est le nom du fichier
 Ensuite, la seule opération est la lecture avec play@
}

procedure TwaveFile.Play;
{$H Joue le fichier ouvert avec OpenFile@ sur le haut-parleur du PC
}

                            { TVList0 stmVlist0 }

function TVList0.count:longint;
{$H Renvoie le nombre de vecteurs de la liste.
}
property TVList0.FirstLine:longint;
{$H Numéro du premier vecteur affiché.

  La fenêtre d'affichage contient au maximum lineCount@ vecteurs, le premier de
ces vecteurs a pour numéro FirstLine.

  Les numéros commencent à 1 .

  FirstLine est identique à la propriété Index@
}
property TVList0.Index:integer;
{$H Numéro du vecteur de la liste accessible à travers la propriété CurVec@

  Les numéros commencent à 1 .

  Index est identique à FirsLine@
}

property TVList0.LineCount:longint;
{$H Nombre de vecteurs affichés dans la fenêtre.
}

property TVlist0.dxWF:real;
{$H Décalage des traces selon X

 dxWF est exprimé en pourcentage de la dimension horizontale de la fenêtre
d'affichage et peut être positif ou négatif.
 Quand dxWF est différent de zéro, l'affichage est décalé selon X à chaque ligne de la
grille.

}
property TVlist0.dyWF:real;
{$H Décalage des traces selon Y

 dyWF est exprimé en pourcentage de la dimension verticale de la fenêtre
d'affichage et peut être positif ou négatif.
 Quand dyWF est différent de zéro, l'affichage est décalé selon Y à chaque colonne de la
grille.
}

property TVlist0.showNumbers:boolean;
{$H Détermine l'affichage des numéros de vecteur sur la gauche de la fenêtre
d'affichage.
}

property TVlist0.showSelection:boolean;
{$H Détermine l'affichage de la sélection.

}

property TVlist0.selected(n:integer):boolean;
{$H Permet de lire ou de modifier l'état de sélection du vecteur de numéro n.

  Chaque vecteur de la liste peut être sélectionné au moyen de la souris
ou bien en affectant cette propriété.

}

property TVlist0.OnSelect:TVlistSelect;
{$H Gestionnaire d'événement appelé quand l'utilisateur clique sur un numéro de la liste.


  OnSelect doit recevoir une procédure conforme à la déclaration suivante:
  TVlistSelect=procedure( var Vlist:TVlist0;n:integer);

 @f6   Exemple:
 @f6   procedure myOnselect(var Vlist:TVlist;n:integer);
 @f6   begin
 @f6
 @f6   end;

 Vlist est l'objet qui a généré l'événement. Le gestionnaire peut donc servir à plusieurs
objets.
 n  est l'indice du vecteur qui vient d'être sélectionné ou désélectionné.
}

property TVlist0.CpLine:integer;
{$H Coefficient de couplage pour FirstLine@
}

Property TVlist0.UseLevel:boolean;
Property TVlist0.XLevel:real;
Property TVlist0.YLevel:real;

Property TVlist0.DisplayMode:integer;
{$H Mode d'affichage pour TVlist

  Les valeurs possibles sont:
    0: Affichage standard
    1: L'échelle verticale contient les numéros des vecteurs
    2: Pas d'échelle verticale
}

                            { TsyncList stmSyncC }

procedure TsyncList.create(stName:string;var source,events:Tvector);
procedure TsyncList.create(var source,events:Tvector);

                            { TVList VlistA1 }

procedure TVList.create(stName:string);
procedure TVList.create;
{$H Constructeur de l'objet TVlist

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 La liste est vide. La propriété count@ vaut zéro.
}


procedure TVList.addVector(var vec:Tvector);
{$H Ajoute le vecteur vec à la fin de la liste.

 Le vecteur vec est d'abord cloné et la copie obtenue est rangée à la fin de la liste.

 La propriété Count@ est incrémentée de une unité.
}
procedure TVList.insertVector(num:integer;var vec:Tvector);
{$H Insère un vecteur dans la liste

 Num doit être compris entre 1 et count@

 Tous les vecteurs de la liste de numéro égal ou supérieur à num voient leur numéro incrémenté de une unité.
 Le vecteur vec est ensuite cloné et la copie obtenue est rangée à l'emplacement libéré.

 La propriété count@ est incrémentée de une unité.
}

procedure TVList.deleteVector(num:integer);
{$H Détruit le vecteur de numéro Num.

 Num est compris entre 1 et count@

 Les numéros des vecteurs suivants sont décrémentés de une unité.
 La propriété count@ est également décrémentée.
}
procedure TVlist.clear;
{$H Détruit tous les vecteurs de la liste
}

property TVlist.V(num:integer):Tvector readOnly default;
{$H Permet de manipuler n'importe quel vecteur de la liste.

 Num doit être compris entre 1 et count.
}
property TVlist.CurVec:Tvector readOnly;
{$H Vecteur désigné par la propriété Index@

 Le contenu de ce vecteur change quand la propriété Index@ est modifiée.

 Voir aussi v@
}

procedure TVlist.medianVector(var vec:Tvector);
{$H Calcule la médiane de tous les vecteurs de la liste.

 Tous les vecteurs de la liste doivent avoir la même structure.
}

procedure TVList.MaxVector(var vec:Tvector);
{$H Calcule le maximum point par point de tous les vecteurs de la liste.

 La mesure est faite sur le premier point de tous les vecteurs, puis sur le deuxième point, etc...

 Tous les vecteurs de la liste doivent avoir la même structure.
}

procedure TVList.MinVector(var vec:Tvector);
{$H Calcule le minimum point par point de tous les vecteurs de la liste.

 La mesure est faite sur le premier point de tous les vecteurs, puis sur le deuxième point, etc...

 Tous les vecteurs de la liste doivent avoir la même structure.
}

procedure TVList.MeanVector(var vec:Tvector);
{$H Calcule la moyenne point par point de tous les vecteurs de la liste.

 La mesure est faite sur le premier point de tous les vecteurs, puis sur le deuxième point, etc...

 Tous les vecteurs de la liste doivent avoir la même structure.
}

procedure TVList.StdDevVector(var vec:Tvector);
{$H Calcule la standard deviation point par point de tous les vecteurs de la liste.

 La mesure est faite sur le premier point de tous les vecteurs, puis sur le deuxième point, etc...
 
 Tous les vecteurs de la liste doivent avoir la même structure.
}



property TVlist.UseVparams:boolean;
{$H Indique quels paramètres d'affichage utiliser.

 Par défaut, UseVparams vaut FALSE et l'objet TVlist utilise ses propres paramètres d'affichage.

 Si UseVparams vaut TRUE, chaque vecteur utilisera ses propres paramètres d'affichage.

 Les paramètres concernés sont: color@, color2@, Mode@, SymbolSize@ et lineWidth@


}


                            { Taverage stmAve1 }

procedure Taverage.create(stName:string;tp:integer;n1,n2:longint);
procedure Taverage.create(tp:integer;n1,n2:longint);
{$H Constructeur de l'objet Taverage.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 tp indique le (type de nombre)@(types de nombre) . Les types autorisés sont les
mêmes que pour Tvector@ mais il est recommandé d'utiliser un type réel (t_single
ou T_extended).

 n1 et n2 sont les indices de début et de fin du vecteur moyenne.
 Ces indices seront automatiquement adaptés au vecteur moyenné si l'on utilise la
méthode add@ ( mais pas addEx@ ) .
}


procedure Taverage.add(var v:Tvector);
{$H Accumule le vecteur v dans l'objet Taverage.

 Si v est le premier vecteur moyenné (donc count@ = 0 ), les propriétés Istart, Iend,
Dx et x0 de l'objet Taverage deviennent égales aux propriétés correspondantes de v.

 Si l'on a affecté stdON@ à TRUE, il peut être intéressant d'utiliser add1@ .
}

procedure Taverage.add1(var v:Tvector);
{$H Accumule le vecteur v dans l'objet Taverage.

 Si v est le premier vecteur moyenné (donc count@ = 0 ), les propriétés Istart, Iend,
Dx et x0 de l'objet Taverage deviennent égales aux propriétés correspondantes de v.

 L'effet de add1 est le même que celui de add@ mais le calcul des déviations standard
est optimisé. Add1 ne calcule que le vecteur Vsqrs@ . Une fois que Add1 a été appelé
pour chaque vecteur que l'on souhaitait moyenner, il faut appeler UpdateStdDev@ pour
compléter le calcul des déviations standard et des vecteurs associés.
}

procedure Taverage.UpdateStdDev;
{$H Complète le calcul des déviations standard et des vecteurs associés.

 Voir Add1@ .
}

procedure Taverage.addEx(var v:Tvector;xorg:real);
{$H Accumule le vecteur v dans l'objet Taverage en prenant le point d'abscisse
xorg comme origine dans v.

 Dans l'opération d'accumulation, le point d'abscisse xorg sera donc ajouté au point
d'abscisse 0 dans Taverage.
 Contrairement à ce qui se passe avec add@, la structure de l'objet n'est jamais
modifiée.
}

procedure Taverage.addEx1(var v:Tvector;xorg:real);
{$H Accumule le vecteur v dans l'objet Taverage en prenant le point d'abscisse
xorg comme origine dans v.

 Dans l'opération d'accumulation, le point d'abscisse xorg sera donc ajouté au point
d'abscisse 0 dans Taverage.
 Contrairement à ce qui se passe avec add@, la structure de l'objet n'est jamais
modifiée.

 L'effet de addEx1 est le même que celui de addEx@ mais le calcul des déviations standard
est optimisé. AddEx1 ne calcule que le vecteur Vsqrs@ . Une fois que AddEx1 a été appelé
autant de fois que nécessaire, il faut appeler UpdateStdDev@ pour compléter le calcul
des déviations standard et des vecteurs associés.
}
procedure Taverage.reset;
{$H Remise à zéro de la moyenne.
 Le vecteur moyenne est rempli avec des zéros et la propriété count@ reçoit la valeur zéro.
}

property Taverage.count:longint;
{$H Contient le nombre de vecteurs moyennés.

 Est remis à zéro par reset@
}

property Taverage.Finvalidate:boolean;
{$H Indique s'il faut appeler la procédure invalidate après chaque calcul.

 Cette propriété vaut True par défaut.
 En la fixant à false, on peut accélérer sensiblement les calculs dans certaines situations.
}

property Taverage.StdOn:boolean;
{$H Si stdOn est vrai, les vecteurs VSqrs, VStdDev, VStdUp et VStdDw seront calculés.

La propriété vaut False par défaut. Elle doit être mise en place avant de commencer
un calcul de moyenne.
}

Property Taverage.VSqrs:Tvector readOnly;
{$H Ce vecteur contient la somme des carrés des vecteurs moyennés.
 Son utilité est sans doute assez réduite mais son existence est nécessaire au calcul
de VStdDev@ , VstdUp@ et VstdDw@ .
}
Property Taverage.VStdDev:Tvector readOnly;
{$H Ce vecteur contient l'écart-type des vecteurs moyennés.
L'amplitude de chaque point d'indice i du vecteur VstdDev est donné par l'expression

    ys[i]= sqrt( sum( sqr(y[i]-ym[i]))/(N-1) )

 où:
 sqrt désigne la racine carrée
 sum désigne la somme effectuée sur tous les vecteurs moyennés.
 y[i] est l'amplitude d'un vecteur à l'indice i
 ym[i] est l'amplitude  moyenne à l'indice i
 N est le nombre de vecteurs moyennés.
}
Property Taverage.VStdUp:Tvector readOnly;
{$H Ce vecteur contient le vecteur moyenne augmenté de l'écart-type VstdDev@ des
vecteurs moyennés.

 Si ce vecteur est affiché dans la même fenêtre que le vecteur moyenne et le vecteur
VstdDw@ , on visualise commodément la distribution des vecteurs moyennés.
}
Property Taverage.VStdDw:Tvector readOnly;
{$H Ce vecteur contient le vecteur moyenne diminué de l'écart-type VstdDev@ des
vecteurs moyennés.

 Si ce vecteur est affiché dans la même fenêtre que le vecteur moyenne et le vecteur
VstdUp@ , on visualise commodément la distribution des vecteurs moyennés.
}



                    { Tdac2file dac2File }

procedure Tdac2file.create(stName:string);
procedure Tdac2file.create;
{$H Constructeur de l'objet Tdac2file.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
}
property Tdac2file.ChannelCount:integer;
{$H Nombre de voies multiplexées du fichier.

 Sa valeur est 1 par défaut. Si on la change, il faut fixer la nouvelle valeur avant
d'appeler setChannel@ .
}

property Tdac2file.TagChannelCount:integer;
{$H Nombre de voies Tag du fichier.

 Sa valeur est 0 par défaut. Si on la change, il faut fixer la nouvelle valeur avant
d'appeler setTagChannel@ .

 On ne peut ajouter des voies tags que si les vecteurs sauvegardés sont du type Integer
et que si les données tiennent sur douze bits. Ajouter des tags permet de créer
des fichiers ayant la même structure qu'en acquisition.
}

property Tdac2file.Xorg:real;
{$H Abscisse réelle du premier point sauvé au moment de la relecture.

 Autrement dit, quand on chargera le fichier dans DAC2, toutes les voies auront leur
propriété x0 égale à Xorg.

 Par défaut Xorg est égal à zéro.
}
property Tdac2file.Continuous:boolean;
{$H Permet de créer un fichier continu.

 Il n'y a en fait pas de différence entre un fichier continu et un fichier de séquences
contenant une seule séquence. Toutefois, pour un fichier continu, les appels successifs à
la méthode Save@ n'auront pas pour effet de créer une nouvelle séquence mais ajouteront les
données à la suite de celles qui sont déjà stockées sans tenir compte des abscisses
des nouvelles données.


 Continuous vaut false par défaut. Il faut modifier sa valeur avant d'appeler CreateFile.
}

procedure Tdac2file.setChannel(num:integer;var v:Tvector;x1,x2:real);
{$H Définit les données qui seront sauvées sur la voie num.

 num doit être compris entre 1 et ChannelCount@ .
 v est n'importe quel vecteur.

 x1 et x2 sont les abscisses de début et de fin de la partie du vecteur qui devra
être sauvée.
}

procedure Tdac2file.setTagChannel(num:integer;var v:Tvector;x1,x2,threshold:real);
{$H Définit les données qui seront sauvées sur la voie tag num.

 num doit être compris entre 1 et TagChannelCount@ .
 v est n'importe quel vecteur.
 Le bit de la voie tag est mis à 1 si v.Yvalue est supérieur ou égal à Threshold
et est mis à zéro dans le cas contraire.

 x1 et x2 sont les abscisses de début et de fin de la partie du vecteur qui devra
être sauvée.
}

procedure Tdac2file.createFile(FileName:String);
{$H Crée un nouveau fichier de nom FileName.

 st est le nom complet du fichier (avec chemin d'accès et extension).

 Si le fichier existe déjà, il est effacé. L'entête du fichier est écrite sur
le disque à cet instant, ainsi que le bloc d'information utilisateur s'il existe.

}
procedure Tdac2file.Append(st:String);
{$H Ouvre le fichier de nom st et place le pointeur d'écriture à la fin du fichier.

 st est le nom complet du fichier (avec chemin d'accès et extension).

 Les opérations d'écriture qui suivront (au moyen de la méthode save@ ) ajouteront des
données à la suite de celles qui existent déjà dans le fichier. Ces nouvelles données
doivent être compatibles avec les précédentes sinon une erreur est générée.

}


procedure Tdac2file.save;
{$H sauve les données dans le fichier.

}

procedure Tdac2file.close;
{$H Ferme le fichier

 Le fichier est automatiquement fermé quand l'objet est détruit ou recréé mais
il est préférable d'appeler close à chaque fois que l'on considère que l'on n'a plus
rien à écrire.
}

{procedure Tdac2file.GetEpInfo(var x;dep:longint);}
{Permet de lire une variable dans le bloc d'informations séquence.
 A peu d'intérêt actuellement.

 Voir setEpInfo@ .
}
procedure Tdac2file.SetEpInfo(var x;dep:longint);
{$H Permet de ranger une variable dans le bloc d'informations séquence.

 La variable est rangée à l'offset dep.
 Pour ne pas avoir à gérer des offsets, il est préférable d'utiliser writeEpInfo@ .
}
{procedure Tdac2file.ReadEpInfo(var x);}

procedure Tdac2file.WriteEpInfo(var x);
{$H Permet d'écrire la variable x dans le bloc d'informations séquence.

 Pour ranger une série de variables, on appelle d'abord resetEpInfo@ qui positionne
un pointeur d'écriture au début du bloc. Puis pour chaque variable, on appelle writeEpInfo .
Ainsi, les variables sont rangées dans le bloc d'une façon compacte, les unes après les
autres.

Pour la relecture, on peut utiliser les méthodes readEpInfo de TdataFile@ par exemple.

}
procedure Tdac2file.ResetEpInfo;
{$H Positionne un pointeur d'écriture au début du bloc d'information séquence.

Il est nécessaire d'appeler cette méthode avant une série de writeEpInfo@ .
}
procedure Tdac2file.GetFileInfo(var x;dep:longint);
{$H Permet de lire une variable rangée à l'offset dep dans le bloc d'informations fichier.

 Pour ne pas avoir à gérer des offsets, il est préférable d'utiliser readFileInfo@ .

 Les opérations de lectures d'informations peuvent être utiles si on ouvre un fichier
avec Append@ .
}
procedure Tdac2file.SetFileInfo(var x;dep:longint);
{$H Permet de ranger une variable dans le bloc d'informations fichier.

 La variable est rangée à l'offset dep.
 Pour ne pas avoir à gérer des offsets, il est préférable d'utiliser writeFileInfo@ .
}
procedure Tdac2file.ReadFileInfo(var x);
{$H Permet de lire une variable dans le bloc d'informations fichier.

 Pour lire une série de variables, on appelle d'abord resetFileInfo@ qui positionne
un pointeur d'écriture au début du bloc. Puis pour chaque variable, on appelle readFileInfo .
Les variables doivent être lues dans le même ordre que pendant l'écriture.

 Les opérations de lectures d'informations peuvent être utiles si on ouvre un fichier
avec Append@ .
}

procedure Tdac2file.WriteFileInfo(var x);
{$H Permet d'écrire la variable x dans le bloc d'informations fichier.

 Pour ranger une série de variables, on appelle d'abord resetFileInfo@ qui positionne
un pointeur d'écriture au début du bloc. Puis pour chaque variable, on appelle writeFileInfo .
Ainsi, les variables sont rangées dans le bloc d'une façon compacte, les unes après les
autres.

Pour la relecture, on peut utiliser les méthodes readFileInfo de TdataFile@ par exemple.
}

procedure Tdac2file.ResetFileInfo;
{$H Positionne un pointeur d'écriture au début du bloc d'information fichier.

Il est nécessaire d'appeler cette méthode avant une série de writeFileInfo@ .
}
property Tdac2file.EpInfoSize:longint;
{$H Taille du bloc d'information séquence.

 Si on affecte cette propriété (ce qu'il faut faire avant d'appeler CreateFile),
un bloc d'informations de taille EpInfoSize sera sauvé après chaque séquence.
 Pour ranger des informations dans ce bloc, il faut utiliser writeEpInfo@ .
}
property Tdac2file.FileInfoSize:longint;
{$H Taille du bloc d'information fichier

 Si on affecte cette propriété (ce qu'il faut faire avant d'appeler CreateFile),
un bloc d'informations sera sauvé immédiatement après l'entête standard.
Ce bloc a pour taille FileInfoSize + 18 octets.
 Pour ranger des informations dans ce bloc, il faut utiliser writeFileInfo@ .
}
procedure Tdac2file.addMtag(time:real;code:integer);
procedure Tdac2file.allocMtag(nb:longint);


                    { Tcursor stmCurs }

procedure Tcursor.create(stName:string);
procedure Tcursor.create;
{$H Constructeur de l'objet Tcursor.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
}
Property Tcursor.position1:real;
{$H Définit la position du curseur.

 Voir Position@ .
}
Property Tcursor.position2:real;
{$H Définit la position du second curseur quand le curseur est double.

  Voir Position@ .
}
Property Tcursor.position(i:integer):real;
{$H Définit la position du curseur.

 i vaut obligatoirement 1 pour les curseurs simples et peut valoir 1 ou 2 pour les
curseurs doubles@doubleCursor .

 La signification de cette valeur dépend du style@ de curseur.

 En style X ou Y, la propriété position reflète effectivement l'abscisse ou l'ordonnée
du curseur.

 En style Index, la propriété position contient l'indice du point du vecteur.
 Si l'on veut connaitre ou modifier l'abscisse ou l'ordonnée correspondante,
il faut utiliser respectivement les propriétés Xposition@ et Yposition@ .

 Position1@ est équivalent à position[1] .
 Position2@ est équivalent à position[2] .

}
Property Tcursor.Xposition(i:integer):real;
{$H Quand le curseur est utilisé en style@ Index, Xposition représente l'abscisse
réelle du point désigné par le curseur.

 En effet, en style Index, Position@ représente l'indice du point alors que Xposition
et Yposition@ sont les ccoordonnées réelles du point.

 i vaut obligatoirement 1 pour les curseurs simples et peut valoir 1 ou 2 pour les
curseurs doubles@doubleCursor .

 XPosition1@ est équivalent à Xposition[1] .
 XPosition2@ est équivalent à Xposition[2] .

}
Property Tcursor.Xposition1:real;
{$H Représente l'abscisse réelle du point désigné par le curseur en style@ index.

 Voir Xposition@ .
}
Property Tcursor.Xposition2:real;
{$H Représente l'abscisse réelle du point désigné par le second curseur en style@ index,
pour les curseurs doubles@doubleCursor .

 Voir Xposition@ .
}

Property Tcursor.Yposition(i:integer):real;
{$H Quand le curseur est utilisé en style@ Index, Yposition représente l'ordonnée
réelle du point désigné par le curseur.

 En effet, en style Index, Position@ représente l'indice du point alors que Xposition@
et Yposition sont les ccoordonnées réelles du point.

 i vaut obligatoirement 1 pour les curseurs simples et peut valoir 1 ou 2 pour les
curseurs doubles@doubleCursor .

 YPosition1@ est équivalent à Yposition[1] .
 YPosition2@ est équivalent à Yposition[2] .

}
Property Tcursor.Yposition1:real;
{$H Représente l'ordonnée réelle du point désigné par le curseur en style@ index.

 Voir Yposition@ .
}
Property Tcursor.Yposition2:real;
{$H Représente l'ordonnée réelle du point désigné par le second curseur en style@ index,
pour les curseurs doubles@doubleCursor .

 Voir Yposition@ .
}

Property Tcursor.posMin:real;
Property Tcursor.posMax:real;

Property Tcursor.SmallIncrement:real;
{$H Petit incrément de la barre de défilement dans la fenêtre curseur.

 Voir LargeIncrement@ .
}
Property Tcursor.LargeIncrement:real;
{$H Grand incrément de la barre de défilement dans la fenêtre curseur.

 Voir SmallIncrement@ .
}
Property Tcursor.TrackSource:boolean;
{$H Si TrackSource vaut True, le système s'efforcera de garder le curseur visible
quand l'utilisateur modifie ses coordonnées.

 Autrement dit, si le curseur sort de la fenêtre dans laquelle il s'affiche, les
coordonnées de l'objet TdataPlot associé seront modifiées pour suivre le
déplacement.
}
Property Tcursor.visible:boolean;
{$H Définit la visibilité du curseur.

 Par défaut, Visible vaut false. Il ne faut pas oublier de fixer la propriété à
True pour rendre le curseur visible.
}
Property Tcursor.style:integer;
{$H Style du curseur.

 Il y a trois styles possibles, définis par les (constantes de style)@(Styles de curseur)

 En style X ou Y, le curseur ne tient pas compte des données contenues dans
l'objet source, sa propriété position@ reflète effectivement l'abscisse ou l'ordonnée
du curseur.
 En style Index (applicable seulement aux descendants de Tvector), le curseur se place
obligatoirement sur un point de l'objet source et sa propriété position@ contient l'indice
de ce point.

}
Property Tcursor.WinContent:integer;
{$H Définit le contenu de la fenêtre du curseur.

 Il est souhaitable d'utiliser les (constantes associées)@(Affichage des curseurs) .

}
Property Tcursor.color:longint;
{$H Couleur du curseur.
}
Property Tcursor.CaptionColor:longint;
{$H Couleur de la poignée du curseur
}

procedure Tcursor.InstallSource(var plot:Tdataplot);
{$H Permet de sélectionner l'objet sur lequel se déplace le curseur.

 Quand on crée un curseur, il est préférable de fixer d'abord toutes ses propriétés
puis d'appeler la méthode InstallSource en dernier.
}

procedure Tcursor.InstallZoom(var plot:Tdataplot);
{$H Après l'appel de cette méthode, les coordonnées de l'objet plot fourni comme paramètre
se modifieront automatiquement afin de pouvoir afficher le curseur au centre de la
fenêtre d'affichage.
}
Property Tcursor.title:string;
{$H Titre apparaissant dans la fenêtre du curseur.
}
Property Tcursor.doubleCursor:boolean;
{$H Quand doubleCursor vaut true, on peut manipuler deux curseurs avec le même objet.
}
Property Tcursor.decimal:integer;
{$H Nombre de décimales pour l'affichage dans la fenêtre du curseur.
}
Property Tcursor.WindowWidth:integer;
{$H Largeur de la fenêtre du curseur en pixels.
}

Property Tcursor.OnChange:Tprocedure1;
{$H Gestionnaire d'événement appelé à chaque fois que l'utilisateur déplace le curseur.

 TProcedure1 est une procédure ayant un seul paramètre de type longint.

 Le paramètre transmis est le tag du curseur.
}
function Tcursor.showModal:integer;
{$H Ouvre la fenêtre du curseur d'une façon modale, c'est à dire que l'utilisateur
sera obligé de fermer cette fenêtre avant de continuer une autre tâche.
}
property Tcursor.OnClick:Tprocedure1;
{$H Gestionnaire d'événement appelé à chaque fois que l'utilisateur clique sur la
poignée du curseur.

 TProcedure1 est une procédure ayant un seul paramètre de type longint.

 Le paramètre transmis est le tag du curseur.
}

property Tcursor.Locked:boolean;
{$H Quand Locked vaut true, l'utilisateur ne peut pas changer la place du curseur
au moyen de la souris.
}


procedure CurseurX(var v:Tvector;var x:real;title:String);
/cursorX
{$H La procédure crée un objet de type Tcursor en style X,
avec pour source le vecteur v, pour titre la chaine title et pour position la valeur x .
 Elle rend ensuite le curseur visible et ouvre sa fenêtre de façon modale.

 Quand la fenêtre se referme, la variable x contient la position finale du curseur.
}

procedure CurseurY(var v:Tvector;var x:real;title:String);
/cursorY
{$H La procédure crée un objet de type Tcursor en style Y,
avec pour source le vecteur v, pour titre la chaine title et pour position la valeur x .
 Elle rend ensuite le curseur visible et ouvre sa fenêtre de façon modale.

 Quand la fenêtre se referme, la variable x contient la position finale du curseur.
}


                    { TimageVector stmVzoom }

procedure TimageVector.create(stName:String;var source:Tvector);
procedure TimageVector.create(var source:Tvector);
procedure TimageVector.installSource(v:Tvector);



                    { TMtag Mtag1 }

property TMtag.times(i:longint):real readOnly;
{$H Renvoie la date réelle du tag manuel d'indice i.
}
property TMtag.Itimes(i:longint):longint readOnly;
{$H Renvoie la date du tag manuel d'indice i, exprimée en intervalles
d'échantillonnage.
}

property TMtag.codes(i:longint):longint readOnly;
{$H Renvoie le code du tag manuel d'indice i.
}

property TMtag.color(cc:integer):longint readOnly;
{$H Renvoie la couleur des tags manuels de code cc.
}


                    { FFT stmFFT }
procedure FFT(var source,dest:Tvector;x1,x2:real;Nb:integer);
{$H Calcule la FFT (Fast Fourier Transform) d'un vecteur.

 Utilisez de préférence la procedure DFT@ qui est plus récente et plus générale.

 Source contient les données à analyser
 Dest recevra le module de la transformée de Fourier. Le type des nombres de
Dest doit de préférence être un type réel.

 x1 et x2 délimitent la région de la source à analyser.

 Nb est le nombre de points du vecteur FFT. C'est aussi le nombre effectif de données
fournies à la procédure de calcul. L'algorithme utilisé (méthode de Cooley-Tukey) exige
que ce nombre soit une puissance de 2.
 Nb doit donc être choisi parmi les valeurs: 2, 4, 8, 16, 32, 64, 128, 256, 512,
1024, 2048, 4096, 8192, 16384 ou 32768.

 Les valeurs de la source utilisées dans le calcul sont choisies de la façon suivante:

 Soit Ndata le nombre de données comprises entre x1 et x2.
 Si Ndata<Nb, on prend les Ndata données et on complète avec un nombre de zéros suffisant
pour obtenir Nb données.
 Si  nb<=Ndata<2*Nb , les nb premières données à partir de x1 sont utilisées.
 Si  2*nb<=Ndata<3*Nb , on choisit un point sur deux de la source en commençant en x1.
 Si  3*nb<=Ndata<4*Nb , on choisit un point sur trois de la source en commençant en x1.
 Etc...

 La première situation (Ndata<nb) est la plus favorable. Il est donc recommandé de
choisir la valeur de nb admissible qui est juste supérieure ou égale à Ndata .

 On considère par défaut que les abscisses du vecteur source sont exprimées en
secondes. Ce qui implique que le paramètre Dx@ du vecteur dest sera égal à 1/(x2-x1).
 Toutefois, quand le paramètre unitX@ de source est égal à 'ms', on tient compte du fait
que les abscisses sont exprimées en millisecondes en donnant à Dx la valeur 1000/(x2-x1).
 Dans un cas différent, on peut toujours modifier le paramètre Dx après le calcul.

 Les procédures FFT1@ et FFT2@ sont des variantes de FFT qui renvoient le module et
l'argument pour FFT1, et les parties réelles et imaginaires pour FFT2 .

 La procédure ComplexFFT@ calcule la FFT d'un vecteur complexe.

}
procedure FFT1(var source,module,phase:Tvector;x1,x2:real;Nb:integer);
{$H Calcule la FFT (Fast Fourier Transform) d'un vecteur.

 La procédure est analogue à FFT@ mais renvoie deux vecteurs contenant le module et
la phase de la FFT.

 Utilisez de préférence la procedure DFT@ qui est plus récente et plus générale.

 Voir FFT@
}

procedure FFT2(var source,DestReal,DestIm:Tvector;x1,x2:real;Nb:integer);
{$H Calcule la FFT (Fast Fourier Transform) d'un vecteur.

 La procédure est analogue à FFT@ mais renvoie deux vecteurs contenant les parties
réelle et imaginaire de la FFT.

 Utilisez de préférence la procedure DFT@ qui est plus récente et plus générale.

 Voir FFT@
}
procedure complexFFT(var Sreal,Sim,Dreal,Dim:Tvector;x1,x2:real;Nb:integer;inverse:boolean);
{$H Calcule la FFT (Fast Fourier Transform) d'un vecteur complexe.

 Utilisez de préférence la procedure DFT@ qui est plus récente et plus générale.

 La procédure est analogue à FFT@ mais travaille sur un vecteur source complexe
dont la partie réelle est dans Sreal et la partie imaginaire est dans Sim, et renvoie
deux vecteurs contenant les parties réelle et imaginaire de la FFT.

 Si inverse est vrai, c'est la transformée inverse qui est calculée.

 Voir FFT@
}


                     { TcolorMap stmUpal0 }

procedure TcolorMap.create(Stname:string);
procedure TcolorMap.create;
{$H Constructeur de l'objet TcolorMap@ .

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

}
property TcolorMap.gamma:real;
{$H Permet d'appliquer une correction gamma à l'échelle des couleurs.

 Sa valeur par défaut est 1.
}
property TcolorMap.twoColors:boolean;
{$H Lorsque la palette est monochrome (PalName@='' ou PalName@='Monochrome'),
il est possible d'utiliser deux couleurs différentes pour représenter les valeurs
positives et les valeurs négatives.

 Par défaut, twoColors vaut False. Dans ce cas, la palette s'étend du noir jusqu'à
la couleur saturée définie par palColor@[1] .

 Si twoColors vaut True,les valeurs positives seront représentées par
des couleurs s'étendant du noir jusqu'à la couleur saturée définie par palColor@[1]
alors que les valeurs négatives seront représentées par
des couleurs s'étendant du noir jusqu'à la couleur saturée définie par palColor@[2]

 Si la palette n'est pas monochrome, twoColors est ignoré.
}
property TcolorMap.PalColor(n:integer):integer;
{$H Définit la ou les couleurs utilisées par la palette monochrome.

 Lorsque TwoColors vaut False, PalColor[1] définit la couleur utilisée par la
palette monochrome, PalColor[2] est alors ignoré.

 Lorsque TwoColors vaut True, PalColor[1] définit la couleur utilisée par la
palette monochrome pour les valeurs positives alors que PalColor[2] définit la couleur
utilisée par la palette monochrome pour les valeurs négatives.

 PalColor[n] peut prendre des valeurs de 1 à 7 qui correspondent aux couleurs suivantes:
   1 : Red
   2 : Green
   3 : Blue
   4 : Red + Green
   5 : Red + Blue
   6 : Green + Blue
   7 : Red + Green +Blue

 Par exemple, quand PalColor[1]=6, les couleurs utilisées sont rgb(0,i,i) où
i prend toutes les valeurs comprises entre 0 et 255.
}
property TcolorMap.PalName:string;
{$H PalName est le nom de la palette utilisée pour afficher les cartes.

 Voir (Tmatrix.PalName)@ .
}
property TcolorMap.direction:integer;
{$H Définit la direction de l'affichage de la carte des couleurs.

 0 : affichage de gauche à droite (Défaut)
 1 : affichage du bas vers le haut
 2 : affichage de droite à gauche
 3 : affichage du haut vers le bas

 Le fait de modifier Direction modifie automatiquement les propriétés des
échelles
}
property TcolorMap.ColCount:integer;
{$H Définit le nombre de couleurs effectivement représentées dans la carte.

 La valeur par défaut est 256, ce qui donne un spectre quasi continu, mais il
peut être intéressant de réduire ce nombre pour montrer des valeurs discrètes.
}

                             {stmFont1}

property Tfont.name:string;
{$H Définit le nom de la police de caractère.
 Le nom doit correspondre exactement à un nom de police tel qu'il apparait dans
une boite de dialogue permettant un choix de police, en respectant les majuscules
et minuscules, et les espaces.
}
property Tfont.size:integer;
{$H Définit la taille de la police de caractères }

property Tfont.color:longint;
{$H Définit la couleur de la police de caractères }

property Tfont.style:integer;
{$H Définit le style de la police de caratères.

 Par défaut, la propriété vaut zéro. Ce qui correspond à un style normal.

 On peut ajouter les styles gras, italique, souligné ou barré en combinant les
(constantes de style de police)@(styles de police) .

 @f6 Exemple: FontStyle:=fs_bold+fs_underline;
}
                             {stmMemo1}

procedure Tmemo.create(stName:string);
procedure Tmemo.create;
procedure Tmemo.create(WithPanelVisible: boolean);
{$H Constructeur de l'objet Tmemo.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 On peut fixer directement la propriété PanelVisible avec la troisième variante.

}
property Tmemo.lines(num:longint):string default;
{$H Permet d'accéder à une ligne de texte.

 Num est le numéro de la ligne (les numéros commencent à un)

 Le fait d'accéder en écriture à la ligne de numéro num modifie si nécessaire la propriété count@ .

 Comme il s'agit de la propriété par défaut, on remplacer @prog memo.lines[n] @notprog par @prog memo[n] @notprog
}
property Tmemo.font:Tfont readOnly;
{$H Police de caractères utilisée.

 Voir Tfont@
}
procedure Tmemo.Insert(num:longint;st:string);
{$H Insère la chaine st à la ligne de numéro num.

 Toutes les chaines de numéro supérieur ou égal à num sont décalées vers le bas.
}
procedure Tmemo.delete(num:longint);
{$H Supprime la ligne de numéro num.

}
property Tmemo.x:real;
{$H Abscisse du texte dans la fenêtre Multigraph qui le contient.

 x doit être compris entre 0 et 100.
}
property Tmemo.y:real;
{$H Ordonnée du texte dans la fenêtre Multigraph qui le contient.

 y doit être compris entre 0 et 100.
}

procedure Tmemo.addLine(st:string);
{$H Ajoute une ligne à la fin du texte

 La propriété count est incrémentée.
}
procedure Tmemo.clear;
{$H Efface tout le texte.

 La propriété count vaut ensuite zéro.
}
property Tmemo.count:integer;
{$H Indique le nombre de lignes contenues dans l'objet

 L'affectation de count supprime les lignes au-delà de la valeur demandée.
}
property Tmemo.text:string;
{$H Text représente l'ensemble des lignes contenues dans l'objet sous la forme
d'une seule chaîne de caractères.

 Les lignes sont séparées par le couple CR+LF ( chr(13) +chr(10) ).
}

function Tmemo.LoadFromFile(stF:string):boolean;
{$H Charge le fichier de nom stf.

 La fonction renvoie True si le chargement est correctement réalisé
et False dans le cas contraire.

}

function Tmemo.SaveToFile(stF:string):boolean;
{$H Sauve le texte du memo dans le fichier de nom stf.

 La fonction renvoie True si la sauvegarde est correctement effectuée
et False dans le cas contraire.
}

property Tmemo.caption:string;
{$H Chaine de caractère apparaissant dans la barre de titre de la fenêtre d'édition de Tmemo

 Par défaut, Caption est égal à SysName@
}

property Tmemo.PanelVisible: boolean;
{$H Par défaut, la fenêtre d'édition de Tmemo contient un panel qui permet de préciser quelques options
d'affichage dans un objet Multigraph.
 Si on veut masquer ce panel, il faut donner la valeur False à la propriété PanelVisible.
 PanelVisible vaut True par défaut.

}


                             { Tpolyline stmGraph2 }

procedure Tpolyline.addPoint(x,y:real);
procedure Tpolyline.addPoint(x,y:real; col:integer);

{$H Ajoute un point de coordonnées (x,y) et de couleur col à la fin de la liste de points.
 La propriété count est incrémentée à chaque appel de cette méthode.
}
property TpolyLine.count:longint readOnly;
{$H Renvoie le nombre de points contenus dans la liste.
}
property TpolyLine.X(i:longint):real;
{$H La propriété X contient les abscisses des points de la liste.

 Le premier point a pour indice 1, le dernier a pour indice Count@.
}
property TpolyLine.Y(i:longint):real;
{$H La propriété Y contient les ordonnées des points de la liste.

 Le premier point a pour indice 1, le dernier a pour indice Count@.
}

property TpolyLine.PointColor(i:longint):integer;
{$H La propriété PointColor contient les couleurs  des points de la liste.

 Le premier point a pour indice 1, le dernier a pour indice Count@.
 Voir X@ , Y@
}

procedure TpolyLine.clear;
{$H Supprime tous les points de la liste.
 La propriété count@ vaudra ensuite zéro.
}
property TpolyLine.color:longint;
{$H Couleur de tracé de l'objet polyLine.

 Quand l'objet Tpolyline appartient à TXYPlot@ , sa couleur est initialement
définie par la couleur de TXYPlot. Cependant, on peut modifier individuellement la
couleur de chaque courbe de TXYPlot.

 Voir aussi color2@ .
}

property TpolyLine.UsePointColor: boolean;
{$H Indique qu'il faut utiliser les couleurs des points plutôt que la propriété Color@
}

property TpolyLine.color2:longint;
{$H Deuxième Couleur de tracé de l'objet polyLine.

 Cette couleur est utilisée par le mode DM_polygon@ . Dans ce mode, les contours
fermés sont remplis avec color2.
 Quand l'objet Tpolyline appartient à TXYPlot@ , les couleurs sont initialement
définie par les couleurs de TXYPlot. Cependant, on peut modifier individuellement les
couleurs de chaque courbe de TXYPlot.
}
property TpolyLine.lineWidth:longint;
{$H Largeur de trait de l'objet polyLine.

 Quand l'objet Tpolyline appartient à TXYPlot@ , les largeurs de trait sont initialement
définie par TXYPlot. Cependant, on peut modifier individuellement les largeurs de trait
de chaque courbe de TXYPlot.
}

property TpolyLine.mode:integer;
{$H Définit le mode d'affichage. Il est recommandé d'utiliser les constantes
définissant les (modes d'affichage)@ pour modifier cette propriété.

 Quand l'objet Tpolyline appartient à TXYPlot@ , les modes d'affichage sont initialement
définie par TXYPlot. Cependant, on peut modifier individuellement les modes d'affichage
de chaque courbe de TXYPlot.
}

property TpolyLine.SymbolSize:integer;
{$H Définit la taille des symboles en pixels.

 Quand l'objet Tpolyline appartient à TXYPlot@ , les tailles des symboles sont initialement
définie par TXYPlot. Cependant, on peut modifier individuellement les les tailles des symbole
de chaque courbe de TXYPlot.
}

procedure Tpolyline.LoadFromVectors(var v1,v2:Tvector;i1,i2:integer);
procedure Tpolyline.LoadFromVectors(var v1,v2,v3: Tvector;i1,i2:integer);

{$H Permet de charger une polyline avec des couples de valeurs tirées de
deux vecteurs v1 et v2 .
  Optionnellement, le vecteur v3 peut contenir les couleurs.
 Les points sont pris entre les indices i1 et i2 et sont ajoutés à la fin de la liste
de points. Il faut donc penser à appeler clear@ auparavant si nécessaire.

 Rien n'est copié si un des indices i1 ou i2 est en dehors des limites de v1 ou de v2.
}

procedure Tpolyline.LoadPolyline(source:Tpolyline);
{$H Copie le contenu d'un objet Tpolyline.

 Les points de source sont ajoutés à la fin de la liste de points. Il faut donc
penser à appeler clear@ auparavant si nécessaire.
}

procedure TpolyLine.intersection(p1,p2:TpolyLine);
{$H Remplit la polyline avec l'intersection de p1 et p2.

 La polyline doit être fermée: le dernier point doit être égal au premier.
}

procedure TpolyLine.Rotate(x0,y0,theta:real);
{$H Fait tourner tous les points d'un angle theta (exprimé en degrés) autour de (x0,y0) .
}

procedure TpolyLine.Translate(dx,dy:real);
{$H Fait subir une translation (dx,dy) à tous les points .
}

function Tpolyline.area:real;
{$H Renvoie l'aire du polygone délimité par la polyline.

 La polyline doit être fermée: le dernier point doit être égal au premier.
}

procedure TpolyLine.rectangle(x,y,dx,dy,theta:real);
{$H Dessine un rectangle dans la polyline.

 On utilise les conventions du stimulateur visuel:
 x et y sont les coordonnées du centre.
 dx et dy sont les dimensions du rectangle.
 theta est l'angle (en degrés) dont on a fait tourner le rectangle.
}
property Tpolyline.Xlabel(i:integer): integer;
{$H Abscisse du label d'indice i, relativement à la position du point correspondant

 Par défaut, sa valeur est 2 (pixels)

 Les indices sont compris entre 1 et count@
}

property Tpolyline.Ylabel(i:integer): integer;
{$H Ordonnée du label d'indice i, relativement à la position du point correspondant

 Par défaut, sa valeur est 2 (pixels)

 Les indices sont compris entre 1 et count@
}

property Tpolyline.label(i:integer): string;
{$H Label associé au point d'indice i
}

property Tpolyline.Font: Tfont readonly;
{$H Fonte utilisée par les labels
}


                             { TXYplot stmGraph2 }

procedure TXYplot.create(stName:string);
procedure TXYplot.create;
{$H Constructeur de l'objet TXYPlot.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
}
property TXYplot.PolyLines(i:longint):TpolyLine readOnly default;
{$H Chaque objet du tableau PolyLines est du type Tpolyline@ et représente une courbe.

 Polylines[1] est donc la première courbe, Polylines[2] est la seconde, etc..
 PolyLines[count] est la dernière courbe.

 Initialement, l'objet TXYplot ne contient aucun polyline. Il faut appeler
addPolyline@ avant d'utiliser la propriété PolyLines.

 Polylines est la propriété par défaut de TXYplot. Ce qui signifie que l'écriture
 @f6 plot.polylines[1]
 peut être remplacée par
 @f6 plot[1]
}

property TXYplot.last:TpolyLine readOnly;
{$H Désigne le dernier objet polylines de la liste

 Last est identique à Polylines[count]
}


procedure TXYplot.addPolyLine;
{$H Crée un nouvel objet de type TpolyLine et le range à la fin de la liste
polyLines@ .
 La propriété count est incrémentée.

}
property TXYplot.count:longint readOnly;
{$H Renvoie le nombre de courbes contenue dans la liste.
}
procedure TXYplot.clear;
{$H Supprime toutes les courbes de la liste.
}

property TXYplot.NextColor:integer;
{$H Définit la couleur qui sera utilisée par les nouveaux objets polylines.

 Quand on modifie NextColor, on ne change pas la couleur des polylines existants. Seuls
ceux qui seront créés par la suite utiliseront cette couleur.

 Quand on modifie Color@ , on modifie aussi NextColor.

 Voir NextColor2@
}

property TXYplot.NextColor2:integer;
{$H Définit la deuxième couleur qui sera utilisée par les nouveaux objets polylines.

 Quand on modifie NextColor2, on ne change pas la couleur des polylines existants. Seuls
ceux qui seront créés par la suite utiliseront cette couleur.

 Quand on modifie Color2@ , on modifie aussi NextColor2.

 Voir NextColor@
}


procedure TcontourPlot.create(stName:string);
procedure TcontourPlot.create;
{$H  Constructeur de l'objet TcontourPlot.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

}
procedure TcontourPlot.Calculate(var mat:Tmatrix; level:real);
procedure TcontourPlot.Calculate(var mat:Tmatrix; level:real; UsePosition: boolean);


{$H Calcule une courbe de niveau en se basant sur les valeurs de la matrice Mat.

 Level est le niveau de référence.
 UsePosition vaut false par défaut. Si sa valeur est true, le calcul tient compte des
paramètres fixés avec (Tmatrix.setPosition)@(Tmatrix.setPosition) .

 Lorsque la matrice est affichée en mode lissé (displayMode@(Tmatrix.displayMode)<>0),
les courbes sont calculées en utilisant les valeurs lissées et non les valeurs brutes
de la matrice.

 Chaque appel à Calculate crée un nouvel objet PolyLines@(TXYplot.polyLines)

}



procedure TcontourPlot.setOptions(FselPix,FmarkPix,Fvalue:boolean;value:real);
{$H Fixe les options de calcul d'une courbe de niveau.

 Si FselPix vaut TRUE, les éléments sélectionnés dans la matrice seront exclus
du calcul.
 Si FmarkPix vaut TRUE, les éléments marqués dans la matrice seront exclus
du calcul.
 Si Fvalue vaut TRUE, les éléments de la matrice contenant la valeur value
seront exclus du calcul.
 Le paramètre value n'est utilisé que si Fvalue vaut true.

 SetOptions doit être appelée avant chaque appel de calculate@ sinon les valeurs
par défaut seront utilisées (FALSE pour toutes les options).

}

                             { stmAvi1 }

procedure TaviBuilder.createFile(fileName:string);
{$H Ouvre un nouveau fichier AVI de nom fileName.

 L'extension recommandée est .avi .

}
procedure TaviBuilder.setWindow(num:integer);
{$H Indique le numéro de la fenêtre qui sera sauvée à chaque appel de save@ .

 Par défaut, c'est toute la page courante de multigraph0 qui est utilisée.
}
procedure TaviBuilder.setWindowEx(x1,y1,x2,y2:integer);
{$H Définit la fenêtre qui sera sauvée à chaque appel de save@ .

 (x1,y1) et (x2,y2) sont respectivement les coordonnées des points situés en haut à gauche
et en bas à droite de la fenêtre.

 Les coordonnées sont les coordonnées absolues dans la page multigraph (elles
commencent à zéro) .
}

procedure TaviBuilder.save;
{$H Sauve la page courante ou la fenêtre sélectionnée dans le fichier avi.

 L'image est sauvée sous la forme d'un bitmap compressé au format Microsoft RLE.
Cette compression n'entraîne aucune perte d'information.
}
procedure TaviBuilder.closeFile;
{$H Ferme le fichier AVI
}
property TaviBuilder.rate:integer;
{$H Définit la vitesse de rafraichissement en images par seconde.

 Il faut modifier cette propriété immédiatement après l'appel de createFile@.
 La valeur par défaut est 20.
}

property TaviBuilder.compress:boolean;
{$H Détermine le fait que les images seront compressées ou non.

 La valeur est TRUE par défaut.

 Le taux de compression est considérable lorsque l'image contient seulement des
vecteurs. D'autre part, la méthode de compression utilisée n'entraîne en général
aucune perte d'information.

 Lorsque l'image contient un grand nombre de couleurs (cartes ou matrices), une
certaine perte d'information a lieu du fait de la réduction du nombre de couleurs
à 256.

 Il faut modifier cette propriété immédiatement après l'appel de createFile@.
}

procedure TaviBuilder.setColorTable(num:integer);

{$H Choisit une palette de couleurs.

  Il y a trois palettes disponibles:
    num=0 : palette standard contenant toutes les couleurs
    num=1 : palette contenant 256 niveaux de gris.
    num=2 : palette mixte contenant 192 niveaux de gris et 64 couleurs standard

 Par défaut, num=0 .
}

procedure TaviBuilder.setUserColorTable(var PaletteEntries);
{$H Choisit une palette de couleurs.

  PaletteEntries doit être un tableau de 256 entiers (longint)
qui représente la palette définie par l'utilisateur.
}

property TaviBuilder.TrueColor:boolean;
{$H Indique si l'on utilise des couleurs vraies ou des couleurs palettisées.

 Si TrueColor est false (valeur par défaut), chaque point de l'image est codé sur 8 bits
et ce code renvoie à une valeur de palette. Ce mode utilise automatiquement une compression
d'image (RLE)

 Si TrueColor est vrai, il n'y a pas de palette. Chaque point de l'image est codé sur 24 bits.
Il n'y a pas de compression d'image. D'où des tailles de fichier très importantes.

}


                             { stmPlotF }
procedure TplotVideo.create(stName:string);
procedure TplotVideo.create;
{$H Constructeur de l'objet TplotVideo

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
}


procedure TplotVideo.addPlot(var plot:Tplot);
{$H Ajoute l'objet Plot à la fin de la liste des objets.
}
procedure TplotVideo.addPlot2(var plot:Tplot);
{$H Ajoute l'objet Plot dans la liste des objets. Cet objet s'affichera en même
temps que le dernier objet ajouté avec AddPlot.

}
procedure TplotVideo.clear;
{$H Efface le contenu de la liste des objets.
}

property TplotVideo.imageIndex:longint;
{$H Désigne le numéro de l'image courante.

 Ce numéro peut varier entre 1 et imageCount.
}
property TplotVideo.imageCount:longint readonly;
{$H Renvoie le nombre d'images stockées dans la liste.
}

                             { module Filter1 }

procedure Filter(tp:integer;passeHaut:boolean;ordre:integer;Fc:real;var source,dest:Tvector; x1,x2:real);
{$H Effectue un filtrage numérique sur le vecteur source et range le résultat dans le vecteur
dest.

 Tp est le type de filtre. La valeur 1 correspond à un filtre de Bessel. C'est actuellement
le seul type de filtre installé.

 PasseHaut doit valoir TRUE pour un filtre passe-haut, FALSE  pour un filtre passe-bas.

 Ordre est l'ordre du filtre, les valeurs acceptables sont comprises entre 1 et 12 mais
pratiquement, il est rarement possible d'utiliser des valeurs supérieures à 8 sans faire
diverger le calcul.

 Fc est la fréquence caractéristique du filtre exprimée en Hertz. En première approximation,
on peut considérer que c'est la fréquence de coupure à 3 décibels mais ce n'est qu'une
approximation.

 x1 et x2 définissent la zone du signal source sur laquelle on effectue le filtrage. Il
est possible d'utiliser des valeurs telles que x2<x1 afin de forcer un filtrage dans le
sens rétrograde.
  En effet, en filtrant dans un sens puis dans l'autre, on supprime le retard introduit
par le filtrage, comme dans l'exemple ci-dessous:

 @f6 Filter(1,true,4,1,v1,c2,v1.Xstart,v1.Xend);
 @f6 Filter(1,true,4,1,c2,c1,v1.Xend,v1.Xstart);

 Si la propriété UnitX@(TdataPlot.unitX) du vecteur source est égale à 'sec', on considère
que les unités horizontales sont des secondes sinon,  on considère que les unités
horizontales sont des millisecondes.

}

procedure FilterC(var source,dest:Tvector;x1,x2:real;var coeffA,coeffB;passeHaut:boolean);


                             { TcursorList stmClist1 }

procedure TcursorList.create(stname:string);
procedure TcursorList.create;
{$H  Constructeur de l'objet
}

procedure TcursorList.installVevent(var v:Tvector);
{$H Indique le vecteur contenant les événements

 Ce vecteur doit contenir les temps associés à chaque curseur.
}

procedure TcursorList.installVdisplay(var v:Tvector);
{$H Indique le vecteur sur lequel s'affichent les curseurs
}

procedure TcursorList.installVzoom(var v:Tvector);
{$H Indique le vecteur Zoom

 En général, on choisira une objet du type Timagevector et on associera cet objet
au vecteur source (celui mis en place avec installVdisplay@ ).
}

procedure TcursorList.installVaux(var v:Tvector);
{$H Installe un vecteur auxiliaire

 Un vecteur auxiliaire aura le même nombre d'éléments que le vecteur Vevent principal
En général, chaque valeur correspondra à une mesure temporelle associée à un événement de Vevent.
 Exemple: position du maximum qui suit l'événement détecté.

 A chaque vecteur auxiliaire correspondra un curseur dans la fenêtre Vzoom
 Pour chaque suppression d'événement dans Vevent, l'événement correspondant sera supprimé dans les vecteurs auxiliaires.
 Pour chaque ajout d'événement dans Vevent, un événement sera ajouté à la même position dans les vecteurs auxiliaires.

}

property TcursorList.Selected(n:longint):boolean;
{$H Indique que l'événement d'indice n est sélectionné
 Les événements sélectionnés sont affichés avec une couleur différente.
}
property TcursorList.index:integer;
{$H Indice de l'événement courant
}

procedure TcursorList.DeleteCurrent;
{$H Supprime l'événement courant.
}

                             { Tsymb stmSymbs }

property TsymbPlot.color:longint;
property TsymbPlot.visible:boolean;

                             { Tsymbol stmSymbs }
procedure Tsymbol.create(stName:string;x,y:real;color:longint;style:integer);
procedure Tsymbol.create(x,y:real;color:longint;style:integer);
property Tsymbol.x:real;
property Tsymbol.y:real;
property Tsymbol.style:integer;
property Tsymbol.size:integer;

                             {Tellipse stmSymbs }

procedure Tellipse.create(x,y:real;w,h,color:integer);
property Tellipse.x:real;
property Tellipse.y:real;

property Tellipse.pixWidth:integer;
property Tellipse.pixHeight:integer;
property Tellipse.lineWidth:integer;

property Tellipse.BrushStyle:integer;
{$H Style de remplissage

  Les valeurs possibles sont:
    0: Solid
    1: Clear
    2: Horizontal
    3: Vertical
    4: FDiagonal
    5: BDiagonal
    6: Cross
    7: DiagCross
}
                             {TbarSymbol stmSymbs }

procedure TbarSymbol.create(x,y, dx,dy,theta:real;color:integer);
property TbarSymbol.x:real;
property TbarSymbol.y:real;
property TbarSymbol.dx:real;
property TbarSymbol.dy:real;
property TbarSymbol.theta:real;


                             { TlineHor stmSymbs }
procedure TlineHor.create(stName:string;y0:real;color:longint;style:integer);
procedure TlineHor.create(y0:real;color:longint;style:integer);
property TlineHor.y:real;
property TlineHor.style:integer;
property TlineHor.width:integer;

                             { TlineVer stmSymbs }
procedure TlineVer.create(stName:string;y0:real;color:longint;style:integer);
procedure TlineVer.create(y0:real;color:longint;style:integer);
property TlineVer.x:real;
property TlineVer.style:integer;
property Tlinever.width:integer;

                             { Tline stmSymbs }
procedure Tline.create(stName:string;x1,y1,x2,y2:real;color:longint;style:integer);
procedure Tline.create(x1,y1,x2,y2:real;color:longint;style:integer);
property Tline.x1:real;
property Tline.y1:real;
property Tline.x2:real;
property Tline.y2:real;
property Tline.style:integer;
property Tline.width:integer;


                             { TlinearFunc stmSymbs }
procedure TlinearFunc.create(stName:string;a,b:real;color:longint;style:integer);
procedure TlinearFunc.create(a,b:real;color:longint;style:integer);
property TlinearFunc.a:real;
property TlinearFunc.b:real;
property TlinearFunc.style:integer;
property TlinearFunc.width:integer;

function Multigraph0:Tmultigraph;

                             { Twavelet stmWt1 }

procedure Twavelet.create(stName:string);
procedure Twavelet.create;
{$H Constructeur de l'objet Twavelet.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
}
procedure Twavelet.decompose(var vec:Tvector;level:integer);
{$H Décompose en ondelettes le vecteur vec.

 Level est le nombre de niveaux de décomposition. En indiquant Level=0, le
nombre de niveaux sera égal à la valeur maximale possible.

 Auparavant, il faut avoir fixé le type d'ondelettes ( WtType@ ) et les paramètres associés
Par1@ et Par2@ .

 Le résultat de la décomposition se retrouve dans Vtemp@
 Pour manipuler ce résultat, il sera plus commode d'utiliser les vecteurs VD@ et VA
qui permettent d'accéder respectivement aux détails et à la dernière approximation.
}

procedure Twavelet.reconstruct(var vec:Tvector);
{$H Reconstruction du vecteur.

 Le contenu de Vtemp@ est utilisé pour reconstruire le vecteur vec.

 Entre la décomposition et la reconstruction, il est évidemment interdit de changer
les paramètres WtTYpe@, Par1@ et Par2@, sinon le résultat sera incohérent.
 Il est seulement autorisé de modifier le contenu de Vtemp@, soit directement, soit
en utilisant les propriétés VD@ et VA@ .
}

property Twavelet.Vtemp:Tvector readOnly;
{$H Vecteur contenant la décomposition en ondelettes.

 Une décomposition de niveau N est formée de N vecteurs contenant les détails
et de un vecteur contenant l'approximation de niveau N. Tous ces vecteurs, dont les
longueurs sont différentes se retrouvent les uns après les autres dans un même buffer.
Ce buffer est accessible à travers Vtemp mais il sera plus commode d'accéder aux détails
en utilisant la propriété VD@, et à la dernière approximation en utilisant la propriété VA@ .

}

property Twavelet.VD(i:integer):Tvector readOnly;
{$H Vecteurs contenant les "détails" de la décomposition en ondelettes.

 Une décomposition de niveau N est formée de N vecteurs contenant les détails
et de un vecteur contenant l'approximation de niveau N.
 VD[i] contient le ième détail

}

property Twavelet.VA:Tvector readOnly;
{$H Vecteur contenant la dernière approximation de la décomposition en ondelettes.

 Une décomposition de niveau N est formée de N vecteurs contenant les détails
et de un vecteur contenant l'approximation de niveau N.
 VA contient cette approximation.

}


property Twavelet.WtType:integer;
{$H Type d'ondelette.

 Ce type doit être fixé avant une décomposition.
 Neufs types sont disponibles. On peut utiliser les constantes définissant
(les différents types d'ondelettes)@

 @f6   WT_Haar         =  1;
 @f6   WT_Daublet      =  2;
 @f6   WT_Symmlet      =  3;
 @f6   WT_Coiflet      =  4;
 @f6   WT_Vaidyanathan =  5;
 @f6   WT_BSpline      =  6;
 @f6   WT_BSplineDual  =  7;
 @f6   WT_LinSpline    =  8;
 @f6   WT_QuadSpline   =  9;

  Pour certains types, il faut également fixer les propriétés Par1@ et Par2@ .

 @f6   WT_Haar           par1 - dummy
 @f6                     par2 - dummy
 @f6   WT_Daublet        par1 = 1,2,3,4,5,6,7,8,9,10.
 @f6                     par2 - dummy
 @f6   WT_Symmlet        par1 = 1,2,3,4,5,6,7.
 @f6                     par2 - dummy
 @f6   WT_Coiflet        par1 = 1,2,3,4,5.
 @f6                     par2 - dummy
 @f6   WT_Vaidyanathan   par1 - dummy
 @f6                     par2 - dummy

 @f6   WT_BSpline, WT_BSplineDual
 @f6                      box -
 @f6                          (1, 1 ), (1, 3 ), (1, 5 );
 @f6                      lin. spline -
 @f6                          (2, 2 ), (2, 4 ), (2, 6 ), (2, 8 );
 @f6                      quad. spline -
 @f6                          (3, 1 ), (3, 3 ), (3, 5 ), (3, 7 ), (3, 9 ).

 @f6   WT_LinSpline      par1 - dummy
 @f6                     par2 - dummy
 @f6   WT_QuadSpline     par1 - dummy
 @f6                     par2 - dummy

}
property Twavelet.Par1:integer;
{$H Premier paramètre associé à certains types d'ondelettes.

 Voir WtType@
}
property Twavelet.Par2:integer;
{$H Second paramètre associé à certains types d'ondelettes.

 Voir WtType@ .
}
property Twavelet.level:integer readOnly;
{$H Niveau de décomposition.

 Le niveau de décomposition est fixé quand on appelle Decompose@ .
 Toutefois, le niveau de décomposition demandé peut être modifié pour
correspondre aux données.

}
function Twavelet.WtTypeString:string;
{$H Renvoie une chaîne de caractères contenant les noms des types d'ondelettes
séparés par des barres verticales.

 Cette chaîne est utile dans la construction des dialogues. On peut la passer
à la méthode GetStringList@(Tdialog.getStringList) .
}

procedure TWavelet.Scalogram(var vec:Tvector;var mat: Tmatrix;level:integer;Freconstruct:boolean);
{$H Construction d'un scalogramme.

 Le scalogramme est une matrice dont les propriétés Istart et Iend sont égales
respectivement à vec.Istart et vec.Iend, dont la propriété Jstart vaut 1 et
dont la propriété Jend vaut level.

 Si Freconstruct vaut TRUE, chaque ligne i de la matrice contiendra une reconstruction du signal basée
uniquement sur l'approximation de niveau i .

}


                              { TmatList stmMlist }

procedure TmatList.create(name:string);
procedure TmatList.create;
{$H Constructeur de l'objet}
procedure TmatList.AddMatrix(var mat:TMatrix);
procedure TmatList.InsertMatrix(n:integer;var mat:TMatrix);
procedure TmatList.DeleteMatrix(num:integer);
procedure TmatList.Clear;

property Tmatlist.M(i:integer):Tmatrix readOnly default;
{$H Permet de manipuler la matrice d'index i

  i doit être compris entre 1 et count@

}

property TmatList.count:integer readOnly;
{$H Renvoie le nombre de matrices de la liste }

property TmatList.Index:integer;
{$H Indice de la matrice affichée

 Quand l'objet est rangé dans une fenêtre, c'est cette matrice qui est affichée.
 index est compris entre 1 et count@
}
property TmatList.Selected(n:integer):boolean;
property TmatList.CpLine(p:integer):integer;

property TmatList.Zmin:real;
property TmatList.Zmax:real;

property TmatList.theta:real;

property TmatList.AspectRatio:real;
property Tmatrix.PixelRatio:real;

property TmatList.gamma:real;
property TmatList.TwoColors:boolean;
property TmatList.PalColor(n:integer):integer;
property TmatList.PalName:string;
property TmatList.DisplayMode:integer;

procedure TmatList.autoscaleZ;
procedure TmatList.autoscaleZsym;
procedure TmatList.autoscaleXYZ;

procedure TmatList.getMinMaxI(var Vmin,Vmax:longint);
procedure TmatList.getMinMax(var Vmin,Vmax:real);

procedure TmatList.saveToVectorArray(var va:TvectorArray;tp:integer);

property Tmatlist.Oncontrol: boolean;
procedure Tmatlist.setPosition(x,y,dx,dy,theta:real);

property Tmatlist.UsePosition:boolean;
{$H Indique que l'affichage des matrices doit utiliser les paramètres de position
(fixés par exemple avec setPosition@ )

}

property Tmatlist.CpxMode:integer;
{$H Définit le mode d'affichage des matrices contenant des nombres complexes.

 Voir Tmatrix.CpxMode@(Tmatrix.CpxMode)
}

procedure TMatList.Filter1( var matF: Tmatrix; var vecF: Tvector);
{$H Applique un filtre spatio-temporel à la liste de matrice.

 La liste doit contenir des matrices de mêmes dimensions et même type.

 matF est le filtre spatial. C'est une matrice réelle de mêmes dimensions que les matrices de la liste.
 vecF est le filtre temporel. C'est un vecteur réel contenant count@ éléments.

 L'algorithme est le suivant:
 - on calcule la transformée de Fourier de la structure 3D constituée par la liste.
 - On multiplie chaque élément (x,y,z) de la DFT par matF[x,y]*vecF[z]
 - on calcule la transformée de Fourier inverse. 

}


procedure JPcov(var src1,src2:TVlist;Vdate:Tvector;var dest:Tmatrix;Fevt1,Fevt2:boolean;mode:integer);
{$H Calcul d'un JPSTH normalisé généralisé

 src1 et src2 sont deux listes de vecteurs de données.
 Les listes contiennent le même nombre de vecteurs et dans chaque liste, les vecteurs
doivent avoir la même structure et les mêmes paramètres d'échelle.
 Les vecteurs doivent être du type t_single@ .

 Ces vecteurs peuvent contenir des événements ou des données ordinaires.
 Quand src1 contient des événements, on doit l'indiquer en donnant Fevt1 = TRUE .
 Quand src2 contient des événements, on doit l'indiquer en donnant Fevt2 = TRUE .

 Vdate est un vecteur contenant des dates de stimulus. Son premier indice Istart doit
être égal à 1, son dernier indice doit être supérieur ou égal au nombre de vecteurs
contenus dans les listes.

 Dest est la matrice devant contenir les résultats. Elle doit être initialisée
correctement ( indices et paramètres d'échelle ). Elle doit aussi être remplie
avec des zéros.

 Mode peut contenir la valeur 1 , 2 ou 3 :
 1 :  on calcule le JPSTH brut
 2 :  on calcule le JPSTH brut puis on retranche la matrice produit des psths
 3:  on effectue 1 et 2, puis on normalise le résultat.



}

procedure TotalEntropy(var src:TVlist;x1,x2:real;dt1,dt2:real;ndt:integer;dim1,dim2:integer;dV:real;var dest:Tmatrix);
{$H
}


procedure NoiseEntropy(var src:TVlist;x1,x2:real;dt1,dt2:real;ndt:integer;dim1,dim2:integer;dV:real;var dest:Tmatrix);
{$H
}


procedure Information(var src:TVlist;x1,x2:real;dt1,dt2:real;ndt:integer;dim1,dim2:integer;dV:real;var dest:Tmatrix);
{$H
}

function simpleEntropy(var vec:Tvector):real;

procedure TotalEntropyMa(var src:TVlist;x1,x2:real;dt1,dt2:real;ndt:integer;dim1,dim2:integer;dV:real;var dest:Tmatrix);
{$H
}


procedure NoiseEntropyMa(var src:TVlist;x1,x2:real;dt1,dt2:real;ndt:integer;dim1,dim2:integer;dV:real;var dest:Tmatrix);
{$H
}


                            { TmatAverage stmMatAve1 }

procedure TmatAverage.create(stName:string;tp:integer;i1,i2,j1,j2:longint);
procedure TmatAverage.create(tp:integer;i1,i2,j1,j2:longint);
{$H Constructeur de l'objet TmatAverage.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 tp indique le (type de nombre)@(types de nombre) . Les types autorisés sont les
mêmes que pour Tmatrix@ mais il est recommandé d'utiliser un type réel (t_single
ou T_double).

 i1 et i2 sont les valeurs de début et de fin du premier indice.
 j1 et j2 sont les valeurs de début et de fin du second indice.

 Ces indices seront automatiquement adaptés à la matrice moyennée si l'on utilise la
méthode add@ ( mais pas addEx@ ) .
}


procedure TmatAverage.add(var m:Tmatrix);
{$H Accumule la matrice m dans l'objet TmatAverage.

 Lorsque count@ = 0 , les propriétés Istart, Iend, Jstart, Jend, Dx, x0, Dy et y0
de la matrice m sont affectées à celles de l'objet Taverage.

 Si l'on a affecté stdON@ à TRUE, il peut être intéressant d'utiliser add1@ .
}

procedure TmatAverage.add1(var m:Tmatrix);
{$H Accumule la matrice m dans l'objet TmatAverage.

 Lorsque count@ = 0 , les propriétés Istart, Iend, Jstart, Jend, Dx, x0, Dy et y0
de la matrice m sont affectées à celles de l'objet TmatAverage.

 L'effet de add1 est le même que celui de add@ mais le calcul des déviations standard
est optimisé. Add1 ne calcule que la matrice Msqrs@ . Une fois que Add1 a été appelé
pour chaque matrice que l'on souhaitait moyenner, il faut appeler UpdateStdDev@ pour
compléter le calcul des déviations standard et des matrices associées.
}

procedure TmatAverage.UpdateStdDev;
{$H Complète le calcul des déviations standard et des vecteurs associés.

 Voir Add1@ .
}

procedure TmatAverage.addEx(var m:Tmatrix;xorg,yorg:real);
{$H Accumule la matrice m dans l'objet Taverage en prenant le point de coordonnées
(xorg,yorg) comme origine dans m.

 Dans l'opération d'accumulation, le point (xorg,yorg) sera donc ajouté au point
(0,0) dans Taverage.
 Contrairement à ce qui se passe avec add@, la structure de l'objet n'est jamais
modifiée.
}
procedure TmatAverage.reset;
{$H Remise à zéro de la moyenne.
 La matrice moyenne est remplie avec des zéros et la propriété count@ reçoit la valeur zéro.
}

property TmatAverage.count:longint;
{$H Contient le nombre de matrices moyennées.

 Est remis à zéro par reset@
}

property TmatAverage.StdOn:boolean;
{$H Si stdOn est vrai, les matrices MSqrs, MStdDev, MStdUp et MStdDw seront calculées.

La propriété vaut False par défaut. Elle doit être mise en place avant de commencer
un calcul de moyenne.
}

Property TmatAverage.MSqrs:Tmatrix readOnly;
{$H Cette matrice contient la somme des carrés des vecteurs moyennés.
 Son utilité est sans doute assez réduite mais son existence est nécessaire au calcul
de MStdDev@ , MstdUp@ et MstdDw@ .
}
Property TmatAverage.MStdDev:Tmatrix readOnly;
{$H Cette matrice contient l'écart-type des matrices moyennées.
L'amplitude de chaque point (i,j) de MstdDev est donnée par l'expression

    zs[i]= sqrt( sum( sqr(z[i,j]-zm[i,j]))/(N-1) )

 où:
 sqrt désigne la racine carrée
 sum désigne la somme effectuée sur toutes les matrices moyennées.
 z[i,j] est la valeur d'une matrice en (i,j)
 zm[i,j] est la valeur moyenne en (i,j)
 N est le nombre de matrices moyennées.
}
Property TmatAverage.MStdUp:Tvector readOnly;
{$H Cette matrice contient la matrice moyenne augmentée de l'écart-type MstdDev@ des
matrices moyennées.

}
Property TmatAverage.MStdDw:Tvector readOnly;
{$H Cette matrice contient la matrice moyenne diminuée de l'écart-type MstdDev@ des
matrices moyennées.

}


procedure optiTh0(var VInput,VOutPut,Vlin,vecE: Tvector;Nblin: integer;var chi2:real;maxIt:integer);
procedure optiTh1(var VInput,VOutPut,Vlin,vecE: Tvector;Nblin: integer;var threshold,chi2:real;maxIt:integer);
procedure OptiPoly(var VInput,VOutPut,Vlin,Vnotlin,VecE: Tvector;Nblin1,nbNotlin1:integer;var chi2:real;nbIt:integer);
procedure optiPower1(var VInput,VOutPut,Vlin,vecE: Tvector;Nblin: integer;var Cp,chi2:real;maxIt,clamp:integer);

procedure OptiPower2(var VInput1,Vinput2,VOutPut,Vseg,Vlin1,Vlin2,VecE: Tvector;Nblin1,Nblin2: integer;var Cp,g0,Cte,chi2:real;nbIt,clamp:integer);

procedure OptiModel1(var VInput1,Vinput2,VOutPut,Vseg,Vlin1,Vlin2,Vlin3,VnonLin,vecE,Vclamp: Tvector;NblinA1,NblinA2,nblinA3:integer;var chi2:real;nbIt:integer);
procedure OptiModel2(var VInput1,Vinput2,VOutPut,Vseg,Vlin1,Vlin2,Vlin3,Vlin4,VnonLin,vecE,Vclamp: Tvector;Nblin:integer;var chi2:real;nbIt:integer);


procedure Toptimizer.create(name:string);
procedure Toptimizer.create;

procedure Toptimizer.loadFromFile(st:string);
procedure Toptimizer.loadFromText(st:string);

function Toptimizer.compile:boolean;
procedure Toptimizer.reset;
procedure Toptimizer.setVector(stName:string;var vec:Tvector);
procedure Toptimizer.getVector(stName:string;var vec:Tvector);
procedure Toptimizer.setSeg(var Vseg:Tvector);
procedure Toptimizer.setClamp(var VClamp:Tvector);
procedure Toptimizer.setParams(var vec:Tvector);
procedure Toptimizer.getParams(var vec:Tvector);

procedure Toptimizer.initOpti(stOut:string; var vecOut:Tvector);
procedure Toptimizer.Optimize;

procedure Toptimizer.CalculateOutput(stName:string);
function Toptimizer.chi2:real;
function Toptimizer.getChi2(stOut:string; var vec:Tvector):real;
property Toptimizer.maxIt:integer;

procedure Toptimizer.setFilterParam(name:string;w:real);
function Toptimizer.getFilterParam(name:string):real;

procedure Toptimizer.setFilterParams(name:string;var vec:Tvector);
procedure Toptimizer.getFilterParams(name:string;var vec:Tvector);

procedure Toptimizer.InitLMQN(stOut:String;var vecOut:Tvector);
procedure Toptimizer.LMstep(var chi2,NormG1:real);
procedure Toptimizer.QNstep(var chi2:real);

property Toptimizer.Ngrad:integer;
procedure Toptimizer.setHistoryList(var Vlist:TVlist);

procedure Toptimizer.setFilterBounds(name:string;var vecMin,vecMax:Tvector);
procedure Toptimizer.setFilterBounds(name:string; Min,Max:real);

procedure Toptimizer.getFilterBounds(name:string;var vecMin,vecMax:Tvector);

procedure Toptimizer.setBounds(var vecMin,vecMax:Tvector);
procedure Toptimizer.getBounds(var vecMin,vecMax:Tvector);

procedure Toptimizer.getFilterAux(name:string;numVec,NumOcc:integer;var vec:Tvector);

procedure Toptimizer.setFilterClamp(name:string;w:real);
procedure Toptimizer.setFilterClamp(name:string;w:real;num:integer);
procedure Toptimizer.setFilterClamp(name:string;var vec:Tvector);

procedure Toptimizer.setFilterConsts(name:string;var vec:Tvector);


function SegAngle(xa,ya,xb,yb:real):real;
function PointInSector(xa,ya,xb,yb,Dtheta,xm,ym:real):boolean;

procedure sendCommand(num:integer);
procedure sendCommand(num,delay:integer);
{$H Active une commande du menu Acquisition

 num=1 : active la commande Acquisition/Start
 num=2 : active la commande Acquisition/Start and Save(New file)
 num=3 : active la commande Acquisition/Start and Save(Same file)
 num=4 : active la commande Acquisition/Stop

 Si delay est présent, la commande est envoyée après ce délai (en millisecondes)
}




procedure gstest(var x:real);

procedure InitIntelLib;


                    { TmgPage et Tmultigraph }

property TMGpage.color:integer;
{$H Color est la couleur de fond de la page.
}

property TMGpage.Scalecolor:integer;
{$H ScaleColor est la couleur utilisée pour afficher les échelles des objets
contenus dans la page.
  Cette propriété n'est utilisée que si la propriété PageFont vaut TRUE.
}


property TMGpage.font: Tfont readOnly;
{$H Jeu de caractères utilisé dans la page pour afficher les échelles ( voir Tfont@ ).

 Ce jeu n'est utilisé que si PageFont@ vaut true.

}
property TMGpage.PageFont: boolean;
{$H Indique s'il faut utiliser le jeu de caractères de la page ( propriété Font@ ) pour
afficher les échelles ou bien le jeu de caractère propre à chaque objet affiché.

 Si PageFont vaut True, c'est le jeu de caractères de la page qui est utilisé.
 La propriété ScaleColor@ est également utilisée à la place de la propriété correspondante de
l'objet affiché.
}

property TMGpage.ShowTitles: boolean;
{$H Indique s'il faut afficher les titres des objets (propriété Title@(Tplot.title) ) dans les fenêtres de la page.
}
property TMGpage.ShowOutlines: boolean;
{$H Indique s'il faut afficher les contours des fenêtres de la page.
}
property TMGpage.ShowNumbers: boolean;
{$H Indique s'il faut afficher les numéros des fenêtres de la page.
}

procedure TMGpage.initGrid(nx,ny:integer);
procedure TMGpage.initGrid(nx,ny,Wtype:integer);

{$H Initialise une grille contenant nx*ny fenêtres.
 nx est le nombre de fenêtres dans le sens horizontal.
 ny est le nombre de fenêtres dans le sens vertical.

 Toutes les fenêtres existant auparavant sont détruites.
 Ensuite, on peut ranger des objets dans les fenêtres en utilisant addObjectOnGrid@
au lieu de addObject@.

}

procedure TMGpage.addObjectOnGrid(i,j:integer;plot:Tplot);
procedure TMGpage.addObjectOnGrid(i,j:integer;plot:Tplot; Wtype: integer);
{$H Range l'objet Plot dans la fenêtre de coordonnées grille (i,j) .

 Cette procédure n'a d'effet que si l'on a appelé InitGrid@ auparavant. Elle remplace
avantageusement AddObject@ quand on souhaite référencer les fenêtres au moyen de
deux coordonnées.

 i est la position horizontale de la fenêtre. Elle doit être comprise entre 1 et le
nombre de fenêtres dans le sens horizontal.
 j est la position verticale de la fenêtre. Elle doit être comprise entre 1 et le
nombre de fenêtres dans le sens vertical.
 La fenêtre située en haut à gauche dans la grille a pour coordonnées (1,1).

 Plot doit être un descendant de Tplot (exemple: Tvector ou Tmatrix)

 }
procedure TMGpage.addObject(w:integer;u:Tplot);
procedure TMGpage.addObject(w:integer;u:Tplot;Wtype:integer);

{$H Range l'objet Plot dans la fenêtre de numéro w .

 w est le numéro de création de la fenêtre. Il est compris entre 1 et le
nombre de fenêtres.

 Plot doit être un descendant de Tplot (exemple: Tvector ou Tmatrix)

 La procédure a le même effet qu'un glisser-déposer de l'inspecteur d'objet vers
une fenêtre multigraph.
 }

procedure TMGpage.addObjectEx( w:integer;u:Tobject);
procedure TMGpage.addObjectEx( w:integer;u:Tobject; mode:integer);

{$H Fonctionne comme addObject@ mais ne vérifie pas le type de l'objet à la compilation.

  u peut donc être un objet de n'importe quel type.
  A l'exécution, une erreur sera générée si l'objet u ne peut pas être rangé dans une fenêtre.

  Actuellement addObjectEx peut être utilisé avec Tdialog@ , TDBgrid@ , Tmemo

  Le paramètre mode est utilisé pour les objects qui ont deux modes d'incrustation: par exemple Tmemo@
peut simplement afficher du texte dans la fenêtre (mode=1) ou bien peut permettre la saisie de texte (mode=2).
}


procedure TMGpage.addDialog(w:integer;u:Tdialog);
{$H Range un objet Tdialog@ dans la fenêtre de numéro w

}
procedure TMGpage.addCursor(w:integer;u:Tcursor);
{$H Range un objet Tcursor@ dans la fenêtre de numéro w

}
procedure TMGpage.ClearObjects(w:integer);
procedure TMGpage.ClearObjects(w,Wtype:integer);

{$H Enlève tous les objets de la fenêtre de numéro w.
}

procedure TMGpage.getWindowPos(win:integer;var x1,y1,x2,y2:integer);
{$H Renvoie les coordonnées de la fenêtre de numéro win.

  x1 et y1 sont les coordonnées du coin en haut à gauche de la fenêtre.
  x2 et y2 sont les coordonnées du coin en bas à droite de la fenêtre.
}

function TMGpage.GetWin(p:Tplot):integer;
{$H Renvoie le numéro de la fenêtre qui contient l'objet plot.

 Si la page ne contient pas l'objet, la fonction renvoie zéro.
}

function TMGpage.winCount:longint;
function TMGpage.winCount(Wtype:integer):longint;
{$H Renvoie le nombre de fenêtres de la page.
}


function TMGpage.DefineWindow(x1,y1,x2,y2:integer):integer;
function TMGpage.DefineWindow(x1,y1,x2,y2:integer;WType:integer;Fback:boolean):integer;

{$H Crée une nouvelle fenêtre multigraph.

  x1 et y1 sont les coordonnées du coin en haut à gauche de la fenêtre.
  x2 et y2 sont les coordonnées du coin en bas à droite de la fenêtre.

  La fonction renvoie zéro si la fenêtre ne peut être créée (coordonnées
incorrectes) et renvoie le numéro de la fenêtre dans le cas contraire.

  Les coordonnées sont exprimées en pixels. Si l'utilisateur redimensionne la fenêtre
Elphy, ces coordonnées changeront puisque les dimensions des fenêtres sont
proportionnelles aux dimensions de la page. Il est donc important de calculer des
dimensions en se basant sur les dimensions actuelles de la page ( pageWidth@(Tmultigraph.PageWidth) et
pageHeight@(Tmultigraph.PageHeight) ).


}
function TMGpage.DefineGrid(x1,y1,x2,y2,nx,ny:integer):integer;
function TMGpage.DefineGrid(x1,y1,x2,y2,nx,ny:integer; Wtype:integer):integer;

{$H Définit une grille de fenêtres.

  x1 et y1 sont les coordonnées du coin en haut à gauche de la grille.
  x2 et y2 sont les coordonnées du coin en bas à droite de la grille.

  nx et ny sont les nombres de fenêtres dans les sens horizontal et vertical. Il
y a donc nx*ny fenêtres créées.

  La fonction renvoie zéro si la fenêtre ne peut être créée (coordonnées
incorrectes) et renvoie le numéro de la première fenêtre de la grille dans le
cas contraire. Les numéros des autres fenêtres prennent des valeurs consécutives
quand on se déplace ligne par ligne.

}
procedure TMGpage.DestroyAllWindows;
procedure TMGpage.DestroyAllWindows(Wtype:integer);
{$H Supprime toutes les fenêtre de la page

 Si Ntype=0 (valeur par défaut), les fenêtres de type 1 et 2 sont supprimées
 Si Ntype=1, seules les fenêtres de type 1 sont supprimées
 Si Ntype=2, seules les fenêtres de type 2 sont supprimées

}

Procedure TMGpage.SaveAsBMP(st:string);
{$H Sauve la page dans un fichier de nom st.

 Le fichier créé est au format BMP .
}

Procedure TMGpage.SaveAsPNG(st:string);
{$H Sauve la page dans un fichier de nom st .

 Le fichier créé est au format PNG .
}

Procedure TMGpage.SaveAsJPEG(st:string;quality:integer);
{$H Sauve la page dans un fichier de nom st.

 Le fichier créé est au format JPEG .
 Quality est un nombre compris entre 1 et 100 qui affecte le taux de compression
de l'image.
 Pour quality=100 , l'image est parfaitement conservée mais le taux de compression
est minimal.
}

Procedure TMGpage.SaveAsEMF(st:string);
{$H Sauve la page dans un fichier au format EMF (extended metafile).
}

procedure TMGpage.Print;
{$H Imprime la page courante.

 La méthode utilise les paramètres introduits dans le menu Impression.
}
procedure TMGpage.divideWindow(Win,nx,ny:integer);
procedure TMGpage.divideWindow(Win,nx,ny,Wtype:integer);

{$H Divise une fenêtre existante en plusieurs fenêtres formant une grille.

 Win est le numéro de la fenêtre.
 nx et ny sont les nombres de fenêtres souhaités dans les sens horizontal et
vertical.
}
function TMGpage.newWindow(x,y:integer):integer;
{$H Crée une nouvelle fenêtre.

 x et y sont les coordonnées en pixels d'un point de la page. Ce point ne doit
appartenir à aucune fenêtre existante. La méthode crée la fenêtre la plus grande
possible contenant ce point. Tout se passe comme si l'on activait la commande
New Window avec un clic droit de la souris au point (x,y).
}
procedure TMGpage.destroyWindows(win,count:integer);
procedure TMGpage.destroyWindows(win,count,Wtype:integer);

{$H Détruit plusieurs fenêtres de numéros consécutifs.

 win est le numéro de la première fenêtre à détruire.
 count est le nombre de fenêtres à détruire. Si l'on indique une valeur
supérieure au nombre de fenêtres, seules les fenêtres existantes seront
détruites.
}

property TmgPage.name:string readOnly;
{$H Indique le contenu de l'onglet qui permet de sélectionner la page.

 La propriété est en lecture seule. Le nom est donné au moment de la création.
 Ensuite, il ne peut plus être modifié.
}

property TMGpage.Vparams: TMGVparams readonly;
{$H Contient des paramètres de visualisation qui peuvent remplacer les paramètres
standard des objets affichés dans la page.

 Vparams est du type TMGVparams@ .
}

property TMGpage.UseVparams:boolean;
{$H Quand UseVparams vaut false (valeur par défaut), tous les objets affichés dans la page
utilisent leurs propres paramètres de visualisation.

 Quand UseVparams vaut True, les objets affichés dans la page utilisent certains paramètres de visualisation
contenus dans Vparams@ . Les paramètres sont sélectionnés quand leur propriété Vflag@ vaut True.

}
property TMGpage.Vflag(n:integer):boolean;
{$H Un paramètre contenu dans Vparams@ est utilisé pour l'affichage d'un objet si, d'une part, UseVparams@ vaut true, et d'autre part,
si Vflag[n] vaut true. n étant la constante associée au paramètre (voir les constantes@(Paramètres d'affichage Multigraph)

 Par défaut, tous les flags valent false. Dés que l'on affecte la valeur d'un paramètre de Vparams, le flag associé passe à True, ce qui économise
l'écriture d'une ligne de code.
}

procedure Tmultigraph.selectPage(st:string);
{$H Place la page de nom st au premier plan.
}

property Tmultigraph.MgPage(st:string):TmgPage readOnly;
property Tmultigraph.MgPage(n:integer):TmgPage readOnly;
{$H Propriété de Tmultigraph@ permettant de manipuler une page graphique.

 St est le nom de la page.
 n est le numéro de la page.

 Les pages sont de type TMGpage@ .
}

property Tmultigraph.CurMgPage: TmgPage readOnly;
{$H Renvoie la page courante (objet de type TmgPage@ )

}

procedure Tmultigraph.AddPage(stname:string);
{$H Ajoute une nouvelle page de nom stName dans l'objet Tmultigraph@

 La page est rangée après toutes les autres pages dans l'objet Tmultigraph.
}
procedure Tmultigraph.InsertPage(num:integer;stname:string);
{$H Ajoute une nouvelle page de nom stName dans l'objet Tmultigraph@

 La page est rangée en position num dans l'objet Tmultigraph (Les numéros commencent à 1).

}

procedure Tmultigraph.DeletePage(stname:string);
{$H Supprime la page de nom stName dans l'objet Tmultigraph@

 S'il n'y a qu'une seule page, la méthode n'a aucun effet.
}

procedure Tmultigraph.DeleteAllPages(stname:string);
{$H Supprime toutes les pages sauf la page de nom StName dans l'objet Tmultigraph@ .

 S'il n'existe pas de page de nom StName, c'est la première page qui est conservée.
}

function  Tmultigraph.PageIndex(stname:string):integer;
{$H Renvoie la position de la page de nom stName

 Les indices commencent à un
 Si la page n'existe pas, la fonction renvoie zéro.
}

property TMultigraph.WinAlign(page,num:integer):integer;
{$H Définit l'alignement de la fenêtre de numéro num dans la page page

 Les valeurs possibles sont :
 0: aucun alignement (valeur par défaut)
 1: Top
 2: Bottom
 3: Left
 4: Right
}

property TMGpage.WinAlign(num:integer):integer;
{$H Définit l'alignement de la fenêtre de numéro num

 Les valeurs possibles sont :
 0: aucun alignement (valeur par défaut)
 1: Top
 2: Bottom
 3: Left
 4: Right
}


procedure TmultiGraph.addMGDialog(AlignMode:integer; var u:Tdialog);
{$H Ajoute une dialogue dans l'objet Tmultigraph.

 AddMGdialog ne range pas le dialogue dans une fenêtre comme le fait AddDialog@ mais
associe le dialogue à l'objet Tmultigraph. Ce dialogue apparaitra en haut, en bas, à droite
ou à gauche du système de fenêtres, suivant la valeur du paramètre AlignMode.

 Vous pouvez utiliser les (constantes d'alignement)@Align:

 @f6 Al_Top =    1;
 @f6 Al_Bottom = 2;
 @f6 Al_Left=    3;
 @f6 Al_Right=   4;

 Le dialogue restera visible quelle que soit la page sélectionnée.

 Voir ClearMGDialogs@
}
procedure TmultiGraph.ClearMGDialogs;
{$H Supprime tous les dialogues ajoutés au moyen de addMGdialog@

}

property Tmultigraph.ToolbarVisible:boolean;
{$H Rend visible ou invisible la barre d'outils de la fenêtre Tmultigraph.

 Si cette barre est invisible, il devient impossible de changer de page.
 On utilisera cette propriété uniquement pour les objets autres que multigraph0@
}

                         { TMGVparams }

property TmgVparams.Xmin:real;
property TmgVparams.Xmax:real;
property TmgVparams.Ymin:real;
property TmgVparams.Ymax:real;

property TmgVparams.LogX:boolean;
property TmgVparams.LogY:boolean;

property TmgVparams.Xscale:boolean;
property TmgVparams.Yscale:boolean;
property TmgVparams.Xticks:boolean;
property TmgVparams.Yticks:boolean;
property TmgVparams.ExtTicksX:boolean;
property TmgVparams.ExtTicksY:boolean;
property TmgVparams.RightTicks:boolean;
property TmgVparams.TopTicks:boolean;
property TmgVparams.ZeroAxisX:boolean;
property TmgVparams.ZeroAxisY:boolean;

property TmgVparams.inverseX:boolean;
property TmgVparams.inverseY:boolean;

property TmgVparams.color:longint;
property TmgVparams.color2:longint;

property TmgVparams.Mode:integer;
property TmgVparams.SymbolSize:integer;
property TmgVparams.lineWidth:integer;
property TmgVparams.keepAspectRatio:boolean;


                         { Tmacro }

procedure Tmacro.create(stFile:string);
{$H Constructeur de l'objet Tmacro.

 Le fichier texte de nom stFile est chargé en mémoire et compilé si nécessaire.
 Si le fichier texte a déjà été compilé, il existe un fichier de même nom mais d'extension pgc (ou pgc64
pour la version 64 bits). Ce fichier contient le code exécutable. Si la date de ce fichier est postérieure à la date du fichier texte, le
code compilé est directement chargé en mémoire.
 Sinon, le fichier texte est compilé. Un message d'erreur est généré si nécessaire.

}
procedure Tmacro.executeCommand(st:string);
{$H Execution d'un commande

  Le fichier PG2 contient un certain nombre de blocs PROGRAM
  La chaine st doit correspondre exactement au nom d'un de ces programmes.
  Si c'est le cas, le programme est exécuté.
  Si aucun programme ne correspond, rien n'est exécuté et aucune erreur n'est générée.
}
procedure Tmacro.showMenu;
{$H Montre le menu programme

  Le menu programme est formé des noms de tous les blocs PROGRAM
  Il apparait sous la forme d'un popup menu.
}
procedure Tmacro.showMenu(Fmenu:boolean);
{$H Montre le menu programme

  Le menu programme est formé des noms de tous les blocs PROGRAM

  Si Fmenu vaut true, le popup menu est réactivé dés la fin de l'exécution de la commande.
  Sinon, il ne réapparait pas.

}

procedure Tmacro.reset;
{$H Effectue un reset du programme.

 Tous les objets sont détruits.
 Toutes les variables globales sont remises à zéro.
}

function Tmacro.fileName: string;
{$H Renvoie le nom du fichier PG2
}

function Tmacro.path: string;
{$H Renvoie le chemin d'accès au fichier PG2
}


procedure releasePgMenu;
{$H Cache le popup menu associé au programme.
}

                         { Tregion }

property Tregion.RegType:integer readOnly;
{$H Type de la région.

 Les valeurs possibles sont:
 1: région rectangulaire
 2: région elliptique
 3: région polygonale
 4: liste de pixels

 Le type est décidé à la création et n'est pas modifiable.
}
property Tregion.PixCount:integer readOnly;
{$H Renvoie le nombre de pixels de la région
}
property Tregion.XPix(n:integer):integer readOnly;
{$H Abscisses des pixels de la région.

 n doit être compris entre 1 et PixCount@
}
property Tregion.YPix(n:integer):integer readOnly;
{$H Ordonnées des pixels de la région.

 n doit être compris entre 1 et PixCount@
}
property Tregion.color:integer;
{$H Couleur d'affichage.
}

procedure Tregion.move(deltaX,deltaY:integer);
{$H Déplacement relatif de toute la région

 Tous les pixels voient leur abscisse augmentée de deltaX
et leur ordonnée augmentée de deltaY

}

procedure Tregion.moveAbs(newX,newY:integer);
{$H Déplacement absolu de toute la région

  Le point situé à la fois le plus à gauche et le plus en haut dans la région
est positionné en (newX,newY)

 Les propriétés left@ et top@ sont donc modifiées.
}

property Tregion.left:integer readOnly;
{$H Renvoie l'abscisse du point situé le plus à gauche
}
property Tregion.top:integer readOnly;
{$H Renvoie l'ordonnée du point situé le plus en haut
}
property Tregion.width:integer readOnly;
{$H Renvoie la largeur du plus petit rectangle contenant tous les points de la région
}
property Tregion.height:integer readOnly;
{$H Renvoie la hauteur du plus petit rectangle contenant tous les points de la région
}
property Tregion.Filled:boolean;
{$H Si cette propriété vaut TRUE, les pixels de la région sont coloriés à l'affichage

 Ceci peut permettre de mettre en évidence une région particulière.
}
procedure Tregion.saveToXYplot(plot:TXYplot);
{$H Copie la région dans un objet TXYplot

 La région copiée doit être du type rectangle ou polygone
 Un objet polyline est d'abord créé dans XYplot puis tous les points formant
le contour de la région sont ajoutés à cette polyline.

}

                         { TregionList }

procedure TregionList.create(stName:string);
procedure TregionList.create;
{$H Constructeur de l'objet TregionList.

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .
 Si StName est omis ou vide, l'objet prend le nom de la variable.

}
property TregionList.Count:integer readOnly;
{$H Renvoie le nombre de régions de la liste
}
property TregionList.region(n:integer):Tregion readOnly;
{$H Permet d'accéder à chaque région (Tregion@) de la liste

 n doit être compris entre 1 et Count@

}
procedure TregionList.clear;
{$H Efface toutes les régions de la liste
}
procedure TregionList.copy(regList:TregionList);
{$H Copie toutes les régions de RegList

 Auparavant, les régions existantes sont effacées
 Pour copier sans effacer, il faut utiliser Add@
}

procedure TregionList.add(reg:Tregion);
procedure TregionList.add(regList:TregionList);
{$H Ajoute une région ou une liste de régions à la fin de la liste.


}
property TregionList.Defcolor:integer;
{$H Couleur par défaut.

 Quand on crée une nouvelle région, cette couleur est utilisée.
}



procedure TregionList.createRegionFromMatrix(var mat:Tmatrix;tt:integer);
{$H Crée une région à partir des pixels sélectionnés dans la matrice.

 Si tt=1, la région contient les pixels sélectionnés (propriété Tmatrix.SelPix@=true)
 Si tt=2, la région contient les pixels marqués (propriété Tmatrix.MarkPix@=true)
 Si tt=3, la région contient les pixels marqués et les pixels sélectionnés

 La région créée est ajoutée à la fin de la liste.
}

procedure TregionList.createRectRegion(left1,top1,width1,height1:integer);
{$H Crée une région rectangulaire.

 La région créée est ajoutée à la fin de la liste.
}

procedure TregionList.createEllipticRegion(left1,top1,width1,height1:integer);
{$H Crée une région elliptique.

 La région créée est ajoutée à la fin de la liste.
}

procedure TregionList.saveToFile(stF: string);
{$H Sauve les regions dans le fichier de nom stF.
}

procedure TregionList.LoadFromFile(stF: string);
{$H Charge les regions à partir du fichier de nom stF.
}


property Tmatrix.regionList:TregionList readOnly;
{$H Objet de type TregionList@ associé à la matrice.

 Cet objet n'existe pas tant qu'on n'essaie pas de l'utiliser. Il est créé automatiquement
si l'on utilise la commande 'Show select window' dans le menu associé à la matrice ou bien si
le programme utilise cette propriété.
}











                         { Dip test }

function DipTest(var vec:Tvector):real;
{$H Le DIP test mesure la multimodalité d'une distribution en évaluant une distance
entre la distribution observée et la distribution unimodale la plus proche.

 La méthode est basée sur l'article suivant:
   J.A.Hartigan and P.M. Hartigan
   The Annals of statistics
   1985, vol. 13, N°1, 70-84


 Le vecteur vec doit contenir la fonction de distribution , fonction croissante variant entre 0 et 1,
et non pas la densité de probabilité.

 La fonction de test renvoie zéro si la distribution est parfaitement unimodale
et une valeur positive, inférieure à 0.5 , dans le cas contraire.

 Voir aussi DistriFunction@
}

procedure DistriFunction(var src,dest:Tvector);
{$H Calcule la fonction de distribution connaissant la densité de probabilité.

 src doit contenir une densité de probabilité: toutes ses valeurs doivent donc être positives.
 Au retour, dest contiendra la fonction de distribution correspondante.

 La structure de dest est d'abord modifiée de la façon suivante:
 - les bornes de dest deviennent égales à celles de src.
 - si le type de dest est un type réel, ce type reste inchangé. Sinon, ce type devient t_single.

 dest est ensuite obtenu en calculant d'abord pour chaque point d'indice i l'intégrale de la source
entre Istart et i, puis en divisant le vecteur obtenu par dest.Yvalue[Iend].

 Les valeurs de dest sont croissantes et atteignent la valeur maximale 1 .

}
                         { Timage  stmBMP1}

procedure Timage.create(stName:string;stFile:string);
procedure Timage.create(stFile:string);
{$H Constructeur de l'objet Timage

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 stFile est un nom de fichier image. La chaîne stFile peut éventuellement être vide.
Dans ce cas, l'image sera vide.
}
property Timage.stretch:boolean;
{$H Indique si l'affichage doit remplir la totalité de la fenêtre
}
property Timage.tile:boolean;
{$H Indique si l'affichage est en mode MOSAIQUE
}
property Timage.keepAspectRatio:boolean;
{$H Indique si l'affichage doit conserver le rapport d'aspect (TRUE par défaut)
}
property Timage.fileName:string readOnly;
{$H Renvoie le nom du fichier chargé dans Timage.
}
procedure Timage.load(st:string);
{$H Charge un fichier image de nom st.

 Le fichier doit être du type BMP ou JPEG
}
procedure Timage.save(st:string;format,quality:integer);
{$H Sauve l'image dans un fichier de nom st

 Si format=1, l'image est sauvée au format JPEG et le paramètre Quality
représente la qualité de l'image sauvée. Quality doit être compris entre 0 et 100 .

 Si format=2, l'image est sauvée au format PNG

 Pour toute autre valeur de format, l'image est sauvée au format BMP

}
                         { TbitmapPlot }

procedure TbitmapPlot.create(stName:string;stFile:string);
procedure TbitmapPlot.create(stFile:string);
{$H Constructeur de l'objet TbitmapPlot

 Stname est le nom attribué à l'objet. Il devient sa propriété SysName@ .

 stFile est un nom de fichier image. La chaîne stFile peut éventuellement être vide.
Dans ce cas, l'image sera vide.
}
property TbitmapPlot.fileName:string readOnly;
{$H Renvoie le nom du fichier chargé dans TbitmapPlot.
}
procedure TbitmapPlot.load(st:string);
{$H Charge un fichier image de nom st.

 Le fichier doit être du type BMP ou JPEG
}
procedure TbitmapPlot.save(st:string;format,quality:integer);
procedure TbitmapPlot.save(st:string;format,quality,x1,y1,x2,y2:integer);
{$H Sauve l'image dans un fichier de nom st

 Si format=1, l'image est sauvée au format JPEG et le paramètre Quality
représente la qualité de l'image sauvée. Quality doit être compris entre 0 et 100 .

 Si format=2, l'image est sauvée au format PNG

 Pour toute autre valeur de format, l'image est sauvée au format BMP

 Si les paramètres x1,y1,x2,y2 sont spécifiés , seule la partie du bitmap contenue dans
le rectangle de coordonnées (x1,y1,x2,y2) est sauvé.
 x1,y1 désigne le point situé en haut à gauche
 x2,y2 désigne le point situé en bas  à droite

}
property TbitmapPlot.Gdisp:real;
property TbitmapPlot.Xdisp:real;
property TbitmapPlot.Ydisp:real;

property TbitmapPlot.Transparent:boolean;
{$H Si Transparent vaut TRUE, les pixels contenant la valeur TransparentValue@ ne sont pas affichés.
}

Property TbitmapPlot.TransparentValue:real;
{$H Si Transparent@ vaut TRUE, les pixels contenant la valeur TransparentValue ne sont pas affichés.
}


                        { TstatusBar }
procedure TstatusBar.create;
procedure TStatusBar.create(nbPanel:integer);
{$H Constructeur de l'objet TsatusBar.

 nbPanel est le nombre de volets contenus dans la barre d'état.
}

procedure TStatusBar.setPanelProp(PanelNum,width,Alignment,Bevel:integer;text:String);
{$H Fixe les paramètres du panel de numéro PanelNum.

 PanelNum doit être compris entre 1 et le nombre de panels.

 Width est la largeur du panel en pixels.

 Alignment peut prendre les valeurs suivantes:
     0: alignement du texte à gauche
     1: alignement du texte à droite
     2: texte centré

 Bevel peut prendre les valeurs suivantes:
     0: pas de biseau
     1: panel abaissé
     2: panel surélevé

 text est le texte contenu dans le panel.

}


property TStatusBar.text(PanelNum:integer):string;
{$H Texte contenu dans la panel de numéro PanelNum
}

property TStatusBar.font:Tfont readonly;
{$H Jeu de caractères de la barre d'états

 Voir Tfont@
}
property TStatusBar.height:integer;
{$H Hauteur en pixels de la barre d'état
}

property TStatusBar.visible:boolean;
{$H Indique si la barre est visible ou non

 La valeur par défaut est TRUE
}

property TStatusBar.ImmediateUpdate:boolean;
{$H Indique si chaque modification du texte entraîne un réaffichage immédiat.

 La valeur par défaut est TRUE
}


procedure HideSystemStatusBar;
{$H Masque la barre d'état de Elphy

 Dans certains cas, ce masquage est supprimé quand Elphy a besoin d'afficher des informations,
par exemple en acquisition.

  Voir aussi ShowSystemStatusBar@
}

procedure ShowSystemStatusBar;
{$H Montre la barre d'état de Elphy

  Voir aussi HideSystemStatusBar@
}

function paramstr(i:integer):String;

function maj(st:string):String;
/Uppercase
{$H Renvoie la chaîne st en majuscules}

function LowerCase(st:string):string;
{$H Renvoie la chaîne st en minuscules}



procedure MyHH(var src,dest1,dest2,dest3,dest4:Tvector);



                   { TarrowPlot }

procedure TArrowPlot.create;
procedure TArrowPlot.addPoint(x,y,len,theta:real;color:integer; lineWidth,tipLen,TipWidth:real);
procedure TArrowPlot.addPoint(x,y,len,theta:real;color:integer);
procedure TArrowPlot.addPoint(x,y,len,theta:real);
function TArrowPlot.count:integer;
procedure TArrowPlot.clear;


procedure TArrowPlot.SaveSingleData(var binF: TbinaryFile);
{$H Sauve les data dans un fichier binaire

 Pour chaque point, on sauve les valeurs de X@, Y@, Len@ et Theta@ dans cet ordre
avec un format de type Single.
}

property TArrowPlot.X(i:integer): real;
{$H Abscisse du point d'indice i

 Les indices sont compris entre 1 et count@
}
property TArrowPlot.Y(i:integer): real;
{$H Ordonnée du point d'indice i

 Les indices sont compris entre 1 et count@
}

property TArrowPlot.Len(i:integer): real;
{$H Longueur de la flêche au point d'indice i

 Les indices sont compris entre 1 et count@
}

property TArrowPlot.Theta(i:integer): real;
{$H Orientation de la flêche au point d'indice i

 Theta est exprimé en radians
 Les indices sont compris entre 1 et count@
}

property TArrowPlot.Xlabel(i:integer): integer;
{$H Abscisse du label d'indice i, relativement à la position du point correspondant

 Par défaut, sa valeur est 2 (pixels)

 Les indices sont compris entre 1 et count@
}

property TArrowPlot.Ylabel(i:integer): integer;
{$H Ordonnée du label d'indice i, relativement à la position du point correspondant

 Par défaut, sa valeur est 2 (pixels)

 Les indices sont compris entre 1 et count@
}

property TArrowPlot.label(i:integer): string;
{$H Label associé au point d'indice i
}

property TArrowPlot.Font: Tfont readonly;
{$H Fonte utilisée par les labels
}

                   { TvectorSpk }

property TvectorSpk.Uvalue(n:integer):integer;
{$H Renvoie l'attribut (numéro d'unité) du spike d'indice n

 n doit être compris entre Istart et Iend.
}
property TvectorSpk.UseStdColors: boolean;
{$H Si UseStdColors vaut true (valeur par défaut), chaque événement est affiché avec une couleur
liée à l'attribut. Ces couleurs sont rangées dans une table appelée StdColors@

 Si UseStdColors vaut False, tous les événements sont affichés de la même couleur en utilisant
la propriété Color@ habituelle.
}

property TvectorSpk.VU(n:integer): Tvector readOnly;
{$H Vecteur contenant tous les événements d' attribut n .

 n doit être compris entre 0 et VUcount@-1
}

property TvectorSpk.VUcount: integer readOnly;
{$H Nombre de vecteurs VU@ contenus dans l'objet TvectorSpk.

 C'est le nombre d'unités gérées par l'objet TvectorSpk.
}


                   { TwaveList }

property TwaveList.UseStdColors: boolean;
{$H Si UseStdColors vaut true (valeur par défaut), chaque vecteur est affiché avec une couleur
liée à l'attribut. Ces couleurs sont rangées dans une table appelée StdColors@
}
property TwaveList.Index: integer;
{$H Indice du vecteur courant.

 Les indices sont compris entre 1 et MaxIndex@
}

property TwaveList.MaxIndex: integer readonly;
{$H Nombre de waveforms contenue dans la liste.

 La propriété index@ est comprise entre 1 et MaxIndex.
}


property TwaveList.WU(n:integer): TwaveList readOnly;
{$H WaveList contenant les waveforms correspondant à l'attribut n

 n est compris entre 0 et WUcount@-1  (5 par défaut)
}

property TwaveList.WUcount: integer readonly;
{$H Nombre de TWaveList enfants contenue dans l'objet.

 L'objet contient les wavelists WU[0] ,WU[1]... WU[WUcount-1].
 Chacune de ces wavelists contient les waveforms correspondant respectivement aux attributs 0 ,1 , 2...WUcount-1

 Par défaut, WUcount est fixé à 6
}

property TwaveList.Att:integer;
{$H Attribut du vecteur courant.

 Pour le système CyberKinetics/BlackRock , c'est le numéro d'unité affecté par l'algorithme de tri

}

procedure TwaveList.setMultiDisplay(MultiDisplayMode:boolean; i1,i2:integer);
{$H Indique le mode d'affichage.

 Par défaut, on affiche uniquement la waveform à l'indice courant.

 En donnant le paramètre MultiDisplayMode = True , l'affichage standard comportera toutes
les waveforms d'indices compris entre i1 et i2

 Pour afficher toutes les waveforms, on peut donner à i1 la valeur 1 et à i2 une valeur très élevée. 

}

                  { TspkTable }

procedure TSpkTable.create;
{$H Constructeur de l'objet }

property TspkTable.EpCount:integer readonly;
{$H Renvoie la première dimension de la table.
   Cette dimension est toujours le nombre d'épisodes du fichier de données initial.
}

property TspkTable.ChCount:integer readonly;
{$H Renvoie la seconde dimension de la table.
   Cette dimension est toujours le nombre de canaux SPK du fichier de données initial.
}

property TspkTable.SpkCount(ep,ch:integer):integer readonly;
{$H Renvoie la troisième dimension de la table.
  Cette dimension est égale au nombre de spikes dans l'épisode ep, dans le canal ch .
}
property TSpkTable.Att(ep,ch,n:integer):integer;
{$H Renvoie la valeur d'un attribut pour un spike donné
  ep est le numéro d'épisode, compris entre 1 et EpCount@ .
  ch est le numéro du canal, compris entre 1 et ChCount@ .
  n  est le numéro du spike, compris entre 1 et SpkCount@[ep,ch] .

}

procedure TSpkTable.LoadFromNexFile(var df:TdataFile; stf:string);
procedure TSpkTable.LoadFromNexFile(var df:TdataFile; stf:string; deltaT:real);

{$H Charge le contenu d'un fichier NEX (NeuroExplorer).

 stf est le nom du fichier.

 On suppose que le fichier de données chargé dans l'objet df (de type TdataFile@) a été traité au moyen du logiciel Plexon/Offline Sorter.
 Dans Offline Sorter, on a sauvé les résultats dans un fichier NEX.
 LoadFromNexFile permet de charger ces résultats dans la table.

 LoadFromNexFile ne modifie pas la structure de la table.
 Il se peut que le fichier NEX contienne moins de spikes que le fichier de data original. Dans ce cas,
tous les spikes non présents seront affectés d'une valeur d'attribut 0 .

 Si le fichier Nex contient des temps de spikes non présents dans le fichier original, une erreur est générée.
 Toutefois, si le paramètre DeltaT est utilisé, on accepte une certaine tolérance sur les temps des spikes: on
considère que deux temps t1 et t2 sont égaux si abs(t1-t2)<=DeltaT
 DeltaT doit être exprimé en millisecondes. Sa valeur par défaut est zéro.
 Dans tous les cas, les temps ne sont pas modifiés dans le fichier Elphy original.

  

}

procedure TdataFile.initSpkTable(var table:TspkTable);
{$H Donne à la table des dimensions correspondant au contenu du fichier de données courant.

 C'est la première méthode à appeler lorsque l'on veut procéder à un nouveau tri de spikes.
Ensuite, il suffit de remplir la table en utilisant la propriété Att@

}

procedure TdataFile.SetSpkTable(var table:TspkTable);
{$H Etablit un lien entre le fichier de données et la table.

 Tous les spikes (objets Vspk et Wspk de TdataFile)
utiliseront ensuite le contenu de la table plutôt que les attributs rangés dans le fichier.

 Pour supprimer le lien entre une table et le fichier de données, on peut appeler SetSpkTable avec
pour argument NIL@
}

procedure TdataFile.LoadSpkTable(n:integer);
{$H Charge la n-ème table du fichier de données.

 Les numéros commencent à 1

 L'utilisateur peut sauver un ou plusieurs objets TspkTable@ à la fin du fichier de données
en appelant  AppendObject@ .

 Ensuite, en utilisant LoadSpkTable, on peut sélectionner l'une de ces tables.
 Tous les spikes (objets Vspk et Wspk de TdataFile)
utiliseront ensuite le contenu de la table plutôt que les attributs rangés dans le fichier.

}


                { TrasterPlot }

procedure TrasterPlot.create;
{$H Constructeur de l'objet.
}

property TrasterPlot.LineHeight:integer;
{$H Définit la hauteur en pixels de l'espace réservé à une ligne d'événements

 Il faut choisir une valeur légèrement supérieure à la propriété SymbolSize@ .
}
property TrasterPlot.TitleWidth:integer;
{$H Largeur de l'espace réservé aux noms des vecteurs sur la gauche de la fenêtre (en pixels) .

 Pour que les noms apparaissent, il faut aussi que la propriété Ftitle@ vaille TRUE.
}
property TrasterPlot.Ftitle:boolean;
{$H Indique s'il faut afficher les noms sur la gauche de la fenêtre d'affichage.


}

                { THexaPlot }


procedure ThexaPlot.create(order:integer);
property ThexaPlot.hexaMode:integer;
{$H Mode d'affichage

  0= Normal
  1= Smooth
  2= Wires
}
procedure ThexaPlot.BuildContour(var plot:TXYPlot; level:real; Fsmooth:boolean);

property THexaPlot.Zvalue(i,j:longint):real;
{$H Permet d'accéder aux valeurs du plot.

 i et j sont les coordonnées dans le repère de définition (repère normé dont les axes forment
un angle de 60 degrés)

 On peut aussi utiliser la propriété Zpoint@ dont l'argument est le numéro du point.
}
function ThexaPlot.PointCount:integer;
{$H Renvoie le nombre de points du plot.
}

function THexaPlot.Ipoint(p: integer):integer;
{$H Renvoie l'abscisse du point de numéro p
}

function THexaPlot.Jpoint(p: integer):integer;
{$H Renvoie l'ordonnée du point de numéro p
}

property THexaPlot.Zpoint(p: integer): real;
{$H Permet d'accéder aux valeurs du plot

 p est l'indice du point dans la liste des points (compris entre 1 et PointCount)
 Voir aussi Ipoint@ , Jpoint@ , Zvalue@
}

property THexaPlot.Mark(p: integer):boolean;
{$H Marque associée à chaque point

 p est l'indice du point dans la liste des points (compris entre 1 et PointCount)
 Voir aussi Ipoint@ , Jpoint@ , Zvalue@
}



property THexaPlot.Zmin:real;
{$H Définit la limite inférieure de l'échelle de couleurs.

}
property THexaPlot.Zmax:real;
{$H Définit la limite supérieure de l'échelle de couleurs.

}
property THexaPlot.gamma:real;
{$H Facteur de correction pour la palette de couleurs.

 Pour représenter la matrice au moyen d'une palette de couleurs, on découpe l'intervalle (Zmin@ - Zmax@) en
256 segments et on attribue une couleur de la palette à chacun de ces segments.

 Par défaut, gamma vaut 1 et l'intervalle Zmin@ - Zmax@ est découpé en 256 segments de même longueur (variation linéaire).

 En augmentant ou en diminuant gamma (entre 0.1 et 10) , on obtient des segments de longueurs croissantes
ou décroissantes, on favorise ainsi les faibles ou les fortes valeurs de z.


}
property THexaPlot.theta:real;
{$H Orientation du graphe.

 Theta est exprimé en degrés.
}

property THexaPlot.twoColors:boolean;
{$H Lorsque la palette est monochrome (PalName@='' ou PalName@='Monochrome'),
il est possible d'utiliser deux couleurs différentes pour les valeurs positives
et les valeurs négatives.

 Par défaut, twoColors vaut False. Dans ce cas, les valeurs comprises entre Zmin@
et Zmax@ seront représentées par des couleurs s'étendant du noir jusqu'à la couleur
saturée définie par palColor@[1] .

 Si twoColors vaut True,les valeurs comprises entre 0 et Zmax@ seront représentées par
des couleurs s'étendant du noir jusqu'à la couleur saturée définie par palColor@[1]
alors que les valeurs comprises entre 0 et Zmin@ seront représentées par
des couleurs s'étendant du noir jusqu'à la couleur saturée définie par palColor@[2]

 Si la palette n'est pas monochrome, twoColors est ignoré.
}
property THexaPlot.PalColor(n:integer):integer;
{$H Définit la ou les couleurs utilisées par la palette monochrome.

 Lorsque TwoColors vaut False, PalColor[1] définit la couleur utilisée par la
palette monochrome, PalColor[2] est alors ignoré.

 Lorsque TwoColors vaut True, PalColor[1] définit la couleur utilisée par la
palette monochrome pour les valeurs positives alors que PalColor[2] définit la couleur
utilisée par la palette monochrome pour les valeurs négatives.

 PalColor[n] peut prendre des valeurs de 1 à 7 qui correspondent aux couleurs suivantes:
   1 : Red
   2 : Green
   3 : Blue
   4 : Red + Green
   5 : Red + Blue
   6 : Green + Blue
   7 : Red + Green +Blue

 Par exemple, quand PalColor[1]=6, les couleurs utilisées sont rgb(0,i,i) où
i prend toutes les valeurs comprises entre 0 et 255.
}
property THexaPlot.PalName:string;
{$H PalName est le nom de la palette utilisée.

 Si PalName='', on considère que la palette est monochrome.

}

property THexaPlot.DisplayMode:integer;
{$H Définit le mode d'affichage.

 0 correspond au mode normal.
 1 correspond à un lissage de rang 3
 2 correspond à une représentation "Wires"

}

procedure THexaPlot.autoScaleZ;
{$H Cherche le minimum et le maximum des éléments du HexaPlot
et range les valeurs trouvées dans Zmin@ et Zmax@
}


procedure SimpleParser(St:string;var pcDef:integer;var stIdent:string;var tp:integer;var x:real;var error:integer;Sep:string);

{$H
 SimpleParser sort les nombres signés,
              les chaines de caractères ( tous caractères entre  deux apostrophes ),
              et les identificateurs.

  St designe la  chaîne à analyser

  pcDef est la position du dernier caractère analysé. Autrement dit, il faut que pcDef=0 au premier appel.
  stIdent est le mot sorti de la chaîne st.
  tp est le type obtenu.
     0: vide
     1: nombre
     2: chaine
     3: identificateur
     4: Autre
     5:  fini
  x est la valeur du nombre lorque tp=1.

  error vaut 0 si le décodage est correct.
             1 si une chaîne n'a pas été fermée par '.
             2 si un nombre est incorrect


}

function TempDirectory:string;
function DataRoot: string;
function PGroot: string;

procedure TserialCom.create(num: integer);
procedure TserialCom.setParams(BaudRate, ByteSize,StopBits,Parity: integer);
procedure TserialCom.SetTimeOuts( ReadI, ReadC, ReadM, writeC,writeM:integer);

function TserialCom.ReadString(sep:Char): String;
procedure TserialCom.WriteString(st:string);

procedure SwapBytes(var x:smallint);
procedure SwapBytes(var x:longint);
procedure SwapBytes(var x:double);

function Hstep(x:real):real;
{$H Step function (Heaviside)

Renvoie 1 si x>=0 , 0 dans le cas contraire.

}

procedure DispatchMessages;
{$H Implémente une boucle de messages Windows

  
}

procedure GPUfft(var mat: Tmatrix; fwd: boolean);

function fileAge(FileName:string): TdateTime;
function fileAge(FileName:string; mode:integer): TdateTime;
{$H renvoie la date et l'heure d'un fichier de nom fileName.

 En fonction de mode, on obtient les différentes dates associées au fichier:
   mode= 1 ==> Last Write Time
   mode= 2 ==> Last Access Time
   mode= 3 ==> Creation Time

 mode=1 est la valeur par défaut

 C'est la valeur la plus pertinente. En effet, le Creation Time peut avoir été modifié pendant
la dernière copie du fichier. Il n'y a aucun moyen (en général) de connaitre la date exacte
de la toute première création du fichier.


}


procedure LookForWordInFile(stWord, stf: String;var Vpos: Tvector);

(*
function BestOfToday(x,y:real):real;
{$H Premier essai de Christophe
}
*)
